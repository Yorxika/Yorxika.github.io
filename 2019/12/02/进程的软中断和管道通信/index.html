<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yorxika.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":270,"display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Linux进程管理命令——进程查看 ps命令：报告进程标识、用户、CPU时间消耗及其他属性  命令单独使用可以看到前台执行的进程；后台进程可以使用带参 数的ps命令（如ps -ax）">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux进程的软中断和管道通信">
<meta property="og:url" content="http://yorxika.github.io/2019/12/02/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1/index.html">
<meta property="og:site_name" content="Nameless Site">
<meta property="og:description" content="Linux进程管理命令——进程查看 ps命令：报告进程标识、用户、CPU时间消耗及其他属性  命令单独使用可以看到前台执行的进程；后台进程可以使用带参 数的ps命令（如ps -ax）">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yorxika.github.io/2019/12/02/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1/12/02/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1/1.jpg">
<meta property="og:image" content="http://yorxika.github.io/2019/12/02/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1/12/02/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1/2.jpg">
<meta property="article:published_time" content="2019-12-02T13:15:55.000Z">
<meta property="article:modified_time" content="2019-12-12T12:49:59.000Z">
<meta property="article:author" content="HMF">
<meta property="article:tag" content="进程">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yorxika.github.io/2019/12/02/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1/12/02/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1/1.jpg">

<link rel="canonical" href="http://yorxika.github.io/2019/12/02/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Linux进程的软中断和管道通信 | Nameless Site</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Nameless Site" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Nameless Site</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">But one day, you will stand before its decrepit gate,without really knowing why.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>links</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yorxika.github.io/2019/12/02/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="HMF">
      <meta itemprop="description" content="To your valor, my sword, and our victory together.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nameless Site">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux进程的软中断和管道通信
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-02 21:15:55" itemprop="dateCreated datePublished" datetime="2019-12-02T21:15:55+08:00">2019-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-12-12 20:49:59" itemprop="dateModified" datetime="2019-12-12T20:49:59+08:00">2019-12-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>12 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="Linux进程管理命令——进程查看"><a href="#Linux进程管理命令——进程查看" class="headerlink" title="Linux进程管理命令——进程查看"></a>Linux进程管理命令——进程查看</h3><ul>
<li>ps命令：报告进程标识、用户、CPU时间消耗及其他属性 <ul>
<li>命令单独使用可以看到前台执行的进程；后台进程可以使用带参 数的ps命令（如ps -ax） <span id="more"></span></li>
<li>提供进程的一次性查看，结果不连续 </li>
<li>结果数据很精确，但数据量庞大</li>
</ul>
</li>
<li>top命令：显示CPU占用率为前几位的进程 <ul>
<li>动态显示，输出结果连续 </li>
<li>消耗较多的系统资源</li>
</ul>
</li>
<li>pstree命令：列出当前的进程，以及它们的树状结构 <ul>
<li>将当前的执行程序以树状结构显示，弥补ps命令的不足</li>
<li>支持指定特定程序(PID)或使用者(USER)作为显示的起始</li>
</ul>
</li>
</ul>
<h3 id="Linux进程管理命令—进程终止"><a href="#Linux进程管理命令—进程终止" class="headerlink" title="Linux进程管理命令—进程终止"></a>Linux进程管理命令—进程终止</h3><ul>
<li>终止一个进程或终止一个正在运行的程序 <ul>
<li>kill命令：根据PID向进程发送信号，缺省操作是停止进程 </li>
<li>如果进程启动了子进程，只终止父进程，子进程运行中将仍 消耗资源成为“僵尸”进程，可用kill -9强制终止退出 </li>
<li>pkill命令：终止同一进程组内的所有进程。允许指定要终止的进程名称，而非PID </li>
<li>Killall命令：与pkill应用方法类似，直接杀死运行中的程 序</li>
<li>数据库服务器的父进程不能用这些命令杀死（容易产生更多 的文件碎片导致数据库崩溃）</li>
</ul>
</li>
</ul>
<h3 id="Linux进程控制函数——进程创建"><a href="#Linux进程控制函数——进程创建" class="headerlink" title="Linux进程控制函数——进程创建"></a>Linux进程控制函数——进程创建</h3><h4 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h4><p>pid=fork();<br>fork系统调用用于创建一个新进程，称为子进程，它与进程（称为系统调用fork的进程）同时运行，此进程称为父进程。创建新的子进程后，两个进程将执行fork（）系统调用之后的下一条指令。子进程使用相同的pc（程序计数器），相同的CPU寄存器，在父进程中使用的相同打开文件。</p>
<div align="center">
<img width="500" src="/2019/12/02/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1/12/02/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1/1.jpg">
</div>

<p>它不需要参数并返回一个整数值。下面是fork（）返回的不同值。</p>
<ul>
<li>负值：创建子进程失败。</li>
<li>零：返回到新创建的子进程。</li>
<li>正值：返回父母或来电者。该值包含新创建的子进程的进程ID</li>
</ul>
<p><strong>头文件</strong>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span><span class="comment">/*#包含&lt;unistd.h&gt;*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span><span class="comment">/*#包含&lt;sys/types.h&gt;*/</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>函数原型</strong>:<br>pid_t fork( void);<br>（pid_t 是一个宏定义，其实质是int 被定义在#include<sys types.h>中）<br>返回值： 若成功调用一次则返回两个值，子进程返回0，父进程返回子进程ID；否则，出错返回-1</sys></p>
<p><strong>函数说明</strong>：<br>一个现有进程可以调用fork函数创建一个新进程。由fork创建的新进程被称为子进程（child process）。fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值而父进程中返回子进程ID。<br>子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。<br>UNIX将复制父进程的地址空间内容给子进程，因此，子进程有了独立的地址空间。在不同的UNIX (Like)系统下，我们无法确定fork之后是子进程先运行还是父进程先运行，这依赖于系统的实现。所以在移植代码的时候我们不应该对此作出任何的假设。</p>
<p><strong>为什么fork会返回两次？</strong><br>由于在复制时复制了父进程的堆栈段，所以两个进程都停留在fork函数中，等待返回。因此fork函数会返回两次，一次是在父进程中返回，另一次是在子进程中返回，这两次的返回值是不一样的。</p>
<p>fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：<br>(1)在父进程中，fork返回新创建子进程的进程ID；<br>(2)在子进程中，fork返回0；<br>(3)如果出现错误，fork返回一个负值。<br>在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。<br>引用一位网友的话来解释fork函数返回的值为什么在父子进程中不同。“其实就相当于链表，进程形成了链表，父进程的fork函数返回的值指向子进程的进程id, 因为子进程没有子进程，所以其fork函数返回的值为0.<br>调用fork之后，数据、堆、栈有两份，代码仍然为一份但是这个代码段成为两个进程的共享代码段都从fork函数中返回，箭头表示各自的执行处。当父子进程有一个想要修改数据或者堆栈时，两个进程真正分裂。</p>
<h4 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h4><p>函数族exec() ：启动另外的进程取代当前的进程 </p>
<ul>
<li><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <unistd.h></unistd.h></h1></li>
<li>extern char **environ;</li>
<li>int execl(const char *path, const char *arg, …); </li>
<li>int execlp(const char *file, const char *arg, …); </li>
<li>int execle(const char *path, const char *arg, const char *envp[]); </li>
<li>int execv(const char *path, const char *argv[]); </li>
<li>int execve(const char *path, const char *argv[], const char *envp[]; </li>
<li>int execvp(const char *file, const char *argv[]);</li>
</ul>
<p>其中只有execve是真正意义上的系统调用，其它都是在此基础上经过包装的库函数。</p>
<p><strong>exec族函数的作用</strong></p>
<p>exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。这里的可执行文件既可以是二进制文件，也可以是任何Linux下可执行的脚本文件。<br>与一般情况不同，exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样，颇有些神似”三十六计”中的”金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回一个-1，从原程序的调用点接着往下执行。<br>现在我们应该明白了，Linux下是如何执行新程序的，每当有进程认为自己不能为系统和用户做出任何贡献了，他就可以发挥最后一点余热，调用任何一个exec，让自己以新的面貌重生；或者，更普遍的情况是，如果一个进程想执行另一个程序，它就可以fork出一个新进程，然后调用任何一个exec，这样看起来就好像通过执行应用程序而产生了一个新进程一样。<br>事实上第二种情况被应用得如此普遍，以至于Linux专门为其作了优化，我们已经知道，fork会将调用进程的所有内容原封不动的拷贝到新产生的子进程中去，这些拷贝的动作很消耗时间，而如果fork完之后我们马上就调用exec，这些辛辛苦苦拷贝来的东西又会被立刻抹掉，这看起来非常不划算，于是人们设计了一种”写时拷贝（copy-on-write）”技术，使得fork结束后并不立刻复制父进程的内容，而是到了真正实用的时候才复制，这样如果下一条语句是exec，它就不会白白作无用功了，也就提高了效率。<br>对于新程序的命令行参数和环境表有长度大小的限制，对于linux来讲这个限制是4096个字节。执行了exec函数的进程不改变以下进程特征：</p>
<ul>
<li>1.进程ID和父进程ID</li>
<li>2.实际用户ID和实际组ID</li>
<li>3.进程组ID和附加组ID</li>
<li>4.控制终端 </li>
<li>5.会话ID</li>
<li>6.时钟预留着时间</li>
<li>7.当前工作目录和根目录</li>
<li>8.文件创建屏蔽字和文件锁</li>
<li>9.信号屏蔽字和未处理信号集</li>
<li>10.资源限制</li>
</ul>
<p><strong>返回值</strong><br>如果执行成功则函数不会返回，执行失败则直接返回-1，失败原因存于errno 中。</p>
<p><strong>注意</strong><br>大家在平时的编程中，如果用到了exec函数族，一定记得要加错误判断语句。因为与其他系统调用比起来，exec很容易受伤，被执行文件的位置，权限等很多因素都能导致该调用的失败。最常见的错误是：</p>
<ul>
<li>1.找不到文件或路径，此时errno被设置为ENOENT；</li>
<li>2.数组argv和envp忘记用NULL结束，此时errno被设置为EFAULT；</li>
<li>3.没有对要执行文件的运行权限，此时errno被设置为EACCES。</li>
<li>l表示以参数列表的形式调用</li>
<li>v表示以参数数组的方式调用</li>
<li>e表示可传递环境变量</li>
<li>p表示PATH中搜索执行的文件，如果给出的不是绝对路径就会去PATH搜索相应名字的文件，如PATH没有设置， 则会默认在/bin,/usr/bin下搜索。</li>
<li>另：调用时参数必须以NULL结束。原进程打开的文件描述符是不会在exec中关闭的，除非用fcntl设置它们的“执行时关闭标志（close on exec）”而原进程打开的目录流都将在新进程中关闭。</li>
</ul>
<h4 id="Linux进程属性操作"><a href="#Linux进程属性操作" class="headerlink" title="Linux进程属性操作"></a>Linux进程属性操作</h4><ul>
<li>设置进程属性 <ul>
<li>nice()：改变进程执行的优先级 </li>
<li>setpgid()：将指定进程的组进程设为指定的组识别码 </li>
<li>setpgrp()：将目前进程的组进程识别码设为目前进程的进程 识别码，等价于setpgid(0,0) </li>
<li>setpriority()：设置进程、进程组和用户的执行优先权 </li>
</ul>
</li>
<li>获取进程属性 <ul>
<li>getpid()：获取目前进程的进程标识 </li>
<li>getpgid()：获得参数pid指定进程所属的组识别码 </li>
<li>getpgrp()：获得目前进程所属的组识别号，等价于 </li>
<li>getpgid(0) </li>
<li>getpriotity()：获得进程、进程组和用户的执行优先权</li>
</ul>
</li>
</ul>
<h4 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h4><ul>
<li>正常退出：在main()函数中执行return、调用exit()函数 或_exit()函数 </li>
<li>异常退出：调用abort()函数、进程收到信号而终止 </li>
<li>区别 <ul>
<li>exit是一个函数，有参数，把控制权交给系统 </li>
<li>return是函数执行完后的返回，将控制权交给调用函数 </li>
<li>exit是正常终止进程，abort是异常终止 </li>
<li>exit中参数为0代表进程正常终止，为其他值表示程序执行过程 中有错误发生 </li>
<li>exit()在头文件stdlib.h中声明，先执行清除操作，再将控制权 返回给内核 </li>
<li>_exit()在头文件unistd.h中声明，执行后立即返回给内核</li>
</ul>
</li>
</ul>
<h4 id="等待进程终止"><a href="#等待进程终止" class="headerlink" title="等待进程终止"></a>等待进程终止</h4><p>wait();    waitpid();</p>
<ul>
<li>① wait() 语法格式： pid=wait(stat_addr);<br> wait()函数使父进程暂停执行，直到它的一个子进程结束为止，该函数 的返回值是终止运行的子进程的PID。参数status所指向的变量存放子 进程的退出码，即从子进程的main函数返回的值或子进程中exit()函数 的参数。如果status不是一个空指针，状态信息将被写入它指向的变量。</li>
<li><p>② waitpid() 语法格式：waitpid(pid_t pid,int * status,int options)<br> 用来等待子进程的结束，但它用于等待某个特定进程结束。<br> 参数pid指明要等待的子进程的PID，参数status的含义与wait()函数中的 status相同。</p>
<p> 如果在调用 waitpid()时子进程已经结束,则 waitpid()会立即返回子进程结束状态值。 子进程的结束状态值会由参数 status 返回,而子进程的进程识别码也会一起返回。如果不在意结束状态值,则参数 status 可以设成 NULL。参数 pid 为欲等待的子进程识别码.<br> 其他数值意义如下:</p>
<ul>
<li>pid&lt;-1 等待进程组识别码为 pid 绝对值的任何子进程。</li>
<li>pid=-1 等待任何子进程,相当于 wait()。</li>
<li>pid=0 等待进程组识别码与目前进程相同的任何子进程。</li>
<li>pid&gt;0 等待任何子进程识别码为 pid 的子进程。</li>
<li><p>参数options提供了一些额外的选项来控制waitpid，参数 option 可以为 0 或可以用”|”运算符把它们连接起来使用，比如：<code>ret=waitpid(-1,NULL,WNOHANG | WUNTRACED);</code><br>WNOHANG 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若结束，则返回该子进程的ID。<br>WUNTRACED 若子进程进入暂停状态，则马上返回，但子进程的结束状态不予以理会。WIFSTOPPED(status)宏确定返回值是否对应与一个暂停子进程。</p>
<p>子进程的结束状态返回后存于 status,底下有几个宏可判别结束情况:<br>WIFEXITED(status)如果若为正常结束子进程返回的状态，则为真；对于这种情况可执行WEXITSTATUS(status)，取子进程传给exit或_eixt的低8位。<br>WEXITSTATUS(status)取得子进程 exit()返回的结束代码,一般会先用 WIFEXITED 来判断是否正常结束才能使用此宏。<br>WIFSIGNALED(status)若为异常结束子进程返回的状态，则为真；对于这种情况可执行WTERMSIG(status)，取使子进程结束的信号编号。<br>WTERMSIG(status) 取得子进程因信号而中止的信号代码,一般会先用 WIFSIGNALED 来判断后才使用此宏。<br>WIFSTOPPED(status) 若为当前暂停子进程返回的状态，则为真；对于这种情况可执行WSTOPSIG(status)，取使子进程暂停的信号编号。<br>WSTOPSIG(status) 取得引发子进程暂停的信号代码,一般会先用 WIFSTOPPED 来判断后才使用此宏。<br>如果执行成功则返回子进程识别码(PID) ,如果有错误发生则返回<br>返回值-1。失败原因存于 errno 中。</p>
</li>
</ul>
</li>
</ul>
<h3 id="进程的软中断通信"><a href="#进程的软中断通信" class="headerlink" title="进程的软中断通信"></a>进程的软中断通信</h3><h4 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h4><p><strong>表头文件</strong>#include<signal.h></signal.h></p>
<p><strong>功能</strong>：设置某一信号的对应动作</p>
<p><strong>函数原型</strong>：void (*signal(int signum,void(* handler)(int)))(int);<br>或者：typedef void (*sig_t)( int );<br>sig_t signal(int signum,sig_t handler);</p>
<p><strong>参数说明</strong>：<br>第一个参数signum指明了所要处理的信号类型，它可以取除了SIGKILL和SIGSTOP外的任何一种信号。<br>第二个参数handler描述了与信号关联的动作，它可以取以下三种值：</p>
<ul>
<li>（1）一个无返回值的函数地址<br> 此函数必须在signal()被调用前申明，handler中为这个函数的名字。当接收到一个类型为signum的信号时，就执行handler 所指定的函数。这个函数应有如下形式的定义：<br> void func(int sig);</li>
<li>（2）SIG_IGN<br> 这个符号表示忽略该信号，执行了相应的signal()调用后，进程会忽略类型为sig的信号。</li>
<li>（3）SIG_DFL<br> 这个符号表示恢复系统对信号的默认处理。</li>
</ul>
<p><strong>函数说明</strong>：<br>signal()会依参数signum 指定的信号编号来设置该信号的处理函数。当指定的信号到达时就会跳转到参数handler指定的函数执行。当一个信号的信号处理函数执行时，如果进程又接收到了该信号，该信号会自动被储存而不会中断信号处理函数的执行，直到信号处理函数执行完毕再重新调用相应的处理函数。但是如果在信号处理函数执行时进程收到了其它类型的信号，该函数的执行就会被中断。</p>
<p><strong>返回值</strong>：返回先前的信号处理函数指针，如果有错误则返回SIG_ERR(-1)。</p>
<p>下面的情况可以产生Signal：</p>
<ul>
<li>按下CTRL+C产生SIGINT</li>
<li>硬件中断，如除0，非法内存访问（SIGSEV）等等</li>
<li>Kill函数可以对进程发送Signal</li>
<li>Kill命令。实际上是对Kill函数的一个包装</li>
<li>软件中断。如当Alarm Clock超时（SIGURG），当Reader中止之后又向管道写数据（SIGPIPE），等等</li>
</ul>
<p>Signals:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Signal</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SIGABRT</td>
<td style="text-align:center">由调用abort函数产生，进程非正常退出 </td>
</tr>
<tr>
<td style="text-align:center">SIGALRM</td>
<td style="text-align:center">用alarm函数设置的timer超时或setitimer函数设置的interval timer超时 </td>
</tr>
<tr>
<td style="text-align:center">SIGBUS</td>
<td style="text-align:center">某种特定的硬件异常，通常由内存访问引起</td>
</tr>
<tr>
<td style="text-align:center">SIGCANCEL</td>
<td style="text-align:center">由Solaris Thread Library内部使用，通常不会使用</td>
</tr>
<tr>
<td style="text-align:center">SIGCHLD</td>
<td style="text-align:center">进程Terminate或Stop的时候，SIGCHLD会发送给它的父进程。缺省情况下该Signal会被忽略</td>
</tr>
<tr>
<td style="text-align:center">SIGCONT</td>
<td style="text-align:center">当被stop的进程恢复运行的时候，自动发送</td>
</tr>
<tr>
<td style="text-align:center">SIGEMT</td>
<td style="text-align:center">和实现相关的硬件异常</td>
</tr>
<tr>
<td style="text-align:center">SIGFPE</td>
<td style="text-align:center">数学相关的异常，如被0除，浮点溢出，等等</td>
</tr>
<tr>
<td style="text-align:center">SIGFREEZE</td>
<td style="text-align:center">Solaris专用，Hiberate或者Suspended时候发送</td>
</tr>
<tr>
<td style="text-align:center">SIGHUP</td>
<td style="text-align:center">发送给具有Terminal的Controlling Process，当terminal被disconnect时候发送</td>
</tr>
<tr>
<td style="text-align:center">SIGILL</td>
<td style="text-align:center">非法指令异常</td>
</tr>
<tr>
<td style="text-align:center">SIGINFO</td>
<td style="text-align:center">BSD signal。由Status Key产生，通常是CTRL+T。发送给所有Foreground Group的进程</td>
</tr>
<tr>
<td style="text-align:center">SIGINT</td>
<td style="text-align:center">由Interrupt Key产生，通常是CTRL+C或者DELETE。发送给所有ForeGround Group的进程</td>
</tr>
<tr>
<td style="text-align:center">SIGIO</td>
<td style="text-align:center">异步IO事件</td>
</tr>
<tr>
<td style="text-align:center">SIGIOT</td>
<td style="text-align:center">实现相关的硬件异常，一般对应SIGABRT</td>
</tr>
<tr>
<td style="text-align:center">SIGKILL</td>
<td style="text-align:center">无法处理和忽略。中止某个进程</td>
</tr>
<tr>
<td style="text-align:center">SIGLWP</td>
<td style="text-align:center">由Solaris Thread Libray内部使用</td>
</tr>
<tr>
<td style="text-align:center">SIGPIPE</td>
<td style="text-align:center">在reader中止之后写Pipe的时候发送</td>
</tr>
<tr>
<td style="text-align:center">SIGPOLL</td>
<td style="text-align:center">当某个事件发送给Pollable Device的时候发送</td>
</tr>
<tr>
<td style="text-align:center">SIGPROF</td>
<td style="text-align:center">Setitimer指定的Profiling Interval Timer所产生</td>
</tr>
<tr>
<td style="text-align:center">SIGPWR</td>
<td style="text-align:center">和系统相关。和UPS相关。</td>
</tr>
<tr>
<td style="text-align:center">SIGQUIT</td>
<td style="text-align:center">输入Quit Key的时候（CTRL+\）发送给所有Foreground Group的进程</td>
</tr>
<tr>
<td style="text-align:center">SIGSEGV</td>
<td style="text-align:center">非法内存访问</td>
</tr>
<tr>
<td style="text-align:center">SIGSTKFLT</td>
<td style="text-align:center">Linux专用，数学协处理器的栈异常</td>
</tr>
<tr>
<td style="text-align:center">SIGSTOP</td>
<td style="text-align:center">中止进程。无法处理和忽略。</td>
</tr>
<tr>
<td style="text-align:center">SIGSYS</td>
<td style="text-align:center">非法系统调用</td>
</tr>
<tr>
<td style="text-align:center">SIGTERM</td>
<td style="text-align:center">请求中止进程，kill命令缺省发送</td>
</tr>
<tr>
<td style="text-align:center">SIGTHAW</td>
<td style="text-align:center">Solaris专用，从Suspend恢复时候发送</td>
</tr>
<tr>
<td style="text-align:center">SIGTRAP</td>
<td style="text-align:center">实现相关的硬件异常。一般是调试异常</td>
</tr>
<tr>
<td style="text-align:center">SIGTSTP</td>
<td style="text-align:center">Suspend Key，一般是Ctrl+Z。发送给所有Foreground Group的进程</td>
</tr>
<tr>
<td style="text-align:center">SIGTTIN</td>
<td style="text-align:center">当Background Group的进程尝试读取Terminal的时候发送</td>
</tr>
<tr>
<td style="text-align:center">SIGTTOU</td>
<td style="text-align:center">当Background Group的进程尝试写Terminal的时候发送</td>
</tr>
<tr>
<td style="text-align:center">SIGURG</td>
<td style="text-align:center">当out-of-band data接收的时候可能发送</td>
</tr>
<tr>
<td style="text-align:center">SIGUSR1</td>
<td style="text-align:center">用户自定义signal 1</td>
</tr>
<tr>
<td style="text-align:center">SIGUSR2</td>
<td style="text-align:center">用户自定义signal 2</td>
</tr>
<tr>
<td style="text-align:center">SIGVTALRM</td>
<td style="text-align:center">setitimer函数设置的Virtual Interval Timer超时的时候</td>
</tr>
<tr>
<td style="text-align:center">SIGWAITING</td>
<td style="text-align:center">Solaris Thread Library内部实现专用</td>
</tr>
<tr>
<td style="text-align:center">SIGWINCH</td>
<td style="text-align:center">当Terminal的窗口大小改变的时候，发送给Foreground Group的所有进程</td>
</tr>
<tr>
<td style="text-align:center">SIGXCPU</td>
<td style="text-align:center">当CPU时间限制超时的时候</td>
</tr>
<tr>
<td style="text-align:center">SIGXFSZ</td>
<td style="text-align:center">进程超过文件大小限制</td>
</tr>
<tr>
<td style="text-align:center">SIGXRES</td>
<td style="text-align:center">Solaris专用，进程超过资源限制的时候发送</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意</strong></p>
<ul>
<li>不要使用低级的或者STDIO.H的IO函数</li>
<li>不要使用对操作</li>
<li>不要进行系统调用</li>
<li>不是浮点信号的时候不要用longjmp</li>
<li>signal函数是由ISO C定义的。因为ISO C不涉及多进程，进程组以及终端I/O等，所以他对信号的定义非常含糊，以至于对UNIX系统而言几乎毫无用处。</li>
<li>备注：因为signal的语义与现实有关，所以最好使用sigaction函数替代本函数</li>
</ul>
<p>当某个信号出现时，系统有三种处理方式： </p>
<ul>
<li>忽略信号：大多数信号使用，但SIGKIL和SIGSTOP不能被忽略 </li>
<li>捕捉信号：通知内核在某种信号发生时，调用一个用户函数 </li>
<li>执行系统默认动作：异常终止(abort)、退出(exit)、忽略(ignore)、停 止(stop)或继续(continue)</li>
</ul>
<p><strong>功能 </strong></p>
<ul>
<li>发送信号：发送进程把信号送到指定进程信号域的某一位上，如目标进程正在一个可被中断的优先级上睡眠，核心便将其唤醒 </li>
<li>预置对信号的处理方式：进程处于核心态时，即使受到软中断也不予理睬；只有当它返回到用户态后，才处理软中断信号 </li>
<li>收受信号的进程按事先规定完成对相应事件的处理</li>
</ul>
<h3 id="进程的软中断通信——函数的使用"><a href="#进程的软中断通信——函数的使用" class="headerlink" title="进程的软中断通信——函数的使用"></a>进程的软中断通信——函数的使用</h3><ul>
<li><p>向一个进程或一组进程发送一个信号：int kill(pid, sig)<br> pid&gt;0时，核心将信号发送给进程pid<br> pid&lt;0时，核心将信号发送给与发送进程同组的所有进程<br> pid=-1时，核心将信号发送给所有用户标识符真正等于发送进程的有 效用户标识号的进程</p>
</li>
<li><p>预置信号接收后的处理方式：signal(sig, function)<br> function=1时，屏蔽该类信号<br> function=0时，收到sig信号后终止自己<br> function为非0、非1类整数时，执行用户设置的软中断处理程序</p>
</li>
</ul>
<h3 id="Linux进程间通信—管道和有名管道"><a href="#Linux进程间通信—管道和有名管道" class="headerlink" title="Linux进程间通信—管道和有名管道"></a>Linux进程间通信—管道和有名管道</h3><ul>
<li>管道用于具有亲缘关系进程间的通信<ul>
<li>管道是半双工的，数据只能单向流动（双方通信需建立两个管道）</li>
<li>管道只能用于父子进程或兄弟进程之间</li>
<li>管道对于管道两端的进程而言就是一个文件，并单独构成一种文件 系统，存在于内存中</li>
<li>写管道的内容添加在管道缓冲区的末尾，读管道则从缓冲区头部读 出</li>
</ul>
</li>
<li>有名管道在普通管道具备功能基础上，通过给管道命名的 方法变成管道文件，允许无亲缘关系进程间通过访问管道 文件进行通信</li>
</ul>
<h4 id="无名管道的使用"><a href="#无名管道的使用" class="headerlink" title="无名管道的使用"></a>无名管道的使用</h4><ul>
<li>int pipefd[2]; int pipe(pipefd); /*创建无名管道*/<br> pipefd[0]只能用于读;  pipe[1]只能用于写</li>
</ul>
<p>pipe函数定义中的fd参数是一个大小为2的一个数组类型的指针。该函数成功时返回0，并将一对打开的文件描述符值填入fd参数指向的数组。失败时返回 -1并设置errno。</p>
<p>通过pipe函数创建的这两个文件描述符 fd[0] 和 fd[1] 分别构成管道的两端，往 fd[1] 写入的数据可以从 fd[0] 读出。并且 fd[1] 一端只能进行写操作，fd[0] 一端只能进行读操作，不能反过来使用。要实现双向数据传输，可以使用两个管道。</p>
<p>默认情况下，这一对文件描述符都是阻塞的。此时，如果我们用read系统调用来读取一个空的管道，则read将被阻塞，知道管道内有数据可读；如果我们用write系统调用往一个满的管道中写数据，则write也将被阻塞，直到管道有足够的空闲空间可用(read读取数据后管道中将清除读走的数据)。当然，用户可自行将 fd[0] 和 fd[1] 设置为非阻塞的。</p>
<p>如果管道的写端文件描述符 fd[1] 的引用计数减少至0，即没有任何进程需要往管道中写入数据，则对该管道的读端文件描述符 fd[0] 的read操作将返回0(管道内不存在数据的情况)，即读到了文件结束标记(EOF，End Of File)；反之，如果管道的读端文件描述符 fd[0] 的引用计数减少至0，即没有任何进程需要从管道读取数据，则针对该管道的写端文件描述符 fd[1] 的write操作将失败，并引发SIGPIPE信号(往读端被关闭的管道或socket连接中写数据)。</p>
<p>管道内部传输的数据是字节流，这和TCP字节流的概念相同。但它们又存在细微的差别。应用层程序能往一个TCP连接中写入多少字节的数据，取决于对方接受窗口的大小和本端的拥塞窗口的大小。而管道的话本身拥有一个容量限制，它规定如果管道的写端应用程序不将管道中数据读走的话，该管道最多还能被写入多少字节的数据。管道容量的大小默认是65536字节。我们也可以使用fcntl函数来修改管道容量。</p>
<div align="center">
<img width="500" src="/2019/12/02/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1/12/02/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1/2.jpg">
</div>

<ol>
<li><p>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。</p>
</li>
<li><p>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</p>
</li>
<li><p>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</p>
</li>
</ol>
<ul>
<li>将数据写入管道：write() <ul>
<li>函数原型:<code>int write(int handle, void *buf, int nbyte)</code></li>
<li>管道长度受到限制，管道满时写入操作将被阻塞，直到管道中的 数据被读取 </li>
<li>fcntl()可将管道设置为非阻塞模式</li>
</ul>
</li>
<li>从管道读取数据：read() <ul>
<li>函数原型:<code>ssize_t read   (int fd, void *buf, size_t count);</code></li>
<li>返回值：成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0。</li>
<li>参数：参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移。注意这个读写位置和使用C标准I/O库时的读写位置有可能不同，这个读写位置是记在内核中的，而使用C标准I/O库时的读写位置是用户空间I/O缓冲区中的位置。比如用fgetc读一个字节，fgetc有可能从内核中预读1024个字节到I/O缓冲区中，再返回第一个字节，这时该文件在内核中记录的读写位置是1024，而在FILE结构体中记录的读写位置是1。注意返回值类型是ssize_t，表示有符号的size_t，这样既可以返回正的字节数、0（表示到达文件末尾）也可以返回负值-1（表示出错）。<br>read函数返回时，返回值说明了buf中前多少个字节是刚读上来的。有些情况下，实际读到的字节数（返回值）会小于请求读的字节数count，例如：读常规文件时，在读到count个字节之前已到达文件末尾。例如，距文件末尾还有30个字节而请求读100个字节，则read返回30，下次read将返回0。</li>
<li>当数据被读取后，数据将自动被管道清除 </li>
<li>不能由一个进程向多个进程同时传递同一个数据 </li>
<li>fcntl()可将管道读模式设置为非阻塞模式 </li>
</ul>
</li>
<li>关闭管道：close()<ul>
<li>函数原型:<code>int close(int fd);</code></li>
<li>返回值：成功返回0，出错返回-1并设置errno</li>
<li>参数fd是要关闭的文件描述符。需要说明的是，当一个进程终止时，内核对该进程所有尚未关闭的文件描述符调用close关闭，所以即使用户程序不调用close，在终止时内核也会自动关闭它打开的所有文件。但是对于一个长年累月运行的程序（比如网络服务器），打开的文件描述符一定要记得关闭，否则随着打开的文件越来越多，会占用大量文件描述符和系统资源。</li>
<li>关闭读端口时，在管道上进行写操作的进程将收到SIGPIPE信号 </li>
<li>关闭写端口时，进行读操作的read()函数将返回0</li>
</ul>
</li>
</ul>
<h4 id="管道通信的使用—命名管道的创建与读写"><a href="#管道通信的使用—命名管道的创建与读写" class="headerlink" title="管道通信的使用—命名管道的创建与读写"></a>管道通信的使用—命名管道的创建与读写</h4><ul>
<li>创建命名管道： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mod, <span class="type">dev_t</span> dev)</span>； </span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>；</span><br></pre></td></tr></table></figure></li>
<li>命名管道必须先调用open()将其打开 <ul>
<li>同时用读写方式(O_RDWR)打开时，一定不会导致阻塞 </li>
<li>以只读方式(O_RDONLY)打开时，调用open()函数的进程将会被 阻塞直到有写方打开管道 </li>
<li>以写方式(O_WRONLY)打开时，阻塞直到有读方打开管道</li>
</ul>
</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>实现进程简单控制和利用管道通信</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">//exex、fork头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span>  <span class="comment">//signal头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  <span class="comment">//wait头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span>  <span class="comment">//wait头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  <span class="comment">//exit头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> <span class="comment">//mutex头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pipefd[<span class="number">2</span>];   <span class="comment">/*创建无名管道,pipefd[0]只能用于读;  pipe[1]只能用于写*/</span></span><br><span class="line"><span class="type">int</span> child_1, child_2;  <span class="comment">//用于存储创建的子进程pid</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;  <span class="comment">//进程互斥锁，避免抢占打印输出</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kill_child1</span><span class="params">()</span> &#123; <span class="comment">//父进程杀死子进程1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Child process 1 is killed by parent!\n&quot;</span>);</span><br><span class="line">	close(pipefd[<span class="number">1</span>]);  <span class="comment">//关闭管道写端</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">//子进程1退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kill_child2</span><span class="params">()</span> &#123; <span class="comment">//父进程杀死子进程2</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Child process 2 is killed by parent!\n&quot;</span>);</span><br><span class="line">	close(pipefd[<span class="number">0</span>]);  <span class="comment">//关闭管道读端</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">//子进程2退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kill_childprocess</span><span class="params">()</span> &#123;  <span class="comment">//父进程捕捉到中断信号，用系统调用Kill()向两个子进 程发出信号</span></span><br><span class="line">	<span class="keyword">if</span> (kill(child_1, SIGUSR1) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Kill child1 process error!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (kill(child_2, SIGUSR1) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Kill child2 process error!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> rtn; </span><br><span class="line">	pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>); <span class="comment">//初始化mutex</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建管道 </span></span><br><span class="line">	<span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Create a nameless pipe error!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建第一个子进程</span></span><br><span class="line">	<span class="keyword">switch</span> (child_1 = fork())</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> - <span class="number">1</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Create child process failed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		close(pipefd[<span class="number">0</span>]);  <span class="comment">//子进程1关闭读端</span></span><br><span class="line">		signal(SIGINT, SIG_IGN);  <span class="comment">//SIGINT:由Interrupt Key产生，通常是CTRL+C或者DELETE。</span></span><br><span class="line">													 <span class="comment">//发送给所有ForeGround Group的进程</span></span><br><span class="line">		signal(SIGUSR1, kill_child1);   <span class="comment">// 设置进程处理信号</span></span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">//死循环里每秒通过管道发送信号给子进程2</span></span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">			write(pipefd[<span class="number">1</span>], (<span class="type">void</span>*)&amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">			pthread_mutex_lock(&amp;mutex);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;I have send you %d times!\n&quot;</span>, i);</span><br><span class="line">			pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建第二个子进程</span></span><br><span class="line">	<span class="keyword">switch</span> (child_2 = fork())</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Create child process failed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		close(pipefd[<span class="number">1</span>]);  <span class="comment">//子进程关闭写端</span></span><br><span class="line">		signal(SIGINT, SIG_IGN);  <span class="comment">//SIGINT:由Interrupt Key产生，通常是CTRL+C或者DELETE。</span></span><br><span class="line">											 <span class="comment">//发送给所有ForeGround Group的进程</span></span><br><span class="line">		signal(SIGUSR1, kill_child2);   <span class="comment">// 设置进程处理信号</span></span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">//死循环里每秒通过管道发送信号给子进程2</span></span><br><span class="line">			read(pipefd[<span class="number">0</span>], (<span class="type">void</span>*)&amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">			pthread_mutex_lock(&amp;mutex);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;I have received your message %d times!\n&quot;</span>, i);</span><br><span class="line">			pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	signal(SIGINT,kill_childprocess);  <span class="comment">//当捕捉到中断信号后</span></span><br><span class="line">	<span class="comment">//父进程用系统调用Kill()向两个子进 程发出信号</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//等到两个子进程结束</span></span><br><span class="line">	waitpid(child_1, &amp;rtn, <span class="number">0</span>);</span><br><span class="line">	waitpid(child_2, &amp;rtn, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭管道</span></span><br><span class="line">	close(pipefd[<span class="number">0</span>]);</span><br><span class="line">	close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Parent Process is killed!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>HMF
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="http://yorxika.github.io/2019/12/02/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1/" title="Linux进程的软中断和管道通信">http://yorxika.github.io/2019/12/02/进程的软中断和管道通信/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E8%BF%9B%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 进程</a>
              <a href="/tags/Linux/" rel="tag"><i class="fa fa-tag"></i> Linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%A0%E9%A2%98/" rel="prev" title="动态规划习题">
      <i class="fa fa-chevron-left"></i> 动态规划习题
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/02/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/" rel="next" title="打家劫舍">
      打家劫舍 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E6%9F%A5%E7%9C%8B"><span class="nav-number">1.</span> <span class="nav-text">Linux进程管理命令——进程查看</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%E2%80%94%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-number">2.</span> <span class="nav-text">Linux进程管理命令—进程终止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">3.</span> <span class="nav-text">Linux进程控制函数——进程创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fork"><span class="nav-number">3.1.</span> <span class="nav-text">fork()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exec"><span class="nav-number">3.2.</span> <span class="nav-text">exec()</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#include"><span class="nav-number"></span> <span class="nav-text">include </span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E8%BF%9B%E7%A8%8B%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="nav-number">0.1.</span> <span class="nav-text">Linux进程属性操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA"><span class="nav-number">0.2.</span> <span class="nav-text">进程退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-number">0.3.</span> <span class="nav-text">等待进程终止</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E9%80%9A%E4%BF%A1"><span class="nav-number">1.</span> <span class="nav-text">进程的软中断通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#signal"><span class="nav-number">1.1.</span> <span class="nav-text">signal()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">进程的软中断通信——函数的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E2%80%94%E7%AE%A1%E9%81%93%E5%92%8C%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">3.</span> <span class="nav-text">Linux进程间通信—管道和有名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.1.</span> <span class="nav-text">无名管道的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E2%80%94%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AF%BB%E5%86%99"><span class="nav-number">3.2.</span> <span class="nav-text">管道通信的使用—命名管道的创建与读写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B"><span class="nav-number">4.</span> <span class="nav-text">实例</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="HMF"
      src="/images/touxiang.jpg">
  <p class="site-author-name" itemprop="name">HMF</p>
  <div class="site-description" itemprop="description">To your valor, my sword, and our victory together.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">246</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Yorxika" title="GitHub → https://github.com/Yorxika" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:huamingf@foxmail.com" title="E-Mail → mailto:huamingf@foxmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

<div id="music163">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=300 height=370 src="//music.163.com/outchain/player?type=0&id=7760409930&auto=1&height=430"></iframe>
</div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HMF</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">968k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">14:40</span>
</div><script color="255,255,255" opacity="0.5" zIndex="-1" count="180" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '0635d0bc6ad58e628693',
      clientSecret: 'a02a3a1ab4874ccb117251539125fe3a1a4d43da',
      repo        : 'blogtalk',
      owner       : 'Yorxika',
      admin       : ['Yorxika'],
      id          : md5(window.location.pathname),
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","hOffset":40,"width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
