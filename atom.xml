<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nameless blog</title>
  <icon>https://www.gravatar.com/avatar/ac88b61adfe8890cbf94b774785887f8</icon>
  <subtitle>But one day, you will stand before its decrepit gate,without really knowing why.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yorxika.github.io/"/>
  <updated>2019-12-26T13:49:17.897Z</updated>
  <id>http://yorxika.github.io/</id>
  
  <author>
    <name>HMF</name>
    <email>774123033@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一些讨论</title>
    <link href="http://yorxika.github.io/2019/12/26/%E4%B8%80%E4%BA%9B%E8%AE%A8%E8%AE%BA/"/>
    <id>http://yorxika.github.io/2019/12/26/%E4%B8%80%E4%BA%9B%E8%AE%A8%E8%AE%BA/</id>
    <published>2019-12-26T12:52:23.000Z</published>
    <updated>2019-12-26T13:49:17.897Z</updated>
    
    <content type="html"><![CDATA[<p>计算机系统的性能能被准确测量吗？</p><p>不能，计算机的性能与很多因素有关，比如指令集、程序自身等，是一个综合的考量。所以是没法用一个统一的指标来描述计算机系统的性能，这是不够全面不够客观的。<a id="more"></a>且各种测量的标准，比如MIPS、MFLOPS等等，都是针对某一个或者某一类测试程序而言，但实际上，每一个计算机系统进行的工作都不一样，很难出现像测试程序中设想的样子，所以测试的结果并不能准确衡量一个实际应用中的计算机系统的性能。</p><hr><p>浮点数零与浮点数溢出之间的关系</p><p>浮点数零是阶位E为0且小数位M为0的情况。浮点数溢出有两种情况：上溢和下溢。上溢是指数据绝对值太大，机器无法表示；下溢是指数据绝对值太小，机器无法表示。如果运算结果落在上溢区，则产生溢出错误，机器停止运算；如果运算结果落在下溢区，由于数据绝对值很小，常作零处理。</p><hr><p>什么条件下对CRC检测出的错误可以按照CRC的纠错原理进行纠错</p><p>如果没有总校验位的，CRC至多能检测出一位错，并可以进行纠正。如果增设总校验位，可以判断出一位错和两位错，对于判断出两位错的情况，选择丢弃当前数据，发送送重传信号给传输方。</p><hr><p>如何检测程序运行中的数据溢出错误</p><p>无符号数根据最高进位是否溢出进行判断，具体说来，加法看进位是为1，减法看是否为0<br>有符号数有三种方法：<br>1.两个操作数的符号位相同时判断结果的符号是否与操作数相同<br>2.次高位和最高位进位异或<br>3.利用双符号运算，10负溢出，01正溢出</p><hr><p>为什么计算机采用二进制？</p><p>1.对于计算机而言，数据表示方便使用高低电平表示1,0<br>2.运算规则简单<br>3.利于数据纠错，只需要找出是哪一位错了就能纠错<br>4.可以使用逻辑门进行算数运算</p><hr><p>数据存放的大、小端方式对程序设计有何影响？</p><p>数据存放的大小端方式对程序员透明。一般来说，在同一机器，程序员不用考虑这一问题（因为在统一要么大端要么小端）。而且原则上，不同机器在传输过程中一定会考虑大小端问题（网络的表示层进行转化），但是也有可能会在传输过程中有的机器做的不够好，产生高低字节反转或者未识别大小端的情况。</p><hr><p>为什么动态存储器比精态存储器慢</p><p>DRAM读之前需要预充电<br>DRAM需要每隔一段时间进行刷新<br>DRAM存储体的行列地址线复用，导致每次需要分时传送</p><hr><p>为什么计算机需要使用多种数据寻址方式</p><p>从数据的存放特点上看，计算机需要处理的数据的存储方式是多种多样的，可以是存储在寄存器中的一些中间结果，可以是调入到内存中的一些变量，也可以是存放在主存设备中的数据，要将这些不同存储方式的数据调入CPU内进行运算，仅采用单一的寻址方式是很难实现的；<br>从程序设计的角度上看，多种的数据寻址方式能为程序设计很高的灵活性，例如对数组或结构成员的访问，可采用基址寻址，对指针对象进行访问可以用寄存器间接寻址，等等；<br>从执行的效率角度上看，寄存器寻址速度很快，但不能访问主存，寄存器间接寻址速度较慢，但可以访问主存，立即寻址较快，但寻址范围受限，为了使程序能够获得较高的性能但又不失方便性，多种的数据寻址方式能够均衡这两个矛盾。</p><hr><p>系统总线能否用作存储总线</p><p>原理上可以，但会降低系统并行性，增加复杂度</p><hr><p>总线性能分析 试从总线的性能指标分析，为什么目前串行总线比较流行。</p><p>串行传输所需要的传输线少，成本低，适合远距离传输。缺点：每次只能传输一位数据，所以传输速度很慢。并行传输的需要的传输线与信息位有关，所有位同时传输，传输速度非常快，但是要求的线路多，成本很高，适用于短距离传输。实际使用过程中，使用串行传输，用户基本感觉不到太大的延迟，所以串行传输在成本上比较占据优势。</p><hr><p>单级总线结构 为什么嵌入式处理器系统通常采用单级总线结构？</p><p>程序和数据共同使用一个存储空间，程序指令存储器地址和数据存储地址指向同一个存储器的不同物理位置。该结构的程序指令宽度相同，采用单一的地址及数据总线，比较典型的例子就是MIPS</p><hr><p>总线仲裁 试分析什么情况下需要进行总线仲裁。</p><p>系统中多个设备或模块可能同时申请对总线的使用权，为避免产生总线冲突，需由总线仲裁机构合理地控制和管理系统中需要占用总线的申请者，在多个申请者同时提出总线请求时，以一定的优先算法仲裁哪个应获得对总线的使用权。</p><hr><p>总线标准  能否预测一下，下一代总线标准会是怎样的。</p><p>1、面向存储器的双总线结构信息传送效率较高，这是它的主要优点。但CPU与I/O接口都要访问存储器时，仍会产生冲突。所以下一步是解决或减少这样的冲突。<br>2、CPU与高速的局部存储器和局部I/O接口通过高传输速率的局部总线连接，速度较慢的全局存储器和全局I/O接口与较慢的全局总线连接，从而兼顾了高速设备和慢速设备，使它们之间不互相牵扯。<br>3、简化了硬件的设计。便于采用模块化结构设计方法，面向总线的微型计算机设计只要按照这些规定制作cpu插件、存储器插件以及I/O插件等，将它们连入总线就可工作，而不必考虑总线的详细操作。<br>4、简化了系统结构。整个系统结构清晰。连线少，底板连线可以印制化。<br>5、系统扩充性好。一是规模扩充，规模扩充仅仅需要多插一些同类型的插件。二是功能扩充，功能扩充仅仅需要按照总线标准设计新插件，插件插入机器的位置往往没有严格的限制。<br>6、系统更新性能好。因为cpu、存储器、I/O接口等都是按总线规约挂到总线上的，因而只要总线设计恰当，可以随时随着处理器的芯片以及其他有关芯片的进展设计新的插件，新的插件插到底板上对系统进行更新，其他插件和底板连线一般不需要改。<br>7、便于故障诊断和维修。用主板测试卡可以很方便找到出现故障的部位，以及总线类型。</p><hr><p>存储IO和通信IO  举例分析存储IO和通信IO的异同。</p><p>存储IO是在缓存与磁盘阵列之间进行数据交换的过程，涉及IO接口和读写性能，存储IO的速度取决于磁盘的速度。<br>通信IO是通过网络进行数据交换，比如socket，执行阻塞IO，通过应用层，运输层，网络层，数据链路层，物理层的五级网络架构进行数据的封装和交换。</p><hr><p>中断IO方式  为什么中断IO方式的应用最广泛。</p><p>可以让CPU避免忙于查询各个外部设备的状态，提高CPU利用率;<br>中断除了传输数据还可以处理异常;<br>软硬件结合的方式也让使用成本变得不是那么高。<br>因而应用广泛。</p><p>由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。 同步IO模式，程序暂停执行后续代码，等待数据写入磁盘，再接着往下执行； 异步IO模式，CPU不等待，只是告诉磁盘继续读写，后续代码可以立刻接着执行。 当有新的IO请求时，设备发出中断请求，CPU收到请求后，进行IO请求中断响应，完成响应后恢复现场，回到原来的地方继续执行。 当IO完成时，设备发出完成IO的中断信号，CPU进入中断处理读写完成的数据和缓存。 采用中断IO的方式，大大提高了有IO需求时，CPU的工作效率</p><hr><p>中断优先级  中断优先级低的中断请求能否优先处理完成，为什么？</p><p>在中断处理程序中设置新的中断屏蔽字。为了能根据需要，改变实际的中断处理次序，很多机器都设置了中断屏蔽寄存器硬件，以决定是否让某级中断请求进入中断优先权电路进行优先权比较。级别高的中断请求优先得到响应。只要将每一类中断处理程序的各级中断屏蔽位设置成不同的状态，就可以得到所希望的中断处理次序。因此，可以通过设置中断屏蔽字实现低优先级的中断先处理，实际上，可以任意改变处理次序，这为中断处理带来了灵活性。</p><hr><p>DMA传输模式  你觉得DMA传输模式的控制可由什么部件来实现的。</p><p>当外围设备要求传送一批数据时，由<strong>DMA控制器</strong>发一个停止信号给CPU，要求CPU放弃对地址总线、数据总线和有关控制总线的使用权。DMA控制器获得总线控制权以后，开始进行数据传送。在一批数据传送完毕后，DMA控制器通知CPU可以使用内存，并把总线控制权交还给CPU在这种DMA传送过程中，CPU基本处于不工作状态或者说保持状态。DMA传输方式无需CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件为RAM与I/O设备开辟一条直接传送数据的通路，使CPU的效率大为提高。</p><hr><p>实验中的所选用的生成多项式对编码求余数的循环周期是多少？为什么？</p><p>CRC-5，余数为5位，只有全为0时表示正确，剩余31种状态表示错误，也就是出错的状态有31种。</p><hr><p>Logisim中的毛刺如何消除？</p><p>增加冗余项、增加惯性延时环节（logisim中可以增加缓冲器），选通法</p><hr><p>逻辑门组件最多可以有32个输入，实际电路中有这样的逻辑门吗？</p><p>理论上有，但是实际实验时输入太多会使逻辑变得非常复杂，而且输入增多, 门电路里的晶体管也会增多, 本身即会增大门电路时延, 同时多晶体管也不利于电平的稳定控制，需要更大的电压。</p><hr><p>如果合并LW，SW指令第三个状态，微程序控制器需要如何修改？<br>本次实验中，LW指令，SW指令的第三个时钟周期的状态进行了分离，简化了设计，如果不进行状态分离，微程序控制器需要做什么修改？给出你的方案。</p><p>增加一个判断位，假设判断位不为00时使用下址字段给出的地址，判断位为其他值时使用地址转移逻辑给出的地址（判断位为01表示计算地址状态），更改地址转移逻辑，增加判断位为地址转移逻辑输入，当判断位为01时，地址转移逻辑根据指令的不同给出不同的下址</p><hr><p>硬件cache机制设计实验研讨<br>1）如果采用软件程序来实现cache，哪种映射方法更有效？<br>2）如果采用软件程序实现cache，LRU算法采用什么数据结构实现更加方便？<br>3）软件实现中不可能实现全相联查找的并发查找机制，如何提升查找速度？</p><p>我个人回答：全相连，哈希链表，哈希</p><hr><p>MIPS 寄存器文件设计实验研讨  零号寄存器的值为什么要恒零，这样做有什么好处？</p><p>汇编代码中有大量赋值为0或者与0比较的指令，设置一个恒0的寄存器可以避免这类指令中装载立即数0的过程，可以提高效率</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机系统的性能能被准确测量吗？&lt;/p&gt;
&lt;p&gt;不能，计算机的性能与很多因素有关，比如指令集、程序自身等，是一个综合的考量。所以是没法用一个统一的指标来描述计算机系统的性能，这是不够全面不够客观的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机组成原理" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="组成原理" scheme="http://yorxika.github.io/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>输入输出系统</title>
    <link href="http://yorxika.github.io/2019/12/26/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yorxika.github.io/2019/12/26/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/</id>
    <published>2019-12-26T11:22:46.000Z</published>
    <updated>2019-12-26T12:51:55.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="输入输出接口概述"><a href="#输入输出接口概述" class="headerlink" title="输入输出接口概述"></a>输入输出接口概述</h2><p>输入/输出系统组成：外部设备、接口部件、总线以及相应的管理软件统称为计算机的 输入/输出系统，简称I/O系统。<a id="more"></a><br><img src="/2019/12/26/输入输出系统/image-20191226193057280.png" alt="image-20191226193057280"></p><p>I/O系统基本功能：</p><ul><li>完成计算机内部二进制信息与外部多种信息形式间的交流；</li><li>保证CPU能够正确选择输入输出设备并实现对其控制，传输大量数据、 避免数据出错；</li><li>利用数据缓冲、选择合适的数据传送方式等，实现主机与外设间 速度的匹配。</li></ul><p>I/O系统特点：</p><ul><li>异步性：外围设备相对于处理机通常是异步工作的；</li><li>实时性：当外围设备与处理机交互时，由于设备的类型不同，它们的工 作步调是不同的，处理机必须按照不同设备所要求传送方式和传输速率 不失时机地为设备提供服务，这就要求实时性控制；</li><li>与设备无关性：各种外部设备必须根据其特点和要求选择一种标准接口 和处理机进行连接，它们之间的差别必须由设备本身的控制器通过硬件 和软件来填补；这样，处理机本身无须了解外设的具体细节，可以采用 统一的硬件和软件对其管理。</li></ul><h3 id="输入-输出设备同CPU交换数据的过程"><a href="#输入-输出设备同CPU交换数据的过程" class="headerlink" title="输入/输出设备同CPU交换数据的过程"></a>输入/输出设备同CPU交换数据的过程</h3><p>输入过程：</p><ul><li>CPU把一个地址值放在地址总线上，这一步将选择某一输入设备；</li><li>CPU等候输入设备的数据成为有效；</li><li>CPU从数据总线读入数据，并放在一个相应的寄存器中</li></ul><p>输出过程：</p><ul><li>CPU把一个地址值放在地址总线上，选择输出设备</li><li>CPU把数据放在数据总线上；</li><li>输出设备认为数据有效，从而把数据取走</li></ul><h3 id="I-O系统性能"><a href="#I-O系统性能" class="headerlink" title="I/O系统性能"></a>I/O系统性能</h3><p>按照主要完成的工作可以分为以下二类：存储 I/O  通信 I/O</p><p>I/O系统的性能对CPU的性能有很大的影响，若两者的性能不匹配，I/O系统就有可能成为整个系统的瓶颈。</p><p>评价I/O系统性能的主要参数：</p><ul><li>连接特性：哪些I/O设备可以和计算机系统相连接</li><li>I/O系统的容量：I/O系统可以容纳的I/O设备数 </li><li>响应时间和吞吐率等</li><li>系统的响应时间：从用户输入命令开始，到得到结果所花费的时间； 由I/O系统的响应时间和CPU的处理时间两部分构成，单位通常用秒（s）表示。</li><li>I/O的吞吐率：单位时间完成的I/O操作次数，单位通常用IOP表示。</li></ul><h2 id="输入输出方式"><a href="#输入输出方式" class="headerlink" title="输入输出方式"></a>输入输出方式</h2><p>输入/输出方式：</p><ul><li>无条件I/O方式</li><li>程序控制I/O方式</li><li>中断I/O方式</li><li>DMA（Direct Memory Access）方式</li><li>通道方式</li><li>I/O处理机方式</li></ul><h3 id="无条件I-O方式"><a href="#无条件I-O方式" class="headerlink" title="无条件I/O方式"></a>无条件I/O方式</h3><ul><li>在程序的适当位置直接安排 I/O指令，当程序执行到这些 I/O指令时，CPU默认外设始终是准备就绪的（I/O总是准备好接收CPU的输出数据，或 总是准备好向CPU输入数据）， 无需检查I/O的状态，就进行数据的传输；</li><li>硬件接口电路和软件控制程序都比较简单。输入时，必须确保CPU执行 I/O指令读取数据时，外设已将数据 准备好；输出时，必须确保外部设备 的数据锁存器为空，即外设已将上次 的数据取走，等待接收新的数据，否 则会导致数据传送出错，但一般的外设难以满足这种要求。</li></ul><h3 id="程序控制方式"><a href="#程序控制方式" class="headerlink" title="程序控制方式"></a>程序控制方式</h3><p>一种早期计算机采用的输入/输出方式，数据在计算机和外设之 间的传送全部靠计算机程序控制；计算机执行I/O指令时，先获取外设状态，并根据外设的状态决定下一步操作。</p><p>程序查询的I/O原理：</p><ul><li>程序先向I/O设备发出I/O命令字； </li><li>读取I/O设备工作状态信息； </li><li>检查状态字中的标志，看是否可以进行数据交换； </li><li>若设备未准备就绪，则返回到上步，重复查询；否则，发出设备准备就绪信号； </li><li>CPU与I/O接口的数据缓冲寄存器进行数据交换，与此同时，将接口中的状态标志复位<br><img src="/2019/12/26/输入输出系统/image-20191226194626791.png" alt="image-20191226194626791"></li></ul><p>设备状态字寄存器：</p><ul><li>用来标志设备的工作状态，以便接口对外部设备进行监视。 </li><li>CPU通过程序查询设备状态位来判断设备的状态。 </li><li>因此，设备状态寄存器是设备对主机的窗口，主机通过它了解设备的 状态，并对设备设置操作方式。 </li><li>设备状态寄存器又叫设备状态字（DSW）是设备所有状态的集合，每 种状态均用一个触发器来表示。</li></ul><p>特点：何时对何设备进行输入输出操作完全受CPU控制， 外围设备与CPU处于异步工作关系，数据的输入/输出都要经过CPU。<br>优点：计算机和外设之间能够同步，控制简单，硬件简单。<br>缺点：CPU的大量时间用来查询外设的状态</p><h3 id="中断I-O方式"><a href="#中断I-O方式" class="headerlink" title="中断I/O方式"></a>中断I/O方式</h3><ul><li>当外设准备好后，主动通知CPU并进行接收或输出数据的方法；</li><li>CPU接到外设的通知后暂停现行的工作，转入中断服务程序，和外设交换数据， 等中断程序处理完毕后，再返回到被中断的原程序中继续以前被暂停的工作。</li></ul><p>优点：节约CPU时间，实时性好。<br>缺点：控制电路相对复杂，服务开销较大（现场和断点的保护）。<br>应用场合：实时性要求高，且数据传输量又不大的场合</p><h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><ul><li>是一种完全由硬件执行的I/O交换方式</li><li>当外设准备好后，通知DMA控制器，DMA控制器从CPU接管总线，并完成外 设和内存之间的大量数据传输；传输完成后DMA控制器将总线控制权交还给 CPU，整个数据交换的过程不需要CPU参与。</li></ul><p>优点：既有中断的优点，同时又降低了服务开销。<br>缺点：控制电路更加复杂。<br>应用场合：高速、大批量数据传输。</p><h3 id="通道和I-O处理机方式"><a href="#通道和I-O处理机方式" class="headerlink" title="通道和I/O处理机方式"></a>通道和I/O处理机方式</h3><ul><li>复杂的计算机系统中，外围设备的台数一般比较多，设备的种类、工作方式 和工作速度的差别很大，为了把对外围设备的管理工作从CPU中分离出来，采 用通道或I/O处理机方式。</li><li>通道是能够专门执行I/O指令的处理机，它可以实现对外围设备的统一管理， 以及外设与主存之间的数据传输。</li><li>I/O处理机是通道方式的进一步发展，它的结构更接近于一般处理机。</li></ul><h2 id="中断请求与响应"><a href="#中断请求与响应" class="headerlink" title="中断请求与响应"></a>中断请求与响应</h2><p>中断：是指CPU在正常运行程序时，由于内部/外部事 件（或由程序）引起CPU中断正在运行的程序，而转到 为中断事件服务的程序中去，服务完毕，再返回执行原 程序的这一过程。<br>中断的特征：具有随机性。</p><p>中断的作用：</p><ul><li><p>实现主机与外设之间的并行工作</p></li><li><p>故障处理：中断系统能使计算机在运行过程中出现故障的时候， 调用相应的中断服务程序处理故障。</p></li><li><p>实时处理<br><img src="/2019/12/26/输入输出系统/image-20191226200348777.png" alt="image-20191226200348777"></p><h3 id="中断的类型"><a href="#中断的类型" class="headerlink" title="中断的类型"></a>中断的类型</h3><ul><li>内部中断</li><li>软件中断</li><li>异常<ul><li>故障(Fault)</li><li>自陷(Trap)</li><li>终止(Abort)</li></ul></li></ul></li><li><p>外部中断</p><ul><li>可屏蔽中断INTR</li><li>不可屏蔽中断NMI</li></ul></li><li><p>内部中断：来自于CPU内部的指令中断请求，分为软件中断和异常。</p></li><li><p>外部中断：中断请求来自CPU外部，又分为可屏蔽和不可屏蔽中断。</p></li><li><p>不可屏蔽中断NMI：由系统内部硬件引发的中断，优先级高于外部硬 件中断，且不受中断允许标志位的影响，所以是不可屏蔽中断。</p></li><li><p>可屏蔽中断：由外设通过中断请求线向处理器申请而产生的中断，处 理器可以用指令来屏蔽（禁止），即不响应它的中断请求。</p></li></ul><h3 id="中断系统的基本功能"><a href="#中断系统的基本功能" class="headerlink" title="中断系统的基本功能"></a>中断系统的基本功能</h3><ul><li>中断请求信号保持与清楚</li><li>中断优先级</li><li>中断源识别</li><li>中断的处理</li><li>中断控制</li></ul><h4 id="中断请求信号保持与清除"><a href="#中断请求信号保持与清除" class="headerlink" title="中断请求信号保持与清除"></a>中断请求信号保持与清除</h4><ul><li>中断号：是系统分配给每个中断源的代号，以便识别和处理。中断号在中断处理过程中起到很重要的作用。</li><li>中断号的获取：CPU对系统中不同类型的中断源，获取它们的中断号 的方法是不同的。</li></ul><p><img src="/2019/12/26/输入输出系统/image-20191226200930087.png" alt="image-20191226200930087"></p><h4 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h4><p>中断触发方式：是指外设以什么逻辑信号去申请中断，即边沿触发和电 平触发两种方式。<br>中断排队方式：当系统有多个中断源时，就可能出现同时有几个中断源 都申请中断，而处理器在一个时刻只能响应并处理一个中断请求；为此， 要进行中断排队。处理器按“优先级高的先服务”的原则提供服务。</p><ul><li>按优先级排队：根据任务的轻重缓急，给每个中断源指定CPU响应的 优先级，任务紧急的先响应，可以暂缓的后响应。 </li><li>循环轮流排队：不分级别高低，CPU轮流响应各个中断源的中断请求。</li></ul><p>中断嵌套：</p><ul><li>当CPU正在处理某个中断时，会出现优先级更高的 中断源申请中断；为了使更紧急的、级别更高的中断源及时得到服务，需要暂时打断（挂起）当前正 在执行的中断服务程序，去处理级别更高的中断请 求，处理完成后再返回被打断了的中断服务程序继 续执行。 </li><li>但级别相同或级别低的中断源不能打断级别高的中 断服务，这就是所谓的中断嵌套。 </li><li>可屏蔽中断可以进行中断嵌套。NMI不可以进行中断嵌套。</li></ul><p>中断屏蔽：</p><ul><li>处理器用指令来控制中断屏蔽触 发器的状态，从而控制是否接受 某个特殊外设的中断请求。</li><li>处理器内部也有一个中断允许触 发器，只有当其为“1”（即开中 断），CPU才能响应外部中断。</li></ul><p>中断优先级：是指CPU响应和处理中断请求的先后次序<br>为了兼顾中断响应的时效与配置的灵活，通常采用两套机制结合组成 中断优先序管理体系：</p><ul><li>硬件响应优先序：未被屏蔽的几个中断源同时提出申请时， CPU选择服务对象的顺序由硬件电路实现，用户不能修改。 </li><li>软件服务优先序：在各中断服务程序开头，用软件设置自己 的中断屏蔽字，以此改变实际服务顺序。</li></ul><h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><ul><li>中断响应周期：当CPU收到外设的中断请求后，如果当前一条指令已执行完，且允许中断， CPU进入中断响应周期，发出中断应 答信号完成一个中断响应周期。</li><li>中断响应：读取中断源的中断号，完成中断申请与中断响应的握手过程。</li></ul><p>中断处理：</p><ul><li><p>标志位的处理与断点保存<br>处理器获得外部中断源的中断号后，保存断点（返回地址），关闭中断，保护现场。</p></li><li><p>向中断服务程序转移并执行中断服务程序</p></li><li><p>返回断点<br>中断服务程序执行完毕后，恢复断点和现场， 要返回主程序。</p><p>单级中断处理流程：<br><img src="/2019/12/26/输入输出系统/image-20191226201407259.png" alt="image-20191226201407259"></p><p>多级中断处理流程：<br><img src="/2019/12/26/输入输出系统/image-20191226201438871.png" alt="image-20191226201438871"></p><h2 id="DMA方式-1"><a href="#DMA方式-1" class="headerlink" title="DMA方式"></a>DMA方式</h2></li></ul><p>DMA方式的基本原理：数据的传送不经过CPU，由DMA控制器实现内存和外设、外设和外 设之间的直接快速传送。<br>用于需要高速大批量数据传送的系统中。<br><img src="/2019/12/26/输入输出系统/image-20191226202606347.png" alt="image-20191226202606347"></p><p>DMA传输计算机系统构成：</p><ul><li>DMA控制器作为主设备之一<br><img src="/2019/12/26/输入输出系统/image-20191226202653346.png" alt="image-20191226202653346"></li><li>DMA控制器与I0接口集成<br><img src="/2019/12/26/输入输出系统/image-20191226202732946.png" alt="image-20191226202732946"></li><li>DMA控制器提供专门I/O中间<br><img src="/2019/12/26/输入输出系统/image-20191226202757677.png" alt="image-20191226202757677"></li></ul><p>DMA控制器(DMAC)：<br>DMA控制器的两种工作状态</p><ul><li>被动态（受控器）：未取得总线控制权，受CPU的控制。</li><li>主动态（主控器）：接管并取得总线控制权，取代CPU而成为系统的主控者。</li></ul><h3 id="DMA传输步骤"><a href="#DMA传输步骤" class="headerlink" title="DMA传输步骤"></a>DMA传输步骤</h3><ul><li>申请阶段：一个设备接口试图通过总线直接向另一个设备发送数据(一般是大批量的数据)，它会先向 CPU发送DMA请求信号；</li><li>响应阶段：CPU收到DMA请求信号后，在当前的总线周期结束后，会按DMA信号的优先级和提出 DMA请求的先后顺序响应DMA信号；</li><li>数据传送阶段 CPU对某个设备接口响应DMA请求时，会让出总线控制权；于是在DMA控制器的管理下，外设和存储器直接进行数据交换，而不需CPU干预；</li><li>传送结束阶段 ：数据传送完毕后，设备接口会向CPU发送DMA结 束信号，交还总线控制权。</li></ul><h3 id="DMA操作类型"><a href="#DMA操作类型" class="headerlink" title="DMA操作类型"></a>DMA操作类型</h3><ul><li>数据传送：把源地址的数据传输到目的地址去（存储器或I/O）。</li><li>数据校验：不进行数据传输，只对数据块内部的每个字节进行某种校验； 这种数据校验一般安排在读数据块之后，以便校验所读的数据是否有效。</li><li>数据检索：不进行数据传输，只是在指定的内存区域内查找某个关键字节 或某几个数据位是否存在</li></ul><h3 id="DMA操作方式"><a href="#DMA操作方式" class="headerlink" title="DMA操作方式"></a>DMA操作方式</h3><ul><li>单字节传输模式：每次DMA操作传送一个字节后，接着释放总线。</li><li>块传输模式：连续传送多个字节，每传输一个字节，当前字节计数器 减1，当前地址寄存器加1或减1，直到所要求的字节数传输完（当前 字节计数器减至0），然后释放总线。</li><li>请求传输模式：DMA控制器要询问外设，当外设请求信号无效时， 暂停传输（不释放总线）；当请求信号再次有效后，继续进行传输。</li><li>级联传输模式：多片DMA控制器级联，构成主从式DMA系统。</li></ul><h3 id="DMA传输模式"><a href="#DMA传输模式" class="headerlink" title="DMA传输模式"></a>DMA传输模式</h3><h4 id="停止CPU访问内存"><a href="#停止CPU访问内存" class="headerlink" title="停止CPU访问内存"></a>停止CPU访问内存</h4><p>当需要传送一批数据时，DMA控制器首先要求CPU放弃对总线的控制权；然后开始进行数据传送。在一批数据传送完毕后，DMA控制器通知CPU可以使用内存，并把总线控制权交还给CPU。<br>在这种DMA传送过程中，CPU基本处于不工作状态或者说保持状态。<br>优点：控制简单，它适用于数据传输率很高的设备进行成组传送。<br>缺点：在DMA控制器访内存阶段，内存的效能没有充分发挥，相当一部分内存 工作周期是空闲的。这是因为，传送两个数据之间的间隔一般总是大于内 存存储周期，即使高速I/O设备也是如此。 </p><h4 id="请求传输模式——周期挪用"><a href="#请求传输模式——周期挪用" class="headerlink" title="请求传输模式——周期挪用"></a>请求传输模式——周期挪用</h4><p>当I/O设备没有DMA请求时，CPU按程序要求访问内存；一旦I/O设备有DMA请求，则由I/O设备挪用一个或几个内存周期。<br>I/O设备要求DMA传送时可能遇到两种情况： </p><ul><li>当CPU不需要访内时，此时I/O访内与CPU访内没有冲突，即 I/O设备挪用一二个内存周期对CPU执行程序没有任何影响； </li><li>CPU也同时要求访问内存，这就产生了访存冲突，在这种情况 下I/O设备访存优先。<br>优点：既实现了I/O传送，又较好地发挥了内存和CPU的效率，是一种广泛采 用的方法。<br>缺点：I/O设备每一次周期挪用都有申请、建立、归还总线控制权的过程，所 以传送一个字对内存来说要占用一个周期，但对DMA控制器来说一般要2-5个内存周期；因此，周期挪用方法适用于I/O设备读写周期大于内存存储周期的 情况。</li></ul><h4 id="请求传输模式——DMA与CPU交替访存"><a href="#请求传输模式——DMA与CPU交替访存" class="headerlink" title="请求传输模式——DMA与CPU交替访存"></a>请求传输模式——DMA与CPU交替访存</h4><p>如果CPU的工作周期比内存存取周期长很多，此时采用交替访存的方法，可以使DMA传送和CPU同时发挥最高的效率。<br>这种方式不需要总线使用权的申请、建立和归还过 程，总线使用权是通过分 时进行的，这种总线控制权的转移几乎不需要什么时间，所以对DMA传送来讲效率是很高的。<br>这种传送方式又称为”透明的DMA”方式，在透 明的DMA方式下工作，CPU既不停止主程序的 运行，也不进入等待状态，同样是一种高效率的 工作方式。<br>缺点：相应的硬件逻辑也就更加复杂。 </p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>采用DMA方式传送数据时，每传送一个数据就要用一个（<strong>存储周期</strong>）时间。</p><hr><p>通道对CPU的请求形式是(<strong>中断</strong>)</p><hr><p>描述PCI总线中基本概念正确的句子是（<strong>ACD</strong>）。<br>A.HOST 总线不仅连接主存，还可以连接多个CPU<br>B.以桥连接实现的PCI总线结构不允许许多条总线并行工作<br>C.PCI 总线体系中有三种桥，它们都是PCI 设备<br>D.桥的作用可使所有的存取都按CPU 的需要出现在总线上</p><hr><p>中断向量地址是<strong>中断服务例行程序入口地址的指示器</strong></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;输入输出接口概述&quot;&gt;&lt;a href=&quot;#输入输出接口概述&quot; class=&quot;headerlink&quot; title=&quot;输入输出接口概述&quot;&gt;&lt;/a&gt;输入输出接口概述&lt;/h2&gt;&lt;p&gt;输入/输出系统组成：外部设备、接口部件、总线以及相应的管理软件统称为计算机的 输入/输出系统，简称I/O系统。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机组成原理" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="组成原理" scheme="http://yorxika.github.io/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>系统总线</title>
    <link href="http://yorxika.github.io/2019/12/26/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/"/>
    <id>http://yorxika.github.io/2019/12/26/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/</id>
    <published>2019-12-26T08:40:21.000Z</published>
    <updated>2019-12-26T10:35:14.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总线的特性及其应用"><a href="#总线的特性及其应用" class="headerlink" title="总线的特性及其应用"></a>总线的特性及其应用</h2><p>总线的概念：是计算机体系结构的重要组成部分，通过它可以将计算机系统中各个功能部件连接起来，构成一个完整的系统。</p><a id="more"></a><p>总线的作用：</p><ul><li>是各功能部件间传递各类信息的通道；</li><li>是系统中各部件间的物理接口，能够减少各部件通信的复杂程度； </li><li>提供信息交换时所需的数据、地址、时序和控制信息； </li><li>提供一个共同遵循的协议或标准； </li><li>不应成为整个计算机性能的瓶颈； </li><li>方便计算机系统的集成、扩展和进化。</li></ul><p>总线的分类：总线分类的方式有很多，如被分为外部总线和内部 总线、系统总线和非系统总线、片内总线和PCB板级总线、串行总线 和并行总线、高速总线和低速总线、同步总线和异步总线，专用总线 和通用总线等等。</p><h3 id="按用途分"><a href="#按用途分" class="headerlink" title="按用途分"></a>按用途分</h3><ul><li>存储总线：短距离、 高速总线，与存储器 的特性相匹配，尽最 大可能提高处理器与 存储器之间的数据带 宽，针对Cache块数 据传输进行性能优化；</li><li>系统总线：又称内 部总线或板级总线， 是计算机系统中最 重要的总线，也是 连接存储总线和I/O 总线的中间总线；</li><li>I/O总线：通常连 接距离较远、速度 相对较慢，用于连 接多种外部设备， 同时与系统总线或 存储总线连接。</li></ul><h3 id="按位置分"><a href="#按位置分" class="headerlink" title="按位置分"></a>按位置分</h3><p>按照总线所在的位置，总线可以分为：</p><ul><li>外部总线：USB、火线（IEEE-1394）等</li><li>内部总线：PCI、AGP等</li><li>片内总线：AMBA</li></ul><h3 id="总线的组成"><a href="#总线的组成" class="headerlink" title="总线的组成"></a>总线的组成</h3><ul><li>数据总线：用于传送数据信息，通常是双向三态形式的总线；</li><li>地址总线：专门用来传送地址，地址总线总是单向三态的;</li><li>控制总线：用来传送控制信号和时序信号。</li><li>电源线和地</li></ul><h2 id="总线性能和总线事物"><a href="#总线性能和总线事物" class="headerlink" title="总线性能和总线事物"></a>总线性能和总线事物</h2><h3 id="总线性能参数："><a href="#总线性能参数：" class="headerlink" title="总线性能参数："></a>总线性能参数：</h3><p>总线性能参数：</p><ul><li>总线频率：反映总线工作的速率（f），通常单位是MHz； </li><li>总线宽度：数据总线的位数（w），单位是b（位）， 是微型计算机的一个重要指标，通常与处理器的字长相一致； </li><li>总线传输速率：总线上可传输的数据总量（BW），单位是MB/s； 总线传输速率＝（总线宽度÷8位）×总线频率 BW = （w÷8）× f </li><li>同步方式：同步、异步</li><li>多路复用：地址线和数据线能否共用一条物理线；</li><li>信号线数量：数据线、控制线和地址线的总和；</li><li>总线控制方式：传输方式、配置方式、中断分配和仲裁方式等。</li></ul><h3 id="总线事物"><a href="#总线事物" class="headerlink" title="总线事物"></a>总线事物</h3><ul><li>总线事务：从请求总线到完成总线使用的操作序列称 为总线事务（Bus Transaction），它是在一个总线周 期中发生的一系列活动。</li><li>典型的总线事务包括：请求操作、裁决操作、地址传 输、数据传输和总线释放。</li></ul><p>主设备（master）：能够提出申请并获得总线控制权的设备；<br>从设备（slave）   ：只能被动接受总线控制传送数据的设备。</p><p><img src="/2019/12/26/系统总线/image-20191226170508498.png" alt="image-20191226170508498"></p><h3 id="总线传输过程"><a href="#总线传输过程" class="headerlink" title="总线传输过程"></a>总线传输过程</h3><ul><li>总线传输：在主设备（如CPU、DMA控制器等）控制 下通过总线进行的信息传送（数据读写）操作。 </li><li>总线完成一次数据传输操作，一般经过如下四个阶段：<ul><li>申请与仲裁阶段</li><li>寻址阶段</li><li>传输阶段</li><li>结束阶段</li></ul></li></ul><p>常见总线操作：</p><ul><li>读操作（Read）</li><li>写操作（Write）</li><li>读修改写操作（Read-modify-Write）</li><li>写后读操作（Read-after-Write）</li><li>块操作（Block）等</li></ul><h2 id="总线连接方式"><a href="#总线连接方式" class="headerlink" title="总线连接方式"></a>总线连接方式</h2><h3 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h3><ul><li>访问存储器和访问外设指令相同，由地址来区分；</li><li>总线简单，使用灵活，易于扩展；</li><li>任意两设备之间理论上都可以直接交换信息；</li><li>所有设备分时工作，仅适用于慢速的计算机系统中。</li></ul><p><img src="/2019/12/26/系统总线/image-20191226171940833.png" alt="image-20191226171940833"></p><h3 id="双级总线结构"><a href="#双级总线结构" class="headerlink" title="双级总线结构"></a>双级总线结构</h3><ul><li>由于外设和内存分处于不同的总线，需要增加I/O指令；</li><li>存储总线的增加减轻了系统总线的负担，提高了并行性； </li><li>仍然保持了单总线结构的系统简单、易于扩充的优点。</li></ul><p><img src="/2019/12/26/系统总线/image-20191226172026248.png" alt="image-20191226172026248"></p><h3 id="多级总线结构"><a href="#多级总线结构" class="headerlink" title="多级总线结构"></a>多级总线结构</h3><ul><li>在双级总线结构的基础上增加I/O总线构成； </li><li>并行性进一步提高，并可以通过增加通道或IO处理机来分担部分CPU 的I/O功能，但是总线结构得越来越复杂。</li></ul><p><img src="/2019/12/26/系统总线/image-20191226172053836.png" alt="image-20191226172053836"></p><h3 id="总线示例"><a href="#总线示例" class="headerlink" title="总线示例"></a>总线示例</h3><h4 id="多级总线示例"><a href="#多级总线示例" class="headerlink" title="多级总线示例"></a>多级总线示例</h4><p>总线桥：是不同速率总线 之间的连接器件，起信号 速度缓冲、电平转换、控 制协议转换等作用。</p><p><img src="/2019/12/26/系统总线/image-20191226172131126.png" alt="image-20191226172131126"></p><h4 id="单级总线示例"><a href="#单级总线示例" class="headerlink" title="单级总线示例"></a>单级总线示例</h4><p><img src="/2019/12/26/系统总线/image-20191226172214936.png" alt="image-20191226172214936"></p><h3 id="总线结构对计算机系统性能的影响"><a href="#总线结构对计算机系统性能的影响" class="headerlink" title="总线结构对计算机系统性能的影响"></a>总线结构对计算机系统性能的影响</h3><ul><li>对最大存储容量的影响：单总线结构有影响，双总线和多总线结构没有；</li><li>对指令系统的影响：双总线和多总线结构需要增加IO指令；</li><li>吞吐量：单总线结构的吞吐量小，多总线结构的吞吐量大，双总线结 构的吞吐量居中</li></ul><h2 id="总线仲裁和数据传输方式"><a href="#总线仲裁和数据传输方式" class="headerlink" title="总线仲裁和数据传输方式"></a>总线仲裁和数据传输方式</h2><h3 id="菊花链式串行总线仲裁"><a href="#菊花链式串行总线仲裁" class="headerlink" title="菊花链式串行总线仲裁"></a>菊花链式串行总线仲裁</h3><p><img src="/2019/12/26/系统总线/image-20191226173643508.png" alt="image-20191226173643508"></p><h3 id="集中式并行总线仲裁"><a href="#集中式并行总线仲裁" class="headerlink" title="集中式并行总线仲裁"></a>集中式并行总线仲裁</h3><p><img src="/2019/12/26/系统总线/image-20191226173726362.png" alt="image-20191226173726362"></p><h3 id="常见总线仲裁策略"><a href="#常见总线仲裁策略" class="headerlink" title="常见总线仲裁策略"></a>常见总线仲裁策略</h3><ul><li>固定优先级总线仲裁</li><li>轮叫式总线仲裁（Round Robin）</li><li>LRG总线仲裁（Least Recently Granted）</li><li>混合式总线仲裁</li></ul><h3 id="总线时序"><a href="#总线时序" class="headerlink" title="总线时序"></a>总线时序</h3><h4 id="同步定时"><a href="#同步定时" class="headerlink" title="同步定时"></a>同步定时</h4><p>同步定时：信息传送由公共时钟控制，总线中包含时钟线。</p><p><img src="/2019/12/26/系统总线/image-20191226173902376.png" alt="image-20191226173902376"></p><ul><li>优点：时序关系简单，实现简单。</li><li>缺点：在设备速度不一致时按最坏情况确定， 传输线不能太长（时钟相移）。 </li></ul><h4 id="异步定时"><a href="#异步定时" class="headerlink" title="异步定时"></a>异步定时</h4><p>异步定时：信息传送的每一个操作都是由主设备或从设备特定信号的 跳变所确定，总线上每一个事件的发生取决于前一个事件的发生。</p><p><img src="/2019/12/26/系统总线/image-20191226174007685.png" alt="image-20191226174007685"></p><ul><li>优点：数据传输可靠，适用于传输周期不同的设备， 对通讯线的长度没有严格的要求。 </li><li>缺点：速度较慢。</li></ul><h4 id="半同步定时"><a href="#半同步定时" class="headerlink" title="半同步定时"></a>半同步定时</h4><p>半同步定时：总线上各操作之间的时间间隔可以变化，但仅允许为公 共时钟周期的整数倍。信号的出现、采样和结束仍以公共时钟为基准。</p><p><img src="/2019/12/26/系统总线/image-20191226174058360.png" alt="image-20191226174058360"></p><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><h4 id="并行传送"><a href="#并行传送" class="headerlink" title="并行传送"></a>并行传送</h4><ul><li>同时并行传送的二进位数就是数据宽度；</li><li>通常采用应答式的联络信号来协调双方的数据传送操作。</li></ul><h4 id="串行传送"><a href="#串行传送" class="headerlink" title="串行传送"></a>串行传送</h4><ul><li>只使用一根传输线，采用脉冲方式传送信息；</li><li>每次传送1位信息；</li><li>一次新的传送，一定是以一个电平的跳变开始。</li></ul><h4 id="串并传送"><a href="#串并传送" class="headerlink" title="串并传送"></a>串并传送</h4><ul><li>一次传送多个二进制位，但是同时传送的二进制位数小于数据宽度；</li><li>按照串行的方式将整个数据宽度传送完。</li></ul><h2 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h2><p>总线标准：计算机系统的各部件之间利用总线进行信 息传输时应遵守的协议和规范，包括硬件 和软件两个方面。</p><h3 id="常见总线标准"><a href="#常见总线标准" class="headerlink" title="常见总线标准"></a>常见总线标准</h3><ul><li>ISA（Industrial Standard Architecture）：最早制定的总线技术标 准，总线宽度8/16位，总线频率5<del>8MHz，总线带宽5</del>8MB/s。<br><img src="/2019/12/26/系统总线/image-20191226180444002.png" alt="image-20191226180444002"></li><li>EISA（Extended Industry Standard Architecture）总线：在ISA总 线的基础上为32位微机开发。</li><li>VESA（Video Electronics Standard Association)总线：1992年推， 它的推出为微机系统总线体系结构的革新奠定了基础，该总线系统考 虑到CPU与主存和Cache的直接相连。标准定义了32位数据线，且可 通过扩展槽扩展到64位，使用33MHz时钟频率，最大传输率为 128MB/s~132MB/s。</li><li>PCI（Peripheral Component Interconnect）总线：PCI是由Intel 公司1991年推出的总线规范，用于取代ISA；不同于ISA总线，PCI总 线的地址总线与数据总线是分时复用的，支持插即用。<ul><li>PCI总线支持10台外设，总线宽度32/64位，总线时钟 频率33.3MHz/66MHz，最大数据传输速率 133/264 MB/s，时钟同步方式，且与CPU的时钟频率无关。</li><li>插即用：是指当板卡插入系统时，系统会自动对板卡所需资源进行分 配，如基地址、中断号等，并自动寻找相应的驱动程序；而不象旧的 ISA板卡，需要进行复杂的手动配置。<br><img src="/2019/12/26/系统总线/image-20191226180527801.png" alt="image-20191226180527801"></li></ul></li><li>AGP（Accelerated Graphics Port）总线：是Intel公司1997年推出 的一种3D标准图像接口， 基于PCI2.1版规范并进 行扩充修改而成，它采 用点对点通道方式，能 够提供四倍于PCI的传输 速度。<br><img src="/2019/12/26/系统总线/image-20191226180559822.png" alt="image-20191226180559822"></li><li>PCIe（Peripheral Component Interconnect Express）总线：是 Intel公司2001年推出的一种高速串行计算机扩展总线标准，用于替 代PCI、PCI-X和AGP总线。<ul><li>PCIe相比以前的标准，有许多改进之外，包括：更高的最大 系统总线吞吐量，更低的I/O引脚数量和更小的物理尺寸，更 好的总线设备性能缩放，更详细的错误检测和报告机制； PCIe标准的更新版本为I/O虚拟化提供了硬件支持。</li><li>PCIe有多种不同速度的接口模式，包括：1X、2X、4X、8X、 16X 以及更高速的32X；PCIe 1X 模式的传输速率可以达到 250MB/s，PCIe 2.0 X16 接口能够提供8GB/s的总线带宽。<br><img src="/2019/12/26/系统总线/image-20191226180630424.png" alt="image-20191226180630424"></li></ul></li><li>USB（Universal Serial Bus）总线：是由Intel、Compaq、IBM、 Microsoft等多家公司1994年联合提出的一种通用串行总线。<ul><li>采用四线电缆，其中两根是用来传送数据的串行通道，另两根 为下游设备提供电源<br><img src="/2019/12/26/系统总线/image-20191226180817639.png" alt="image-20191226180817639"> </li><li>采用级联星型拓扑，由三个基本部分组成：主机（Host），集 线器（Hub）和功能设备<br><img src="/2019/12/26/系统总线/image-20191226180907659.png" alt="image-20191226180907659"></li><li>USB 1.1 总线带宽为12Mbps（1.5MB/s），可接入多达127 个设备。</li><li>USB 3.1 Gen2 最大传输速率可达10Gbps（1280MB/s）。</li><li>USB自推出后，已成功替代串口和并口，并成为个人电脑和大 量智能设备的必配的接口之一。</li></ul></li><li>AMBA（Advanced Microcontroller Bus Architecture）总线：是 ARM公司推出的片上总线；AMBA提供了一种特殊的机制，可将RISC 处理器集成在其它IP核和外设中。<br>AMBA 2.0 标准定义了三组总线<ul><li>AHB（Advanced High-Performance Bus）：AMBA高性能总线<br>AHB总线：属于高性能、高时钟频率的系统总线，主要特点包括流水 线操作、数据突发传输（Burst Transfer）、可支持多个总线主设备 （最多16个）、单时钟沿触发操作、总线宽度32、64、128位（最高 可达1024位，但推荐不要超过256位)。</li><li>ASB（Advanced System Bus）：AMBA系统总线<br>ASB总线：与AHB相比数据宽度要小一些，支持8、16、32位，且为三 态、双向总线。</li><li>APB（Advanced Peripheral Bus）：AMBA外设总线<br>APB总线：是本地二级总线，通过桥和AHB/ASB相连。它主要是为了满 足不需要高性能流水线接口或不需要高带宽接口的设备的互连。<br>AMBA总线结构：<br><img src="/2019/12/26/系统总线/image-20191226181128289.png" alt="image-20191226181128289"></li></ul></li><li>AMBA 4.0 是最新增添到AMBA系列中的规范，增加了三个新接口 协议（Advanced eXtensible Interface）：AXI4有助于最大化性 能和能效、AXI4-Lite和AXI4-Stream是 FPGA中实现的理想选择。<img src="/2019/12/26/系统总线/image-20191226181323636.png" alt="image-20191226181323636"></li></ul><p>特点：</p><ul><li>独立的读地址、写地址、读数据、写数据和写确认5个通道</li><li>支持乱序传输</li><li>支持固定模式突发传输， 主要用于I/O接口</li><li>支持系统高速缓存</li><li>持增强保护功能</li><li>互斥访问（用于semaphore操作</li><li>寄存器分片以便于高频操<br>AXI4总线结构：<br><img src="/2019/12/26/系统总线/image-20191226181340500.png" alt="image-20191226181340500"><ul><li>InfiniBand总线：是由InfiniBand行业协会推出的，该协会的主要成员 包括Compaq、Dell、HP、IBM、Intel、Microsoft和Sun等公司。</li></ul></li><li>InfiniBand是PCI总线的替代品，采用了与PCI完全不同的架构， 具有极高带宽和灵活的扩展能力，理论带宽分别可以达到 500MB/s、2GB/s和6GB/s。</li><li>InfiniBand解决了PCI总线中设备的距离问题，外部设备可以放 到距离服务器很远的地方工作（如果使用的是光缆，最远距离 可以达到0.3~10千米）。</li></ul><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>系统总线地址的功能是（<strong>指定主存和I / O设备接口电路的地址</strong>）。</p><hr><p>异步控制常用于（*<em>在单总线结构计算机中访问主存与外围设备时 *</em>）作为其主要控制方式。</p><hr><p>描述PCI总线中基本概念正确的句子是（<strong>BCD</strong>）。<br>A.PCI设备一定是主设备<br>B.PCI总线的基本传输机制是猝发式（Burst）传送<br>C.PCI总线是一个与处理器无关的高速外围总线<br>D.系统中可以有多条PCI总线</p><hr><p>下面叙述中，不正确的是（<strong>ABD</strong>）。<br>A.总线一定要和接口相连<br>B.总线始终由CPU控制和管理<br>C.接口一定要和总线相连<br>D.通道可以替代接口</p><hr><p>计算机使用总线结构的主要优点是便于实现积木化，同时（<strong>减少了信息传输线的条数</strong>）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;总线的特性及其应用&quot;&gt;&lt;a href=&quot;#总线的特性及其应用&quot; class=&quot;headerlink&quot; title=&quot;总线的特性及其应用&quot;&gt;&lt;/a&gt;总线的特性及其应用&lt;/h2&gt;&lt;p&gt;总线的概念：是计算机体系结构的重要组成部分，通过它可以将计算机系统中各个功能部件连接起来，构成一个完整的系统。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机组成原理" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="组成原理" scheme="http://yorxika.github.io/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>中央处理器</title>
    <link href="http://yorxika.github.io/2019/12/25/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://yorxika.github.io/2019/12/25/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</id>
    <published>2019-12-25T15:03:54.000Z</published>
    <updated>2019-12-26T08:39:52.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU组成与功能"><a href="#CPU组成与功能" class="headerlink" title="CPU组成与功能"></a>CPU组成与功能</h2><h3 id="CPU概述"><a href="#CPU概述" class="headerlink" title="CPU概述"></a>CPU概述</h3><a id="more"></a><p><img src="/2019/12/25/中央处理器/image-20191225231349628.png" alt="image-20191225231349628"></p><h3 id="CPU基本组成"><a href="#CPU基本组成" class="headerlink" title="CPU基本组成"></a>CPU基本组成</h3><ul><li>运算器 数据加工</li><li>控制器 程序执行/执行执行<ul><li>取指令 Mem[PC++] -&gt; IR</li><li>执行指令 <ul><li>指令字 -&gt; 控制信号序列</li><li>信号序列 -&gt; 数据通路</li></ul></li></ul></li></ul><p><img src="/2019/12/25/中央处理器/image-20191225231525021.png" alt="image-20191225231525021"></p><h3 id="CPU主要功能"><a href="#CPU主要功能" class="headerlink" title="CPU主要功能"></a>CPU主要功能</h3><p>取指令并执行指令的部件——CPU</p><ul><li>数据加工:  算术/逻辑运算  运算器</li><li>程序控制:  程序中指令执行顺序控制</li><li>操作控制:  将机器指令翻译成执行部件所需的操作控制信号</li><li>时序控制:  控制操作信号的产生时间、持续时间</li><li>异常控制:  异常处理，外设交互<br>后4个为控制器功能</li></ul><h3 id="主要寄存器"><a href="#主要寄存器" class="headerlink" title="主要寄存器"></a>主要寄存器</h3><ul><li>PC (Program Counter)——程序计数器 X86：EIP MIPS：PC</li><li>IR  (Instruction Register)——指令寄存器 [可选]</li><li>AR  (Address Register)——地址寄存器 MAR [可选]</li><li>DR  (Data Register)——数据缓冲寄存器 MDR [可选]</li><li>AC  (Accumulate Count)——累加寄存器 [可选]</li><li>PSW (Program Status Word)——程序状态字 [可选]<ul><li>X86 EFLAGS   MIPS：无</li></ul></li></ul><h3 id="操作控制器"><a href="#操作控制器" class="headerlink" title="操作控制器"></a>操作控制器</h3><p>取指令，将机器指令译码并生成执行部件控制信号序列 ，建立正确的数据 通路，从而完成指令的正确执行。</p><ul><li>硬布线控制器 (时序逻辑型)  (硬件实现)</li><li>微程序控制器 (存储程序型)  (软件实现)</li></ul><h2 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h2><p>数据通路——执行部件间传送信息的路径。</p><ul><li>通路的建立由控制信号控制，受时钟驱动；</li><li>不同指令、同一指令在执行的不同阶段的数据通路不同；</li><li>数据通路分类：共享通路（总线）、专用通路<ul><li>指令执行流程、执行效率</li><li>微操作控制信号的时序安排</li></ul></li></ul><h2 id="数据通路与总线结构"><a href="#数据通路与总线结构" class="headerlink" title="数据通路与总线结构"></a>数据通路与总线结构</h2><p>数据通路分类：</p><ul><li>共享通路（总线型）<ul><li>主要部件都连接在公共总线上，各部件间通过总线进行数据传输</li><li>结构简单，实现容易，但并发性较差，需分时使用总线，效率低</li></ul></li><li>专用通路<ul><li>并发度高，性能佳，设计复杂，成本高</li><li>可以看做多总线结构</li></ul></li></ul><p>单总线数据通路：<br><img src="/2019/12/25/中央处理器/image-20191225233819137.png" alt="image-20191225233819137"></p><p>双总线数据通路：<br><img src="/2019/12/25/中央处理器/image-20191225233848478.png" alt="image-20191225233848478"></p><p>三总线数据通路：<br><img src="/2019/12/25/中央处理器/image-20191225233919390.png" alt="image-20191225233919390"></p><h2 id="数据通路实例"><a href="#数据通路实例" class="headerlink" title="数据通路实例"></a>数据通路实例</h2><p>单总线CPU：<br><img src="/2019/12/25/中央处理器/image-20191225235209491.png" alt="image-20191225235209491"></p><p>多总线CPU：<br><img src="/2019/12/25/中央处理器/image-20191225235241019.png" alt="image-20191225235241019"></p><p>专用通路 单周期MIPS：<br><img src="/2019/12/25/中央处理器/image-20191225235310044.png" alt="image-20191225235310044"></p><h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><p>指令执行一般流程：<br><img src="/2019/12/25/中央处理器/image-20191226001010996.png" alt="image-20191226001010996"></p><p>指令周期基本概念：<br><img src="/2019/12/25/中央处理器/image-20191226001033946.png" alt="image-20191226001033946"></p><p>指令控制同步：<br>不同指令功能不同，复杂度不同，如何进行时间控制？</p><ul><li>定长指令周期：早期三级时序系统<ul><li>机器周期数固定，节拍数固定，按机器周期同步，mips单周期</li></ul></li><li>变长指令周期：现代时序系统<ul><li>机器周期数可变，节拍数可变，按时钟周期同步，mips多周期</li></ul></li></ul><p>早期三级时序系统<br><img src="/2019/12/25/中央处理器/image-20191226001138799.png" alt="image-20191226001138799"></p><p>时序产生与控制器：<br><img src="/2019/12/25/中央处理器/image-20191226001211781.png" alt="image-20191226001211781"></p><p>现代时序系统：<br><img src="/2019/12/25/中央处理器/image-20191226001239185.png" alt="image-20191226001239185"></p><h2 id="总线结构与CPU指令周期"><a href="#总线结构与CPU指令周期" class="headerlink" title="总线结构与CPU指令周期"></a>总线结构与CPU指令周期</h2><p><img src="/2019/12/25/中央处理器/image-20191226002209956.png" alt="image-20191226002209956"></p><h3 id="取指令数据通路"><a href="#取指令数据通路" class="headerlink" title="取指令数据通路"></a>取指令数据通路</h3><p><img src="/2019/12/25/中央处理器/image-20191226002222707.png" alt="image-20191226002222707"></p><h3 id="LOAD指令执行数据通路"><a href="#LOAD指令执行数据通路" class="headerlink" title="LOAD指令执行数据通路"></a>LOAD指令执行数据通路</h3><p><img src="/2019/12/25/中央处理器/image-20191226002311808.png" alt="image-20191226002311808"></p><h3 id="MOVE指令执行数据通路"><a href="#MOVE指令执行数据通路" class="headerlink" title="MOVE指令执行数据通路"></a>MOVE指令执行数据通路</h3><p><img src="/2019/12/25/中央处理器/image-20191226003023840.png" alt="image-20191226003023840"></p><h3 id="ADD指令执行数据通路"><a href="#ADD指令执行数据通路" class="headerlink" title="ADD指令执行数据通路"></a>ADD指令执行数据通路</h3><p><img src="/2019/12/25/中央处理器/image-20191226003041973.png" alt="image-20191226003041973"></p><h3 id="STORE指令执行数据通路"><a href="#STORE指令执行数据通路" class="headerlink" title="STORE指令执行数据通路"></a>STORE指令执行数据通路</h3><p><img src="/2019/12/25/中央处理器/image-20191226003103363.png" alt="image-20191226003103363"></p><h3 id="JMP指令执行数据通路"><a href="#JMP指令执行数据通路" class="headerlink" title="JMP指令执行数据通路"></a>JMP指令执行数据通路</h3><p><img src="/2019/12/25/中央处理器/image-20191226003124517.png" alt="image-20191226003124517"></p><h2 id="硬布线控制器设计I"><a href="#硬布线控制器设计I" class="headerlink" title="硬布线控制器设计I"></a>硬布线控制器设计I</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul><li>将控制器看成产生固定时序控制信号的逻辑电路</li><li>输入信号：指令译码，时钟信号，反馈信号</li><li>输出信号：功能部件控制信号序列</li><li>设计目标：最少元件，最快速度</li><li>理论基础：布尔代数</li><li>组成器件：门电路，触发器</li></ul><p><img src="/2019/12/25/中央处理器/image-20191226004240269.png" alt="image-20191226004240269"></p><h3 id="单总线结构CPU指令周期"><a href="#单总线结构CPU指令周期" class="headerlink" title="单总线结构CPU指令周期"></a>单总线结构CPU指令周期</h3><p><img src="/2019/12/25/中央处理器/image-20191226004314609.png" alt="image-20191226004314609"></p><p><img src="/2019/12/25/中央处理器/image-20191226004328026.png" alt="image-20191226004328026"></p><h3 id="时序产生器状态机与控制器基本架构"><a href="#时序产生器状态机与控制器基本架构" class="headerlink" title="时序产生器状态机与控制器基本架构"></a>时序产生器状态机与控制器基本架构</h3><p><img src="/2019/12/25/中央处理器/image-20191226004422271.png" alt="image-20191226004422271"></p><p><img src="/2019/12/25/中央处理器/image-20191226004440469.png" alt="image-20191226004440469"></p><p><img src="/2019/12/25/中央处理器/image-20191226004449528.png" alt="image-20191226004449528"></p><p>固定指令周期硬布线控制器设计过程</p><ol><li>设计三级时序产生器： 所有指令固定机器周期数，节拍数，</li><li>列出所有机器指令的指令周期流程图，明确每个节拍的控制信号；</li><li>找出产生同一微操作控制信号的条件；</li><li>写出各微操作控制信号的布尔表达式；</li><li>化简各表达式；</li><li>利用组合逻辑电路实现。</li></ol><h2 id="硬布线控制器设计II"><a href="#硬布线控制器设计II" class="headerlink" title="硬布线控制器设计II"></a>硬布线控制器设计II</h2><p>多周期</p><p><img src="/2019/12/25/中央处理器/image-20191226005355693.png" alt="image-20191226005355693"></p><p><img src="/2019/12/25/中央处理器/image-20191226005414350.png" alt="image-20191226005414350"></p><p>有限状态机真值表：<br><img src="/2019/12/25/中央处理器/image-20191226005443176.png" alt="image-20191226005443176"></p><p>可变周期硬布线控制器设计步骤</p><ol><li>列出所有机器指令的指令周 期流程图，明确每个节拍的 控制信号；</li><li>绘制指令执行状态转换图</li><li>根据状态转换图构建状态机 真值表，实现有限状态机组 合逻辑</li><li>实现控制器组合逻辑电路</li></ol><h2 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h2><p><img src="/2019/12/25/中央处理器/image-20191226141854193.png" alt="image-20191226141854193"></p><p>工作原理：</p><ul><li>微程序是利用软件方法来设计硬件的技术</li><li>将完成指令所需的控制信号按格式编写成微指令，存放到控制存储器<ul><li>一条机器指令对应一段微程序（多条微指令）</li><li>指令取指执行 -&gt; 微程序的执行 -&gt; 执行多条微指令 -&gt; 依次生成控制信号</li></ul></li><li>存储技术和程序设计相结合，回避复杂的同步时序逻辑设计</li></ul><p>单总线CPU微指令构造</p><ul><li>操作控制字段： 存储操作控制信号<ul><li>每一位对应一个控制信号，也称微命令，可同时给出多个操作信号</li></ul></li><li>顺序控制字段： 用于控制微程序的执行顺序<ul><li>判别逻辑为零，下一条微指令地址从下址字段获取，否则按约定规则生成</li></ul></li></ul><p><img src="/2019/12/25/中央处理器/image-20191226142125377.png" alt="image-20191226142125377"></p><p><img src="/2019/12/25/中央处理器/image-20191226142140226.png" alt="image-20191226142140226"></p><p>优劣：</p><ul><li>速度慢 访存频繁、成本低廉</li><li>设计规整，设计简单，易于修改、扩展指令系统功能<ul><li>适合CISC等功能较复杂的系列机 X86、IBM S/360、 DEC VAX</li><li>可写控存方便修复出厂故障 Intel Core 2 、Intel Xeon</li></ul></li><li>硬布线控制器执行速度快，但设计复杂，代价昂贵，不便于修改<ul><li>适合RISC计算机，如MIPS，ARM</li></ul></li></ul><h2 id="微程序设计"><a href="#微程序设计" class="headerlink" title="微程序设计"></a>微程序设计</h2><ul><li>一条微指令对应一个时钟周期</li><li>微指令操作控制字段的信号在该时钟周期内有效</li><li>指令需要多少时钟周期就包括多少微指令</li></ul><p><img src="/2019/12/25/中央处理器/image-20191226143130682.png" alt="image-20191226143130682"></p><h2 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h2><p>设计原则：</p><ul><li>有利于缩短微指令字长度</li><li>有利于减少控制存储器容量</li><li>有利于提高微程序执行速度</li><li>有利于对微指令进行修改</li><li>有利于提高微程序设计的灵活性</li></ul><p>直接表示简单直观，便于输出控制，微指令长度太长，控存容量大，如何压缩微指令长度？</p><ul><li>改直接表示为编码表示 （压缩互斥性微指令）</li><li>去掉下址字段，采用 μPC = μPC +1 的方式生成微指令地址</li><li>改水平型微指令为垂直型微指令 （牺牲并行性）</li></ul><p><img src="/2019/12/25/中央处理器/image-20191226144718065.png" alt="image-20191226144718065"></p><p>如果互斥的输出控制信号8个，编码后长度多少？<br>至少为4，预留一个状态表示所有状态输出为0</p><p><img src="/2019/12/25/中央处理器/image-20191226145046465.png" alt="image-20191226145046465"></p><p>垂直型微指令：<br><img src="/2019/12/25/中央处理器/image-20191226145128307.png" alt="image-20191226145128307"></p><ul><li>水平型微指令<ul><li>并行操作能力强，效率高，灵活性强，</li><li>微指令字较长，微程序短，控存容量大，性能佳</li></ul></li><li>垂直型微指令<ul><li>字长短，微程序长，控存容量小，性能差</li><li>垂直型与指令相似，易于掌握</li><li>基本被淘汰</li></ul></li></ul><h2 id="单周期MIPS-CPU"><a href="#单周期MIPS-CPU" class="headerlink" title="单周期MIPS CPU"></a>单周期MIPS CPU</h2><p>MIPS CPU控制器设计：</p><ul><li>定长指令周期：单周期实现<ul><li>所有指令均在一个时钟周期内完成， CPI=1</li><li>性能取决于最慢的指令，时钟周期过长</li></ul></li><li>变长指令周期：多周期实现<ul><li>缩短时钟周期，复用器件或数据通路</li><li>可支持流水操作，提升性能</li></ul></li></ul><p>R型指令格式<br><img src="/2019/12/25/中央处理器/image-20191226151355789.png" alt="image-20191226151355789"></p><p>I型指令格式<br><img src="/2019/12/25/中央处理器/image-20191226151416087.png" alt="image-20191226151416087"></p><p>数据通路：<br><img src="/2019/12/25/中央处理器/image-20191226151503460.png" alt="image-20191226151503460"></p><p> R型指令数据通路建立过程<br><img src="/2019/12/25/中央处理器/image-20191226151635760.png" alt="image-20191226151635760"></p><p>LW指令数据通路建立过程<br><img src="/2019/12/25/中央处理器/image-20191226151658900.png" alt="image-20191226151658900"></p><p>SW指令数据通路建立过程<br><img src="/2019/12/25/中央处理器/image-20191226151719963.png" alt="image-20191226151719963"></p><p>BEQ指令数据通路建立过程<br><img src="/2019/12/25/中央处理器/image-20191226151736211.png" alt="image-20191226151736211"></p><p>MIPS控制器设计：</p><ul><li>单周期控制器无时序逻辑，纯组合逻辑电路</li><li>输入信号<ul><li>指令字Opcode，Func字段（12位）</li></ul></li><li>输出信号<ul><li>多路选择器选择信号</li><li>内存访问控制信号</li><li>寄存器写使能信号</li></ul></li></ul><p><img src="/2019/12/25/中央处理器/image-20191226151829362.png" alt="image-20191226151829362"></p><h2 id="多周期MIPS-CPU"><a href="#多周期MIPS-CPU" class="headerlink" title="多周期MIPS CPU"></a>多周期MIPS CPU</h2><p>多周期MIPS数据通路特点</p><ul><li>不再区分指令存储器和数据存储器，分时使用部分功能部件</li><li>主要功能单元输出端增加寄存器锁存数据</li><li>传输通路延迟变小，时钟周期变短</li></ul><p>多周期MIPS CPU数据通路：<br><img src="/2019/12/25/中央处理器/image-20191226153829403.png" alt="image-20191226153829403"></p><p>多周期MIPS取指令阶段T1<br><img src="/2019/12/25/中央处理器/image-20191226153856881.png" alt="image-20191226153856881"></p><p>多周期MIPS取指令阶段T2<br><img src="/2019/12/25/中央处理器/image-20191226153913682.png" alt="image-20191226153913682"></p><p>R型指令执行状态周期T3~T4<br><img src="/2019/12/25/中央处理器/image-20191226154005989.png" alt="image-20191226154005989"></p><p>LW指令执行状态周期T3~T5<br><img src="/2019/12/25/中央处理器/image-20191226154026467.png" alt="image-20191226154026467"></p><p>Beq指令执行状态周期T3<br><img src="/2019/12/25/中央处理器/image-20191226154040788.png" alt="image-20191226154040788"></p><p>多周期状态转换图<br><img src="/2019/12/25/中央处理器/image-20191226154127994.png" alt="image-20191226154127994"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>冯•诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU依据（<strong>指令和数据的访问时间不同</strong> ）来区分它们</p><p>虽然指令和数据都是以二进制形式存放在存储器中，但 CPU 可以根据指令周期的不同阶段来区分是指令还是数据，通常在取指阶段取出的是指令，在执行阶段取出的是数据。本题容易误选 A ，需要清楚的是， CPU 只有在确定取出的是指令之后，才会将其操作码送去译码，因此，不可能依据译码的结果来区分指令和数据。</p><hr><p>某计算机指令集中包含有RR型运算指令、访存指令Load、Store、分支指令Branch和跳转指令Jump。若采用单周期数据通路实现该指令系统，若指令存储器和数据存储器的时延都是3ns;ALU时延为2ns;寄存器文件读写时延都是1ns。在不考虑多路复用器、控制单元、PC、符号扩展单元和传输线路等延迟的情况下，该计算机时钟周期至少为<strong>10ns</strong></p><p>单周期取指令3ns，访问寄存器文件1ns，计算需要ALU2ns，然后写入数据存储器3ns，然后在写回寄存器1ns</p><hr><p>下列有关指令周期的叙述中，正确的是（<strong>ACD</strong>）。（多选）<br>A.单周期CPU中的指令周期就是一个时钟周期<br>B.乘法指令和加法指令的指令周期总是一样长<br>C.指令周期的第一个阶段一定是取指令阶段<br>D.一个指令周期可由若干个机器周期或时钟周期组成</p><hr><p>下列寄存器中，对汇编语言程序员不透明的是（<strong>C</strong>）（单选）<br>A.程序计数器(PC)<br>B.存储器地址寄存器(MAR)<br>C.条件状态寄存器<br>D.存储器数据寄存器(MDR)</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CPU组成与功能&quot;&gt;&lt;a href=&quot;#CPU组成与功能&quot; class=&quot;headerlink&quot; title=&quot;CPU组成与功能&quot;&gt;&lt;/a&gt;CPU组成与功能&lt;/h2&gt;&lt;h3 id=&quot;CPU概述&quot;&gt;&lt;a href=&quot;#CPU概述&quot; class=&quot;headerlink&quot; title=&quot;CPU概述&quot;&gt;&lt;/a&gt;CPU概述&lt;/h3&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机组成原理" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="组成原理" scheme="http://yorxika.github.io/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>指令系统</title>
    <link href="http://yorxika.github.io/2019/12/25/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yorxika.github.io/2019/12/25/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</id>
    <published>2019-12-25T03:43:24.000Z</published>
    <updated>2019-12-26T17:18:30.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指令系统概述及指令格式"><a href="#指令系统概述及指令格式" class="headerlink" title="指令系统概述及指令格式"></a>指令系统概述及指令格式</h2><h3 id="指令的基本概念"><a href="#指令的基本概念" class="headerlink" title="指令的基本概念"></a>指令的基本概念</h3><ul><li>指令<ul><li>计算机能直接识别、执行的操作命令（机器指令）；</li><li>冯诺依曼结构计算机 “程序控制”原理实现的载体；</li></ul></li><li>指令系统（指令集）<a id="more"></a><ul><li>一台计算机中所有机器指令的集合；</li><li>系列机：同一公司不同时期生产，基本系统结构和指令系统相同的计算机。 如IBM，PDP-11，VAX-11，Intel-x86</li><li>兼容机：不同公司生产，基本系统结构和指令系统相同的计算机。 如IBM兼容机</li></ul></li><li>指令字长<ul><li>指令中包含的二进制位数 </li><li>与机器字长相比:   单字长、双字长、半字长等长度指令 </li><li>多字长指令：<ul><li>解决寻址较大存储空间的问题 </li><li>取指多次访问内存，影响速度，占用空间大</li></ul></li><li>等长指令: 指令字长度固定。</li><li>变长指令: 指令字长度根据需要可变</li></ul></li></ul><h3 id="指令分类"><a href="#指令分类" class="headerlink" title="指令分类"></a>指令分类</h3><p><img src="/2019/12/25/指令系统/image-20191225115956648.png" alt="image-20191225115956648"></p><p><img src="/2019/12/25/指令系统/image-20191225120008896.png" alt="image-20191225120008896"></p><p>根据指令中操作数的物理位置分类:</p><ul><li>存储器－存储器（SS）型</li><li>寄存器－寄存器（RR）型 </li><li>寄存器－存储器（RS）型</li></ul><p>根据指令功能分类：</p><ul><li>传送指令 MOV 、PUSH/POP、 IN/OUT等 </li><li>定点算术运算指令 ADD、SUB、INC、CMP、MUL等 </li><li>位运算指令 NOT、AND、OR、SHL、SAL等 </li><li>控制转移指令 JMP 、JNE、CALL、RET等</li></ul><h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><p><img src="/2019/12/25/指令系统/image-20191225120247603.png" alt="image-20191225120247603"></p><ul><li>操作码字段的位数与支持的最大指令数量有关 <ul><li>对于定长操作码而言，LengthOP =⌈log2 n⌉</li><li>支持变长操作码时，操作码向不用的地址码字段扩展</li></ul></li><li>寻址方式字段的位数与支持的寻址方式种类有关 </li><li>地址码字段的作用及影响与其位数和寻址方式有关</li></ul><h2 id="寻址方式及指令寻址"><a href="#寻址方式及指令寻址" class="headerlink" title="寻址方式及指令寻址"></a>寻址方式及指令寻址</h2><p>指令的顺序寻址</p><ul><li>程序的指令序列在主存顺序存放。执行时从第一条指令开始(!)，逐 条取出并执行，这种程序的顺序执行过程，称为顺序寻址方式。</li><li>CPU中设置程序计数器（PC）对指令的顺序号进行计数。PC开始时存 放程序的首地址，每执行一条指令，PC 加”1”，指出下条指令的地址， 直到程序结束。<ul><li>存储1条指令占用的字节单元数与存储字长有关！</li></ul></li></ul><p>跳跃寻址：<br><img src="/2019/12/25/指令系统/image-20191225123815326.png" alt="image-20191225123815326"></p><h2 id="操作数寻址方式"><a href="#操作数寻址方式" class="headerlink" title="操作数寻址方式"></a>操作数寻址方式</h2><h3 id="立即数寻址"><a href="#立即数寻址" class="headerlink" title="立即数寻址"></a>立即数寻址</h3><p>地址码字段是操作数本身<br>例 MOV  AX,200H    （ AX &lt;-  200H）<br>特点：</p><ul><li>取指操作将数据与指令一并读入CPU内部的寄存器，指令执行速度快 </li><li>便于程序设计（变量赋初值） </li><li>数据大小受字段位数限制</li></ul><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>操作数在CPU内部的寄存器中<br>例 MOV  AX, BX    （ AX &lt;-  ( BX）)<br>特点： </p><ul><li>操作数在寄存器中，指令执行速度快 </li><li>能访问的数据大小一般与计算机字长有关 </li><li>地址字段的位数与计算机通用寄存器数量相关</li></ul><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>地址码字段直接给出操作数在内存的地址.  E=D, S=(D)<br>例 MOV  AX, [200H]<br>特点：</p><ul><li>提供访问主存的操作 </li><li>获得数据要访问主存，指令执行速度慢 </li><li>地址字段的位数决定了访存空间大小</li></ul><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>地址码字段给出的是操作数主存地址的地址.  E=(D), S= ((D))<br>例 MOV  AX, I[200H]<br>特点：</p><ul><li>获得数据要访问主存2次，指令执行速度太慢 </li><li>解决了直接寻址方式下地址字段的位数限制访存范围大小的问题</li></ul><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p>地址码字段给出的是寄存器编号R.  E=(R), S= ((R))<br>例 MOV  AX, [BX]<br>特点：</p><ul><li>获得数据只需访问主存1次 </li><li>解决了直接寻址方式下地址字段的位数限制访存范围大小的问题</li></ul><h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><p>E=D + (PC), D为指令中地址字段的值特点：</p><p><img src="/2019/12/25/指令系统/image-20191225130335074.png" alt="image-20191225130335074"></p><ul><li>注意PC的改变对计算E的影响，如 本例中E = 200 + 2000 + 2 </li><li>可节省指令中的地址位数，便于程序在内存中成块移动</li></ul><p>例 某计算机采用双字节长指令,内存基于字节寻址,指令中的数据采用补码表示,且PC 的值在取指阶段完成修改。<br>1)若某采用相对寻址指令的当前地址为2003H,且要求转移后的目标地址为200AH, 则该指令形式地址字段的值为多少?<br>2)2)若某采用相对寻址的指令的当前地址为2008H,且要求转移后的目标地址为2001H, 则该指令的形式地址字段的值为多少?<br>解: 1)200AH – (2003H +2) = 5 (0000 0101)<br>2)2001H – (2008H +2) = -9 (1111 0111 即F7H)<br>若计算机字长32位, 且PC的值在取指阶段修改,情况如何?<br>+2变为+4</p><h3 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h3><p>指定一个基址寄存器B，与本指令地址无关 E= D + (B), D为指令中地址字段的值<br>MOV AX, 32[B]<br>特点：</p><ul><li>对某一程序而言，基址值设定后不变，故要访问不同数据需修改D </li><li>使用基址寄存器可以访问更大的主存空间</li></ul><h3 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h3><p>指定一个变址寄存器X，与本指令地址无关, 内容可随要求改变， E= D + (X), D为指令中地址字段的值<br>MOV AX, 32[SI]                 SI,DI 都称为变址寄存器<br>特点： </p><ul><li>不改变指令即可改变数据的有效地址，可在循环中使用 </li><li>在字符串处理，向量运算等等成批数据处理中非常有用</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2019/12/25/指令系统/image-20191225130635792.png" alt="image-20191225130635792"></p><h2 id="指令格式设计"><a href="#指令格式设计" class="headerlink" title="指令格式设计"></a>指令格式设计</h2><h3 id="指令格式设计主要内容"><a href="#指令格式设计主要内容" class="headerlink" title="指令格式设计主要内容"></a>指令格式设计主要内容</h3><ul><li>根据指令数量的要求及是否支持操作码扩展，确定操作码字段的位数</li><li>根据对操作数的要求确定地址码字段的个数 </li><li>根据寻址方式的要求，为每个地址码字段确定寻址方式字段位数 </li><li>确定采用定长指令还是变长指令</li></ul><h3 id="指令格式设计举例"><a href="#指令格式设计举例" class="headerlink" title="指令格式设计举例"></a>指令格式设计举例</h3><p>某机字长32位，采用三地址指令，支持8种寻址操作，完成60种操作，各 寻址方式均可在2K主存范围内取得操作数，并可在1K范围内保存运算结果。 问应采用什么样的指令格式？指令字长最少应为多少位？执行一条指令最多要 访问多少次主存？</p><p><img src="/2019/12/25/指令系统/image-20191225131913595.png" alt="image-20191225131913595"></p><hr><p>字长16位，主存64K，指令单字长单地址，80条指令。寻址方式有直接、 间接、相对、变址。请设计指令格式</p><p><img src="/2019/12/25/指令系统/image-20191225131937862.png" alt="image-20191225131937862"></p><p><img src="/2019/12/25/指令系统/image-20191225132001888.png" alt="image-20191225132001888"></p><hr><p>设某指令系统指令字长16位，每个地址码为6位。若要求设计二地址指令15 条、一地址指令34条，问最多还可设计多少条零地址指令？<br>解: OP(4) A1(6) A2(6)<br>操作码按从短码到长码进行扩展编码<br>假定二地址指令编码: (0000 – 1110)  共15条，1111作为扩展标识； 则一地址指令编码的全集可表示为: 1111 000000 – 111111(假定扩向A1)； 因一地址指令只需34条，可将全集中多余的30种编码作为向零地址指 令扩展的标识，假定为: 100010 – 111111 故最多可支持的故零地址指令数为： 30*2^6 条</p><h2 id="MIPS-指令概述"><a href="#MIPS-指令概述" class="headerlink" title="MIPS 指令概述"></a>MIPS 指令概述</h2><h3 id="MIPS-指令概述-1"><a href="#MIPS-指令概述-1" class="headerlink" title="MIPS 指令概述"></a>MIPS 指令概述</h3><ul><li>MIPS (Microprocessor without Intellocked Pipleline Stages)是80年代初期由斯 坦福大学Hennessy教授领导的研究小组研制成功； Million Instructions Per Second </li><li>属于精简指令集计算机RISC(Reduced Instruction Set Computer)；-&gt; 复杂指令集计算机CISC(Complex Instruction Set Computer )；</li><li>MIPS指令集有MIPS I，MIPS II，MIPS III，MIPS IV，MIPS V，MIPS32，和 MIPS64多个版本;</li><li>早期主要用于嵌入式系统，如Windows CE的设备，路由器，家用网关和视频游 戏机，现在已经在PC机、服务器中得到广泛应用</li></ul><p>MIPS指令集有以下特点： </p><ul><li>简单的Load/Store结构 </li><li>易于流水线CPU设计 </li><li>易于编译器开发 </li><li>MIPS指令的寻址方式非常简单，每条指令的操作也非常简单</li></ul><h3 id="MIPS指令格式概述"><a href="#MIPS指令格式概述" class="headerlink" title="MIPS指令格式概述"></a>MIPS指令格式概述</h3><p><img src="/2019/12/25/指令系统/image-20191225143633747.png" alt="image-20191225143633747"></p><h3 id="MIPS-寄存器"><a href="#MIPS-寄存器" class="headerlink" title="MIPS 寄存器"></a>MIPS 寄存器</h3><p><img src="/2019/12/25/指令系统/image-20191225143652075.png" alt="image-20191225143652075"></p><h3 id="MIPS-寻址方式"><a href="#MIPS-寻址方式" class="headerlink" title="MIPS 寻址方式"></a>MIPS 寻址方式</h3><ul><li>在MIPS32指令集中，不单设寻址方式说明字段<br><img src="/2019/12/25/指令系统/image-20191225143724205.png" alt="image-20191225143724205"></li><li>立即数寻址 ( Immediate addressing)<br><img src="/2019/12/25/指令系统/image-20191225143754663.png" alt="image-20191225143754663"></li><li>寄存器直接寻址(Register Addressing)<br><img src="/2019/12/25/指令系统/image-20191225143826805.png" alt="image-20191225143826805"></li><li>基址寻址(Basic Addressing)<br><img src="/2019/12/25/指令系统/image-20191225143858053.png" alt="image-20191225143858053"><br>使用基址寻址的指令：lw ,sw, lh, sh, lb, lbu等<br>LB rt , offset (base)</li><li>相对寻址<br><img src="/2019/12/25/指令系统/image-20191225143956018.png" alt="image-20191225143956018"><br>使用相对寻址的指令：beq, bne<br>if (GRP[rs] == GPR[rt]) PC = PC + 4 + BranchAddr</li><li>伪直接寻址(页面寻址)<br><img src="/2019/12/25/指令系统/image-20191225144037090.png" alt="image-20191225144037090"><br>使用伪直接寻址的指令：j, jal</li></ul><h2 id="MIPS指令详解"><a href="#MIPS指令详解" class="headerlink" title="MIPS指令详解"></a>MIPS指令详解</h2><h3 id="R型指令"><a href="#R型指令" class="headerlink" title="R型指令"></a>R型指令</h3><p><img src="/2019/12/25/指令系统/image-20191225145613421.png" alt="image-20191225145613421"></p><p>操作数和保存结果均通过寄存器进行； </p><ul><li>op：操作码，所有R型指令中都全为0； </li><li>rs：寄存器编号，对应第1个源操作数； </li><li>rt：寄存器编号，对应第2个源操作数； </li><li>rd：寄存器编号，据此保存结果； </li><li>shamt：常数，在移位指令中使用； </li><li>funct：功能码，指定指令的具体功能；</li></ul><p><img src="/2019/12/25/指令系统/image-20191225145707263.png" alt="image-20191225145707263"></p><h4 id="3寄存器R型指令"><a href="#3寄存器R型指令" class="headerlink" title="3寄存器R型指令"></a>3寄存器R型指令</h4><p><img src="/2019/12/25/指令系统/image-20191225145743811.png" alt="image-20191225145743811"></p><h4 id="2寄存器R型指令"><a href="#2寄存器R型指令" class="headerlink" title="2寄存器R型指令"></a>2寄存器R型指令</h4><p><img src="/2019/12/25/指令系统/image-20191225145805858.png" alt="image-20191225145805858"></p><h4 id="1寄存器R型指令"><a href="#1寄存器R型指令" class="headerlink" title="1寄存器R型指令"></a>1寄存器R型指令</h4><p><img src="/2019/12/25/指令系统/image-20191225145825365.png" alt="image-20191225145825365"></p><h3 id="I型指令"><a href="#I型指令" class="headerlink" title="I型指令"></a>I型指令</h3><p><img src="/2019/12/25/指令系统/image-20191225145843032.png" alt="image-20191225145843032"></p><p>操作数中涉及立即数，结果保存到寄存器； </p><ul><li>op：标识指令的操作功能； </li><li>rs：第1个源操作数，是寄存器操作数；</li><li>rt：目的寄存器编号，用来保存运算结果； </li><li>imm：第2个源操作数，立即数；</li></ul><p><img src="/2019/12/25/指令系统/image-20191225145942182.png" alt="image-20191225145942182"></p><h4 id="面向运算的I型指令"><a href="#面向运算的I型指令" class="headerlink" title="面向运算的I型指令"></a>面向运算的I型指令</h4><p><img src="/2019/12/25/指令系统/image-20191225150005890.png" alt="image-20191225150005890"></p><h4 id="面向访存的I型指令"><a href="#面向访存的I型指令" class="headerlink" title="面向访存的I型指令"></a>面向访存的I型指令</h4><p><img src="/2019/12/25/指令系统/image-20191225150028541.png" alt="image-20191225150028541"></p><h4 id="面向数位设置的I型指令"><a href="#面向数位设置的I型指令" class="headerlink" title="面向数位设置的I型指令"></a>面向数位设置的I型指令</h4><p><img src="/2019/12/25/指令系统/image-20191225150115338.png" alt="image-20191225150115338"></p><h4 id="面向条件转移-分支-的I型指令"><a href="#面向条件转移-分支-的I型指令" class="headerlink" title="面向条件转移(分支)的I型指令"></a>面向条件转移(分支)的I型指令</h4><p><img src="/2019/12/25/指令系统/image-20191225150151595.png" alt="image-20191225150151595"></p><h3 id="J型指令"><a href="#J型指令" class="headerlink" title="J型指令"></a>J型指令</h3><p><img src="/2019/12/25/指令系统/image-20191225150223733.png" alt="image-20191225150223733"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;指令系统概述及指令格式&quot;&gt;&lt;a href=&quot;#指令系统概述及指令格式&quot; class=&quot;headerlink&quot; title=&quot;指令系统概述及指令格式&quot;&gt;&lt;/a&gt;指令系统概述及指令格式&lt;/h2&gt;&lt;h3 id=&quot;指令的基本概念&quot;&gt;&lt;a href=&quot;#指令的基本概念&quot; class=&quot;headerlink&quot; title=&quot;指令的基本概念&quot;&gt;&lt;/a&gt;指令的基本概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;指令&lt;ul&gt;
&lt;li&gt;计算机能直接识别、执行的操作命令（机器指令）；&lt;/li&gt;
&lt;li&gt;冯诺依曼结构计算机 “程序控制”原理实现的载体；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指令系统（指令集）&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机组成原理" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="组成原理" scheme="http://yorxika.github.io/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>存储系统II</title>
    <link href="http://yorxika.github.io/2019/12/24/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FII/"/>
    <id>http://yorxika.github.io/2019/12/24/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FII/</id>
    <published>2019-12-24T08:24:43.000Z</published>
    <updated>2019-12-24T17:22:08.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多体交叉存储器"><a href="#多体交叉存储器" class="headerlink" title="多体交叉存储器"></a>多体交叉存储器</h2><a id="more"></a><p><img src="/2019/12/24/存储系统II/image-20191224210559403.png" alt="image-20191224210559403"></p><p><img src="/2019/12/24/存储系统II/image-20191224210607265.png" alt="image-20191224210607265"></p><p><img src="/2019/12/24/存储系统II/image-20191224210614243.png" alt="image-20191224210614243"></p><p><img src="/2019/12/24/存储系统II/image-20191224210623500.png" alt="image-20191224210623500"></p><h2 id="Cache的基本原理"><a href="#Cache的基本原理" class="headerlink" title="Cache的基本原理"></a>Cache的基本原理</h2><p><img src="/2019/12/24/存储系统II/image-20191224212037889.png" alt="image-20191224212037889"></p><p><img src="/2019/12/24/存储系统II/image-20191224212100127.png" alt="image-20191224212100127"></p><p><img src="/2019/12/24/存储系统II/image-20191224212112439.png" alt="image-20191224212112439"></p><p><img src="/2019/12/24/存储系统II/image-20191224212119403.png" alt="image-20191224212119403"></p><h2 id="组相联存储器"><a href="#组相联存储器" class="headerlink" title="组相联存储器"></a>组相联存储器</h2><p><img src="/2019/12/24/存储系统II/image-20191224212557005.png" alt="image-20191224212557005"></p><p><img src="/2019/12/24/存储系统II/image-20191224212604189.png" alt="image-20191224212604189"></p><h2 id="Cache地址映射与变换方法"><a href="#Cache地址映射与变换方法" class="headerlink" title="Cache地址映射与变换方法"></a>Cache地址映射与变换方法</h2><h3 id="全相联"><a href="#全相联" class="headerlink" title="全相联"></a>全相联</h3><p><img src="/2019/12/24/存储系统II/image-20191224215252084.png" alt="image-20191224215252084"></p><p><img src="/2019/12/24/存储系统II/image-20191224215303023.png" alt="image-20191224215303023"></p><p><img src="/2019/12/24/存储系统II/image-20191224215314152.png" alt="image-20191224215314152"></p><p>特点：</p><ul><li>Cache利用率高</li><li>块冲突率低</li><li>淘汰算法复杂<br>应用场合：小容量Cache</li></ul><h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p><img src="/2019/12/24/存储系统II/image-20191224215413222.png" alt="image-20191224215413222"><img src="/2019/12/24/存储系统II/image-20191224215413308.png" alt="image-20191224215413308"></p><p><img src="/2019/12/24/存储系统II/image-20191224215420100.png" alt="image-20191224215420100"></p><p><img src="/2019/12/24/存储系统II/image-20191224215430954.png" alt="image-20191224215430954"></p><p>特点：<br>特点：</p><ul><li>Cache利用率低</li><li>块冲突率高</li><li>淘汰算法简单<br>应用场合：大容量Cache</li></ul><h3 id="组相联"><a href="#组相联" class="headerlink" title="组相联"></a>组相联</h3><p><img src="/2019/12/24/存储系统II/image-20191224215513463.png" alt="image-20191224215513463"></p><p><img src="/2019/12/24/存储系统II/image-20191224215520381.png" alt="image-20191224215520381"></p><p><img src="/2019/12/24/存储系统II/image-20191224215526406.png" alt="image-20191224215526406"></p><p><img src="/2019/12/24/存储系统II/image-20191224215532554.png" alt="image-20191224215532554"></p><h2 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h2><h3 id="先进先出-（First-in-First-out）"><a href="#先进先出-（First-in-First-out）" class="headerlink" title="先进先出-（First in First out）"></a>先进先出-（First in First out）</h3><p><img src="/2019/12/24/存储系统II/image-20191224221407980.png" alt="image-20191224221407980"></p><h3 id="最不经常使用法-LFU-（Least-Frequently-Used"><a href="#最不经常使用法-LFU-（Least-Frequently-Used" class="headerlink" title="最不经常使用法-LFU （Least Frequently Used )"></a>最不经常使用法-LFU （Least Frequently Used )</h3><p><img src="/2019/12/24/存储系统II/image-20191224221454348.png" alt="image-20191224221454348"></p><h3 id="近期最少使用法—-LRU-Least-recently-used"><a href="#近期最少使用法—-LRU-Least-recently-used" class="headerlink" title="近期最少使用法— LRU(Least recently used )"></a>近期最少使用法— LRU(Least recently used )</h3><p><img src="/2019/12/24/存储系统II/image-20191224221523084.png" alt="image-20191224221523084"></p><h2 id="Cache例题选讲"><a href="#Cache例题选讲" class="headerlink" title="Cache例题选讲"></a>Cache例题选讲</h2><p>假定主存和Cache之间采用直接映射方式，块大小为16B。Cache数据区容量 为64KB，主存地址为32位，按字节编址，数据字长32位。要求 1)给出直接映射方式下主存地址划分 2)完成Cache访问的硬件实现 3)计算Cache容量<br>解：1)由题目条件知：<br>数据块大小16B  -&gt;   块内偏移地址4位；<br>Cache数据区容量为64KB -&gt;  64KB/16B = 4096行Cache）；-&gt; Index字段12位<br>Tag字段的位数为 32- 12 - 4 =16位（Tag）<br>由第一问的解答可知：Tag 为16 bit<br>由题目条件及Cache的工作原理知： Cache每行数据存储体容量为 16<em>8 = 128 bit<br>Cache 每行的总存储容量为： 1+ 16 + 128 = 145 bit<br>Cache 总容量为：4096 \</em>（1+16 +128）= 580Kbit<br><img src="/2019/12/24/存储系统II/image-20191224224643640.png" alt="image-20191224224643640"></p><p>设某机内存容量为16MB,Cache的容量16KB,每块8个字,每个字32位.设计一个四 路组相联映射(即Cache内每组包含4个字块)的Cache组织方式。<br>1）求满足组相联映射的主存地址字段中各字段的位数<br>2)设Cache的初态为空,CPU从主存第0号单元开始连续访问100个字(主存一次读出一 个字),重复此次序读8次,求存储访问的命中率<br>3)若Cache的速度是主存速度的6倍,求存储系统访问加速比</p><p><img src="/2019/12/24/存储系统II/image-20191224224843910.png" alt="image-20191224224843910"></p><p><img src="/2019/12/24/存储系统II/image-20191224224850389.png" alt="image-20191224224850389"><br>3）设Cache的存取周期为t，则主存存取周期为6t<br>直接从内存读取所有数据所需时间为: Tnc = 800*6t = 4800t<br>通过Cache访问800个数据的时间为: Tc = 13*6t +(800-13)*t = 865t<br>存储系统访问的加速比 S = Tnc/Tc =( 4800t/865t) = 5.5</p><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><ul><li>处于主存 –辅存存储层次</li><li>解决主存容量不足的问题，为程序设计者提供比主存空间大的编程空间</li><li>分类：页式虚拟存储器、段式虚拟存储器 、段页式虚拟存储器</li></ul><p>采用MMU(Memory Management Unit):管理虚拟存储器与物理存储器<br>采用页表来判断CPU要访问的内容是否在主存，并与MMU配合实现 逻辑地址与物理地址之间的转换？</p><p><img src="/2019/12/24/存储系统II/image-20191224231716146.png" alt="image-20191224231716146"></p><p><img src="/2019/12/24/存储系统II/image-20191224231728581.png" alt="image-20191224231728581"></p><p><img src="/2019/12/24/存储系统II/image-20191224231739198.png" alt="image-20191224231739198"></p><p><img src="/2019/12/24/存储系统II/image-20191224232305422.png" alt="image-20191224232305422"></p><h2 id="TLB-Translation-Lookaside-Buffer"><a href="#TLB-Translation-Lookaside-Buffer" class="headerlink" title="TLB (Translation Lookaside Buffer)"></a>TLB (Translation Lookaside Buffer)</h2><p>虚实地址转换过程中存在的问题</p><p><img src="/2019/12/24/存储系统II/image-20191224233435375.png" alt="image-20191224233435375"></p><p><img src="/2019/12/24/存储系统II/image-20191224233447289.png" alt="image-20191224233447289"></p><h3 id="TLB工作原理"><a href="#TLB工作原理" class="headerlink" title="TLB工作原理"></a>TLB工作原理</h3><ul><li><p>根据局部性原理，增加一个小容量、高速存储部件存放当前访问页表地址变换条 目，该存储部件称为TLB(Translation Lookaside Buffer:地址转换后备缓冲器)。</p></li><li><p>TLB类似页表，也是PTE的集合。为实现对TLB的快速访问，类似于Cache中的映射方法， 对来自于CPU的虚页号进行逻辑划分，得到相应的标记和索引字段。</p></li></ul><p><img src="/2019/12/24/存储系统II/image-20191224233533276.png" alt="image-20191224233533276"></p><p><img src="/2019/12/24/存储系统II/image-20191224233543726.png" alt="image-20191224233543726"></p><p><img src="/2019/12/24/存储系统II/image-20191224233559705.png" alt="image-20191224233559705"></p><h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><p>Redundant Arrays of Independent Disks：独立磁盘冗余阵列<br>核心技术：</p><ul><li>将数据条带化后的存放在不同磁盘上，通过多磁盘的并行操作提高磁 盘系统的读写速率；</li><li>使用基于异或运算为基础的校验技术恢复损坏的数据</li></ul><p><img src="/2019/12/24/存储系统II/image-20191224235157669.png" alt="image-20191224235157669"></p><p><img src="/2019/12/24/存储系统II/image-20191224235206899.png" alt="image-20191224235206899"></p><p><img src="/2019/12/24/存储系统II/image-20191224235212960.png" alt="image-20191224235212960"></p><p><img src="/2019/12/24/存储系统II/image-20191224235218656.png" alt="image-20191224235218656"></p><p><img src="/2019/12/24/存储系统II/image-20191224235224206.png" alt="image-20191224235224206"></p><p><img src="/2019/12/24/存储系统II/image-20191224235229473.png" alt="image-20191224235229473"></p><p><img src="/2019/12/24/存储系统II/image-20191224235234864.png" alt="image-20191224235234864"></p><p><img src="/2019/12/24/存储系统II/image-20191224235241651.png" alt="image-20191224235241651"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>以下关于虚拟存储管理地址转换的叙述中错误的是（<strong>C</strong>）<br>A.MMU在地址转换过程中要访问页表项<br>B.地址转换过程中可能会发生“缺页”<br>C.一般来说，逻辑地址比物理地址的位数少<br>D.地址转换是指把逻辑地址转换为物理地址</p><p>假定主存按字节编址，cache共有64行，采用4路组相联映射方式，主存块大小为32字节，所有编号都从0开始。问主存第3000号单元所在主存块对应的cache组号是<strong>13</strong></p><p>主存第3000号单元，一个主存块为32字节，故有3000/32 = 93余24，因此在第94块上，又因为编号从0开始，因此在编号为93的块中，因为 Cache有64行，一组有4行，因此 C =16 组，所以i =93mod16 = 13</p><p>下列关于CaChe的说法中，错误的是（ <strong>C</strong>    ）<br>A.CaChe行大小与主存块大小一致<br>B.<strong>分离CaChe(也称哈佛结构)是指存放指令的CaChe与存放数据CaChe分开设置</strong><br>C.读操作也要考虑CaChe与主存的一致性问题<br>D.CaChe对程序员透明</p><p>下列关于命中组合的情况中，一次访存过程中可能发生的是(<strong>acd</strong>)。</p><p>A．TLB未命中，CaChe命中，Page未命中<br>B．TLB未命中，CaChe未命中，Page命中<br>C．TLB命中，CaChe命中，Page未命中<br>D．TLB命中，CaChe未命中，Page未命中</p><p>因此，TLB命中，页表一定命中；TLB不命中，页表可能命中可能不命中；页表命中，TLB可能命中也可能不命中；页表不命中，TLB一定不命中。<br>TLB和页表命中与否与Cache无关。</p><p>虚拟存储器中， 程序执行过程中实现虚拟地址到物理地址映射部件（系统）是 <strong>操作系统和MMU配合完成</strong></p><p>相联存储器是按(<strong>内容指定方式</strong> )进行寻址的存储器。</p><p>关于cache存储器，下面的叙述中正确的是 (<strong>D</strong>) 。</p><p>A．cache存储器是内存中的一个特定区域<br>B．cache存储器的存取速度介于内存和磁盘之间<br>C．cache存储器中存放的内容是内存的备份<br>D．<strong>cache存储器存放正在处理的部分指令和数据</strong>/</p><p>一个组相联高速缓存由64个字块组成，每个字块有256字节，分为8组，主存有4096个字块。请问：<br>1）主存地址有多少位<br>2）请写出主存地址的格式。</p><p>解答：<br>1）主存容量为4096块*256字=2^20字，故主存地址为20位<br>Cache容量为64块*256字<br>共有4096/8 = 512 = 2^9个组群<br>即2^20=2^9 * 2^3 * 2^8<br>2）Cache3，字块为256字节=2^8，所以主存地址的格式为：</p><p><img src="/2019/12/24/存储系统II/view.jfif" alt="cache练习及答案"></p><p>在请求分页存储管理方案中，若某用户空间为16个页面，页长1KB，现有页表如下，则逻辑地址102B（H）所对应的物理地址为（<strong>082BH</strong> ）。<br>页号    块号<br>0    1<br>1    5<br>2    3<br>3    7<br>4    2</p><p>16个页面，2的4次方=16，可知页号部分占4位，页长为1k，2的10次方=1k，页面大小（偏移）占10位<br>102B（H）十六进制表示法，B=11，所以102B（H）=0001 0000 0010 1011<br>页内地址为：00 0010 1011<br>页号为：0100=4.查表可知页号4对应的块号为2，<br>物理地址=物理块号*物理块号大小+页面位移<br>页号=（int）（逻辑地址/页面大小）<br>页面位移=逻辑地址%页面大小=0001 0000 0010 1011%100 0000 0000=0010 1011<br>所以逻辑地址102B（H）所对应的物理地址=2*1k +0010 1011=1000 0010 1011<br>转化为16进制082B（H） </p><p>计算机主存容量8MB，分为4096个主存块，cache有64KB，请问若按照采用直接映射方式。<br>1)cache有多少字块？<br>2)Cache的字块内地址为多少位<br>3)Cache的字块地址为多少位<br>4)请写出该主存的地址格式<br>5）若按照全相联映射方式请写出该主存的地址格式</p><p>解答：<br>1）每字块大小为8MB/4096= 2KB ,cache有64KB，cache块的大小与主存的块大小一样，都为2KB，所以有64KB/2KB=32个块<br>2）Cache的字块与主存的字块一样大小都为2KB=211B，所以cache的字块内地址为11位3）Cache有32块=25，所以Cache的字块地址为5位<br>4）主存容量23<br><img src="/2019/12/24/存储系统II/view-1577207603980.jfif" alt="cache练习及答案"><br>5<br><img src="/2019/12/24/存储系统II/view-1577207604012.jfif" alt="cache练习及答案"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;多体交叉存储器&quot;&gt;&lt;a href=&quot;#多体交叉存储器&quot; class=&quot;headerlink&quot; title=&quot;多体交叉存储器&quot;&gt;&lt;/a&gt;多体交叉存储器&lt;/h2&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机组成原理" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="组成原理" scheme="http://yorxika.github.io/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>存储系统I</title>
    <link href="http://yorxika.github.io/2019/12/24/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E4%B8%80/"/>
    <id>http://yorxika.github.io/2019/12/24/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E4%B8%80/</id>
    <published>2019-12-24T06:24:30.000Z</published>
    <updated>2019-12-26T17:34:34.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储系统层次结构"><a href="#存储系统层次结构" class="headerlink" title="存储系统层次结构"></a>存储系统层次结构</h2><h3 id="基本存储体系"><a href="#基本存储体系" class="headerlink" title="基本存储体系"></a>基本存储体系</h3><p>存储程序                                                  —&gt; 内存<br>1) 输入设备将程序与数据写入主存；   ^<br>2) CPU取指令;                                           |<br>3) CPU执行指令期间读数据；                |<br>4) CPU写回运算结果；                            |<br>5)  输出设备输出结果；                           |<br>程序控制                                                    —&gt; CPU</p><a id="more"></a><p>主存容量不足的原因：</p><ul><li>存在制约主存容量的技术因素</li><li>应用对主存的需求不断扩大</li></ul><p><img src="/2019/12/24/存储系统一/image-20191224143440462.png" alt="image-20191224143440462"></p><p>哈佛结构：是一种将指令储存和数据储存分开的存储器结构，可支持：数据和指令并行储存、指令 预取，提高处理器的执行效率；另外，指令和数据可有不同的数据宽度，如Microchip 公司的PIC16芯片的程序指令是14位宽度，而数据是8位宽度。<br>目前使用哈佛结构的：PIC系列、摩托罗拉公司的MC68系列、Zilog公司的Z8系列、 ATMEL公司的AVR系列和ARM公司的ARM9、ARM10和ARM11。</p><p><img src="/2019/12/24/存储系统一/image-20191227012511278.png" alt="image-20191227012511278"></p><h3 id="存储体系层次化结构的理论基础"><a href="#存储体系层次化结构的理论基础" class="headerlink" title="存储体系层次化结构的理论基础"></a>存储体系层次化结构的理论基础</h3><p>局部性原理 </p><ul><li>时间局部性: <ul><li>现在被访问的信息2在不久的将来还将再次被访问;</li><li>时间局部性的程序结构体现：循环结构 </li></ul></li><li>空间局部性： <ul><li>现访问信息2 ，下一次访问2附近的信息。</li><li>空间局部性的程序结构体现：顺序结构</li></ul></li></ul><h2 id="主存中的数据组织"><a href="#主存中的数据组织" class="headerlink" title="主存中的数据组织"></a>主存中的数据组织</h2><p>存储字长：</p><ul><li>主存的一个存储单元所包含的二进制位数；</li><li>目前大多数计算机的主存按字节编址，存储字长也不断加大,如16位字长、 32位字长和64位字长；</li><li>ISA设计时要考虑的两个问题：<ul><li>a)如何根据字节地址读取一个32位的字？ </li><li>b)一个字能否存放在主存的任何字节边界？ - 字的存放问题 - 字的边界对齐问题</li></ul></li></ul><p><img src="/2019/12/24/存储系统一/image-20191224151529700.png" alt="image-20191224151529700"></p><p><img src="/2019/12/24/存储系统一/image-20191224151536995.png" alt="image-20191224151536995"></p><p>边界对齐与存储地址的关系（以32位为例）</p><ul><li>双字长数据边界对齐的起始地址的最末三位为000(8字节整数倍；</li><li>单字长边界对齐的起始地址的末二位为00(4字节整数倍)；</li><li>半字长边界对齐的起始地址的最末一位为0(２字节整数倍)。</li></ul><p><img src="/2019/12/24/存储系统一/image-20191224151700729.png" alt="image-20191224151700729"></p><p><img src="/2019/12/24/存储系统一/image-20191224151728347.png" alt="image-20191224151728347"></p><h2 id="静态存储器工作原理"><a href="#静态存储器工作原理" class="headerlink" title="静态存储器工作原理"></a>静态存储器工作原理</h2><p><img src="/2019/12/24/存储系统一/image-20191224154646533.png" alt="image-20191224154646533"></p><p><img src="/2019/12/24/存储系统一/image-20191224154652629.png" alt="image-20191224154652629"></p><p><img src="/2019/12/24/存储系统一/image-20191224154658914.png" alt="image-20191224154658914"></p><p><img src="/2019/12/24/存储系统一/image-20191224154704558.png" alt="image-20191224154704558"></p><p><img src="/2019/12/24/存储系统一/image-20191224154711826.png" alt="image-20191224154711826"></p><p><img src="/2019/12/24/存储系统一/image-20191224154729278.png" alt="image-20191224154729278"></p><p><img src="/2019/12/24/存储系统一/image-20191224154739209.png" alt="image-20191224154739209"></p><h2 id="动态存储器工作原理"><a href="#动态存储器工作原理" class="headerlink" title="动态存储器工作原理"></a>动态存储器工作原理</h2><p>SRAM存储单元不足：</p><ul><li>晶体管过多</li><li>存储密度低</li><li>功耗大</li></ul><p><img src="/2019/12/24/存储系统一/image-20191224162301973.png" alt="image-20191224162301973"></p><p><img src="/2019/12/24/存储系统一/image-20191224162316869.png" alt="image-20191224162316869"></p><p><img src="/2019/12/24/存储系统一/image-20191224162327920.png" alt="image-20191224162327920"></p><p><img src="/2019/12/24/存储系统一/image-20191224162336607.png" alt="image-20191224162336607"></p><p><img src="/2019/12/24/存储系统一/image-20191224162343371.png" alt="image-20191224162343371"></p><p><img src="/2019/12/24/存储系统一/image-20191224162351879.png" alt="image-20191224162351879"></p><p><img src="/2019/12/24/存储系统一/image-20191224162357494.png" alt="image-20191224162357494"></p><p><img src="/2019/12/24/存储系统一/image-20191224162402845.png" alt="image-20191224162402845"></p><p><img src="/2019/12/24/存储系统一/image-20191224162410001.png" alt="image-20191224162410001"></p><h2 id="存储拓展"><a href="#存储拓展" class="headerlink" title="存储拓展"></a>存储拓展</h2><p><img src="/2019/12/24/存储系统一/image-20191224161733688.png" alt="image-20191224161733688"></p><p>位拓展举例： 用16K * 8 的存储芯片构建16K * 32的存储器</p><p>所需芯片数量： 16K*32/(16K*8) = 4<br>所有存储芯片并行工作，贡献32位数据中的不同8位</p><p><img src="/2019/12/24/存储系统一/image-20191227012839226.png" alt="image-20191227012839226"></p><hr><p>字扩展举例:  用16K* 8 的存储芯片构建128k* 8的存储器</p><p>所需芯片数量： 128K * 8/ (16K*8) = 8<br>128k存储器 -&gt; 17根地址线<br>16K的存储 -&gt; 14根地址线<br>多余的3根地址线 作为片选译码输入</p><p><img src="/2019/12/24/存储系统一/image-20191227012958630.png" alt="image-20191227012958630"></p><hr><p>用16K* 8 的存储芯片构建128K*  8的存储器，其中08000H~0BFFFH存储空间保留不用</p><p>所需芯片数量： (128K-16k )* 8/ (16K*8) = 7<br><img src="/2019/12/24/存储系统一/image-20191227013302066.png" alt="image-20191227013302066"></p><hr><p><img src="/2019/12/24/存储系统一/image-20191224162032635.png" alt="image-20191224162032635"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>字位结构为256Kｘ4位SRAM存储芯片，其地址引脚与数据引脚之和为：22</p><p>256K 需要18根，4位4根</p><hr><p>假定用若干块4K <em>4位的存储芯片组成一个8K</em>8位的存储器，则地址0B1F所在芯片的最小地址是<strong>0000H</strong></p><hr><p>用若干片2K´4位的存储芯片组成一个8K´8位的存储器，则地址0B1FH所在的芯片在全局的最大地址是<strong>0FFFH</strong></p><hr><p>下列存储器类型中，速度最快的是 <strong>B</strong><br>A.Flash Memory    B.SRAM    C.DRAM    D.EPROM</p><p>SRAM是cache</p><hr><p>关于内存的下列说法中，错误的是<strong>AD</strong><br>A.内存的存取速度不能低于CPU速度，否则会造成数据丢失<br>B.某计算机内存容量为8GB，按字节编址，那么它的地址总线为33位<br>C.程序只有在数据和代码等被调入内存后才能运行<br>D.采用虚拟内存技术后程序可以在硬盘上直接运行</p><hr><p>DRAM比SRAM慢，可能的原因包括<strong>ABCD</strong><br>A.DRAM读之前需要预充电<br>B.DRAM存储体行列地址线复用<br>C.DRAM需要刷新<br>D.DRAM存储单元采用了双译码结构</p><hr><p>不需要定时刷新的半导体存储器芯片是<strong>ACD</strong><br>A.SRAM    B.DRAM    C.Flash Memory    D.EPROM</p><hr><p>某计算机存储器按字节变址，采用小端方式存放数据。假定编译器规定int 型和 short 型长度分别为 32 位和 16 位，并且数据按边界对齐存储。某 C 语言程序段如下：</p><p><img src="/2019/12/24/存储系统一/3814779_1478420350406_9D7738A42D1C889AE8A3BA51F1DEF7AC.png" alt="img"></p><p>若record 变量的首地址为 0xC008，则地址 0xC008 中内容及 record.c 的地址是0x11 0xC00E</p><hr><p>计算机字长32位，主存容量为128MB，按<strong>字</strong>编址，其寻址范围为<strong>0~128M-1</strong></p><hr><p>某计算机内存容量为8GB，按字节编址，那么它的地址总线为33位 <strong>错</strong><br>要大于33根</p><hr><p>下列关于RAM和ROM的叙述中，正确的是<strong>BD</strong><br>A.ROM和RAM都不需要刷新<br>B.RAM是易失性存储器，ROM是非失性存储器<br>C.Cache可选RAM、ROM做数据存储体<br>D. RAM和ROM都采用随机存取的方式进行访问</p><hr><p>一般Cache采用高速的SRAM制作，比ROM速度快很多，因此Ⅲ是错误的，排除法即可选A。动态RAM是靠MOS电路中的栅极电容来记忆信息的。由于电容上的电荷会泄漏,需要定时给与补充,所以动态 RAM需要 设置 刷新 电路。RAM需要刷新，而ROM不需要刷新。<br>ROM与RAM两者的差别：<br>(1) RAM是随机存取存储器; ROM是只读存储器；<br>(2) RAM是易失性的，一旦掉电，则所有信息全部丢失；ROM是非易失性的，其信息可以长期保存，常用于存放一些固定用的数据和程序，如计算机的自检程序、BIOS、游戏卡中的游戏，等等。</p><hr><p>下列属于衡量存储器技术指标的是：<strong>存储容量、存取时间、存储周期和存储器带宽</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;存储系统层次结构&quot;&gt;&lt;a href=&quot;#存储系统层次结构&quot; class=&quot;headerlink&quot; title=&quot;存储系统层次结构&quot;&gt;&lt;/a&gt;存储系统层次结构&lt;/h2&gt;&lt;h3 id=&quot;基本存储体系&quot;&gt;&lt;a href=&quot;#基本存储体系&quot; class=&quot;headerlink&quot; title=&quot;基本存储体系&quot;&gt;&lt;/a&gt;基本存储体系&lt;/h3&gt;&lt;p&gt;存储程序                                                  —&amp;gt; 内存&lt;br&gt;1) 输入设备将程序与数据写入主存；   ^&lt;br&gt;2) CPU取指令;                                           |&lt;br&gt;3) CPU执行指令期间读数据；                |&lt;br&gt;4) CPU写回运算结果；                            |&lt;br&gt;5)  输出设备输出结果；                           |&lt;br&gt;程序控制                                                    —&amp;gt; CPU&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机组成原理" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="组成原理" scheme="http://yorxika.github.io/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>运算器</title>
    <link href="http://yorxika.github.io/2019/12/23/%E8%BF%90%E7%AE%97%E5%99%A8/"/>
    <id>http://yorxika.github.io/2019/12/23/%E8%BF%90%E7%AE%97%E5%99%A8/</id>
    <published>2019-12-22T16:46:38.000Z</published>
    <updated>2019-12-26T17:14:54.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定点数运算及溢出检测"><a href="#定点数运算及溢出检测" class="headerlink" title="定点数运算及溢出检测"></a>定点数运算及溢出检测</h2><ul><li>补码加法：[X＋Y]补 = [X]补＋ [Y]补<ul><li>和的补码 = 补码的和</li></ul></li><li>补码减法：[X−Y]补 = [X]补＋ [−Y]补 = [X]补−[Y]补<ul><li>差的补码 = 补码的差<a id="more"></a></li><li>减法变加法，关键是求[−Y]补</li></ul></li><li>求补公式：[−Y]补= [ [Y]补 ]补<ul><li><strong>对 [Y]补逐位取反, 再在最低位加 1</strong></li></ul></li></ul><p><img src="/2019/12/23/运算器/image-20191223010219114.png" alt="image-20191223010219114"></p><h3 id="单符号数溢出检测"><a href="#单符号数溢出检测" class="headerlink" title="单符号数溢出检测"></a>单符号数溢出检测</h3><h4 id="方法I"><a href="#方法I" class="headerlink" title="方法I"></a>方法I</h4><p>溢出只可能发生在同符号数相加时，包括[X]补与[Y]补； [X]补与[-Y]同号；<br>方法1：对操作数和运算结果的符号位进行检测 当结果的符号位与操作数的符号不相同时就表明发生了溢出 </p><ul><li>正正得负  负负得正</li><li>设两数符号位为 f0 f1 ，和数符号位 fs</li><li>溢出检测信号Overflow   (OF)<br>OF = !f0·!f1·fs + f0·f1·!fs</li></ul><h4 id="方法II"><a href="#方法II" class="headerlink" title="方法II"></a>方法II</h4><p>方法2：对最高数据位进位和符号进位进行检测 •设运算时最高数据位产生的进位为C1，符号位产生的进位为C0， 溢出检测电路为： V= C0 ^ C 1</p><p><img src="/2019/12/23/运算器/image-20191226234848895.png" alt="image-20191226234848895"></p><h4 id="方法III"><a href="#方法III" class="headerlink" title="方法III"></a>方法III</h4><p>方法3：用变型补码 [X]补 = Xf1Xf2. X1X2X3…Xn mod  2^n+2 溢出的判断:  V= Xf1 ^ Xf2</p><p>例6 已知 X=- 10010  Y= -10101  求X+Y<br>解:   [X]补=1101110   [Y]补= 1101011<br>[X+Y]补=[X]补+[Y]补= 1101110  + 1101011 =1 10 10001<br>V= 1 ^ 0 =1 故发生溢出！</p><h4 id="无符号数运算的溢出判断"><a href="#无符号数运算的溢出判断" class="headerlink" title="无符号数运算的溢出判断"></a>无符号数运算的溢出判断</h4><ul><li>无符号数加法的溢出可用ALU的进位表示</li><li>无符号数减法的溢出也可用带加/减功能的ALU的进位取反后表示。</li></ul><h2 id="定点数补码加减运算器设计"><a href="#定点数补码加减运算器设计" class="headerlink" title="定点数补码加减运算器设计"></a>定点数补码加减运算器设计</h2><h3 id="带进位链的一位全加器"><a href="#带进位链的一位全加器" class="headerlink" title="带进位链的一位全加器"></a>带进位链的一位全加器</h3><p>Si  =  Xi ⊕ Yi ⊕ Ci<br>Ci+1  =  Xi Yi  + (Xi ⊕ Yi )Ci</p><p><img src="/2019/12/23/运算器/image-20191226235525221.png" alt="image-20191226235525221"></p><ul><li>n位加法器包含n个全加器</li><li>将n个一位全加器串联</li><li>低位进位输出连接到高位进位输入</li></ul><h4 id="串行加法器时间延迟"><a href="#串行加法器时间延迟" class="headerlink" title="串行加法器时间延迟"></a>串行加法器时间延迟</h4><p>n个全加器延迟，3n个门电路延迟？<br>考虑片内并行性，2n+1个门电路延迟</p><h3 id="四位串行加-减法器设计"><a href="#四位串行加-减法器设计" class="headerlink" title="四位串行加/减法器设计"></a>四位串行加/减法器设计</h3><p>补码减法可以变加法<br>         [X]补 − [Y]补 = [X]补 + [−Y]补<br>关键是求[−Y]补<br>方法：将Y补连同符号位一起逐位取反末位加一<br>         [−Y]补= [ [Y]补 ]补             注意补码区间不对称？</p><ul><li>引入运算控制位 Sub<ul><li>Sub=0 时作加法，送入加法器的是Y补    </li><li>Sub=1 时作减法，送入加法器的是[−Y]补   <ul><li>对 Y补 逐位取反，末位加一</li></ul></li></ul></li></ul><p>[−Y]补= [ [Y]补 ]补<br>Input = Yi ^ Sub</p><p><img src="/2019/12/23/运算器/image-20191223011539952.png" alt="image-20191223011539952"></p><p><img src="/2019/12/23/运算器/image-20191223011546598.png" alt="image-20191223011546598"></p><p><img src="/2019/12/23/运算器/image-20191223011554683.png" alt="image-20191223011554683"></p><p><img src="/2019/12/23/运算器/image-20191223011604477.png" alt="image-20191223011604477"></p><h3 id="并行加法器进位链-carry-lookahead"><a href="#并行加法器进位链-carry-lookahead" class="headerlink" title="并行加法器进位链(carry-lookahead)"></a>并行加法器进位链(carry-lookahead)</h3><p>Si = Xi⊕Yi⊕Ci-1<br>Ci = XiYi+(Xi⊕Yi)Ci-1<br>Gi = XiYi    进位生成函数 Generate<br>Pi = Xi⊕Yi    进位传递函数 Propagate<br>Ci = Gi + Pi·Ci-1<br>高位运算依赖于低位进位 -&gt; 计算不能并行</p><p>Cn = Gn＋PnGn-1＋PnPn-1Gn-2＋PnPn-1Pn-2Gn-3 …＋PnPn-1…P1C0</p><ul><li>进位输出仅与最低位进位输入C0有关</li><li>位数越长，进位链电路复杂度越高</li><li>通常按照4位一组进行分组运算</li></ul><p><img src="/2019/12/23/运算器/image-20191223011617449.png" alt="image-20191223011617449"></p><p><img src="/2019/12/23/运算器/image-20191223011651720.png" alt="image-20191223011651720"><br>①生成P*，G*需3T  -&gt;  ②生成C3/C12需2T -&gt;  ③求和需3T</p><h2 id="原码一位乘法"><a href="#原码一位乘法" class="headerlink" title="原码一位乘法"></a>原码一位乘法</h2><ul><li>符号单独运算：直接异或</li><li>绝对值相乘：   仅需考虑数值部分的计算</li></ul><p><img src="/2019/12/23/运算器/image-20191223105629422.png" alt="image-20191223105629422"></p><p><img src="/2019/12/23/运算器/image-20191223105639405.png" alt="image-20191223105639405"></p><p><img src="/2019/12/23/运算器/image-20191223105649861.png" alt="image-20191223105649861"></p><p><img src="/2019/12/23/运算器/image-20191223105716737.png" alt="image-20191223105716737"></p><h2 id="补码一位乘法"><a href="#补码一位乘法" class="headerlink" title="补码一位乘法"></a>补码一位乘法</h2><p>设[X]补 = X0X1X2X3…Xn [Y]补 = Y0Y1Y2Y3…Yn<br>可证明：<br>   [X•Y]补 = [X]补•( 0.Y1Y2Y3…Yn ) –Y0• [X]补<br>进一步展开合并后可得：<br>   [x•y]补=[x] 补•Σ(yi+1 - yi)2^-i    ( 符号位参加运算 ) </p><p>补码一位乘法的运算规则如下:<br>(1)如果yn+1=yn,部分积加0，部分积算术右移1位；<br>(2)如果yn+1yn=10,部分积加[x]补，部分积算术右移1位；<br>(3)如果yn+1yn=01,部分积加[-x]补，部分积算术右移1位. 重复进行n＋1步，但最后一步不移位。<br>包括一位符号位，所得乘积为2n＋1位，其中n为数据位位数. </p><p>几个特殊问题的处理<br>(1) i=n时 ,yn+1= ？yn+1= 0<br>(2) yn+1 是哪个寄存器？在乘数寄存器Y后增加的一位<br>(3)算术右移的对象有哪些？   部分积和乘数寄存器均右移</p><p><img src="/2019/12/23/运算器/image-20191223110749473.png" alt="image-20191223110749473"></p><p><img src="/2019/12/23/运算器/image-20191223110759842.png" alt="image-20191223110759842"></p><h2 id="乘法运算器设计"><a href="#乘法运算器设计" class="headerlink" title="乘法运算器设计"></a>乘法运算器设计</h2><p><img src="/2019/12/23/运算器/image-20191223112447328.png" alt="image-20191223112447328"></p><h3 id="阵列乘法器"><a href="#阵列乘法器" class="headerlink" title="阵列乘法器"></a>阵列乘法器</h3><p>而对于相加数运算，就变成了一位乘法运算，一位乘法运算很简单，从真值表看，这就是一个简单的与逻辑，也就是逻辑与门就可以实现一位乘法，对于上一页的5*5的乘法运算，需要25个相加数，所以我们可以采用25个与门并发，如图所示，经过<strong>一级门电路延迟</strong>后，就可以得到所有的相加数，下面我们只需要考虑逐列相加的逻辑就可以实现乘法器</p><p><img src="/2019/12/23/运算器/image-20191227001319627.png" alt="image-20191227001319627"></p><ul><li>与门实现一位乘法</li><li>25个与门并发</li><li>一级门延迟，生成所有相加数</li></ul><p><img src="/2019/12/23/运算器/image-20191227001414909.png" alt="image-20191227001414909"></p><p>经过一级门电路延迟后，生成了所有相加数，这里X。。就是，将第二列用一个全加器进行相加，由于全加器有三个输入，所以这里进位位我们给一个零，当然大家也可以使用半加器完成，去掉进位输入，可以减少硬件成本，相加得到的结果就是乘积的P1位，进位输出横向向高位列传递，这就是所谓的横向进位阵列乘法器，将第三列的三个数用两个全加器串联进行运算，就可以得到P2，同样，全加器的进位输出都横向向左侧传递。，最后一个全加器进位输入为零，依次类推，得到P3，P4，P5，对于P6列，这个进位信号直接传递到下一层的全加器，同理得到P7，P。。。。。      如果采用斜向进位，就可以有另外一种连接方法。</p><p>前面我们给出了横向进位和斜向进位两种阵列乘法器，首先我们来看看横向进位阵列乘法器，5*5的横向阵列乘法器包括4行全加器，每行5个，需要20个全加器，进位信号横向传递，每一行都是一个5位串行进位加法器，串行加法器的特点就是性能差，各全加器之间存在着进位依赖，所以这个全加器运算完毕后，这个才能运算，然后是这个，第一行运算完毕后，第二行才能开始运算，所以看上去所有全加器都只能串行工作，整个运算需要20个全加器时延。</p><p>但仔细分析，这个横向进位阵列乘法器还存在这一定的并行性，首先是这个全加器运算，运算完毕后这个全加器运算，当第二个全加器运算完毕后，这两个全加器的输入就绪，两个全加器可以并发，当这两个全加器运算完毕后，这两个全加器运算，然后是这三个全加器并发，所以沿着对角线法线方向上的全加器是可以并发的，我们来看看乘法器的关键路径<br>(T是计算X1Y1，X0Y0的那个时延)</p><p><img src="/2019/12/23/运算器/image-20191227001634066.png" alt="image-20191227001634066"></p><p>斜向进位乘法器和横向进位乘法器结构有一些区别，加法器一共5行，每行4个全加器，横向进位是4行，每行5个，硬件电路成本相同，都是n。     由于斜向进位的引入，同一行的全加器可以并发，行与行之间有结果依赖，所以前面4行需要4个全加器延迟，也就是n-1个全加器延迟，最后一行由于采用的是横向进位，所以这部分如果不做优化，器时间延迟也是n-1个全加器延迟，电路运行的关键路径如下，一共需要。。。。。。。 斜式时间复杂度优于横向进位阵列乘法器，由3n个全加器延迟结标变成2n级别，性能明显由于横向进位阵列乘法器</p><p><img src="/2019/12/23/运算器/image-20191227002149154.png" alt="image-20191227002149154"></p><p>最后对比一下横向进位阵列乘法器，和斜向阵列乘法器，两个电路硬件成本都是n*n-1个全加器，只不过一个是4行5列，一个是5行4列但由于内部进位信号传递方式不同，直接导致性能差异加大，大约是1.5倍的差异， 不同结构硬件实现方式就和软件的算法一样，好的算法可以得到优秀的性能</p><p><img src="/2019/12/23/运算器/image-20191223112518818.png" alt="image-20191223112518818"></p><p><img src="/2019/12/23/运算器/image-20191223112531553.png" alt="image-20191223112531553"></p><h3 id="计算机中的流水线"><a href="#计算机中的流水线" class="headerlink" title="计算机中的流水线"></a>计算机中的流水线</h3><ul><li>流水思想：复杂问题分解成细粒度任务并发<ul><li>乘法流水线，浮点流水线，指令流水线</li><li>流水线 = 寄存器 + 组合逻辑 + 寄存器 + 组合逻辑 + 寄存器  …        数据通路串联</li><li>流水线时钟频率取决于组合逻辑的关键路径</li></ul></li></ul><p><img src="/2019/12/23/运算器/image-20191227003555284.png" alt="image-20191227003555284"></p><p>回到阵列乘法器上，如果简单的5*5将阵列乘法器看做4个5位串行加法器的级联，我们可以将运算过程细分为4个步骤，第一步计算Y+。。。。  得到部分积，为了简化设计，我们这里可以直接采用10位的加法器进行运算，不足的位补零即可， 第二部将第一步运算的结果累加上Y2X*4，*4是考虑权值对齐的问题，同理第三部。。。。第四部是。。。。。。完成第四部运算后10位加法器的运算结果就是最终的成绩，如果吧这里绿色的横线当做流水接口，实际上就可以演变成一个乘法流水线，这里流水接口本质上就是一堆寄存器，用于锁存当前步骤运算的部分积，，，以及后续步骤运算所需要的Yi*X。   后续我们实验中要求大家按照这个思路实现一个乘法流水线。</p><p><img src="/2019/12/23/运算器/image-20191227003638643.png" alt="image-20191227003638643"></p><p>刚刚我们给出的第一种流水线改造办法将乘法运算细分成了4部，实际上我们还可以按照横向进位阵列乘法器的关键路径进行流水细分，比如这里我们可以按照关键路径将乘法运算细分成11步，每一步中的全加器都可以完全并行，和刚刚介绍的方案1相比，这里流水线每一步的时间延迟更短，由10位全加器时延变成了一个全加器时延，流水线的时钟频率更高，流水线的性能更优。<br>这两种方法都是将乘法运算细分成若干更小的步骤，让后引入流水接口部件—-寄存器锁存中间结果构成运算流水线，实际上浮点运算流水线也是采用了类似的方法。   真是计算机中的乘法器也是采用流水线实现的，目前大多采用布斯两位乘法+华莱士树的方式构成，如果你有兴趣可以研究一下。</p><p><img src="/2019/12/23/运算器/image-20191227003720937.png" alt="image-20191227003720937"></p><h3 id="变量与常数之间的乘法运算"><a href="#变量与常数之间的乘法运算" class="headerlink" title="变量与常数之间的乘法运算"></a>变量与常数之间的乘法运算</h3><ul><li>整数乘法比移位和加法运算慢很多</li><li>编译器在处理变量与常数相乘时，用其它快速运算指令代替乘法<pre><code>x\*20  -&gt;  (x&lt;&lt;4)+(x&lt;&lt;2)       乘法转换成了2次移位和1次加法x\*15  -&gt;  (x&lt;&lt;4) – x               乘法转换成了1次移位和1次减法</code></pre></li><li>移位加减组合运算和直接相乘结果一样的（包括溢出）</li><li>是否优化取决于组合运算周期数是否小于乘法开销</li></ul><h2 id="定点数除法"><a href="#定点数除法" class="headerlink" title="定点数除法"></a>定点数除法</h2><h3 id="恢复余数除法"><a href="#恢复余数除法" class="headerlink" title="恢复余数除法"></a>恢复余数除法</h3><ul><li>如何判断是否够减<ul><li>利用补码作减法，判断余数符号即可</li></ul></li><li>余数为负数时，必须恢复余数<ul><li>将余数加除数，恢复成原值</li></ul></li><li>求下一位商，必须将余数左移一位，再与除数比较<ul><li>手工运算将除数右移？</li><li>注意这里余数放大了，最后结果要缩小</li></ul></li><li>比较，上商（恢复），余数移位，再比较，<ul><li>直到商的位数足够</li></ul></li></ul><p><img src="/2019/12/23/运算器/image-20191223231843074.png" alt="image-20191223231843074"></p><p><img src="/2019/12/23/运算器/image-20191223231854975.png" alt="image-20191223231854975"></p><p><img src="/2019/12/23/运算器/image-20191223231901994.png" alt="image-20191223231901994"></p><p>问题：</p><ul><li>需要进行恢复余数的操作<ul><li>余数是负数，必须恢复余数</li><li>绝对值运算，余数不可能是负数</li></ul></li><li>恢复余数的操作次数不确定<ul><li>运算时间不固定</li><li>最慢除法（每次都不够除），拖慢除法速度</li></ul></li><li>实际应用通常采用<strong>不恢复余数除法</strong></li></ul><h3 id="不恢复余数除法"><a href="#不恢复余数除法" class="headerlink" title="不恢复余数除法"></a>不恢复余数除法</h3><ul><li>n设某次余数为Ri，求下位商需将Ri左移一位，再减去除数Y进行比较，此过程可表示为<br>2Ri - Y</li><li>余数Ri小于0时商上0，需要恢复余数，左移一位，再减除数Y比较<br>(2Ri - Y）+ Y = 2Ri<br>2*2Ri – Y =4Ri–Y = 2*(2Ri -Y) + Y</li><li>不恢复余数法：余数Ri小于0时商上0，左移一位，再<strong>加</strong>除数Y比较</li></ul><p><img src="/2019/12/23/运算器/image-20191223231927917.png" alt="image-20191223231927917"></p><p><img src="/2019/12/23/运算器/image-20191223232007762.png" alt="image-20191223232007762"></p><p><img src="/2019/12/23/运算器/image-20191223232026608.png" alt="image-20191223232026608"></p><ul><li>n*n个CAS单元</li><li>(n*n) ×4T</li></ul><p><img src="/2019/12/23/运算器/image-20191223232033420.png" alt="image-20191223232033420"></p><h2 id="浮点数加减运算"><a href="#浮点数加减运算" class="headerlink" title="浮点数加减运算"></a>浮点数加减运算</h2><h3 id="规格化浮点数概念"><a href="#规格化浮点数概念" class="headerlink" title="规格化浮点数概念"></a>规格化浮点数概念</h3><ul><li>由于浮点数是将数据的表示范围与精确度分别表示的数据表示方法，若不对浮点数的表示作出明确规定，同一个浮点数的表示就不唯一</li><li>规格化浮点数是指把一个浮点数按指定的格式进行转换，</li><li>由于浮点数是将数据的表示范围与精确度分别表示的数据表示方法，若不 对浮点数的表示作出明确规定，同一个浮点数的表示就不唯一，</li><li>以浮点数一般格式为例，规格化浮点数的尾数形式为: 00.1… 或 11.0…。</li></ul><h3 id="规格化浮点数方法"><a href="#规格化浮点数方法" class="headerlink" title="规格化浮点数方法"></a>规格化浮点数方法</h3><ul><li>当尾数结果为 00.0… 或 11.1，需要左规格化即将尾数向左移动， 每移动一次，阶码减1，直到尾数形式为 00.1… 或 11.0…。</li><li>当尾数的结果为 01.… 或 10.， 表明尾数求和的结果 &gt; 1,此时仅 需要执行一次右移规格化， 阶码加 1 ,尾数形式即为00.1… 或 11.0…</li></ul><h3 id="浮点数加减运算方法及其步骤"><a href="#浮点数加减运算方法及其步骤" class="headerlink" title="浮点数加减运算方法及其步骤"></a>浮点数加减运算方法及其步骤</h3><ul><li><p>对阶 </p><ul><li>求阶差；</li><li>右移阶码小的浮点数的尾数并同步增加其阶码，直至两数阶码相等。</li></ul></li><li><p>尾数加/减 </p><ul><li>尾数加/减运算 （用对阶后的尾数） </li></ul></li><li><p>结果规格化</p><ul><li>尾数非零时，要求绝对值≥0.5，尾数MSB=1</li><li>否则修改阶码并移动尾数，使其满足上述要求</li><li>目的：保证浮点数的编码唯一性</li><li>右移以实现规格化   向右规格化   右归   阶码+<ul><li>右归时连同符号位进位位一起右移，阶码作加法 </li></ul></li><li>左移以实现规格化   向左规格化   左归   阶码-<ul><li>左归时LSB位补0，阶码作减法</li></ul></li></ul></li><li><p>舍入</p><ul><li>右移规格化时可能丢失一些低位的数值位, 为提高精度,  可采取舍入的方法: </li><li>0 舍 1 入 : 若右移出的是1则在最低位加1;<br><img src="/2019/12/23/运算器/image-20191227005213203.png" alt="image-20191227005213203"></li><li>恒置 1 : 只要数字位1被移掉,就将最后一位恒置成1。</li></ul></li><li><p>溢出处理 </p><ul><li>浮点数的溢出标志:  阶码溢出 </li><li>阶码上溢 ： 阶码的符号位为 01 </li><li>阶码下溢 ： 阶码的符号位为 10</li><li>尾数上溢   右归</li><li>尾数下溢   左归</li></ul></li></ul><p>例1  两浮点数 x = 2^101×0.11011011，y = 2^111×(-0.10101100)。假设尾数在计算机中以补码表示，可存储10位尾数，2位符号位，阶码以补码表示，双符号位, 求 x + y。</p><p>解：将x , y转换成浮点格式<br>     [x]浮 = 00101, 00.11011011<br>     [Y]浮 = 00111, 11.01010100<br>步骤1：对阶，阶差为 Ex − Ey = [Ex]补 + [−Ey]补<br>     [−Ey]补=11001  Ex−Ey＝00101＋11001＝11110 = -2 &lt; 0<br>         小阶对大阶， X阶码加2， 尾数右移2位<br>     [x]浮 = 00111,00.0011011011   保留位<br>     [x]浮 = 00111, 00.0011011011   保留位<br>     [Y]浮 = 00111, 11.01010100<br>步骤2：尾数求和<br>     [X+Y]浮 = 00111, 11.1000101011   保留位参与运算<br>步骤3：结果规格化<br>     [X+Y]浮 = 00110, 11.000101011     非规数，左归1位, 阶码减1，保留位？<br>步骤4：舍入处理<br>     [X+Y]浮 = 00110, 11.00010110   (0舍1如法)<br>     [X+Y]浮 = 00110, 11.00010101   (截去法)<br>步骤5：溢出判断<br>    [X+Y]浮 = 2110 x (-0.11101011)   无溢出</p><p>特殊例子：<br>X=2^111 *  0.11111111，Y=2^111 * 0.10000001<br>                      [X]浮  =    0111, 0.1111 1111<br>           +         [Y]浮  =    0111, 0.1000 0001<br>                  [X+Y]浮  =    0111, 1.1000 0000<br>              尾数上溢，右归一位，连同符号位进位位一起右移1位，阶码加1<br>                  [X+Y]浮 =    1000, 0.1100 0000<br>            阶码正溢出，运算结果上溢  </p><p>X=2^-1000 * -0.11110000，Y=2^-1000 * 0.10000001<br>                     [X]浮  =    1000, 1.0001 0000<br>          +         [Y]浮  =    1000, 0.1000 0001<br>                [X+Y]浮   =    1000, 1.1001 0001<br>            尾数下溢，左归一位， 左移一位，阶码减1<br>                [X+Y]浮  =    1000, 1.0010 0010<br>                   1000+1111=0111 =7<br>            阶码负上溢，运算结果下溢</p><h2 id="浮点数乘法运算"><a href="#浮点数乘法运算" class="headerlink" title="浮点数乘法运算"></a>浮点数乘法运算</h2><p>X=2^m * Mx        Y=2^n * My<br>        X * Y = ( 2^m * Mx ) * ( 2^n * My ) = 2^m+n * (Mx * My)<br>(1) 阶码相加<br>阶码相加可能产生溢出，要进行溢出判断，如溢出计算机要进行处理<br>(2) 尾数相乘<br>尾数相乘可得积的尾数，可按定点乘法运算方法运算<br>(3) 结果规格化<br>可按浮点加/减法运算规格化方式处理，舍入方式也相同</p><h2 id="浮点数除法运算"><a href="#浮点数除法运算" class="headerlink" title="浮点数除法运算"></a>浮点数除法运算</h2><p>如：X=2^m * Mx        Y=2^n * My<br>        X / Y = ( 2^m * Mx ) / ( 2n * My ) = 2^m-n * (Mx / My)<br>尾数调整<br>如被除数尾数大于除数尾数 (绝对值)，则将被除数尾数右移一位，阶码+1<br>阶码求差<br>商的阶码等于被除数的阶码减去除数的阶码<br>尾数相除<br>以被除数的尾数除以除数的尾数以获得商的尾数，尾数相除与定点除法运算相同</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p><strong>单符号位补码表示的两个同号数相加或异号数相减时，所得结果的符号位SF和进位标志CF进行（D ）运算为1时，表示运算的结果产生溢出</strong><br>A.与非    B.与        C.或        D.异或</p><hr><p><strong>若采用双符号位补码运算，运算结果的符号位为10，下列结论中错误的是 AB</strong><br>A.产生了上溢    B.运算结果溢出，结果为正数    C.产生了下溢    D.运算结果溢出，结果为负数</p><p>计算机运算溢出检测机制，采用双符号位，00表示正号，11表示负号。如果进位将会导致符号位不一致，从而检测出溢出。结果的符号位为01时，称为上溢；为10时，称为下溢。</p><hr><p>以下说法正确的是<strong>ABCD</strong><br>A.n位小数的补码一位乘法（Booth算法），需做n+1次运算，第n+1次不移位<br>B.浮点运算可由阶码运算和尾数运算两个部分联合实现<br>C.补码加减交替法是一种不恢复余数法<br><strong>D.在定点小数补码一位除法中，为了避免溢出，被除数的绝对值一定要小于除数的绝对值</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定点数运算及溢出检测&quot;&gt;&lt;a href=&quot;#定点数运算及溢出检测&quot; class=&quot;headerlink&quot; title=&quot;定点数运算及溢出检测&quot;&gt;&lt;/a&gt;定点数运算及溢出检测&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;补码加法：[X＋Y]补 = [X]补＋ [Y]补&lt;ul&gt;
&lt;li&gt;和的补码 = 补码的和&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;补码减法：[X−Y]补 = [X]补＋ [−Y]补 = [X]补−[Y]补&lt;ul&gt;
&lt;li&gt;差的补码 = 补码的差&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机组成原理" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="组成原理" scheme="http://yorxika.github.io/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据表示</title>
    <link href="http://yorxika.github.io/2019/12/19/%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/"/>
    <id>http://yorxika.github.io/2019/12/19/%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/</id>
    <published>2019-12-19T14:52:33.000Z</published>
    <updated>2019-12-26T15:38:37.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><a id="more"></a><p><img src="/2019/12/19/数据表示/image-20191220003552325.png" alt="image-20191220003552325"></p><h2 id="机器数及其特点"><a href="#机器数及其特点" class="headerlink" title="机器数及其特点"></a>机器数及其特点</h2><p><img src="/2019/12/19/数据表示/image-20191219231153151.png" alt="image-20191219231153151"></p><p><strong>原码特性</strong></p><ul><li>直观易懂<ul><li>第一位为符号位</li><li>其他为数值位</li></ul></li><li>正零负零两个零</li><li>加、减运算方式不统一<ul><li>符号相异加法不能直接运算</li><li>特别当 a&lt;b时，实现 a-b比较困难</li></ul></li><li>从50年代开始，整数都采用补码来表示</li><li>但浮点数的尾数用原码定点小数表示</li></ul><p><strong>反码特性</strong></p><ul><li>两个零</li><li>求反用逻辑门容易实现</li><li>运算仍然很复杂<ul><li>相加时需要将符号位的进位位增加到LSB上</li></ul></li></ul><p><strong>补码特性</strong></p><ul><li>唯一的零</li><li>符号位可以直接参与运算</li><li>减法可以变成加法，运算电路统一</li><li>负数比整数多一个</li><li>不同位数的整数补码相加减时<ul><li>位数少的补码符号位向左扩展</li><li>一直扩展到符号位对齐</li></ul></li></ul><p><img src="/2019/12/19/数据表示/image-20191219231207351.png" alt="image-20191219231207351"></p><p><img src="/2019/12/19/数据表示/image-20191219232033377.png" alt="image-20191219232033377"></p><p><img src="/2019/12/19/数据表示/image-20191219232235893.png" alt="image-20191219232235893"></p><p>定点数机器码表示范围：<br><img src="/2019/12/19/数据表示/image-20191219232325487.png" alt="image-20191219232325487"></p><h3 id="双符号位补码"><a href="#双符号位补码" class="headerlink" title="双符号位补码"></a>双符号位补码</h3><p><img src="/2019/12/19/数据表示/image-20191220004143783.png" alt="image-20191220004143783"></p><h2 id="定点与浮点数据表示"><a href="#定点与浮点数据表示" class="headerlink" title="定点与浮点数据表示"></a>定点与浮点数据表示</h2><p><img src="/2019/12/19/数据表示/image-20191219233804226.png" alt="image-20191219233804226"></p><p><img src="/2019/12/19/数据表示/image-20191219233824924.png" alt="image-20191219233824924"></p><p><img src="/2019/12/19/数据表示/image-20191219233857085.png" alt="image-20191219233857085"></p><p><img src="/2019/12/19/数据表示/image-20191219233918638.png" alt="image-20191219233918638"></p><p><img src="/2019/12/19/数据表示/image-20191220005108307.png" alt="image-20191220005108307"></p><p><img src="/2019/12/19/数据表示/image-20191220005139118.png" alt="image-20191220005139118"></p><p><img src="/2019/12/19/数据表示/image-20191219233929847.png" alt="image-20191219233929847"></p><ul><li>机器字长一定时，阶码越长，表示范围越大</li><li>阶码相同，尾数越长，数据精度越高</li><li>浮点数表示范围比定点数大，精度高</li><li>阶码尾码长度应为多少合适？  </li><li>阶码越长，表示范围越大，精度越高 (规格化)</li><li>浮点数扩大了数值表示的范围， 未增加表示数值的个数</li><li>绝对值越大，浮点数分布越稀疏，浮点数是离散空间</li><li>浮点运算不满足结合律<ul><li>（2-126+1020）-1020 = ?       2-126 + (1020 - 1020) =?</li></ul></li></ul><h3 id="十进制数的表示-BCD码"><a href="#十进制数的表示-BCD码" class="headerlink" title="十进制数的表示 BCD码"></a>十进制数的表示 BCD码</h3><p><img src="/2019/12/19/数据表示/image-20191220005354101.png" alt="image-2019"></p><h2 id="数据校验的基本原理"><a href="#数据校验的基本原理" class="headerlink" title="数据校验的基本原理"></a>数据校验的基本原理</h2><p><img src="/2019/12/19/数据表示/image-20191219234631646.png" alt="image-20191219234631646"></p><p><img src="/2019/12/19/数据表示/image-20191219234643400.png" alt="image-20191219234643400"></p><p><img src="/2019/12/19/数据表示/image-20191219234654617.png" alt="image-20191219234654617"></p><h2 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h2><p><img src="/2019/12/19/数据表示/image-20191220005825812.png" alt="image-20191220005825812"></p><p><img src="/2019/12/19/数据表示/image-20191219235642154.png" alt="image-20191219235642154"></p><p><img src="/2019/12/19/数据表示/image-20191219235921834.png" alt="image-20191219235921834"></p><h2 id="CRC校验及其实现"><a href="#CRC校验及其实现" class="headerlink" title="CRC校验及其实现"></a>CRC校验及其实现</h2><p><img src="/2019/12/19/数据表示/image-20191220001405535.png" alt="image-20191220001405535"></p><ul><li><p><strong>生成多项式特征</strong></p><ul><li>任意位发生错误都应使余数不为0</li><li>不同位发生错误余数不同</li><li>余数左移一位继续作模2除，应使余数循环，循环周期 N=k+r  ？</li></ul></li><li><p><strong>如何产生生成多项式</strong></p><ul><li>(n,k)码，将Xn+1分解为若干质因子   （模2的运算）</li><li>根据码距要求选择其中的因式或多个因式的乘积为生成多项式</li></ul></li><li><p>码距：任意两个合法编码间不同的二进制位数    最小码距</p></li><li><p>码距越大，抗干扰能力、纠错能力越强，数据冗余越大，编码效率越低</p></li><li><p>选择码距应考虑信息出错概率和系统容错率</p><ul><li>奇偶校验  最小码距为2</li><li>海明码     最小码距为3</li></ul></li></ul><p><img src="/2019/12/19/数据表示/image-20191220001447447.png" alt="image-20191220001447447"></p><p><img src="/2019/12/19/数据表示/image-20191226232339760.png" alt="image-20191226232339760"></p><p><img src="/2019/12/19/数据表示/image-20191220001757864.png" alt="image-20191220001757864"></p><p>(7,3)码多位错余数情况</p><ul><li>两位数出错余数与一位错有重叠（见表）</li><li>三位错余数有可能为零   如 C1，C2，C4   （无法全部检错）</li></ul><p><img src="/2019/12/19/数据表示/image-20191226232647970.png" alt="image-20191226232647970"></p><p>CRC串行编码电路    (时序逻辑)</p><p><img src="/2019/12/19/数据表示/image-20191226233101210.png" alt="image-20191226233101210"></p><ul><li>有异或门的位置是生成多项式为1的位置，G(X)=X4+X+1    10011</li><li>触发器初始状态为0</li><li>Q4=0时，不够除，下一个时钟，数据左移一位</li><li>Q4=1时，够除，商上1， Q4Q3Q2Q1Serial_in ⊕ 生成多项式  结果左移<br>运算速度慢，高速设备普遍采用 并行CRC 编解码</li></ul><p>备注：<br>下面我们来看一看CRC串行编码电路，注意这个串行编码电路是一个同步时序逻辑，具有统一时钟。<br>从图中我们可以看到这个电路的包括若干个D触发器，Q4这Q3…..一共共4个D触发器，所有D触发器时钟同步，注意D触发器之间的链接，部分是直接串联，部分D触发器之间有一个异或门，异或门一个输入连接的是当前寄存器输出，另外一个是Q4的输出。这里有异或门的地方就是CRC编码电路生成多项式为1的位置，具体如红色文字所示，Q4位置是最高位，默认为1，所以生成多项式为10011，初始状态，所有触发器输出Q4Q3Q2Q1的值均为零，最高位Q4为零，按模2的除法不够除，Q4控制所有的异或门，因为Q4为零，所有异或门位置变成数据直通，Q1直接连接到Q2的D端。<br>四个D触发器直接串联，变成一个移位寄存器，时钟到来数据左移一位<br>这和模2除法的不够除的处理过程是完全一致的。根据这个运算规则，如果左移后Q4的值仍然还是0，则会继续左移，Q3，Q2，Q1初值都为零，所以只有串行输入数据中的第一个1传输到Q4时电路才会改变运行模式，当Q4为1时，所有异或门的地方要异或上1，相当于是Q4Q3Q2Q1串行输入这一组数据和生成多项式做异或，生成多项式为1的地方进行异或运算，为0的地方异或上零还是不变，还是原始数据，这里采用直连方式，计算后的结果下一时钟会左移一位，这个电路状态就是模2除法运时最高位为1，够除，商上1，被除数和除数进行异或运算，结果左移当串行输入的最后一位数据抵达进入电路后，各触发器输入端的值D4D3D2D1就是最终的余数这样一个电路，如果串行输入的数据越长，那么它需要的时钟就越多，所以它的运算速度非常慢的，目前在高速网络设备中必须采用并行的CRC编解码电路。</p><p>(7,3）编码电路</p><p><img src="/2019/12/19/数据表示/image-20191226233311840.png" alt="image-20191226233311840"></p><p>CRC   (N,k)码检错性能      r=N-k</p><ul><li>所有小于等于r长度的突发错<ul><li>通讯中常见，各出错位之间有因果关系</li><li>突发错长度：第一和最后一个错位之间的距离</li></ul></li><li>( 1−2^(–r+1))比例的r+1长度的突发错</li><li>( 1−2^–r )比例的大于r+1长度的突发错</li><li>所有小于最小码距的任意位数的错误</li><li>如果生成多项式中1的数目为偶数，可检测所有奇数错</li><li>广泛运用于通信传输领域，磁存储领域</li></ul><h2 id="海明校验及其实现"><a href="#海明校验及其实现" class="headerlink" title="海明校验及其实现"></a>海明校验及其实现</h2><ul><li><p>多个奇偶校验组</p></li><li><p>既能检错，也能纠错</p></li><li><p>最小码距为3</p></li><li><p>编码规则：分组交叉奇偶校验法</p><ul><li>待编码数据分成 r 个奇偶校验组，r&gt;1</li><li>r 位校验位（冗余），生成r位检错码</li><li>各数据位至少参加2个校验组</li><li>一个数据位出错，可导致多个检错码为1</li></ul></li><li><p>检错纠错：检错码值表示出错位置   （假设1位错）</p><ul><li>检错码全零， 数据大概率正常</li><li>可检错，也可纠错，将出错位取反即可</li></ul></li></ul><p><img src="/2019/12/19/数据表示/image-20191220003136644.png" alt="image-20191220003136644"></p><p><img src="/2019/12/19/数据表示/image-20191220003145152.png" alt="image-20191220003145152"></p><p>(4,3)码分组依据<br><img src="/2019/12/19/数据表示/image-20191226231723570.png" alt="image-20191226231723570"></p><p><img src="/2019/12/19/数据表示/image-20191220003206327.png" alt="image-20191220003206327"></p><p><img src="/2019/12/19/数据表示/image-20191220003218848.png" alt="image-20191220003218848"></p><p><img src="/2019/12/19/数据表示/image-20191220003228764.png" alt="image-20191220003228764"></p><p><img src="/2019/12/19/数据表示/image-20191220003246821.png" alt="image-20191220003246821"></p><ul><li>可检一位错<ul><li>检错码G3G2G1 !=000，具体值为出错位置，取反即可纠错</li></ul></li><li>可检两位错<ul><li>假设D1 ，D2同时出错，  G3G2G1=110  ？</li></ul></li><li>大多数三位错<ul><li>D1，D2，D3同时出错？G3G2G1=000  ？</li></ul></li><li>能否区分区分一位错，两位错？  <ul><li>假设没有3位错</li><li>引入总偶校验位 P4=H1⊕H2⊕H3⊕H4⊕H5⊕H6⊕H7</li><li>G4=P4⊕H1⊕H2⊕H3⊕H4⊕H5⊕H6⊕H7  区分一位两位错</li></ul></li></ul><p><img src="/2019/12/19/数据表示/image-20191226231946271.png" alt="image-20191226231946271"></p><p>海明码特点：</p><ul><li>编码效率高：数据增加一倍，校验位只增加一位</li><li>可纠正一位错</li><li>50年代发明时用于自动处理穿孔卡片的故障</li><li>现在普遍用于ECC  DRAM芯片</li><li>RAID2，卫星通讯</li></ul><h2 id="校验码总结"><a href="#校验码总结" class="headerlink" title="校验码总结"></a>校验码总结</h2><p><img src="/2019/12/19/数据表示/image-20191220010548069.png" alt="image-20191220010548069"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>下列对海明校验的描述中，正确的描述是  <strong>C</strong><br>A.在任何条件下，海明校验都无法检测到多位数据同时出错的情况<br>B.分成r组时，可以得到r位指误码，因此可以QU区分2^r种只有1位出错的情况<br>C.待编码数据长度为4位，再增加3位校验码就可以检测到仅1位数据出错的情况并纠错<br>D.海明校验码的码距与校验位的位数没有关系</p><hr><p>计算机字长16位，采用补码表示整数，下列关于其表示数据范围的描述中正确的是<strong>ABCD</strong><br>A.能表示的最小正数是1<br>B.能表示的最小负数是- (2 ^15)<br>C.能表示最大正数是(2^15) - 1<br>D.能表示的最大负数是-1</p><hr><p>列关于补码和移码关系的描述中，错误的是<strong>B</strong><br>A.一般用译码表示浮点数的阶码，而用补码表示定点数<br>B.零的补码和移码相同<br>C.同一个数的补码和移码，其数值部分相同，而符号相反<br>D.相同位数的补码和移码具有相同的数据表示范围</p><p>移码：X+2^n</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进制转换&quot;&gt;&lt;a href=&quot;#进制转换&quot; class=&quot;headerlink&quot; title=&quot;进制转换&quot;&gt;&lt;/a&gt;进制转换&lt;/h2&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机组成原理" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="组成原理" scheme="http://yorxika.github.io/tags/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的右视图</title>
    <link href="http://yorxika.github.io/2019/12/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>http://yorxika.github.io/2019/12/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</id>
    <published>2019-12-19T13:15:29.000Z</published>
    <updated>2019-12-19T13:42:52.558Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第199题二叉树的右视图</p><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">4</span>]</span><br><span class="line">输出: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>            &lt;---</span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span>         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  <span class="number">5</span>     <span class="number">4</span>       &lt;---</span><br></pre></td></tr></table></figure><h3 id="错误的遍历"><a href="#错误的遍历" class="headerlink" title="错误的遍历"></a>错误的遍历</h3><p>第一次提交忽略了当右子树比左子树短的情况下，要对左子树进行遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    helper(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>)</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">        helper(root.right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">        helper(root.left);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>既然要考虑所有情况，那么就进行层序遍历，然后保留最后一个进队列的节点即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> len = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == len - <span class="number">1</span>)</span><br><span class="line">                ans.add(queue.peek().val);</span><br><span class="line">            TreeNode tmp = queue.remove();</span><br><span class="line">            <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(tmp.left);</span><br><span class="line">            <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>来源<a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/solution/er-cha-shu-de-you-shi-tu-by-leetcode/" target="_blank" rel="noopener">题解</a></p><p><strong>直觉</strong></p><p>如果按正确的顺序访问每个节点，就可以有效地获得二叉树的右视图。</p><p><strong>算法</strong></p><p>上面提到的顺序之一可以由深度优先搜索定义。在深度优先搜索中，我们总是先访问右子树。这样就保证了当我们访问树的某个特定深度时，我们正在访问的节点总是该深度的最右侧节点。于是，可以存储在每个深度访问的第一个结点，一旦我们知道了树的层数，就可以得到最终的结果数组。</p><p><img src="/2019/12/19/二叉树的右视图/80f65d954842dc68509b516d563f846d1f02a31d099027d5a94b49b465e6030c-image.png" alt="image.png"></p><p>上图表示了问题的一个实例。红色结点自上而下组成答案，边缘以访问顺序标号。</p><p>题解通过维护两个栈（一个深度栈，一个节点栈）栈以及一个HashMap来填充每层的右视图。通过左子树入栈在右子树入栈的顺序保证出栈时是右子树先出栈，在将其对应深度填到HashMap里，最后按照深度对Map做一次遍历即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; rightmostValueAtDepth = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> max_depth = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* These two stacks are always synchronized, providing an implicit</span></span><br><span class="line"><span class="comment">         * association values with the same offset on each stack. */</span></span><br><span class="line">        Stack&lt;TreeNode&gt; nodeStack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; depthStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        nodeStack.push(root);</span><br><span class="line">        depthStack.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!nodeStack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = nodeStack.pop();</span><br><span class="line">            <span class="keyword">int</span> depth = depthStack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                max_depth = Math.max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* The first node that we encounter at a particular depth contains</span></span><br><span class="line"><span class="comment">                * the correct value. */</span></span><br><span class="line">                <span class="keyword">if</span> (!rightmostValueAtDepth.containsKey(depth)) &#123;</span><br><span class="line">                    rightmostValueAtDepth.put(depth, node.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                nodeStack.push(node.left);</span><br><span class="line">                nodeStack.push(node.right);</span><br><span class="line">                depthStack.push(depth+<span class="number">1</span>);</span><br><span class="line">                depthStack.push(depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Construct the solution based on the values that we end up with at the</span></span><br><span class="line"><span class="comment">         * end. */</span></span><br><span class="line">        List&lt;Integer&gt; rightView = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> depth = <span class="number">0</span>; depth &lt;= max_depth; depth++) &#123;</span><br><span class="line">            rightView.add(rightmostValueAtDepth.get(depth));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>既然题解里用深度标明了每层的元素，那么我也应该可以在递归时多传一个参数，记作是当前节点的深度值，按照右左的顺序递归即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    helper(root,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,<span class="keyword">int</span> deepth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(deepth == ans.size())</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">        helper(root.right,deepth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">        helper(root.left,deepth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第199题二叉树的右视图&lt;/p&gt;
&lt;p&gt;给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
      <category term="广度优先搜索" scheme="http://yorxika.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>求根到叶子节点数字之和</title>
    <link href="http://yorxika.github.io/2019/12/18/%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
    <id>http://yorxika.github.io/2019/12/18/%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</id>
    <published>2019-12-18T15:09:23.000Z</published>
    <updated>2019-12-19T13:08:45.070Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第129题求根到叶子节点数字之和</p><p>给定一个二叉树，它的每个结点都存放一个 <code>0-9</code> 的数字，每条从根到叶子节点的路径都代表一个数字。</p><a id="more"></a><p>例如，从根到叶子节点路径 <code>1-&gt;2-&gt;3</code> 代表数字 <code>123</code>。</p><p>计算从根到叶子节点生成的所有数字之和。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例 1:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">输出: <span class="number">25</span></span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-&gt;<span class="number">2</span> 代表数字 <span class="number">12.</span></span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-&gt;<span class="number">3</span> 代表数字 <span class="number">13.</span></span><br><span class="line">因此，数字总和 = <span class="number">12</span> + <span class="number">13</span> = <span class="number">25.</span></span><br></pre></td></tr></table></figure><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>跟之前写的路径总和差不多，也是要注意DFS在返回时需要去掉最后一个加入的点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    helper(root,ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>)</span><br><span class="line">        sum = sum * <span class="number">10</span> + root.val;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">        ans += sum;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">        helper(root.left,sum);</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">        helper(root.right,sum);</span><br><span class="line">    sum /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>来源<a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/solution/3zhong-jie-fa-di-gui-xian-xu-fei-di-gui-xian-xu-ce/" target="_blank" rel="noopener">题解</a><br>通常还可以用 <code>stack</code> 的思路来解递归的题目。先序非递归的代码我们知道是用 <code>stack</code> 来保存遍历过的元素。而因为本题要记录到叶节点的数字，所以需要一个额外的 <code>stack</code> 来记录数字。每次出 <code>stack</code> 之后，如果是叶子节点，那么加和；如果不是，那么就看左右子树，入 <code>stack</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> sum;</span><br><span class="line">       Stack&lt;TreeNode&gt; nodeStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       Stack&lt;Integer&gt; numStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       nodeStack.add(root);</span><br><span class="line">       numStack.add(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">while</span> (!nodeStack.isEmpty()) &#123;</span><br><span class="line">           TreeNode current = nodeStack.pop();</span><br><span class="line">           Integer currentNum = numStack.pop() * <span class="number">10</span> + current.val;</span><br><span class="line">           <span class="keyword">if</span> (current.left == <span class="keyword">null</span> &amp;&amp; current.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">               sum += currentNum;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">               nodeStack.add(current.left);</span><br><span class="line">               numStack.add(currentNum);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">               nodeStack.add(current.right);</span><br><span class="line">               numStack.add(currentNum);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第129题求根到叶子节点数字之和&lt;/p&gt;
&lt;p&gt;给定一个二叉树，它的每个结点都存放一个 &lt;code&gt;0-9&lt;/code&gt; 的数字，每条从根到叶子节点的路径都代表一个数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
      <category term="深度优先搜索" scheme="http://yorxika.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>复制带随机指针的链表</title>
    <link href="http://yorxika.github.io/2019/12/18/%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://yorxika.github.io/2019/12/18/%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2019-12-17T16:51:34.000Z</published>
    <updated>2019-12-18T05:47:41.092Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第138题复制带随机指针的链表</p><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p><p>要求返回这个链表的<strong><a href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin" target="_blank" rel="noopener">深拷贝</a></strong>。 <a id="more"></a></p><p><strong>示例：</strong></p><p><strong><img src="/2019/12/18/复制带随机指针的链表/1470150906153-2yxeznm.png" alt="img"></strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">&#123;<span class="string">"<span class="subst">$id</span>"</span>:<span class="string">"1"</span>,<span class="string">"next"</span>:&#123;<span class="string">"<span class="subst">$id</span>"</span>:<span class="string">"2"</span>,<span class="string">"next"</span>:<span class="keyword">null</span>,<span class="string">"random"</span>:&#123;<span class="string">"<span class="subst">$ref</span>"</span>:<span class="string">"2"</span>&#125;,<span class="string">"val"</span>:<span class="number">2</span>&#125;,<span class="string">"random"</span>:&#123;<span class="string">"<span class="subst">$ref</span>"</span>:<span class="string">"2"</span>&#125;,<span class="string">"val"</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">节点 <span class="number">1</span> 的值是 <span class="number">1</span>，它的下一个指针和随机指针都指向节点 <span class="number">2</span> 。</span><br><span class="line">节点 <span class="number">2</span> 的值是 <span class="number">2</span>，它的下一个指针指向 <span class="keyword">null</span>，随机指针指向它自己。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>你必须返回<strong>给定头的拷贝</strong>作为对克隆列表的引用。</li></ol><h3 id="哈希Map"><a href="#哈希Map" class="headerlink" title="哈希Map"></a>哈希Map</h3><p>利用一个哈希Map存储原链表结点和对应的拷贝结点，在原链表里遍历，但是要注意当原结点的随机结点为空时，不能将空结点及其拷贝放入哈希Map里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Map&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Node newHead = <span class="keyword">new</span> Node();</span><br><span class="line">    map.put(head,newHead);</span><br><span class="line">    Node p1 = newHead;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p1.val = head.val;</span><br><span class="line">        <span class="comment">//p1.next = head.next;</span></span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(head.random) &amp;&amp; head.random != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node tmp = <span class="keyword">new</span> Node();</span><br><span class="line">            map.put(head.random,tmp);</span><br><span class="line">            p1.random = tmp;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head.random != <span class="keyword">null</span>)</span><br><span class="line">            p1.random = map.get(head.random);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p1.random = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//map.put(head,p1);</span></span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(head))&#123;</span><br><span class="line">            p1.next = <span class="keyword">new</span> Node();</span><br><span class="line">            map.put(head,p1.next);</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p1.next = map.get(head);</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原结点后追加新结点"><a href="#原结点后追加新结点" class="headerlink" title="原结点后追加新结点"></a>原结点后追加新结点</h3><p> <code>HashMap</code> 额外需要 <code>O(n)</code> 的空间复杂度，现在考虑不需要额外空间的方法。</p><p>主要参考了<a href="https://leetcode.com/problems/copy-list-with-random-pointer/discuss/43491/A-solution-with-constant-space-complexity-O(1)-and-linear-time-complexity-O(N)" target="_blank" rel="noopener">这里</a>。主要解决的问题就是我们生成节点以后，当更新它的 <code>random</code> 的时候，怎么找到之前生成的节点，前两种解法用了 <code>HashMap</code> 全部存起来，这里的话可以利用原来的链表的指针域。</p><p>主要需要三步。</p><ol><li>生成所有的节点，并且分别插入到原有节点的后边</li><li>更新插入节点的 <code>random</code></li><li>将新旧节点分离开来</li></ol><p>一图胜千言，大家看一下下边的图吧。</p><p><img src="https://pic.leetcode-cn.com/9bd4662fdbcb1e44f5ce208e29f3459d1adbf1e7ceb723e4bfc8ba2eff3bd186.jpg" alt="img"></p><p>代码对应如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node l1 = head;</span><br><span class="line">    Node l2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//生成所有的节点，并且分别插入到原有节点的后边</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        l2 = <span class="keyword">new</span> Node();</span><br><span class="line">        l2.val = l1.val;</span><br><span class="line">        l2.next = l1.next;</span><br><span class="line">        l1.next = l2;</span><br><span class="line">        l1 = l1.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新插入节点的 random</span></span><br><span class="line">    l1 = head;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">            l1.next.random = l1.random.next;</span><br><span class="line">        &#125;</span><br><span class="line">        l1 = l1.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l1 = head;</span><br><span class="line">    Node l2_head = l1.next;</span><br><span class="line">    <span class="comment">//将新旧节点分离开来</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        l2 = l1.next;</span><br><span class="line">        l1.next = l2.next;</span><br><span class="line">        <span class="keyword">if</span> (l2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            l2.next = l2.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l2_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用random保存新结点"><a href="#利用random保存新结点" class="headerlink" title="利用random保存新结点"></a>利用random保存新结点</h3><p>不利用额外的空间复杂度还有一种思路，参考 <a href="https://leetcode.com/problems/copy-list-with-random-pointer/discuss/43497/2-clean-C%2B%2B-algorithms-without-using-extra-arrayhash-table.-Algorithms-are-explained-step-by-step." target="_blank" rel="noopener">这里</a>。</p><p>上一个解法利用原链表的 <code>next</code> 域把新生成的节点保存了起来。类似的，我们还可以利用原链表的 <code>random</code> 域把新生成的节点保存起来。</p><p>主要还是三个步骤。</p><ol><li>生成所有的节点，将它们保存到原链表的 <code>random</code> 域，同时利用新生成的节点的 <code>next</code> 域保存原链表的 <code>random</code>。</li><li>更新新生成节点的 <code>random</code> 指针。</li><li>恢复原链表的 <code>random</code> 指针，同时更新新生成节点的 <code>next</code> 指针。</li></ol><p>一图胜千言。</p><p><img src="https://pic.leetcode-cn.com/9d18d01597f5ca7562c8dd3908082b13c27b989fcaebb37c163d6e7ced65f412.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node l1 = head;</span><br><span class="line">    Node l2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//生成所有的节点，讲它们保存到原链表的 random 域，</span></span><br><span class="line">    <span class="comment">//同时利用新生成的节点的 next 域保存原链表的 random。</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        l2 = <span class="keyword">new</span> Node();</span><br><span class="line">        l2.val = l1.val;</span><br><span class="line">        l2.next = l1.random;</span><br><span class="line">        l1.random = l2;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    l1 = head;</span><br><span class="line">    <span class="comment">//更新新生成节点的 random 指针。</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        l2 = l1.random;</span><br><span class="line">        l2.random = l2.next != <span class="keyword">null</span> ? l2.next.random : <span class="keyword">null</span>;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l1 = head;</span><br><span class="line">    Node l2_head = l1.random;</span><br><span class="line">    <span class="comment">//恢复原链表的 random 指针，同时更新新生成节点的 next 指针。</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        l2 = l1.random;</span><br><span class="line">        l1.random = l2.next;</span><br><span class="line">        l2.next = l1.next != <span class="keyword">null</span> ? l1.next.random : <span class="keyword">null</span>;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l2_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第138题复制带随机指针的链表&lt;/p&gt;
&lt;p&gt;给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。&lt;/p&gt;
&lt;p&gt;要求返回这个链表的&lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深拷贝&lt;/a&gt;&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="链表" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="链表" scheme="http://yorxika.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>路径总和II</title>
    <link href="http://yorxika.github.io/2019/12/17/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/"/>
    <id>http://yorxika.github.io/2019/12/17/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/</id>
    <published>2019-12-17T12:50:14.000Z</published>
    <updated>2019-12-17T13:05:13.116Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第113题路径总和II</p><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。<a id="more"></a></p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">5</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">4</span>   <span class="number">8</span></span><br><span class="line">   /   / \</span><br><span class="line">  <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></span><br><span class="line"> /  \    / \</span><br><span class="line"><span class="number">7</span>    <span class="number">2</span>  <span class="number">5</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure><p>返回:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [<span class="number">5</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>],</span><br><span class="line">   [<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>在递归返回上一层的时候要删去最后一个加入的节点，这样是否就可以认为是址传递呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    helper(root,sum,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum,List&lt;Integer&gt; ss)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || sum &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//List&lt;Integer&gt; ss = new ArrayList&lt;&gt;(s);</span></span><br><span class="line">    ss.add(root.val);</span><br><span class="line">    sum -= root.val;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == <span class="number">0</span>)</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(ss));</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; sum &gt; <span class="number">0</span>)</span><br><span class="line">        helper(root.left,sum,ss);</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span> &amp;&amp; sum &gt; <span class="number">0</span>)</span><br><span class="line">        helper(root.right,sum,ss);</span><br><span class="line">    ss.remove(ss.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第113题路径总和II&lt;/p&gt;
&lt;p&gt;给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="递归" scheme="http://yorxika.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>printf缓冲区问题</title>
    <link href="http://yorxika.github.io/2019/12/17/printf%E7%BC%93%E5%86%B2%E5%8C%BA%E9%97%AE%E9%A2%98/"/>
    <id>http://yorxika.github.io/2019/12/17/printf%E7%BC%93%E5%86%B2%E5%8C%BA%E9%97%AE%E9%A2%98/</id>
    <published>2019-12-17T06:11:20.000Z</published>
    <updated>2019-12-17T11:15:18.380Z</updated>
    
    <content type="html"><![CDATA[<p>这里就要区分一下标准库函数和系统调用了。</p><p> 系统调用是内核提供给上层程序的接口，能够实现内核和上层之间的交互，系统调用在内核中的实现是软中断的方式，通过相应的中断服务例程来实现，<a id="more"></a>而标准库函数是在系统调用的基础之上封装的应用程序，完全运行在用户态，在必要的时候调用系统调用。编写应用程序可以直接使用应用程序也可以使用库函数，那为什么还要有库函数呢。</p><p> 以printf为例，在printf的实现中，在调用write之前加入了IO缓冲区，这是一个用户空间的缓冲，首先要说明一点，系统调用是软中断，频繁调用，需要内核频繁陷入内核态，这样的效率不是很高，而printf实际是向用户空间的IO缓冲写，在满足条件的情况下（条件下面会说）才会调用write系统调用，这样也就提高了内核的效率。</p><p>  对于普通的文件操作，库函数因为IO缓冲区，效率高，其他方面与直接调用系统调用无异，但是对于一些特殊的文件，如串口终端以及网络设备。对于应用程序来将，我们更加希望的是每次的操作能够真真正正的反映在底层的硬件上，这时我们最好就不要使用类似与printf这样的带IO缓冲区的标准库函数了，而是直接使用系统调用，我上面就是犯了这个错误。</p><p>  说完标准库函数和系统调用的区别，我们就要具体的分析一下printf。</p><p>  printf是一个行缓冲函数，先写到缓冲区，满足条件后，才将缓冲区刷到对应文件中，刷缓冲区的条件如下：</p><p>  1 缓冲区填满</p><p>  2 写入的字符中有‘\n’ ‘\r’</p><p>  3 调用fflush手动刷新缓冲区</p><p>  4 调用scanf要从缓冲区中读取数据时，也会将缓冲区内的数据刷新</p><p> 满足上面4个条件之一缓冲区就会刷新，也就是printf会真正调用write来写入</p><p>  当我们执行printf的进程或者线程结束的时候会主动调用flush来刷新缓冲区，所以程序结束，也会刷新</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里就要区分一下标准库函数和系统调用了。&lt;/p&gt;
&lt;p&gt; 系统调用是内核提供给上层程序的接口，能够实现内核和上层之间的交互，系统调用在内核中的实现是软中断的方式，通过相应的中断服务例程来实现，&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yorxika.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://yorxika.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Crossing River</title>
    <link href="http://yorxika.github.io/2019/12/14/Crossing-River/"/>
    <id>http://yorxika.github.io/2019/12/14/Crossing-River/</id>
    <published>2019-12-14T15:56:22.000Z</published>
    <updated>2019-12-14T16:01:05.906Z</updated>
    
    <content type="html"><![CDATA[<p>来源POJ第1700题Crossing River</p><p><strong>Description</strong></p><p>A group of N people wishes to go across a river with only one boat, which can at most carry two persons. Therefore some sort of shuttle arrangement must be arranged in order to row the boat back and forth so that all people may cross.<a id="more"></a> Each person has a different rowing speed; the speed of a couple is determined by the speed of the slower one. Your job is to determine a strategy that minimizes the time for these people to get across.</p><p><strong>Input</strong></p><p>The first line of the input contains a single integer T (1 &lt;= T &lt;= 20), the number of test cases. Then T cases follow. The first line of each case contains N, and the second line contains N integers giving the time for each people to cross the river. Each case is preceded by a blank line. There won’t be more than 1000 people and nobody takes more than 100 seconds to cross.</p><p><strong>Output</strong></p><p>For each test case, print a line containing the total number of seconds required for all the N people to cross the river.</p><p>Sample Input</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">5</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><p>思路比较简单，分情况讨论，1个人过河，时长取最短的，2个人，时长取nums[1]，3个人取nums[0] + nums[1] + nums[2],当人数增加到4个人以上时要讨论，最快的(即所用时间nums[0])和次快的过河,然后最快的将船划回来,再次慢的和最慢的过河,然后次快的将船划回来.即所需时间为:nums[0]+2<em>nums[1]+nums[n-1],最快的和最慢的过河,然后最快的将船划回来,再最快的和次慢的过河,然后最快的将船划回来.即所需时间为:2</em>nums[0]+nums[n-2]+nums[n-1]这样就将过河所需时间最大的两个人送过了河,而对于剩下的人,采用同样的处理方式,接下来做的就是判断怎样用的时间最少.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public static int[] nums;</span></span><br><span class="line"><span class="comment">//public static long mid;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> all = in.nextInt(), len, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (all &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">len = in.nextInt();</span><br><span class="line"><span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">nums[i] = in.nextInt();</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="keyword">int</span> times = len;</span><br><span class="line"><span class="keyword">while</span>(times &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (times == <span class="number">1</span>) &#123;  <span class="comment">//特殊情况1</span></span><br><span class="line">ans += nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (times == <span class="number">2</span>) &#123;  <span class="comment">//特殊情况2</span></span><br><span class="line">ans += nums[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (times == <span class="number">3</span>) &#123;  <span class="comment">//特殊情况3</span></span><br><span class="line"><span class="comment">//0 2 过河，0回来，0 1 过河</span></span><br><span class="line">ans += nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ans += Math.min(<span class="number">2</span> * nums[<span class="number">1</span>] + nums[<span class="number">0</span>] + nums[times - <span class="number">1</span>], nums[times - <span class="number">1</span>] + <span class="number">2</span> * nums[<span class="number">0</span>] + nums[times - <span class="number">2</span>]);</span><br><span class="line">times -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(ans);</span><br><span class="line">all--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源POJ第1700题Crossing River&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A group of N people wishes to go across a river with only one boat, which can at most carry two persons. Therefore some sort of shuttle arrangement must be arranged in order to row the boat back and forth so that all people may cross.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="POJ" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/POJ/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/POJ/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="POJ" scheme="http://yorxika.github.io/tags/POJ/"/>
    
      <category term="贪心" scheme="http://yorxika.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>Median</title>
    <link href="http://yorxika.github.io/2019/12/14/Median/"/>
    <id>http://yorxika.github.io/2019/12/14/Median/</id>
    <published>2019-12-14T15:48:11.000Z</published>
    <updated>2019-12-14T15:55:55.520Z</updated>
    
    <content type="html"><![CDATA[<p>来源POJ第3579题Median</p><p><strong>Description</strong></p><p>Given <em>N</em> numbers, <em>X</em>1, <em>X</em>2, … , <em>XN</em>, let us calculate the difference of every pair of numbers: ∣<em>Xi</em> - <em>Xj*∣ (1 ≤ *i</em> ＜ <em>j</em> ≤ <em>N</em>). We can get <em>C(N,2)</em> differences through this work, <a id="more"></a>and now your task is to find the median of the differences as quickly as you can!</p><p>Note in this problem, the median is defined as the <em>(m/2)-th</em> smallest number if <em>m</em>,the amount of the differences, is even. For example, you have to find the third smallest one in the case of <em>m</em> = 6.</p><p><strong>Input</strong></p><p>The input consists of several test cases.<br>In each test case, <em>N</em> will be given in the first line. Then <em>N</em> numbers are given, representing <em>X</em>1, <em>X</em>2, … , <em>XN</em>, ( <em>Xi</em> ≤ 1,000,000,000 3 ≤ N ≤ 1,00,000 )</p><p><strong>Output</strong></p><p>For each test case, output the median in a separate line.</p><p><strong>Sample Input</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">10</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p>一共有n*(n-1)/2种不同的配对，一一枚举的时间复杂度为O(n^2)，显然无法在1s内给出答案。在此使用二分法，先将数组排序，然后我们可以确定最大的距离为Xn-X1，那么我们只需要在0~|Xn-X1|，这些数之间寻找中位数即可。</p><p>  一共需要两次二分。第一次二分，是用来寻找（猜测）可能的中位数的大小，当我们选择了一个mid值，我们需要计算有多少组配对的距离是小于这个mid值，如果不到k/2，则需要增加mid值，反之亦然；第二次二分用于对特定的元素计算小于mid的距离点对有多少个。</p><p>  需要注意的是，在发现小于mid的点对刚好是一半的时候，并不能说明mid就是中位数，我们一定要找到满足这一性质最小的mid，才是最终的答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] nums;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> Mid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">n = in.nextInt();</span><br><span class="line">Mid = ((<span class="keyword">long</span>) n * (n - <span class="number">1</span>)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">Mid = (Mid + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">//中位数的位置</span></span><br><span class="line">nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">nums[i] = in.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="keyword">int</span> left = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right = nums[n - <span class="number">1</span>] - nums[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (right - left &gt; <span class="number">1</span>) &#123;<span class="comment">//二分搜索</span></span><br><span class="line"><span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (test(mid,n)) &#123;</span><br><span class="line">right = mid;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">left = mid;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> mid, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (nums[i] - nums[j] &gt; mid)</span><br><span class="line">j++;</span><br><span class="line">count += (i - j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count &gt;= Mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源POJ第3579题Median&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given &lt;em&gt;N&lt;/em&gt; numbers, &lt;em&gt;X&lt;/em&gt;1, &lt;em&gt;X&lt;/em&gt;2, … , &lt;em&gt;XN&lt;/em&gt;, let us calculate the difference of every pair of numbers: ∣&lt;em&gt;Xi&lt;/em&gt; - &lt;em&gt;Xj*∣ (1 ≤ *i&lt;/em&gt; ＜ &lt;em&gt;j&lt;/em&gt; ≤ &lt;em&gt;N&lt;/em&gt;). We can get &lt;em&gt;C(N,2)&lt;/em&gt; differences through this work,&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="POJ" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/POJ/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/POJ/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="POJ" scheme="http://yorxika.github.io/tags/POJ/"/>
    
      <category term="二分" scheme="http://yorxika.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="中位数" scheme="http://yorxika.github.io/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>路径总和</title>
    <link href="http://yorxika.github.io/2019/12/14/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <id>http://yorxika.github.io/2019/12/14/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</id>
    <published>2019-12-14T15:37:24.000Z</published>
    <updated>2019-12-14T15:44:42.173Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第112题路径总和</p><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><a id="more"></a><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">5</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">4</span>   <span class="number">8</span></span><br><span class="line">   /   / \</span><br><span class="line">  <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></span><br><span class="line"> /  \      \</span><br><span class="line"><span class="number">7</span>    <span class="number">2</span>      <span class="number">1</span></span><br></pre></td></tr></table></figure><p>返回 <code>true</code>, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>利用两个栈分别保存到当前叶子节点走过的路径和总和，最后比对出栈换向.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; tree = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; val = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode tmp = root;</span><br><span class="line">    <span class="keyword">int</span> tmp_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tmp != <span class="keyword">null</span> || !tree.empty())&#123;</span><br><span class="line">        <span class="comment">//遍历完左子树</span></span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            tree.push(tmp);</span><br><span class="line">            tmp_sum += tmp.val;</span><br><span class="line">            val.push(tmp_sum);</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = tree.pop();</span><br><span class="line">        tmp_sum = val.pop();</span><br><span class="line">        <span class="comment">//依次遍历值</span></span><br><span class="line">        <span class="keyword">if</span>(tmp_sum == sum &amp;&amp; tmp.left == <span class="keyword">null</span> &amp;&amp; tmp.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//更改方向到右子树</span></span><br><span class="line">        tmp = tmp.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归来源于<a href="https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-leetcode/" target="_blank" rel="noopener">题解</a></p><p>最直接的方法就是利用递归，遍历整棵树：如果当前节点不是叶子，对它的所有孩子节点，递归调用 <code>hasPathSum</code> 函数，其中 sum 值减去当前节点的权值；如果当前节点是叶子，检查 sum 值是否为 0，也就是是否找到了给定的目标和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  sum -= root.val;</span><br><span class="line">  <span class="keyword">if</span> ((root.left == <span class="keyword">null</span>) &amp;&amp; (root.right == <span class="keyword">null</span>))</span><br><span class="line">    <span class="keyword">return</span> (sum == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> hasPathSum(root.left, sum) || hasPathSum(root.right, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自Leetcode第112题路径总和&lt;/p&gt;
&lt;p&gt;给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="栈" scheme="http://yorxika.github.io/tags/%E6%A0%88/"/>
    
      <category term="深度优先搜索" scheme="http://yorxika.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>SOLDIERS</title>
    <link href="http://yorxika.github.io/2019/12/14/SOLDIERS/"/>
    <id>http://yorxika.github.io/2019/12/14/SOLDIERS/</id>
    <published>2019-12-14T11:43:49.000Z</published>
    <updated>2019-12-14T11:51:43.287Z</updated>
    
    <content type="html"><![CDATA[<p>来源POJ第1723题SOLDIERS</p><p><strong>Description</strong></p><p>N soldiers of the land Gridland are randomly scattered around the country.<br>A position in Gridland is given by a pair (x,y) of integer coordinates.<a id="more"></a> Soldiers can move - in one move, one soldier can go one unit up, down, left or right (hence, he can change either his x or his y coordinate by 1 or -1).</p><p>The soldiers want to get into a horizontal line next to each other (so that their final positions are (x,y), (x+1,y), …, (x+N-1,y), for some x and y). Integers x and y, as well as the final order of soldiers along the horizontal line is arbitrary.</p><p>The goal is to minimise the total number of moves of all the soldiers that takes them into such configuration.</p><p>Two or more soldiers must never occupy the same position at the same time.</p><p><strong>Input</strong></p><p>The first line of the input contains the integer N, 1 &lt;= N &lt;= 10000, the number of soldiers.<br>The following N lines of the input contain initial positions of the soldiers : for each i, 1 &lt;= i &lt;= N, the (i+1)st line of the input file contains a pair of integers x[i] and y[i] separated by a single blank character, representing the coordinates of the ith soldier, -10000 &lt;= x[i],y[i] &lt;= 10000.</p><p><strong>Output</strong></p><p>The first and the only line of the output should contain the minimum total number of moves that takes the soldiers into a horizontal line next to each other.</p><p><strong>Sample Input</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span>-<span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p>其实本题求的是距离，反映到数学上，就是求两点之间的绝对值吗。</p><p>对于一个数列，其各点到此数列的中位数处的距离之和是最短的。</p><p>因此，分别对两个数列进行排序对于纵坐标，直接求出各点到中位数处的距离即可。对于横坐标，首先先将其排序后减去自身的位置，即x[i] - i,这是因为最终要求是在同一横排上，因而当x[i] - i，一样的时候，说明他们本身就是相邻的，最后通过构建出的x[i]-i数组，取中位数d[mid]-d[i]求和即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> len = in.nextInt();</span><br><span class="line"><span class="keyword">int</span> [] dx = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"><span class="keyword">int</span> [] dy = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">dx[i] = in.nextInt();</span><br><span class="line">dy[i] = in.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(dx);</span><br><span class="line">Arrays.sort(dy);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len ; i++)</span><br><span class="line">dx[i - <span class="number">1</span>] -= i;</span><br><span class="line">Arrays.sort(dx);</span><br><span class="line"><span class="keyword">int</span> midx = dx[(len) / <span class="number">2</span> ];</span><br><span class="line"><span class="keyword">int</span> midy = dy[(len) / <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">ans += Math.abs(midx - dx[i]) + Math.abs(midy - dy[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源POJ第1723题SOLDIERS&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;N soldiers of the land Gridland are randomly scattered around the country.&lt;br&gt;A position in Gridland is given by a pair (x,y) of integer coordinates.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="POJ" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/POJ/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/POJ/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="POJ" scheme="http://yorxika.github.io/tags/POJ/"/>
    
      <category term="中位数" scheme="http://yorxika.github.io/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Sacrament of the sum</title>
    <link href="http://yorxika.github.io/2019/12/14/Sacrament-of-the-sum/"/>
    <id>http://yorxika.github.io/2019/12/14/Sacrament-of-the-sum/</id>
    <published>2019-12-14T11:23:33.000Z</published>
    <updated>2019-12-14T11:42:29.754Z</updated>
    
    <content type="html"><![CDATA[<p>来源POJ第2366题Sacrament of the sum</p><p><strong>Description</strong></p><p>— The Brother of mine, the Head of Monastic Order wants to know tomorrow about the results long-term researches. He wants to see neither more nor less than the <a id="more"></a>Summering Machine! Even moreover, he wants our Machine — only a machine — to demonstrate its comprehension of the Sacrament of the Sum as deeply as it is possible. He wants our Machine to find two numbers that give the sum equal to the Sacred Number 10 000.<br>— Tsh-sh-sh! This is madness that borders on blasphemy! How can the Machine calculate the Sacred Number? Twenty seven years we work on it, but we’ve could teach it to tell if the sum of two introduced numbers greater or lower than 10 000. Can an ordinary mortal find two numbers that there sum will be equal to 10 000?<br>— But we’ll have to do it with the help of our Machine, even if it is not capable. Otherwise we’ll have… let’s say, big problems, if it is possible to call boiling oil like this. However, I have an idea. Do you remember, last week we’ve entered two numbers -7 and 13 into the Machine, and it answered that their sum is lower than 10 000. I don’t know how to check this, but nothing’s left for us than to believe to the fruit of our work. Let’s enter now a greater number than -7 and start up the Machine again. We’ll do like this again and again until we find a number that being added to 13 will give us 10 000. The only thing we are to do is to prepare an ascending list of numbers.<br>— I don’t believe in this… Let’s start with the sum that is obviously greater than the Sacred Number and we’ll decrease one of the summand. So we have more chances to avoid boilin… big problems.</p><p>Haven’t come to an agreement, the Brothers went away to their cells. By next day everyone of them has prepared a list of numbers that, to his opinion, could save them… Can both of the lists save them together?<br>Your program should decide, if it is possible to choose from two lists of integers such two numbers that their sum would be equal to 10 000.</p><p><strong>Input</strong></p><p>You are given both of these lists one by one. Format of each of these lists is as follows: in the first line of the list the quantity of numbers Ni of the i-th list is written. Further there is an i-th list of numbers each number in its line (Ni lines).The following conditions are satisfied: 1 &lt;= Ni &lt;= 50 000, each element of the lists lays in the range from -32768 to 32767. The first list is ascending and the second one is descending.</p><p><strong>Output</strong></p><p>You should write “YES” to the standard output if it is possible to choose from the two lists of integers such two numbers that their sum would be equal to 10 000. Otherwise you should write “NO”.</p><p><strong>Sample Input</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">-175</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">10424</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">8951</span></span><br><span class="line"><span class="number">-424</span></span><br><span class="line"><span class="number">-788</span></span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">YES</span></span><br></pre></td></tr></table></figure><p><strong>Hint</strong></p><p>This problem has huge input data,use scanf() instead of cin to read data to avoid time limit exceed.</p><h3 id="空间换时间"><a href="#空间换时间" class="headerlink" title="空间换时间"></a>空间换时间</h3><p>由题目可知数据大小再-32768到32768之间，因而可以直接利用大数组来存输入的数据，输入的输入如果大于0，放在第一个数组对应的A[in]位置，否则放在B[-in]，输入第二个数组的值时，先求出1000-in的值，如果大于0且A[10000-in]的值存在，说明找到了，或者B[in - 10000]存在，否则继续输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">int</span> len1 = in.nextInt();</span><br><span class="line"><span class="keyword">int</span> [] A = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">65535</span>];</span><br><span class="line"><span class="keyword">int</span> [] B = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">65535</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">temp = in.nextInt();  <span class="comment">//数组A升序</span></span><br><span class="line"><span class="keyword">if</span>(temp &gt;= <span class="number">0</span>)</span><br><span class="line">A[temp] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">B[-temp] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len2 = in.nextInt();</span><br><span class="line"><span class="keyword">if</span>(len1 &lt;= <span class="number">0</span> || len2 &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"NO"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len2;i++) &#123;</span><br><span class="line">temp = in.nextInt();  <span class="comment">//数组B降序</span></span><br><span class="line">temp = <span class="number">10000</span> - temp;</span><br><span class="line"><span class="keyword">if</span>(temp &gt;= <span class="number">0</span> &amp;&amp; A[temp] == <span class="number">1</span>)&#123;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(temp &lt; <span class="number">0</span> &amp;&amp; B[-temp] == <span class="number">1</span>)&#123;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">System.out.println(<span class="string">"YES"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.println(<span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希Map"><a href="#哈希Map" class="headerlink" title="哈希Map"></a>哈希Map</h3><p>利用一个Map存放输入的值，和对应的数组标志，在数组B边输入时边查询即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> len1 = in.nextInt();</span><br><span class="line"><span class="keyword">int</span>[] A = <span class="keyword">new</span> <span class="keyword">int</span>[len1];</span><br><span class="line">Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">A[i] = in.nextInt();  <span class="comment">//数组A升序</span></span><br><span class="line">map.put(A[i],<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len2 = in.nextInt();</span><br><span class="line"><span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">65535</span>];</span><br><span class="line"><span class="comment">//Arrays.setAll(B,a -&gt; -2147483647);</span></span><br><span class="line"><span class="keyword">if</span> (len1 &lt;= <span class="number">0</span> || len2 &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"NO"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2 ; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> complement;</span><br><span class="line">B[i] = in.nextInt();</span><br><span class="line"><span class="comment">//key = 1;</span></span><br><span class="line">complement = <span class="number">10000</span> - B[i];</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(complement) &amp;&amp; (map.get(complement) == <span class="number">0</span>))&#123;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">map.put(B[i],<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">System.out.println(<span class="string">"YES"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.println(<span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>思路同上，对输入数组B的每一个数在数组A里进行二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> len1 = in.nextInt();</span><br><span class="line"><span class="keyword">int</span> [] A = <span class="keyword">new</span> <span class="keyword">int</span>[len1];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">A[i] = in.nextInt();  <span class="comment">//数组A升序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len2 = in.nextInt();</span><br><span class="line"><span class="keyword">if</span>(len1 &lt;= <span class="number">0</span> || len2 &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"NO"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp,left,right,mid,complement;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; len2 ; j++) &#123;</span><br><span class="line">temp = in.nextInt();</span><br><span class="line">complement = <span class="number">10000</span> - temp;</span><br><span class="line"><span class="comment">//对数组a中的每个元素进行二分搜索</span></span><br><span class="line">left = <span class="number">0</span>;</span><br><span class="line">right = len1 - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (complement == A[mid]) &#123;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (complement &lt; A[mid]) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">System.out.println(<span class="string">"YES"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.println(<span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源POJ第2366题Sacrament of the sum&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;— The Brother of mine, the Head of Monastic Order wants to know tomorrow about the results long-term researches. He wants to see neither more nor less than the&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="POJ" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/POJ/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/POJ/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="POJ" scheme="http://yorxika.github.io/tags/POJ/"/>
    
      <category term="哈希" scheme="http://yorxika.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
      <category term="二分" scheme="http://yorxika.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Matrix Power Series</title>
    <link href="http://yorxika.github.io/2019/12/14/Matrix-Power-Series/"/>
    <id>http://yorxika.github.io/2019/12/14/Matrix-Power-Series/</id>
    <published>2019-12-14T11:18:48.000Z</published>
    <updated>2019-12-14T11:29:44.832Z</updated>
    
    <content type="html"><![CDATA[<p>来源POJ第3233题Matrix Power Series</p><p><strong>Description</strong></p><p>Given a <em>n</em> × <em>n</em> matrix <em>A</em> and a positive integer <em>k</em>, find the sum <em>S</em> = <em>A</em> + <em>A</em>2 + <em>A</em>3 + … + <em>Ak</em>.</p><a id="more"></a><p><strong>Input</strong></p><p>The input contains exactly one test case. The first line of input contains three positive integers <em>n</em> (<em>n</em> ≤ 30), <em>k</em> (<em>k</em> ≤ 109) and <em>m</em> (<em>m</em> &lt; 104). Then follow <em>n</em> lines each containing <em>n</em> nonnegative integers below 32,768, giving <em>A</em>’s elements in row-major order.</p><p><strong>Output</strong></p><p>Output the elements of <em>S</em> modulo <em>m</em> in the same way as <em>A</em> is given.</p><p><strong>Sample Input</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">2 </span><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br></pre></td></tr></table></figure><p>题目要求的是 A+A2+…+Ak，而不是单个矩阵的幂</p><p>　　那么我们可以构造一个分块的辅助矩阵 S，其中 A 为原矩阵，E 为单位矩阵，O 为0矩阵</p><p>　　<img src="/2019/12/14/Matrix-Power-Series/999549-20160924161629731-1694213740.png" alt="img"></p><p>　　我们将 S 取幂，会发现一个特性</p><p>　　<img src="/2019/12/14/Matrix-Power-Series/999549-20160924162453731-374268381.png" alt="img"></p><p>　　Sk 右上角那一块不正是我们要求的 A+A2+…+Ak 吗？</p><p>　　于是我们构造出 S 矩阵，然后对它求矩阵快速幂即可，最后别忘了减去一个单位阵</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">n = in.nextInt();  <span class="comment">//n阶矩阵</span></span><br><span class="line"><span class="keyword">int</span> k = in.nextInt();  <span class="comment">//k次幂</span></span><br><span class="line"><span class="keyword">int</span> m = in.nextInt();  <span class="comment">//mod m</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> [][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*n][<span class="number">2</span>*n];</span><br><span class="line"><span class="keyword">int</span> [][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">matrix[i][j] = in.nextInt();</span><br><span class="line"><span class="comment">//ans[i][j] = matrix[i][j] % m;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造右边的单位矩阵</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = n ; j &lt; <span class="number">2</span>*n; j++)</span><br><span class="line"><span class="keyword">if</span>(j - i == n)</span><br><span class="line">matrix[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//构造右下方单位矩阵</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; <span class="number">2</span>*n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = n ; j &lt; <span class="number">2</span>*n ; j++)</span><br><span class="line"><span class="keyword">if</span>(i == j)</span><br><span class="line">matrix[i][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">matrix = pow(matrix,k + <span class="number">1</span>,m);</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减去一个单位矩阵</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &lt; <span class="number">2</span>*n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(j - i == n)</span><br><span class="line">matrix[i][j] = (matrix[i][j] - <span class="number">1</span> + m) % m;</span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">2</span>*n - <span class="number">1</span>)</span><br><span class="line">System.out.println(matrix[i][j]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.print(matrix[i][j] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵乘法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] matrixMul(<span class="keyword">int</span> [][] a, <span class="keyword">int</span> [][]b,<span class="keyword">int</span> mod)&#123;</span><br><span class="line"><span class="keyword">int</span> [][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[a.length][a.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; n ; k++)&#123;</span><br><span class="line">ans[i][j] += a[i][k] * b[k][j];</span><br><span class="line">ans[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵加法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> [][]a,<span class="keyword">int</span> [][]b,<span class="keyword">int</span> mod)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; a.length ; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; a.length ; j++)&#123;</span><br><span class="line">a[i][j] += b[i][j];</span><br><span class="line">a[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵快速幂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] pow(<span class="keyword">int</span> [][] a,<span class="keyword">int</span> n,<span class="keyword">int</span> mod)&#123;</span><br><span class="line"><span class="keyword">int</span> [][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[a.length][a.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; a.length / <span class="number">2</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; a.length / <span class="number">2</span>; j++)</span><br><span class="line"><span class="keyword">if</span>(i == j)</span><br><span class="line">ans[i][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">ans = matrixMul(ans,a,mod);</span><br><span class="line">a = matrixMul(a,a,mod);</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源POJ第3233题Matrix Power Series&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given a &lt;em&gt;n&lt;/em&gt; × &lt;em&gt;n&lt;/em&gt; matrix &lt;em&gt;A&lt;/em&gt; and a positive integer &lt;em&gt;k&lt;/em&gt;, find the sum &lt;em&gt;S&lt;/em&gt; = &lt;em&gt;A&lt;/em&gt; + &lt;em&gt;A&lt;/em&gt;2 + &lt;em&gt;A&lt;/em&gt;3 + … + &lt;em&gt;Ak&lt;/em&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="POJ" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/POJ/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/POJ/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="POJ" scheme="http://yorxika.github.io/tags/POJ/"/>
    
      <category term="快速幂" scheme="http://yorxika.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>Babelfish</title>
    <link href="http://yorxika.github.io/2019/12/14/Babelfish/"/>
    <id>http://yorxika.github.io/2019/12/14/Babelfish/</id>
    <published>2019-12-13T16:44:06.000Z</published>
    <updated>2019-12-13T16:48:51.120Z</updated>
    
    <content type="html"><![CDATA[<p>来源POJ第2503题</p><p><strong>Description</strong></p><p>You have just moved from Waterloo to a big city. The people here speak an incomprehensible dialect of a foreign language. Fortunately, <a id="more"></a>you have a dictionary to help you understand them.</p><p><strong>Input</strong></p><p>Input consists of up to 100,000 dictionary entries, followed by a blank line, followed by a message of up to 100,000 words. Each dictionary entry is a line containing an English word, followed by a space and a foreign language word. No foreign word appears more than once in the dictionary. The message is a sequence of words in the foreign language, one word on each line. Each word in the input is a sequence of at most 10 lowercase letters.</p><p><strong>Output</strong></p><p>Output is the message translated to English, one word per line. Foreign words not in the dictionary should be translated as “eh”.</p><p><strong>Sample Input</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dog</span> <span class="string">ogday</span></span><br><span class="line"><span class="attr">cat</span> <span class="string">atcay</span></span><br><span class="line"><span class="attr">pig</span> <span class="string">igpay</span></span><br><span class="line"><span class="attr">froot</span> <span class="string">ootfray</span></span><br><span class="line"><span class="attr">loops</span> <span class="string">oopslay</span></span><br><span class="line"></span><br><span class="line"><span class="attr">atcay</span></span><br><span class="line"><span class="attr">ittenkay</span></span><br><span class="line"><span class="attr">oopslay</span></span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cat</span></span><br><span class="line"><span class="attribute">eh</span></span><br><span class="line"><span class="attribute">loops</span></span><br></pre></td></tr></table></figure><p><strong>Hint</strong></p><p>Huge input and output,scanf and printf are recommended.</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>提示方案上说可用二分查找啥的，但是懒人直接当HashMap水题，直接过了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String input;</span><br><span class="line">String key,value;</span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">while</span> (!(input = in.nextLine()).equals(<span class="string">""</span>))&#123;</span><br><span class="line">index = input.indexOf(<span class="string">' '</span>);</span><br><span class="line">key = input.substring(<span class="number">0</span>,index);</span><br><span class="line">value = input.substring(index + <span class="number">1</span>,input.length());</span><br><span class="line">map.put(value,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!(input = in.nextLine()).equals(<span class="string">""</span>))&#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(input))&#123;</span><br><span class="line">System.out.println(map.get(input));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"eh"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源POJ第2503题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You have just moved from Waterloo to a big city. The people here speak an incomprehensible dialect of a foreign language. Fortunately,&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="POJ" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/POJ/"/>
    
      <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/POJ/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="POJ" scheme="http://yorxika.github.io/tags/POJ/"/>
    
      <category term="字符串" scheme="http://yorxika.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Flip Game</title>
    <link href="http://yorxika.github.io/2019/12/14/Flip-Game/"/>
    <id>http://yorxika.github.io/2019/12/14/Flip-Game/</id>
    <published>2019-12-13T16:20:25.000Z</published>
    <updated>2019-12-13T16:44:56.766Z</updated>
    
    <content type="html"><![CDATA[<p>来源POJ第1753题Flip Game</p><p><strong>Description</strong></p><p>Flip game is played on a rectangular 4x4 field with two-sided pieces placed on each of its 16 squares. One side of each piece is white and the other one is black and each piece is lying either it’s black or white side up. <a id="more"></a>Each round you flip 3 to 5 pieces, thus changing the color of their upper side from black to white and vice versa. The pieces to be flipped are chosen every round according to the following rules:</p><ol><li>Choose any one of the 16 pieces.</li><li>Flip the chosen piece and also all adjacent pieces to the left, to the right, to the top, and to the bottom of the chosen piece (if there are any).</li></ol><p><img src="/2019/12/14/Flip-Game/1753_1.jpg" alt="img">Consider the following position as an example:</p><p>bwbw<br>wwww<br>bbwb<br>bwwb<br>Here “b” denotes pieces lying their black side up and “w” denotes pieces lying their white side up. If we choose to flip the 1st piece from the 3rd row (this choice is shown at the picture), then the field will become:</p><p>bwbw<br>bwww<br>wwwb<br>wwwb<br>The goal of the game is to flip either all pieces white side up or all pieces black side up. You are to write a program that will search for the minimum number of rounds needed to achieve this goal.</p><p><strong>Input</strong></p><p>The input consists of 4 lines with 4 characters “w” or “b” each that denote game field position.</p><p><strong>Output</strong></p><p>Write to the output file a single integer number - the minimum number of rounds needed to achieve the goal of the game from the given position. If the goal is initially achieved, then write 0. If it’s impossible to achieve the goal, then write the word “Impossible” (without quotes).</p><p><strong>Sample Input</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bwwb</span></span><br><span class="line"><span class="keyword">bbwb</span></span><br><span class="line"><span class="keyword">bwwb</span></span><br><span class="line"><span class="keyword">bwww</span></span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>递归遍历所有情况，即从当前点出发，翻还是不翻，然后进入下一层递归，直到满足条件为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> [][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> first = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span> ;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(matrix[i][j] != first)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">matrix[x][y] = matrix[x][y] ^ <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">matrix[x - <span class="number">1</span>][y] ^= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(y - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">matrix[x][y - <span class="number">1</span>] ^= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x + <span class="number">1</span> &lt; <span class="number">4</span>)</span><br><span class="line">matrix[x + <span class="number">1</span>][y] ^= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(y + <span class="number">1</span> &lt; <span class="number">4</span>)</span><br><span class="line">matrix[x][y + <span class="number">1</span>] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> times)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(judge())&#123;</span><br><span class="line"><span class="keyword">if</span>(ans &gt; times)</span><br><span class="line">&#123;</span><br><span class="line">ans = times;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x &gt;= <span class="number">4</span> || y &gt;= <span class="number">4</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> aX,aY;</span><br><span class="line">aX = (x + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">aY = y + (x + <span class="number">1</span>) / <span class="number">4</span>;</span><br><span class="line">dfs(aX,aY,times);</span><br><span class="line">change(x, y);</span><br><span class="line">dfs(aX,aY,times + <span class="number">1</span>);</span><br><span class="line">change(x, y);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">temp = in.nextLine();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp.charAt(j) == <span class="string">'b'</span>) &#123;</span><br><span class="line">matrix[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义黑为1，白为0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ans == Integer.MAX_VALUE)</span><br><span class="line">System.out.println(<span class="string">"Impossible"</span>);</span><br><span class="line"><span class="keyword">else</span> System.out.println(ans);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="BFS-位压缩"><a href="#BFS-位压缩" class="headerlink" title="BFS+位压缩"></a>BFS+位压缩</h3><p>来源于<a href="https://blog.csdn.net/hackbuteer1/article/details/7392245" target="_blank" rel="noopener">blog</a></p><p>主要思想：</p><p>1、如果用一个4*4的数组存储每一种状态，不但存储空间很大，而且在穷举状态时也不方便记录。因为每一颗棋子都只有两种状态，所以可以用二进制0和1表示每一个棋子的状态，则棋盘的状态就可以用一个16位的整数唯一标识。而翻转的操作也可以通过通过位操作来完成。显然当棋盘状态id为0（全白）或65535（全黑）时，游戏结束。</p><p>2、对于棋盘的每一个状态，都有十六种操作，首先要判断这十六种操作之后是否有完成的情况，如果没有，则再对这十六种操作的结果分别再进行上述操作，显然这里就要用到队列来存储了。而且在翻转的过程中有可能会回到之前的某种状态，而这种重复的状态是不应该再次入队的，所以维护 Visit[i]数组来判断 id==i 的状态之前是否已经出现过，如果不是才将其入队。如果游戏无法完成，状态必定会形成循环，由于重复状态不会再次入队，所以最后的队列一定会是空队列。</p><p>3、由于0^1=1，1^1=0，所以翻转的操作可以通过异或操作来完成，而翻转的位置可以通过移位来确定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">int</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">65536</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> change[<span class="number">16</span>] =   <span class="comment">//16种状态转换，对应4*4的翻子位置</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="number">51200</span>,<span class="number">58368</span>,<span class="number">29184</span>,<span class="number">12544</span>,</span><br><span class="line">     <span class="number">35968</span>,<span class="number">20032</span>,<span class="number">10016</span>,<span class="number">4880</span>,</span><br><span class="line"> <span class="number">2248</span>,<span class="number">1252</span>,<span class="number">626</span>,<span class="number">305</span>,</span><br><span class="line"> <span class="number">140</span>,<span class="number">78</span>,<span class="number">39</span>,<span class="number">19</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">memset</span>(visit,<span class="literal">false</span>,<span class="keyword">sizeof</span>(visit));    <span class="comment">//标记每一个状态都未访问过</span></span><br><span class="line"><span class="built_in">queue</span>&lt;Node&gt;q;</span><br><span class="line">Node cur,next;</span><br><span class="line">cur.state = state;</span><br><span class="line">cur.step = <span class="number">0</span>;</span><br><span class="line">q.push(cur);</span><br><span class="line">visit[state] = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">cur = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span>(cur.state == <span class="number">0</span> || cur.state == <span class="number">0xffff</span>)   <span class="comment">//65535</span></span><br><span class="line"><span class="keyword">return</span> cur.step;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">next.state = cur.state^change[i];</span><br><span class="line">next.step = cur.step + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(visit[next.state])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(next.state == <span class="number">0</span> || next.state == <span class="number">0xffff</span>)   <span class="comment">//65535</span></span><br><span class="line"><span class="keyword">return</span> next.step;</span><br><span class="line">visit[next.state] = <span class="literal">true</span>;</span><br><span class="line">q.push(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,state,ans;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,ch[<span class="number">0</span>])!=EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; <span class="number">4</span> ; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,ch[i]);</span><br><span class="line">state = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//初始化棋盘状态</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; <span class="number">4</span> ; ++j)</span><br><span class="line">&#123;</span><br><span class="line">state &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(ch[i][j] == <span class="string">'b'</span>)</span><br><span class="line">state += <span class="number">1</span>;</span><br><span class="line"><span class="comment">//state ^= (1&lt;&lt;((3-i)*4+(3-j)));</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = bfs(state);</span><br><span class="line"><span class="keyword">if</span>(ans == <span class="number">-1</span>)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Impossible"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代码二：DFS+Bit</span></span><br><span class="line"><span class="comment">本题由于要输出每次翻转的棋子，因此不适宜用BFS，应该使用DFS输出完整路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">int</span> chess;        <span class="comment">//棋盘状态</span></span><br><span class="line"> <span class="keyword">int</span> step;</span><br><span class="line"> <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"> <span class="keyword">int</span> ri[<span class="number">16</span>],cj[<span class="number">16</span>];</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">isopen</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(chess == <span class="number">0xFFFF</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span> bit)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     chess=chess^(<span class="number">0x1</span>&lt;&lt;bit);  <span class="comment">//对翻转位取反</span></span><br><span class="line">     <span class="keyword">int</span> row=bit/<span class="number">4</span>;</span><br><span class="line">     <span class="keyword">int</span> col=bit%<span class="number">4</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">4</span>;c++)</span><br><span class="line">         chess=chess^(<span class="number">0x1</span>&lt;&lt;(row*<span class="number">4</span>+c));  <span class="comment">//对全行取反</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;<span class="number">4</span>;r++)</span><br><span class="line">         chess=chess^(<span class="number">0x1</span>&lt;&lt;(r*<span class="number">4</span>+col));  <span class="comment">//对全列取反</span></span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> bit,<span class="keyword">int</span> deep)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(deep==step)</span><br><span class="line">     &#123;</span><br><span class="line">         flag=isopen();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span>(flag || bit&gt;<span class="number">15</span>)</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">int</span> row=ri[deep]=bit/<span class="number">4</span>;</span><br><span class="line">     <span class="keyword">int</span> col=cj[deep]=bit%<span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">     flip(bit);</span><br><span class="line">     <span class="keyword">if</span>(col&lt;<span class="number">4</span>)</span><br><span class="line">         dfs(bit+<span class="number">1</span>,deep+<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         dfs((bit+<span class="number">4</span>)/<span class="number">4</span>*<span class="number">4</span>,deep+<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">     flip(bit);</span><br><span class="line">     <span class="keyword">if</span>(col&lt;<span class="number">4</span>)</span><br><span class="line">         dfs(bit+<span class="number">1</span>,deep);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         dfs((bit+<span class="number">4</span>)/<span class="number">4</span>*<span class="number">4</span>,deep);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> temp;</span><br><span class="line">     <span class="keyword">int</span> i,j;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">         <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">             <span class="keyword">if</span>(temp==<span class="string">'-'</span>)</span><br><span class="line">                 chess=chess^(<span class="number">1</span>&lt;&lt;(i*<span class="number">4</span>+j));</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/*DFS*/</span></span><br><span class="line">     <span class="keyword">for</span>(step=<span class="number">0</span>;step&lt;=<span class="number">16</span>;step++)</span><br><span class="line">     &#123;</span><br><span class="line">         dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">if</span>(flag)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,step);</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;step;i++)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ri[i]+<span class="number">1</span>,cj[i]+<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源POJ第1753题Flip Game&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Flip game is played on a rectangular 4x4 field with two-sided pieces placed on each of its 16 squares. One side of each piece is white and the other one is black and each piece is lying either it’s black or white side up.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="POJ" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/POJ/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/POJ/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="POJ" scheme="http://yorxika.github.io/tags/POJ/"/>
    
      <category term="DFS" scheme="http://yorxika.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>I Think I Need a Houseboat</title>
    <link href="http://yorxika.github.io/2019/12/14/I-Think-I-Need-a-Houseboat/"/>
    <id>http://yorxika.github.io/2019/12/14/I-Think-I-Need-a-Houseboat/</id>
    <published>2019-12-13T16:12:33.000Z</published>
    <updated>2019-12-13T16:19:03.860Z</updated>
    
    <content type="html"><![CDATA[<p>来源POJ第1005题</p><p><strong>Description</strong></p><p>Fred Mapper is considering purchasing some land in Louisiana to build his house on. In the process of investigating the land, he learned that the state of Louisiana is actually shrinking by 50 square miles each year,<a id="more"></a> due to erosion caused by the Mississippi River. Since Fred is hoping to live in this house the rest of his life, he needs to know if his land is going to be lost to erosion.</p><p>After doing more research, Fred has learned that the land that is being lost forms a semicircle. This semicircle is part of a circle centered at (0,0), with the line that bisects the circle being the X axis. Locations below the X axis are in the water. The semicircle has an area of 0 at the beginning of year 1. (Semicircle illustrated in the Figure.)</p><p><img src="/2019/12/14/I-Think-I-Need-a-Houseboat/semicircle.GIF" alt="img"></p><p><strong>Input</strong></p><p>The first line of input will be a positive integer indicating how many data sets will be included (N). Each of the next N lines will contain the X and Y Cartesian coordinates of the land Fred is considering. These will be floating point numbers measured in miles. The Y coordinate will be non-negative. (0,0) will not be given.</p><p><strong>Output</strong></p><p>For each data set, a single line of output should appear. This line should take the form of: “Property N: This property will begin eroding in year Z.” Where N is the data set (counting from 1), and Z is the first year (start from 1) this property will be within the semicircle AT THE END OF YEAR Z. Z must be an integer. After the last data set, this should print out “END OF OUTPUT.”</p><p><strong>Sample Input</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1.0</span> <span class="number">1.0</span></span><br><span class="line"><span class="number">25.0</span> <span class="number">0.0</span></span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Property</span><span class="title"> 1:</span> This <span class="keyword">property</span><span class="title"> </span>will begin eroding <span class="keyword">in</span> year <span class="number">1</span>.</span><br><span class="line"><span class="keyword">Property</span><span class="title"> 2:</span> This <span class="keyword">property</span><span class="title"> </span>will begin eroding <span class="keyword">in</span> year <span class="number">20</span>.</span><br><span class="line">END OF OUTPUT.</span><br></pre></td></tr></table></figure><p><strong>Hint</strong></p><p>1.No property will appear exactly on the semicircle boundary: it will either be inside or outside.<br>2.This problem will be judged automatically. Your answer must match exactly, including the capitalization, punctuation, and white-space. This includes the periods at the ends of the lines.<br>3.All locations are given in miles.</p><hr><p>水题一题，求目标点与原点构成的圆的面积与100之比即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> len = in.nextInt();</span><br><span class="line"><span class="keyword">float</span> years;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len ;i ++)&#123;</span><br><span class="line"><span class="keyword">float</span> a = in.nextFloat();</span><br><span class="line"><span class="keyword">float</span> b = in.nextFloat();</span><br><span class="line">years = (<span class="keyword">float</span>)(Math.PI)*(a*a + b*b)/<span class="number">100</span>;</span><br><span class="line">System.out.println(<span class="string">"Property "</span> + (i+<span class="number">1</span>) + <span class="string">": This property will begin eroding in year "</span> + (<span class="keyword">int</span>)(years + <span class="number">1</span>) + <span class="string">"."</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"END OF OUTPUT."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源POJ第1005题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Fred Mapper is considering purchasing some land in Louisiana to build his house on. In the process of investigating the land, he learned that the state of Louisiana is actually shrinking by 50 square miles each year,&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="POJ" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/POJ/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/POJ/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="POJ" scheme="http://yorxika.github.io/tags/POJ/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的最小深度</title>
    <link href="http://yorxika.github.io/2019/12/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
    <id>http://yorxika.github.io/2019/12/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</id>
    <published>2019-12-13T15:31:48.000Z</published>
    <updated>2019-12-13T16:11:25.335Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第111题二叉树的最小深度</p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><a id="more"></a><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回它的最小深度  2.</p><hr><h3 id="翻车现场"><a href="#翻车现场" class="headerlink" title="翻车现场"></a>翻车现场</h3><p>最开始以为是和最大深度那题差不多的，结果忽略了一种情况，即[1,2]这种根结点只有一个叶子结点的情况，这时最小深度应该是2，因为按题目定义根结点不能作为自己的叶结点，以下是初始代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> left_height = minDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right_height = minDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.min(left_height,right_height) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>根据上面的分析，知道要在递归里做判断，判断是否是叶子结点,然后再进行递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> minDepth = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">        minDepth = Math.min(minDepth,minDepth(root.left));</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">        minDepth = Math.min(minDepth,minDepth(root.right));</span><br><span class="line">    <span class="keyword">return</span> minDepth + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS迭代"><a href="#BFS迭代" class="headerlink" title="BFS迭代"></a>BFS迭代</h3><p>利用一个队列进行层次遍历，用一个 <code>level</code> 变量保存当前的深度,只要在 <code>for</code> 循环中判断当前是不是叶子节点，如果是的话，返回当前的 level 就可以了。此外要把<code>level</code>初始化改为<code>1</code>，因为如果只有一个根节点，它就是叶子节点，而在代码中，level 是在 <code>for</code>循环以后才<code>++</code>的，如果被提前结束的话，此时应该返回<code>1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> levelNum = queue.size();  <span class="comment">//当前层元素个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; levelNum ; i++)&#123;</span><br><span class="line">            TreeNode tmp = queue.poll();  <span class="comment">//队列首元素出队</span></span><br><span class="line">            <span class="keyword">if</span>(tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp.left == <span class="keyword">null</span> &amp;&amp; tmp.right == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> level;</span><br><span class="line">                <span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.offer(tmp.left);  <span class="comment">//节点入队尾</span></span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.offer(tmp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        level ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自Leetcode第111题二叉树的最小深度&lt;/p&gt;
&lt;p&gt;给定一个二叉树，找出其最小深度。&lt;/p&gt;
&lt;p&gt;最小深度是从根节点到最近叶子节点的最短路径上的节点数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="递归" scheme="http://yorxika.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>配置gitalk的坑</title>
    <link href="http://yorxika.github.io/2019/12/12/%E9%85%8D%E7%BD%AEgitalk%E7%9A%84%E5%9D%91/"/>
    <id>http://yorxika.github.io/2019/12/12/%E9%85%8D%E7%BD%AEgitalk%E7%9A%84%E5%9D%91/</id>
    <published>2019-12-12T14:36:25.000Z</published>
    <updated>2019-12-13T16:10:32.067Z</updated>
    
    <content type="html"><![CDATA[<p>今天在把主题从yilia迁移到next的时候，配置gitalk出现了坑，先是gitalk notfound，然后又是说issue过长，把解决办法mark一下。</p><p>先是配置gitalk的gitalk.swig</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.css"</span>&gt;</span><br><span class="line">  &lt;script src=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;script src=<span class="string">"https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;div id=<span class="string">"gitalk-container"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  </span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    var gitalk = new Gitalk(&#123;</span></span><br><span class="line"><span class="string">      clientID: '&#123;&#123; theme.gitalk.clientID &#125;&#125;',</span></span><br><span class="line"><span class="string">      clientSecret: '&#123;&#123; theme.gitalk.clientSecret &#125;&#125;',</span></span><br><span class="line"><span class="string">      repo: '&#123;&#123; theme.gitalk.repo &#125;&#125;',</span></span><br><span class="line"><span class="string">      owner: '&#123;&#123; theme.gitalk.owner &#125;&#125;',</span></span><br><span class="line"><span class="string">      admin: ['&#123;&#123; theme.gitalk.admin &#125;&#125;'],</span></span><br><span class="line"><span class="string">      id: md5(window.location.pathname),</span></span><br><span class="line"><span class="string">      distractionFreeMode: '&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;'</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">    gitalk.render('gitalk-container')</span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure><p>在网上找的配置或多或少有问题，折腾之后发现创建issue时会提示名称过长的问题，百度了解决办法是md5加密，但是会与之前创建的issue冲突，折腾了半天才想起来，直接照搬之前yilia里的gitalk即可，发现他的id直接就是md5加密好的，利用md5，不用担心名称过长的问题，并且利用之前的gitalk.swig，可以解决其他的问题，特此mark。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在把主题从yilia迁移到next的时候，配置gitalk出现了坑，先是gitalk notfound，然后又是说issue过长，把解决办法mark一下。&lt;/p&gt;
&lt;p&gt;先是配置gitalk的gitalk.swig&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yorxika.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://yorxika.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>重排链表</title>
    <link href="http://yorxika.github.io/2019/12/12/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <id>http://yorxika.github.io/2019/12/12/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</id>
    <published>2019-12-12T12:25:05.000Z</published>
    <updated>2019-12-12T13:39:53.660Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第143题重排链表</p><p>给定一个单链表 <em>L</em>：<em>L</em>0→<em>L</em>1→…→<em>L</em>n-1→<em>L</em>n ，<br>将其重新排列后变为： <em>L</em>0→<em>L</em>n→<em>L</em>1→<em>L</em>n-1→<em>L</em>2→<em>L</em>n-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定链表 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>, 重新排列为 <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3.</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定链表 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 重新排列为 <span class="number">1</span>-&gt;<span class="number">5</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3.</span></span><br></pre></td></tr></table></figure><h3 id="空间换时间"><a href="#空间换时间" class="headerlink" title="空间换时间"></a>空间换时间</h3><p>创建线性表，依次存储各个链表结点，然后用双指针依次取头尾元素，避免了每次从头遍历.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    List&lt;ListNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//保存结点</span></span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        list.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//头尾指针取元素</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span> , j = list.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        list.get(i).next = list.get(j);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">//偶数结点相遇</span></span><br><span class="line">        <span class="keyword">if</span>(i == j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        list.get(j).next = list.get(i);</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    list.get(i).next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>参考 <a href="https://leetcode.com/problems/reorder-list/discuss/45113/Share-a-consise-recursive-solution-in-C%2B%2B" target="_blank" rel="noopener">这里</a>。</p><p>解法一中也说到了，我们的问题就是取尾元素的时候，需要遍历一遍链表。</p><p>如果我们的递归函数能够返回当前头元素对应的尾元素，并且将头元素和尾元素之间的链表按要求完成，那就变得简单了。</p><p><img src="https://pic.leetcode-cn.com/cc05523815b2eb5baf80741809193cc5b17f29b6a6efe2c235007a036aff5625.jpg" alt="img"></p><p>如上图，我们只需要将 <code>head</code> 指向 <code>tail</code>，<code>tail</code> 指向处理完的链表头即可。</p><p><img src="https://pic.leetcode-cn.com/0a9173afb9b7f62587f5132689ad5bceb98cd24f8f7a3d5f938ca2886d308892.jpg" alt="img"></p><p>然后我们把之前的 <code>tail.next</code> 返回就是外层 <code>head</code> 对应的 <code>tail</code> 了。</p><p>递归出口的话，如果只有一个节点，那么我们只需要将 <code>head.next</code> 返回。</p><p>递归出口的话，如果只有一个节点，那么我们只需要将 <code>head.next</code> 返回。</p><p>如果是两个节点，我们需要将 <code>head.next.next</code> 返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode ahead = head;</span><br><span class="line">    <span class="keyword">while</span> (ahead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        ahead = ahead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    reorderListHelper(head, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reorderListHelper</span><span class="params">(ListNode head, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">        ListNode outTail = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> outTail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">2</span>) &#123;</span><br><span class="line">        ListNode outTail = head.next.next;</span><br><span class="line">        head.next.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> outTail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到对应的尾节点，并且将头结点和尾节点之间的链表通过递归处理</span></span><br><span class="line">    ListNode tail = reorderListHelper(head.next, len - <span class="number">2</span>);</span><br><span class="line">    ListNode subHead = head.next;<span class="comment">//中间链表的头结点</span></span><br><span class="line">    head.next = tail;</span><br><span class="line">    ListNode outTail = tail.next;  <span class="comment">//上一层 head 对应的 tail</span></span><br><span class="line">    tail.next = subHead;</span><br><span class="line">    <span class="keyword">return</span> outTail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>参考 <a href="https://leetcode.com/problems/reorder-list/discuss/44992/Java-solution-with-3-steps" target="_blank" rel="noopener">这里</a>，主要是利用到一头一尾取元素的特性。</p><p>主要是三步，举个例子。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="number">6</span></span><br><span class="line">第一步，将链表平均分成两半</span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="number">6</span></span><br><span class="line">    </span><br><span class="line">第二步，将第二个链表逆序</span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">6</span> -&gt; <span class="number">5</span> -&gt; <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">第三步，依次连接两个链表</span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">6</span> -&gt; <span class="number">2</span> -&gt; <span class="number">5</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure><p>第一步找中点的话，可以应用 19 题的方法，快慢指针。快指针一次走两步，慢指针一次走一步，当快指针走到终点的话，慢指针会刚好到中点。如果节点个数是偶数的话，<code>slow</code> 走到的是左端点，利用这一点，我们可以把奇数和偶数的情况合并，不需要分开考虑。</p><p>第二步链表逆序的话，在 第 2 题]讨论过了，有迭代和递归的两种方式，迭代的话主要利用两个指针，依次逆转。</p><p>第三步的话就很简单了，两个指针分别向后移动就可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快慢指针找中点，链表一分为二</span></span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode newHead = slow.next;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二个链表倒置</span></span><br><span class="line">    newHead = reverseList(newHead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表节点依次连接</span></span><br><span class="line">    <span class="keyword">while</span> (newHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode temp = newHead.next;</span><br><span class="line">        newHead.next = head.next;</span><br><span class="line">        head.next = newHead;</span><br><span class="line">        head = newHead.next;</span><br><span class="line">        newHead = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode tail = head;</span><br><span class="line">    head = head.next;</span><br><span class="line"></span><br><span class="line">    tail.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode temp = head.next;</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail = head;</span><br><span class="line">        head = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自Leetcode第143题重排链表&lt;/p&gt;
&lt;p&gt;给定一个单链表 &lt;em&gt;L&lt;/em&gt;：&lt;em&gt;L&lt;/em&gt;0→&lt;em&gt;L&lt;/em&gt;1→…→&lt;em&gt;L&lt;/em&gt;n-1→&lt;em&gt;L&lt;/em&gt;n ，&lt;br&gt;将其重新排列后变为： &lt;em&gt;L&lt;/em&gt;0→&lt;em&gt;L&lt;/em&gt;n→&lt;em&gt;L&lt;/em&gt;1→&lt;em&gt;L&lt;/em&gt;n-1→&lt;em&gt;L&lt;/em&gt;2→&lt;em&gt;L&lt;/em&gt;n-2→…&lt;/p&gt;
&lt;p&gt;你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="链表" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="链表" scheme="http://yorxika.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>对链表进行插入排序</title>
    <link href="http://yorxika.github.io/2019/12/12/%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yorxika.github.io/2019/12/12/%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2019-12-12T11:52:04.000Z</published>
    <updated>2019-12-12T12:21:41.397Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第147题对链表进行插入排序</p><p>对链表进行插入排序。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt="img"><br>插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。<a id="more"></a><br>每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。</p><p><strong>插入排序算法：</strong></p><ol><li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li><li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li><li>重复直到所有输入数据插入完为止。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">4</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">3</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="转换成列表后排序"><a href="#转换成列表后排序" class="headerlink" title="转换成列表后排序"></a>转换成列表后排序</h3><p>最简单思路，转换成数组（列表）后直接sort，最后转回链表即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        list.add(p1.val);</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    p1 = head;</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">        head.val = it.next();</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>先假定一个伪头结点，并把尾结点tail设置为伪头结点，接着依次比较当前结点cur与tai的值，如果tail的值大于等于cur，则说明cur应该插入tail之前，先记录下cur.next，并将tail.next设置为cur.next,从伪头结点开始遍历，直到找到一个结点下一个结点的值大于cur，这样就找到了cur结点的插入位置，修改对应结点的位置即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p1 = <span class="keyword">new</span> ListNode(Integer.MIN_VALUE);  <span class="comment">//傀儡头结点</span></span><br><span class="line">    ListNode pre = p1, tail = p1, cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail.val &lt; cur.val)&#123;</span><br><span class="line">            tail.next = cur;</span><br><span class="line">            tail = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ListNode tmp = cur.next;</span><br><span class="line">            tail.next = tmp;</span><br><span class="line">            <span class="comment">//不加这一句，当前面是已经排好序的1-&gt;2-&gt;3-&gt;4这种情况时，</span></span><br><span class="line">            <span class="comment">//如果要再把5插入里面，会造成后面的while语句一直循环</span></span><br><span class="line">            <span class="comment">//tail.next后面接的就是cur，然后cur.next = pre.next;</span></span><br><span class="line">            <span class="comment">//pre.next = cur;就成环了，因为成环接下来会一直困在主while循环</span></span><br><span class="line">            <span class="comment">//找到适当的插入位置</span></span><br><span class="line">            <span class="keyword">while</span> (pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.val &lt; cur.val)</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            cur.next = pre.next;</span><br><span class="line">            pre.next = cur;</span><br><span class="line">            pre = p1;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自Leetcode第147题对链表进行插入排序&lt;/p&gt;
&lt;p&gt;对链表进行插入排序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif&quot; alt=&quot;img&quot;&gt;&lt;br&gt;插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="链表" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="链表" scheme="http://yorxika.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="排序" scheme="http://yorxika.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Excel表列名称</title>
    <link href="http://yorxika.github.io/2019/12/12/Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/"/>
    <id>http://yorxika.github.io/2019/12/12/Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</id>
    <published>2019-12-11T16:14:57.000Z</published>
    <updated>2019-12-12T12:42:13.990Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第168题Excel表列名称</p><p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p><p>例如，</p><a id="more"></a><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> -&gt; A</span><br><span class="line"><span class="number">2</span> -&gt; B</span><br><span class="line"><span class="number">3</span> -&gt; C</span><br><span class="line">...</span><br><span class="line"><span class="number">26</span> -&gt; Z</span><br><span class="line"><span class="number">27</span> -&gt; AA</span><br><span class="line"><span class="number">28</span> -&gt; AB </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: 1</span></span><br><span class="line"><span class="section">输出: "A"</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: 28</span></span><br><span class="line"><span class="section">输出: "AB"</span></span><br></pre></td></tr></table></figure><h4 id="伪进制转换I"><a href="#伪进制转换I" class="headerlink" title="伪进制转换I"></a>伪进制转换I</h4><p>一开始以为是10进制转26进制的题目，但是提交之后发现不对，因为题目要求是从1-26，而不是从0-25，所以取模后取余的方法不适用，需要修改。</p><blockquote><p>此题可以近似看成一个求26进制的题，但是值得注意的是对于26的整数倍，如果我们不加以限制的话就会造成A0的情况出现，而题目给出的条件中是不考虑这种情况的。所以我们只需要排除这种情况对于任何26的整数倍，我们就直接先插入‘Z’，同时还要对原数进行减一的操作。因为如果不进行减一的话对于26所对应的就是AZ（其实就是为了将A0映射为Z要对A0整体减一，由于0-1不够，所以要向A借一位，所以最后就得到了Z。所以我们要插入Z之后再对原数减1。）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    StringBuilder string = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        i = n % <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)  <span class="comment">//第26个字母</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = <span class="number">26</span>;</span><br><span class="line">            n -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string.insert(<span class="number">0</span>,(<span class="keyword">char</span>)(<span class="string">'A'</span> + i - <span class="number">1</span>));</span><br><span class="line">        n /= <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="伪进制转换II"><a href="#伪进制转换II" class="headerlink" title="伪进制转换II"></a>伪进制转换II</h4><blockquote><p>上一种思路我们看到了为什么对于26的整数倍要进行减一的操作，同时对于1-25而言，我们应该映射到A-Y，但是对于1我们直接加上A的ascii码就会得到B，所以我们也要进行减一的操作，(char)(temp+’A’-1)。对于Z我们需要减一，对于A-Y也需要减一，如果我们可以减这两种减一统一起来事情就变得简单了。所以我们可以考虑在取余之前就整体减一。我们可以证明对于26的N倍（num%26 = N），我们整体减一在取余就会得到(num-1)%26 = N-1余25，所以25直接加上A的ASCII码就得Z，所以对于Z而言是可以提前减一的。对于A-Y而言num%26 = N余t，t属于1到25的范围。这个t减一在加上’A’的ASCII码就对于与A-Y（t+’A’-1），而如果我们提前减一的话这个表达式就变成了(num-1)%26 =N余t-1;最后我们的到的值就不用进行减一操作（t-1+’A’）。所以可以将Z和A-Y的操作统一起来了，提前减一，然后再正常取模即可。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n--;</span><br><span class="line">            temp = n%<span class="number">26</span>;</span><br><span class="line">            res =(<span class="keyword">char</span>)(temp+<span class="string">'A'</span>) + res;</span><br><span class="line">            n = n/<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自Leetcode第168题Excel表列名称&lt;/p&gt;
&lt;p&gt;给定一个正整数，返回它在 Excel 表中相对应的列名称。&lt;/p&gt;
&lt;p&gt;例如，&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>多数元素</title>
    <link href="http://yorxika.github.io/2019/12/11/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <id>http://yorxika.github.io/2019/12/11/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</id>
    <published>2019-12-11T15:46:14.000Z</published>
    <updated>2019-12-12T12:44:57.730Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第169题多数元素</p><p>给定一个大小为 <em>n</em> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><a id="more"></a><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>利用HashMap存储每个元素的出现次数，最后在对HashMap做一次遍历，找出最大值即可.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(i))</span><br><span class="line">            map.put(i,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            map.put(i,map.get(i) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Map.Entry&lt;Integer,Integer&gt; major = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">        <span class="keyword">if</span>(major == <span class="keyword">null</span> || entry.getValue() &gt; major.getValue())</span><br><span class="line">            major = entry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> major.getKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>由题目可知，出现次数最多的元素大于n / 2，因而排序后返回中位即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Boyer-Moore-投票算法"><a href="#Boyer-Moore-投票算法" class="headerlink" title="Boyer-Moore 投票算法"></a>Boyer-Moore 投票算法</h4><p>来源<a href="https://leetcode-cn.com/problems/majority-element/solution/qiu-zhong-shu-by-leetcode-2/" target="_blank" rel="noopener">题解</a></p><p><strong>想法</strong></p><p>如果我们把众数记为 +1+1 ，把其他数记为 -1−1 ，将它们全部加起来，显然和大于 0 ，从结果本身我们可以看出众数比其他数多。</p><p><strong>算法</strong></p><p>本质上， Boyer-Moore 算法就是找 <code>nums</code> 的一个后缀 suf<em>s<strong>u</strong>f</em> ，其中 suf[0]<em>s<strong>u</strong>f</em>[0] 就是后缀中的众数。我们维护一个计数器，如果遇到一个我们目前的候选众数，就将计数器加一，否则减一。只要计数器等于 0 ，我们就将 <code>nums</code> 中之前访问的数字全部 <em>忘记</em> ，并把下一个数字当做候选的众数。直观上这个算法不是特别明显为何是对的，我们先看下面这个例子（竖线用来划分每次计数器归零的情况）</p><p>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</p><p>首先，下标为 0 的 <code>7</code> 被当做众数的第一个候选。在下标为 5 处，计数器会变回0 。所以下标为 6 的 <code>5</code> 是下一个众数的候选者。由于这个例子中 <code>7</code> 是真正的众数，所以通过忽略掉前面的数字，我们忽略掉了同样多数目的众数和非众数。因此， <code>7</code> 仍然是剩下数字中的众数。</p><p>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | <strong>5, 5, 5, 5</strong>]</p><p>现在，众数是 <code>5</code> （在计数器归零的时候我们把候选从 <code>7</code> 变成了 <code>5</code>）。此时，我们的候选者并不是真正的众数，但是我们在 <em>遗忘</em> 前面的数字的时候，要去掉相同数目的众数和非众数（如果遗忘更多的非众数，会导致计数器变成负数）。</p><p>因此，上面的过程说明了我们可以放心地遗忘前面的数字，并继续求解剩下数字中的众数。最后，总有一个后缀满足计数器是大于 0 的，此时这个后缀的众数就是整个数组的众数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Integer ans = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            ans = i;</span><br><span class="line">        count += (i == ans)? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>看到 <a href="https://leetcode.com/problems/majority-element/discuss/51612/C%2B%2B-6-Solutions" target="_blank" rel="noopener">这里</a> 介绍的，就是把数字放眼到二进制的形式，举个例子。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">5 </span><span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> 都写成 <span class="number">2</span> 进制</span><br><span class="line"><span class="symbol">1 </span><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>由于 <code>2</code> 是超过半数的数，它的二进制是 <code>010</code>，所以对于从右边数第一列一定是 <code>0</code> 超过半数，从右边数第二列一定是 <code>1</code> 超过半数，从右边数第三列一定是 <code>0</code> 超过半数。然后每一列超过半数的 <code>0,1,0</code> 用 <code>10</code>进制表示就是 <code>2</code> 。</p><p>所以我们只需要统计每一列超过半数的数，<code>0</code> 或者 <code>1</code>，然后这些超过半数的二进制位组成一个数字，就是我们要找的数。</p><p>当然，我们可以只统计 <code>1</code> 的个数，让每一位开始默认为 <code>0</code>，如果发现某一列的 <code>1</code> 的个数超过半数，就将当前位改为 <code>1</code>。</p><p>具体算法通过按位与和按位或实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> majority = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">//判断每一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, mask = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++, mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> bits = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录当前列 1 的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mask &amp; nums[j]) == mask) &#123;</span><br><span class="line">                bits++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前列 1 的个数是否超过半数</span></span><br><span class="line">        <span class="keyword">if</span> (bits &gt; n / <span class="number">2</span>) &#123;</span><br><span class="line">            majority |= mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第169题多数元素&lt;/p&gt;
&lt;p&gt;给定一个大小为 &lt;em&gt;n&lt;/em&gt; 的数组，找到其中的多数元素。多数元素是指在数组中出现次数&lt;strong&gt;大于&lt;/strong&gt; &lt;code&gt;⌊ n/2 ⌋&lt;/code&gt; 的元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="位运算" scheme="http://yorxika.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法习题</title>
    <link href="http://yorxika.github.io/2019/12/09/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98/"/>
    <id>http://yorxika.github.io/2019/12/09/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98/</id>
    <published>2019-12-09T08:43:23.000Z</published>
    <updated>2019-12-12T12:49:29.490Z</updated>
    
    <content type="html"><![CDATA[<h4 id="活动教室分配"><a href="#活动教室分配" class="headerlink" title="活动教室分配"></a>活动教室分配</h4><p>T16.1-4 活动教室分配(区间着色问题)</p><p>题目：</p><p>　　有一组活动，我们需要将它们安排到一些教室，任意活动都可以在任意教室进行。我们希望使用最少的教室完成所有活动。</p><p>　　设计一个高效的贪心算法求每个活动应该在哪个教室进行。<a id="more"></a></p><p>分析：</p><p>　　本题是对书中活动选择问题的一个扩展。在活动选择问题中，我们要求的是一个最大兼容活动集，也就是在所有时间内时间不重叠的最多的活动集合。</p><p>　　易知，这样一个活动集，就是一个教室最多能够举办的活动集。所以剩下的活动一定不能和该活动集内的活动在同一个教室举行。我们不断对剩下的活动使用贪心算法，需要多少次贪心能够选取完所有的活动，就最少需要几个教室。</p><p>　　我们首先对所有活动按结束时间排序。遍历所有活动，如果下一个活动开始时间比某教室中最后一个活动结束时间晚，则加入该教室。如果不能加入已使用的任何教室，则需要新开一个教室。　　</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; Acti;<span class="comment">//用起始时间和结束时间的pair表示一个活动。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">party</span><span class="params">(<span class="built_in">vector</span>&lt;Acti&gt;&amp; acti_vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(acti_vec.begin(),acti_vec.end(),[](<span class="keyword">const</span> Acti&amp; a,<span class="keyword">const</span> Acti&amp; b)&#123;<span class="keyword">return</span> a.second &lt; b.second;&#125;);<span class="comment">//按结束时间对所有活动排序。</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Acti&gt;&gt; classroom;<span class="comment">//教室列表。</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Acti&gt; classroom1;</span><br><span class="line">    classroom1.push_back(*acti_vec.begin());<span class="comment">//初始化第一个教室，将结束时间最早的活动放入。</span></span><br><span class="line">    classroom.push_back(classroom1);<span class="comment">//将第一个教室加入教室列表。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;(<span class="keyword">int</span>)acti_vec.size();i++)<span class="comment">//遍历一遍活动列表。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; (<span class="keyword">int</span>)classroom.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(acti_vec[i].first &gt;= (*(classroom[j].end()<span class="number">-1</span>)).second)<span class="comment">//如果该活动的开始时间比某教室目前为止最后一个活动结束结束时间晚，则加入该教室。</span></span><br><span class="line">            &#123;</span><br><span class="line">                classroom[j].push_back(acti_vec[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == (<span class="keyword">int</span>)classroom.size())<span class="comment">//如果无法加入当前任何一个教室，则需要一个新的教室。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;Acti&gt; classroom_temp;</span><br><span class="line">            classroom_temp.push_back(acti_vec[i]);</span><br><span class="line">            classroom.push_back(classroom_temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)classroom.size();i++)<span class="comment">//对每一个教室，按起始时间 结束时间输出每一个活动。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"classroom "</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">":"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; (<span class="keyword">int</span>)classroom[i].size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;classroom[i][j].first&lt;&lt;<span class="string">" "</span>&lt;&lt;classroom[i][j].second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Acti&gt; acti_vec = &#123;</span><br><span class="line">                            &#123;<span class="number">1</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">3</span>,<span class="number">5</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">0</span>,<span class="number">6</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">5</span>,<span class="number">7</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">3</span>,<span class="number">9</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">5</span>,<span class="number">9</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">6</span>,<span class="number">10</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">8</span>,<span class="number">11</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">8</span>,<span class="number">12</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">2</span>,<span class="number">14</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">12</span>,<span class="number">16</span>&#125;</span><br><span class="line">                            &#125;;</span><br><span class="line">    party(acti_vec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找零问题"><a href="#找零问题" class="headerlink" title="找零问题"></a>找零问题</h4><p>题目：<br>考虑用最少的硬币找n美分零钱的问题。假设每种硬币的面额都是整数。</p><p>A.设计贪心算法求解找零问题，假定有25美分、10美分、5美分和1美分4种面额的硬币。证明你的算法能找到最优解。</p><p>B.假定硬币的面额是c的幂，即面额c0,c1,…,ck,c和k为整数，c&gt;1,k&gt;=1.证明：贪心算法总能得到最优解。</p><p>C.设计一组硬币面额，使得贪心算法不能保证得到最优解。这组硬币面额中应该包含1美分，使得对每个零钱值都存在找零方案。</p><p>D.设计一个O(nk)时间的找零算法，适用于任何k种不同面额的硬币，假定问题包含1美分硬币。</p><p>分析:</p><p>A：</p><p>引理1（离散数学其及应用3.1.4）：若n是正整数，则用25美分、10美分、5美分和1美分等尽可能少的硬币找出的n美分零钱中，至多有2个10美分、至多有1个5美分、至多有4个1美分硬币，而不能有2个10美分和1个5美分硬币。用10美分、5美分和1美分硬币找出的零钱不能超过24美分。</p><p>证用反证法。证明如果有超过规定数目的各种类型的硬币，就可以用等值的数目更少的硬币来替换。注意，如果有3个10美分硬币，就可以换成1个25美分和1个5美分硬币；如果有2个5美分硬币，就可以换成1个10美分硬币；如果有5个1美分硬币，就可以换成1个5美分硬币；如果有2个10美分和1个5美分硬币，就可以换成1个25美分硬币。由于至多可以有2个10美分、1个5美分和4个1美分硬币，而不能有2个10美分和1个5美分硬币，所以当用尽可能少的硬币找n美分零钱时，24美分就是用10美分、5美分和1美分硬币能找出的最大值。</p><p>假设存在正整数n，使得有办法将25美分、10美分、5美分和1美分硬币用少于贪心算法所求出的硬币去找n美分零钱。首先注意，在这种找n美分零钱的最优方式中使用25美分硬币的个数q′，一定等于贪心算法所用25美分硬币的个数。为说明这一点，注意贪心算法使用尽可能多的25美分硬币，所以q′≤q。但是q′也不能小于q。假如q′小于q，需要在这种最优方式中用10美分、5美分和1美分硬币至少找出25美分零钱。而根据引理1，这是不可能的。由于在找零钱的这两种方式中一定有同样多的25美分硬币，所以在这两种方式中10美分、5美分和1美分硬币的总值一定相等，并且这些硬币的总值不超过24美分。10美分硬币的个数一定相等，因为贪心算法使用尽可能多的10美分硬币。而根据引理1，当使用尽可能少的硬币找零钱时，至多使用1个5分硬币和4个1分硬币，所以在找零钱的最优方式中也使用尽可能多的10美分硬币。类似地，5美分硬币的个数相等；最终，1美分的个数相等。</p><p>B：</p><p>分析——同A题，由于1+c1+c2+c3+…ck-1=ck - 1&lt;ck,故当n大于ck时，可以分解为ck与n-ck的值，其中ck只用一个硬币值为ck的硬币就能得到最少硬币数，而子问题变成n-ck的最少硬币数，依次类推，贪心算法总能得到最好的结果。</p><p>C:<br>分析——要分析什么情况下贪心算法无效，如果出现一组硬币25，6，5，1.由于1+5=6，当遇到10元时，按照贪心算法将分解为6+4<em>1，而其实为2</em>5.</p><p>D：<br>假设m(n)表示找零n美分需要的最少硬币数，硬币面值为c1,c2, …,ck，并令m[0]=0,则m(n)=1如果n等于某个ci，否则m(n) =min{ m(n-c1)+1, m(n-c2)+1, …, m(n-ck)+1 }</p><p>代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;c,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;s,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = c.size()<span class="number">-1</span>;<span class="comment">//减掉填充符</span></span><br><span class="line">m[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">m[i] = <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k &amp;&amp; (i&gt;=c[j]);j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(m[i-c[j]]+<span class="number">1</span>&lt; m[i])</span><br><span class="line">&#123;</span><br><span class="line">m[i] = m[i-c[j]]+<span class="number">1</span>;</span><br><span class="line">s[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;c,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;s,<span class="keyword">int</span> n,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = c.size();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;number(k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++)</span><br><span class="line">number[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">number[s[n]] ++;</span><br><span class="line">n = n - c[s[n]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"needs coins : %d \n"</span>,count);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(number[i] &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"need %d %d cents coin  "</span>,number[i],c[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//const int c1[] = &#123;0,1,5,10,25&#125;;//零钱种类 第一个元素0起填充的作用 方便下标处理</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c1[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> k = <span class="keyword">sizeof</span>(c1)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">15</span>;<span class="comment">//所需找零钱数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">c.push_back(c1[i]);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;m(n+<span class="number">1</span>);<span class="comment">//不同零钱数对应的最小硬币数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;s(n+<span class="number">1</span>);<span class="comment">//记录所选硬币</span></span><br><span class="line">change(c,m,s,n);</span><br><span class="line">print(c,s,n,m[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;活动教室分配&quot;&gt;&lt;a href=&quot;#活动教室分配&quot; class=&quot;headerlink&quot; title=&quot;活动教室分配&quot;&gt;&lt;/a&gt;活动教室分配&lt;/h4&gt;&lt;p&gt;T16.1-4 活动教室分配(区间着色问题)&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;p&gt;　　有一组活动，我们需要将它们安排到一些教室，任意活动都可以在任意教室进行。我们希望使用最少的教室完成所有活动。&lt;/p&gt;
&lt;p&gt;　　设计一个高效的贪心算法求每个活动应该在哪个教室进行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法导论" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="贪心" scheme="http://yorxika.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>乘积最大子序列</title>
    <link href="http://yorxika.github.io/2019/12/07/%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yorxika.github.io/2019/12/07/%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2019-12-06T16:22:02.000Z</published>
    <updated>2019-12-12T12:45:14.157Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第152题乘积最大子序列</p><p>给定一个整数数组 <code>nums</code> ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 子数组 [<span class="number">2</span>,<span class="number">3</span>] 有最大乘积 <span class="number">6</span>。</span><br></pre></td></tr></table></figure><hr><h4 id="同最大连续子序和"><a href="#同最大连续子序和" class="headerlink" title="同最大连续子序和"></a>同最大连续子序和</h4><ul><li>遍历数组时计算当前最大值，不断更新</li><li>令imax为当前最大值，则当前最大值为 <code>imax = max(imax * nums[i], nums[i])</code></li><li>由于存在负数，那么会导致最大的变最小的，最小的变最大的。因此还需要维护当前最小值imin，<code>imin = min(imin * nums[i], nums[i])</code></li><li><strong>当负数出现时则imax与imin进行交换再进行下一步计算</strong></li><li>时间复杂度：O(n)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE, imax = <span class="number">1</span>, imin = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = imax;</span><br><span class="line">            imax = imin;</span><br><span class="line">            imin = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        imax = Math.max(imax*nums[i], nums[i]);</span><br><span class="line">        imin = Math.min(imin*nums[i], nums[i]);</span><br><span class="line">        max = Math.max(max, imax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第152题乘积最大子序列&lt;/p&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>翻转字符串里的单词</title>
    <link href="http://yorxika.github.io/2019/12/06/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <id>http://yorxika.github.io/2019/12/06/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</id>
    <published>2019-12-06T15:54:45.000Z</published>
    <updated>2019-12-12T12:45:32.588Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第151题翻转字符串里的单词</p><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: "  hello world!  "</span></span><br><span class="line"><span class="section">输出: "world! hello"</span></span><br><span class="line"><span class="section">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span></span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>无空格字符构成一个单词。</li><li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li><li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li></ul><hr><h4 id="2次遍历"><a href="#2次遍历" class="headerlink" title="2次遍历"></a>2次遍历</h4><p>第一次倒序遍历将单词缓存，接着将单词翻转加入答案字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String ans = <span class="keyword">new</span> String();</span><br><span class="line">    String temp = <span class="keyword">new</span> String();</span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">""</span>) || s.equals(<span class="string">" "</span>))</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span> &amp;&amp; i &gt; <span class="number">1</span>  &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">' '</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp.length() == <span class="number">0</span> ||temp.charAt(<span class="number">0</span>) == <span class="string">' '</span> )</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                ans += reverse(temp);</span><br><span class="line">                ans += <span class="string">' '</span>;</span><br><span class="line">                temp = <span class="keyword">new</span> String();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp += s.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!temp.equals(<span class="string">" "</span>))&#123;</span><br><span class="line">        ans += reverse(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ans.length() &gt; <span class="number">0</span> &amp;&amp; ans.charAt(ans.length() - <span class="number">1</span>) == <span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">return</span> ans.substring(<span class="number">0</span>,ans.length() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] array = s.toCharArray();</span><br><span class="line">    String reverse = <span class="string">""</span>;<span class="comment">//新建空字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        reverse += array[i];</span><br><span class="line">    <span class="keyword">return</span> reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><p>trim()方法：去掉字符串两端的多余空格</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//去掉s的首尾空格 然后将字符串拆分</span></span><br><span class="line">    String[] s1 = s.trim().split(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s1.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">//空格后面的空格会变成空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(!s1[i].equals(<span class="string">""</span>)) ans.append(s1[i] + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去掉最后添加上的空格</span></span><br><span class="line">    ans = <span class="keyword">new</span> StringBuilder(ans.toString().trim());</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == s || s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = c.length;</span><br><span class="line">        <span class="keyword">int</span> i = len - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//去掉末尾的空格</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; c[i] == <span class="string">' '</span>) i--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = i + <span class="number">1</span>;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(i + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right != left) </span><br><span class="line">                <span class="comment">//左不等于右是为了判断没有空格</span></span><br><span class="line">                sb.append(c, left, right - left).append(<span class="string">" "</span>);</span><br><span class="line">                <span class="comment">//加入单词</span></span><br><span class="line">                left = i;</span><br><span class="line">                right = i;</span><br><span class="line">                <span class="comment">//调整指针位置</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left = i;</span><br><span class="line">            <span class="comment">//往前找到不为空格的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != left)</span><br><span class="line">            <span class="keyword">return</span> sb.append(c, left, right - left).toString();</span><br><span class="line">        <span class="keyword">return</span> sb.length() &gt; <span class="number">0</span> ? sb.substring(<span class="number">0</span>, sb.length() - <span class="number">1</span>) : <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第151题翻转字符串里的单词&lt;/p&gt;
&lt;p&gt;给定一个字符串，逐个翻转字符串中的每个单词。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="字符串" scheme="http://yorxika.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>两数之和II</title>
    <link href="http://yorxika.github.io/2019/12/06/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII/"/>
    <id>http://yorxika.github.io/2019/12/06/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII/</id>
    <published>2019-12-05T16:02:08.000Z</published>
    <updated>2019-12-12T12:46:07.057Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第167题两数之和 II - 输入有序数组</p><blockquote><p>给定一个已按照<strong><em>升序排列\</em></strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p><p><strong>说明:</strong></p><a id="more"></a><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: numbers = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">&gt; 输出: [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">&gt; 解释: <span class="number">2</span> 与 <span class="number">7</span> 之和等于目标数 <span class="number">9</span> 。因此 index1 = <span class="number">1</span>, index2 = <span class="number">2</span> 。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><hr><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> [] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(numbers.length == <span class="number">0</span> || numbers.length == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        sum = numbers[i] + numbers[j];</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">            ans[<span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> [] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(numbers.length == <span class="number">0</span> || numbers.length == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; numbers.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(target - numbers[i]))&#123;</span><br><span class="line">            ans[<span class="number">0</span>] = map.get(target - numbers[i]);</span><br><span class="line">            ans[<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            map.put(numbers[i], i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>固定一个数，用二分查找搜索target-nums[I]，时间复杂度O(nlgn)，不如双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> [] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(numbers.length == <span class="number">0</span> || numbers.length == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = numbers.length - <span class="number">1</span>,mid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; numbers.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] &gt; target - numbers[i])</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &lt; target - numbers[i])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans[<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">                ans[<span class="number">1</span>] = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第167题两数之和 II - 输入有序数组&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个已按照&lt;strong&gt;&lt;em&gt;升序排列\&lt;/em&gt;&lt;/strong&gt; 的有序数组，找到两个数使得它们相加之和等于目标数。&lt;/p&gt;
&lt;p&gt;函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2&lt;em&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://yorxika.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>最小栈</title>
    <link href="http://yorxika.github.io/2019/12/05/%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>http://yorxika.github.io/2019/12/05/%E6%9C%80%E5%B0%8F%E6%A0%88/</id>
    <published>2019-12-05T15:29:41.000Z</published>
    <updated>2019-12-12T12:45:50.347Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第155题最小栈</p><blockquote><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li>push(x) – 将元素 x 推入栈中。</li><li>pop() – 删除栈顶的元素。<a id="more"></a></li><li>top() – 获取栈顶元素。</li><li>getMin() – 检索栈中的最小元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;  M<span class="keyword">in</span>Stack <span class="keyword">min</span>Stack = new M<span class="keyword">in</span>Stack();</span><br><span class="line">&gt;  <span class="keyword">min</span>Stack.push(-<span class="number">2</span>);</span><br><span class="line">&gt;  <span class="keyword">min</span>Stack.push(<span class="number">0</span>);</span><br><span class="line">&gt;  <span class="keyword">min</span>Stack.push(-<span class="number">3</span>);</span><br><span class="line">&gt;  <span class="keyword">min</span>Stack.getM<span class="keyword">in</span>();   --&gt; 返回 -<span class="number">3</span>.</span><br><span class="line">&gt;  <span class="keyword">min</span>Stack.pop();</span><br><span class="line">&gt;  <span class="keyword">min</span>Stack.top();      --&gt; 返回 <span class="number">0</span>.</span><br><span class="line">&gt;  <span class="keyword">min</span>Stack.getM<span class="keyword">in</span>();   --&gt; 返回 -<span class="number">2</span>.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 双栈</span><br><span class="line"></span><br><span class="line">利用两个栈，一个数据栈，一个保存所有最小值栈实现。</span><br><span class="line"></span><br><span class="line">当最小值栈非空时，元素直接入栈，否则需要比较栈顶元素与入栈元素大小，如果小于等于，则入栈</span><br><span class="line"></span><br><span class="line">代码如下：</span><br><span class="line"></span><br><span class="line">​```JAVA</span><br><span class="line">    class MinStack &#123;</span><br><span class="line"></span><br><span class="line">        /** initialize your data structure here. */</span><br><span class="line"></span><br><span class="line">        private Stack&lt;Integer&gt; stack;</span><br><span class="line">        private Stack&lt;Integer&gt; miniStack;</span><br><span class="line"></span><br><span class="line">        public MinStack() &#123;</span><br><span class="line">            stack = new Stack&lt;&gt;();</span><br><span class="line">            miniStack = new Stack&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void push(int x) &#123;</span><br><span class="line">            <span class="attribute">stack.push(x);</span></span><br><span class="line">            if(!miniStack.empty())&#123;</span><br><span class="line">                if(x &lt;= miniStack.peek())&#123;</span><br><span class="line">                    <span class="attribute">miniStack.push(x);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else</span><br><span class="line">                <span class="attribute">miniStack.push(x);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void pop() &#123;</span><br><span class="line">            int pop = stack.pop();</span><br><span class="line"></span><br><span class="line">            if(pop == miniStack.peek())</span><br><span class="line">                <span class="attribute">miniStack.pop();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int top() &#123;</span><br><span class="line">            return stack.peek();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getMin() &#123;</span><br><span class="line">            return miniStack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="单栈"><a href="#单栈" class="headerlink" title="单栈"></a>单栈</h4><p>当有更小的值来的时候，我们只需要把之前的最小值入栈，当前更小的值再入栈即可。当这个最小值要出栈的时候，下一个值便是之前的最小值了。</p><p>例如：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">入栈 3 </span><br><span class="line">|<span class="string">   </span>|<span class="string">   min = 3</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">     </span></span><br><span class="line">|<span class="string">_3_</span>|<span class="string">    </span></span><br><span class="line"><span class="string">stack   </span></span><br><span class="line"></span><br><span class="line"><span class="string">入栈 5 </span></span><br><span class="line">|<span class="string">   </span>|<span class="string">   min = 3</span></span><br><span class="line">|<span class="string"> 5 </span>|<span class="string">     </span></span><br><span class="line">|<span class="string">_3_</span>|<span class="string">    </span></span><br><span class="line"><span class="string">stack  </span></span><br><span class="line"></span><br><span class="line"><span class="string">入栈 2 </span></span><br><span class="line">|<span class="string"> 2 </span>|<span class="string">   min = 2?</span></span><br><span class="line">|<span class="string"> 5 </span>|<span class="string">     </span></span><br><span class="line">|<span class="string">_3_</span>|<span class="string">    </span></span><br><span class="line"><span class="string">stack  </span></span><br><span class="line"></span><br><span class="line"><span class="string">入栈 2 ，同时将之前的 min 值 3 入栈，再把 2 入栈，同时更新 min = 2</span></span><br><span class="line">|<span class="string"> 2 </span>|<span class="string">   min = 2</span></span><br><span class="line">|<span class="string"> 3 </span>|<span class="string">  </span></span><br><span class="line">|<span class="string"> 5 </span>|<span class="string">     </span></span><br><span class="line">|<span class="string">_3_</span>|<span class="string">    </span></span><br><span class="line"><span class="string">stack  </span></span><br><span class="line"></span><br><span class="line"><span class="string">入栈 6 </span></span><br><span class="line">|<span class="string"> 6 </span>|<span class="string">  min = 2</span></span><br><span class="line">|<span class="string"> 2 </span>|<span class="string">   </span></span><br><span class="line">|<span class="string"> 3 </span>|<span class="string">  </span></span><br><span class="line">|<span class="string"> 5 </span>|<span class="string">     </span></span><br><span class="line">|<span class="string">_3_</span>|<span class="string">    </span></span><br><span class="line"><span class="string">stack  </span></span><br><span class="line"></span><br><span class="line"><span class="string">出栈 6     </span></span><br><span class="line">|<span class="string"> 2 </span>|<span class="string">   min = 2</span></span><br><span class="line">|<span class="string"> 3 </span>|<span class="string">  </span></span><br><span class="line">|<span class="string"> 5 </span>|<span class="string">     </span></span><br><span class="line">|<span class="string">_3_</span>|<span class="string">    </span></span><br><span class="line"><span class="string">stack  </span></span><br><span class="line"></span><br><span class="line"><span class="string">出栈 2     </span></span><br><span class="line">|<span class="string"> 2 </span>|<span class="string">   min = 2</span></span><br><span class="line">|<span class="string"> 3 </span>|<span class="string">  </span></span><br><span class="line">|<span class="string"> 5 </span>|<span class="string">     </span></span><br><span class="line">|<span class="string">_3_</span>|<span class="string">    </span></span><br><span class="line"><span class="string">stack  </span></span><br><span class="line"></span><br><span class="line"><span class="string">出栈 2     </span></span><br><span class="line">|<span class="string">   </span>|<span class="string">  min = 3   </span></span><br><span class="line">|<span class="string"> 5 </span>|<span class="string">   </span></span><br><span class="line">|<span class="string">_3_</span>|<span class="string">    </span></span><br><span class="line"><span class="string">stack</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前值更小</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt;= min)&#123;   </span><br><span class="line">            <span class="comment">//将之前的最小值保存</span></span><br><span class="line">            stack.push(min);</span><br><span class="line">            <span class="comment">//更新最小值</span></span><br><span class="line">            min=x;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果弹出的值是最小值，那么将下一个元素更新为最小值</span></span><br><span class="line">        <span class="keyword">if</span>(stack.pop() == min) &#123;</span><br><span class="line">            min=stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="差值栈"><a href="#差值栈" class="headerlink" title="差值栈"></a>差值栈</h4><p>用一个 min 变量保存最小值。只不过栈里边我们不去保存原来的值，而是去存储入栈的值和最小值的差值。然后得到之前的最小值的话，我们就可以通过 min 值和栈顶元素得到，举个例子。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">入栈 <span class="number">3</span>，存入 <span class="number">3</span> - <span class="number">3</span> = <span class="number">0</span></span><br><span class="line">|   |   min = <span class="number">3</span></span><br><span class="line">|   |     </span><br><span class="line">|_0_|    </span><br><span class="line">stack   </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">5</span>，存入 <span class="number">5</span> - <span class="number">3</span> = <span class="number">2</span></span><br><span class="line">|   |   min = <span class="number">3</span></span><br><span class="line">| <span class="number">2</span> |     </span><br><span class="line">|_0_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">2</span>，因为出现了更小的数，所以我们会存入一个负数，这里很关键</span><br><span class="line">也就是存入  <span class="number">2</span> - <span class="number">3</span> = <span class="number">-1</span>, 并且更新 min = <span class="number">2</span> </span><br><span class="line">对于之前的 min 值 <span class="number">3</span>, 我们只需要用更新后的 min - 栈顶元素 <span class="number">-1</span> 就可以得到    </span><br><span class="line">| <span class="number">-1</span>|   min = <span class="number">2</span></span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">6</span>，存入  <span class="number">6</span> - <span class="number">2</span> = <span class="number">4</span></span><br><span class="line">| <span class="number">4</span> |   min = <span class="number">2</span></span><br><span class="line">| <span class="number">-1</span>| </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">出栈，返回的值就是栈顶元素 <span class="number">4</span> 加上 min，就是 <span class="number">6</span></span><br><span class="line">|   |   min = <span class="number">2</span></span><br><span class="line">| <span class="number">-1</span>| </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">出栈，此时栈顶元素是负数，说明之前对 min 值进行了更新。</span><br><span class="line">入栈元素 - min = 栈顶元素，入栈元素其实就是当前的 min 值 <span class="number">2</span></span><br><span class="line">所以更新前的 min 就等于入栈元素 <span class="number">2</span> - 栈顶元素(<span class="number">-1</span>) = <span class="number">3</span></span><br><span class="line">|   | min = <span class="number">3</span></span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack</span><br></pre></td></tr></table></figure><p>再理一下上边的思路，我们每次存入的是 <code>原来值 - 当前最小值</code>。</p><p>当原来值大于等于当前最小值的时候，我们存入的肯定就是非负数，所以出栈的时候就是 <code>栈中的值 + 当前最小值</code> 。</p><p>当原来值小于当前最小值的时候，我们存入的肯定就是负值，此时的值我们不入栈，用 <code>min</code> 保存起来，同时将差值入栈。</p><p>当后续如果出栈元素是负数的时候，那么要出栈的元素其实就是 <code>min</code>。此外之前的 <code>min</code> 值，我们可以通过栈顶的值和当前 <code>min</code> 值进行还原，就是用 <code>min</code> 减去栈顶元素即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> min;</span><br><span class="line">Stack&lt;Long&gt; stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">min = x;</span><br><span class="line">stack.push(x - min);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">stack.push(x - min);</span><br><span class="line"><span class="keyword">if</span> (x &lt; min)&#123;</span><br><span class="line">min = x; <span class="comment">// 更新最小值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> pop = stack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出的是负值，要更新 min</span></span><br><span class="line"><span class="keyword">if</span> (pop &lt; <span class="number">0</span>) &#123;</span><br><span class="line">min = min - pop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> top = stack.peek();</span><br><span class="line"><span class="comment">//负数的话，出栈的值保存在 min 中</span></span><br><span class="line"><span class="keyword">if</span> (top &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) (min);</span><br><span class="line">        <span class="comment">//出栈元素加上最小值即可</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) (top + min);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>再分享一个有趣的解法，参考 <a href="https://leetcode.com/problems/min-stack/discuss/49217/6ms-Java-Solution-using-Linked-List.-Clean-self-explanatory-and-efficient." target="_blank" rel="noopener">这里</a> 。</p><p>回到最初的疑虑，我们要不要用 <code>java</code> 提供的 <code>stack</code> 。如果不用的话，可以怎么做的？</p><p>直接用一个链表即可实现栈的基本功能，那么最小值该怎么得到呢？我们可以在 <code>Node</code> 节点中增加一个 <code>min</code> 字段，这样的话每次加入一个节点的时候，我们同时只要确定它的 <code>min</code> 值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> x, <span class="keyword">int</span> min)&#123;</span><br><span class="line">            <span class="keyword">this</span>.value=x;</span><br><span class="line">            <span class="keyword">this</span>.min=min;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head;</span><br><span class="line">    <span class="comment">//每次加入的节点放到头部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>==head)&#123;</span><br><span class="line">            head = <span class="keyword">new</span> Node(x,x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前值和之前头结点的最小值较小的做为当前的 min</span></span><br><span class="line">            Node n = <span class="keyword">new</span> Node(x, Math.min(x,head.min));</span><br><span class="line">            n.next=head;</span><br><span class="line">            head=n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">            head =head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head.value;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>!=head)</span><br><span class="line">            <span class="keyword">return</span> head.min;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第155题最小栈&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push(x) – 将元素 x 推入栈中。&lt;/li&gt;
&lt;li&gt;pop() – 删除栈顶的元素。&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="栈" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%88/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="栈" scheme="http://yorxika.github.io/tags/%E6%A0%88/"/>
    
      <category term="设计" scheme="http://yorxika.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的后序遍历</title>
    <link href="http://yorxika.github.io/2019/12/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://yorxika.github.io/2019/12/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2019-12-04T16:08:30.000Z</published>
    <updated>2019-12-12T12:46:18.927Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第145题二叉树的后序遍历</p><blockquote><p>给定一个二叉树，返回它的 <strong>后序</strong> 遍历。</p></blockquote><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归顺序左右根就完事了嗷。<a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">        postorderTraversal(root.left);</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)</span><br><span class="line">        postorderTraversal(root.right);</span><br><span class="line">    ans.add(root.val);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BFS-倒序输出-后序？"><a href="#BFS-倒序输出-后序？" class="headerlink" title="BFS+倒序输出 = 后序？"></a>BFS+倒序输出 = 后序？</h4><p>再改前序遍历的代码改的时候发现直接reverse输出左右子树的顺序不对，于是将入栈顺序改了就行了。。。<br>原理就是这样的遍历顺序是根右左，而后序遍历是左右根，因而翻转就是左右根了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">        TreeNode temp = stack.pop();</span><br><span class="line">        ans.add(temp.val);</span><br><span class="line">        <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(temp.left);</span><br><span class="line">        <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(temp.right);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第145题二叉树的后序遍历&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，返回它的 &lt;strong&gt;后序&lt;/strong&gt; 遍历。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h4&gt;&lt;p&gt;递归顺序左右根就完事了嗷。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的前序遍历</title>
    <link href="http://yorxika.github.io/2019/12/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://yorxika.github.io/2019/12/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2019-12-04T15:55:18.000Z</published>
    <updated>2019-12-12T12:46:26.169Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第144题二叉树的前序遍历</p><blockquote><p>给定一个二叉树，返回它的<strong>前序</strong>遍历。</p></blockquote><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归很简单，在大二上就已经学过了，按根左右的顺序即可。<a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    ans.add(root.val);</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">        preorderTraversal(root.left);</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)</span><br><span class="line">        preorderTraversal(root.right);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>利用栈，首先根结点入栈，当栈非空，栈顶元素出栈，并且其值写入List，如果左右子树都非空，就右子树入栈再左子树出栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">        TreeNode temp = stack.pop();</span><br><span class="line">        ans.add(temp.val);</span><br><span class="line">        <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(temp.right);</span><br><span class="line">        <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(temp.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="莫里斯遍历"><a href="#莫里斯遍历" class="headerlink" title="莫里斯遍历"></a>莫里斯遍历</h4><p>题解里有，好像之前也看到过，摸了咕咕咕</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自Leetcode第144题二叉树的前序遍历&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，返回它的&lt;strong&gt;前序&lt;/strong&gt;遍历。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h4&gt;&lt;p&gt;递归很简单，在大二上就已经学过了，按根左右的顺序即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>验证二叉搜索树</title>
    <link href="http://yorxika.github.io/2019/12/03/%E9%AA%8C%E8%AF%81%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yorxika.github.io/2019/12/03/%E9%AA%8C%E8%AF%81%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2019-12-03T13:27:19.000Z</published>
    <updated>2019-12-12T12:46:40.324Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第98题验证二叉搜索树</p><blockquote><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。<a id="more"></a></li></ul></blockquote><hr><h4 id="错误的思路"><a href="#错误的思路" class="headerlink" title="错误的思路"></a>错误的思路</h4><p>做的时候忘记判断当前结点的左子树数据是否大于上一结点的数据了，最终在第70/75个用例时出错</p><p>错误的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> root.val&lt; root.right.val &amp;&amp; isValidBST(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> root.val &gt; root.left.val &amp;&amp; isValidBST(root.left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root.val &gt; root.left.val &amp;&amp; root.val&lt; root.right.val &amp;&amp; isValidBST(root.left) &amp;&amp; isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>来源<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode/" target="_blank" rel="noopener">题解</a><br>首先将结点的值与上界和下界（如果有）比较。然后，对左子树和右子树递归进行该过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode node, Integer lower, Integer upper)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> val = node.val;</span><br><span class="line">   <span class="keyword">if</span> (lower != <span class="keyword">null</span> &amp;&amp; val &lt;= lower) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (upper != <span class="keyword">null</span> &amp;&amp; val &gt;= upper) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//遍历右子树，当前结点的值放入lower</span></span><br><span class="line">   <span class="keyword">if</span> (! helper(node.right, val, upper)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//遍历左子树，当前结点的值放入upper</span></span><br><span class="line">   <span class="keyword">if</span> (! helper(node.left, lower, val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> helper(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历迭代"><a href="#中序遍历迭代" class="headerlink" title="中序遍历迭代"></a>中序遍历迭代</h4><p>利用中序遍历来判断是否是二叉搜索树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line"><span class="comment">//先将左子树全部入栈</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//弹出最后一个左边结点</span></span><br><span class="line">            p = stack.pop();</span><br><span class="line"><span class="comment">//如果右子树的值比左子树的值小</span></span><br><span class="line"><span class="comment">//直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt;= p.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            pre = p;</span><br><span class="line"><span class="comment">//右子树入栈</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历递归"><a href="#中序遍历递归" class="headerlink" title="中序遍历递归"></a>中序遍历递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> last = -Double.MAX_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (isValidBST(root.left)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (last &lt; root.val) &#123;</span><br><span class="line">               last = root.val;</span><br><span class="line">               <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第98题验证二叉搜索树&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
&lt;p&gt;假设一个二叉搜索树具有如下特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点的左子树只包含小于当前节点的数。&lt;/li&gt;
&lt;li&gt;节点的右子树只包含大于当前节点的数。&lt;/li&gt;
&lt;li&gt;所有左子树和右子树自身必须也是二叉搜索树。&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>位1的个数</title>
    <link href="http://yorxika.github.io/2019/12/03/%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://yorxika.github.io/2019/12/03/%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2019-12-03T12:07:34.000Z</published>
    <updated>2019-12-12T12:47:35.356Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第191题位1的个数</p><blockquote><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><p>示例 1：</p><p>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。<a id="more"></a></p></blockquote><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><ul><li>1.计算出来的值i的二进制可以按每2个二进制位为一组进行分组，各组的十进制表示的就是该组的汉明重量。</li><li>2.计算出来的值i的二进制可以按每4个二进制位为一组进行分组，各组的十进制表示的就是该组的汉明重量。</li><li>3.计算出来的值i的二进制可以按每8个二进制位为一组进行分组，各组的十进制表示的就是该组的汉明重量。</li><li>4.i * (0x01010101)计算出汉明重量并记录在二进制的高八位，&gt;&gt;24语句则通过右移运算，将汉明重量移到最低八位，最后二进制对应的十进制数就是汉明重量。<br>算法时间复杂度是O（1）的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">i = (i &amp; <span class="number">0x55555555</span>) + ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);  <span class="comment">//相邻位相加</span></span><br><span class="line">i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);  <span class="comment">//相邻为以2为单位相加</span></span><br><span class="line">i = (i &amp; <span class="number">0x0F0F0F0F</span>) + ((i &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F0F0F0F</span>);  <span class="comment">//相邻为以4为单位相加</span></span><br><span class="line">i = (i * (<span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><p>执行32次，每次与1相与，判断结果后累加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">            bits++;</span><br><span class="line">        &#125;</span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h4><p>来源官方题解</p><blockquote><p>在二进制表示中，数字 nn 中最低位的 11 总是对应 n - 1n−1 中的 00 。因此，将 nn 和 n - 1n−1 与运算总是能把 nn 中最低位的 11 变成 00 ，并保持其他位不变。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Integet类库"><a href="#Integet类库" class="headerlink" title="Integet类库"></a>Integet类库</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.bitCount(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lowbit公式"><a href="#lowbit公式" class="headerlink" title="lowbit公式"></a>lowbit公式</h4><p>lowbit公式： x &amp; ~x<br>作用是找出数字n中最后一个1出现的位置<br>例如n = 10。用二进制表示就是1010，而它的负数-10用二进制补码表示则为0110，<br>取&amp;后得到的结果为10，这就得到了n最后一个1出现的位置对应的数字。<br>知道lowbit公式后，这个题目就非常简单了。每次通过lowbit公式找到最后一个1对应的数，然后将它减去，直到n为0为止。统计减法操作的次数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            n -= lowbit(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第191题位1的个数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：00000000000000000000000000001011&lt;br&gt;输出：3&lt;br&gt;解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="位运算" scheme="http://yorxika.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>打家劫舍</title>
    <link href="http://yorxika.github.io/2019/12/02/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <id>http://yorxika.github.io/2019/12/02/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</id>
    <published>2019-12-02T15:31:39.000Z</published>
    <updated>2019-12-12T12:48:55.783Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第198题打家劫舍</p><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><a id="more"></a><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:</p><p>输入: [1,2,3,1]<br>输出: 4<br>解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p></blockquote><hr><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>易知，当前房屋的最大收益dp[i] = max(dp[i - 1],dp[i - 2] + nums[i]}<br>即当前房屋的收益要么是上一房屋的累积收益，即当前房间不抢劫，要么是前前房屋的收益加上当前房屋的收益</p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= nums.length ; i++)&#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h4><p>来自<a href="https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode/" target="_blank" rel="noopener">题解</a></p><p>利用3个变量替代了dp数组，使空间利用率从O(n)降到了O(1)</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prevMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> currMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : num) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = currMax;</span><br><span class="line">        currMax = Math.max(prevMax + x, currMax);</span><br><span class="line">        prevMax = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第198题打家劫舍&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程的软中断和管道通信</title>
    <link href="http://yorxika.github.io/2019/12/02/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1/"/>
    <id>http://yorxika.github.io/2019/12/02/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1/</id>
    <published>2019-12-02T13:15:55.000Z</published>
    <updated>2019-12-12T12:49:59.231Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux进程管理命令——进程查看"><a href="#Linux进程管理命令——进程查看" class="headerlink" title="Linux进程管理命令——进程查看"></a>Linux进程管理命令——进程查看</h3><ul><li>ps命令：报告进程标识、用户、CPU时间消耗及其他属性 <ul><li>命令单独使用可以看到前台执行的进程；后台进程可以使用带参 数的ps命令（如ps -ax） <a id="more"></a></li><li>提供进程的一次性查看，结果不连续 </li><li>结果数据很精确，但数据量庞大</li></ul></li><li>top命令：显示CPU占用率为前几位的进程 <ul><li>动态显示，输出结果连续 </li><li>消耗较多的系统资源</li></ul></li><li>pstree命令：列出当前的进程，以及它们的树状结构 <ul><li>将当前的执行程序以树状结构显示，弥补ps命令的不足</li><li>支持指定特定程序(PID)或使用者(USER)作为显示的起始</li></ul></li></ul><h3 id="Linux进程管理命令—进程终止"><a href="#Linux进程管理命令—进程终止" class="headerlink" title="Linux进程管理命令—进程终止"></a>Linux进程管理命令—进程终止</h3><ul><li>终止一个进程或终止一个正在运行的程序 <ul><li>kill命令：根据PID向进程发送信号，缺省操作是停止进程 </li><li>如果进程启动了子进程，只终止父进程，子进程运行中将仍 消耗资源成为“僵尸”进程，可用kill -9强制终止退出 </li><li>pkill命令：终止同一进程组内的所有进程。允许指定要终止的进程名称，而非PID </li><li>Killall命令：与pkill应用方法类似，直接杀死运行中的程 序</li><li>数据库服务器的父进程不能用这些命令杀死（容易产生更多 的文件碎片导致数据库崩溃）</li></ul></li></ul><h3 id="Linux进程控制函数——进程创建"><a href="#Linux进程控制函数——进程创建" class="headerlink" title="Linux进程控制函数——进程创建"></a>Linux进程控制函数——进程创建</h3><h4 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h4><p>pid=fork();<br>fork系统调用用于创建一个新进程，称为子进程，它与进程（称为系统调用fork的进程）同时运行，此进程称为父进程。创建新的子进程后，两个进程将执行fork（）系统调用之后的下一条指令。子进程使用相同的pc（程序计数器），相同的CPU寄存器，在父进程中使用的相同打开文件。</p><div align="center"><img width="500" src="/2019/12/02/进程的软中断和管道通信/1.jpg"></div><p>它不需要参数并返回一个整数值。下面是fork（）返回的不同值。</p><ul><li>负值：创建子进程失败。</li><li>零：返回到新创建的子进程。</li><li>正值：返回父母或来电者。该值包含新创建的子进程的进程ID</li></ul><p><strong>头文件</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;/*#包含&lt;unistd.h&gt;*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;/*#包含&lt;sys/types.h&gt;*/</span></span></span><br></pre></td></tr></table></figure><p><strong>函数原型</strong>:<br>pid_t fork( void);<br>（pid_t 是一个宏定义，其实质是int 被定义在#include&lt;sys/types.h&gt;中）<br>返回值： 若成功调用一次则返回两个值，子进程返回0，父进程返回子进程ID；否则，出错返回-1</p><p><strong>函数说明</strong>：<br>一个现有进程可以调用fork函数创建一个新进程。由fork创建的新进程被称为子进程（child process）。fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值而父进程中返回子进程ID。<br>子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。<br>UNIX将复制父进程的地址空间内容给子进程，因此，子进程有了独立的地址空间。在不同的UNIX (Like)系统下，我们无法确定fork之后是子进程先运行还是父进程先运行，这依赖于系统的实现。所以在移植代码的时候我们不应该对此作出任何的假设。</p><p><strong>为什么fork会返回两次？</strong><br>由于在复制时复制了父进程的堆栈段，所以两个进程都停留在fork函数中，等待返回。因此fork函数会返回两次，一次是在父进程中返回，另一次是在子进程中返回，这两次的返回值是不一样的。</p><p>fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：<br>(1)在父进程中，fork返回新创建子进程的进程ID；<br>(2)在子进程中，fork返回0；<br>(3)如果出现错误，fork返回一个负值。<br>在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。<br>引用一位网友的话来解释fork函数返回的值为什么在父子进程中不同。“其实就相当于链表，进程形成了链表，父进程的fork函数返回的值指向子进程的进程id, 因为子进程没有子进程，所以其fork函数返回的值为0.<br>调用fork之后，数据、堆、栈有两份，代码仍然为一份但是这个代码段成为两个进程的共享代码段都从fork函数中返回，箭头表示各自的执行处。当父子进程有一个想要修改数据或者堆栈时，两个进程真正分裂。</p><h4 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h4><p>函数族exec() ：启动另外的进程取代当前的进程 </p><ul><li>#include &lt;unistd.h&gt; </li><li>extern char **environ;</li><li>int execl(const char *path, const char *arg, …); </li><li>int execlp(const char *file, const char *arg, …); </li><li>int execle(const char *path, const char *arg, const char *envp[]); </li><li>int execv(const char *path, const char *argv[]); </li><li>int execve(const char *path, const char *argv[], const char *envp[]; </li><li>int execvp(const char *file, const char *argv[]);</li></ul><p>其中只有execve是真正意义上的系统调用，其它都是在此基础上经过包装的库函数。</p><p><strong>exec族函数的作用</strong></p><p>exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。这里的可执行文件既可以是二进制文件，也可以是任何Linux下可执行的脚本文件。<br>与一般情况不同，exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样，颇有些神似”三十六计”中的”金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回一个-1，从原程序的调用点接着往下执行。<br>现在我们应该明白了，Linux下是如何执行新程序的，每当有进程认为自己不能为系统和用户做出任何贡献了，他就可以发挥最后一点余热，调用任何一个exec，让自己以新的面貌重生；或者，更普遍的情况是，如果一个进程想执行另一个程序，它就可以fork出一个新进程，然后调用任何一个exec，这样看起来就好像通过执行应用程序而产生了一个新进程一样。<br>事实上第二种情况被应用得如此普遍，以至于Linux专门为其作了优化，我们已经知道，fork会将调用进程的所有内容原封不动的拷贝到新产生的子进程中去，这些拷贝的动作很消耗时间，而如果fork完之后我们马上就调用exec，这些辛辛苦苦拷贝来的东西又会被立刻抹掉，这看起来非常不划算，于是人们设计了一种”写时拷贝（copy-on-write）”技术，使得fork结束后并不立刻复制父进程的内容，而是到了真正实用的时候才复制，这样如果下一条语句是exec，它就不会白白作无用功了，也就提高了效率。<br>对于新程序的命令行参数和环境表有长度大小的限制，对于linux来讲这个限制是4096个字节。执行了exec函数的进程不改变以下进程特征：</p><ul><li>1.进程ID和父进程ID</li><li>2.实际用户ID和实际组ID</li><li>3.进程组ID和附加组ID</li><li>4.控制终端 </li><li>5.会话ID</li><li>6.时钟预留着时间</li><li>7.当前工作目录和根目录</li><li>8.文件创建屏蔽字和文件锁</li><li>9.信号屏蔽字和未处理信号集</li><li>10.资源限制</li></ul><p><strong>返回值</strong><br>如果执行成功则函数不会返回，执行失败则直接返回-1，失败原因存于errno 中。</p><p><strong>注意</strong><br>大家在平时的编程中，如果用到了exec函数族，一定记得要加错误判断语句。因为与其他系统调用比起来，exec很容易受伤，被执行文件的位置，权限等很多因素都能导致该调用的失败。最常见的错误是：</p><ul><li>1.找不到文件或路径，此时errno被设置为ENOENT；</li><li>2.数组argv和envp忘记用NULL结束，此时errno被设置为EFAULT；</li><li>3.没有对要执行文件的运行权限，此时errno被设置为EACCES。</li><li>l表示以参数列表的形式调用</li><li>v表示以参数数组的方式调用</li><li>e表示可传递环境变量</li><li>p表示PATH中搜索执行的文件，如果给出的不是绝对路径就会去PATH搜索相应名字的文件，如PATH没有设置， 则会默认在/bin,/usr/bin下搜索。</li><li>另：调用时参数必须以NULL结束。原进程打开的文件描述符是不会在exec中关闭的，除非用fcntl设置它们的“执行时关闭标志（close on exec）”而原进程打开的目录流都将在新进程中关闭。</li></ul><h4 id="Linux进程属性操作"><a href="#Linux进程属性操作" class="headerlink" title="Linux进程属性操作"></a>Linux进程属性操作</h4><ul><li>设置进程属性 <ul><li>nice()：改变进程执行的优先级 </li><li>setpgid()：将指定进程的组进程设为指定的组识别码 </li><li>setpgrp()：将目前进程的组进程识别码设为目前进程的进程 识别码，等价于setpgid(0,0) </li><li>setpriority()：设置进程、进程组和用户的执行优先权 </li></ul></li><li>获取进程属性 <ul><li>getpid()：获取目前进程的进程标识 </li><li>getpgid()：获得参数pid指定进程所属的组识别码 </li><li>getpgrp()：获得目前进程所属的组识别号，等价于 </li><li>getpgid(0) </li><li>getpriotity()：获得进程、进程组和用户的执行优先权</li></ul></li></ul><h4 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h4><ul><li>正常退出：在main()函数中执行return、调用exit()函数 或_exit()函数 </li><li>异常退出：调用abort()函数、进程收到信号而终止 </li><li>区别 <ul><li>exit是一个函数，有参数，把控制权交给系统 </li><li>return是函数执行完后的返回，将控制权交给调用函数 </li><li>exit是正常终止进程，abort是异常终止 </li><li>exit中参数为0代表进程正常终止，为其他值表示程序执行过程 中有错误发生 </li><li>exit()在头文件stdlib.h中声明，先执行清除操作，再将控制权 返回给内核 </li><li>_exit()在头文件unistd.h中声明，执行后立即返回给内核</li></ul></li></ul><h4 id="等待进程终止"><a href="#等待进程终止" class="headerlink" title="等待进程终止"></a>等待进程终止</h4><p>wait();    waitpid();</p><ul><li><p>① wait() 语法格式： pid=wait(stat_addr);<br> wait()函数使父进程暂停执行，直到它的一个子进程结束为止，该函数 的返回值是终止运行的子进程的PID。参数status所指向的变量存放子 进程的退出码，即从子进程的main函数返回的值或子进程中exit()函数 的参数。如果status不是一个空指针，状态信息将被写入它指向的变量。</p></li><li><p>② waitpid() 语法格式：waitpid(pid_t pid,int * status,int options)<br> 用来等待子进程的结束，但它用于等待某个特定进程结束。<br> 参数pid指明要等待的子进程的PID，参数status的含义与wait()函数中的 status相同。</p><p> 如果在调用 waitpid()时子进程已经结束,则 waitpid()会立即返回子进程结束状态值。 子进程的结束状态值会由参数 status 返回,而子进程的进程识别码也会一起返回。如果不在意结束状态值,则参数 status 可以设成 NULL。参数 pid 为欲等待的子进程识别码.<br> 其他数值意义如下:</p><ul><li><p>pid&lt;-1 等待进程组识别码为 pid 绝对值的任何子进程。</p></li><li><p>pid=-1 等待任何子进程,相当于 wait()。</p></li><li><p>pid=0 等待进程组识别码与目前进程相同的任何子进程。</p></li><li><p>pid&gt;0 等待任何子进程识别码为 pid 的子进程。</p></li><li><p>参数options提供了一些额外的选项来控制waitpid，参数 option 可以为 0 或可以用”|”运算符把它们连接起来使用，比如：<code>ret=waitpid(-1,NULL,WNOHANG | WUNTRACED);</code><br>WNOHANG 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若结束，则返回该子进程的ID。<br>WUNTRACED 若子进程进入暂停状态，则马上返回，但子进程的结束状态不予以理会。WIFSTOPPED(status)宏确定返回值是否对应与一个暂停子进程。</p><p>子进程的结束状态返回后存于 status,底下有几个宏可判别结束情况:<br>WIFEXITED(status)如果若为正常结束子进程返回的状态，则为真；对于这种情况可执行WEXITSTATUS(status)，取子进程传给exit或_eixt的低8位。<br>WEXITSTATUS(status)取得子进程 exit()返回的结束代码,一般会先用 WIFEXITED 来判断是否正常结束才能使用此宏。<br>WIFSIGNALED(status)若为异常结束子进程返回的状态，则为真；对于这种情况可执行WTERMSIG(status)，取使子进程结束的信号编号。<br>WTERMSIG(status) 取得子进程因信号而中止的信号代码,一般会先用 WIFSIGNALED 来判断后才使用此宏。<br>WIFSTOPPED(status) 若为当前暂停子进程返回的状态，则为真；对于这种情况可执行WSTOPSIG(status)，取使子进程暂停的信号编号。<br>WSTOPSIG(status) 取得引发子进程暂停的信号代码,一般会先用 WIFSTOPPED 来判断后才使用此宏。<br>如果执行成功则返回子进程识别码(PID) ,如果有错误发生则返回<br>返回值-1。失败原因存于 errno 中。</p></li></ul></li></ul><h3 id="进程的软中断通信"><a href="#进程的软中断通信" class="headerlink" title="进程的软中断通信"></a>进程的软中断通信</h3><h4 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h4><p><strong>表头文件</strong>#include&lt;signal.h&gt;</p><p><strong>功能</strong>：设置某一信号的对应动作</p><p><strong>函数原型</strong>：void (*signal(int signum,void(* handler)(int)))(int);<br>或者：typedef void (*sig_t)( int );<br>sig_t signal(int signum,sig_t handler);</p><p><strong>参数说明</strong>：<br>第一个参数signum指明了所要处理的信号类型，它可以取除了SIGKILL和SIGSTOP外的任何一种信号。<br>第二个参数handler描述了与信号关联的动作，它可以取以下三种值：</p><ul><li>（1）一个无返回值的函数地址<br> 此函数必须在signal()被调用前申明，handler中为这个函数的名字。当接收到一个类型为signum的信号时，就执行handler 所指定的函数。这个函数应有如下形式的定义：<br> void func(int sig);</li><li>（2）SIG_IGN<br> 这个符号表示忽略该信号，执行了相应的signal()调用后，进程会忽略类型为sig的信号。</li><li>（3）SIG_DFL<br> 这个符号表示恢复系统对信号的默认处理。</li></ul><p><strong>函数说明</strong>：<br>signal()会依参数signum 指定的信号编号来设置该信号的处理函数。当指定的信号到达时就会跳转到参数handler指定的函数执行。当一个信号的信号处理函数执行时，如果进程又接收到了该信号，该信号会自动被储存而不会中断信号处理函数的执行，直到信号处理函数执行完毕再重新调用相应的处理函数。但是如果在信号处理函数执行时进程收到了其它类型的信号，该函数的执行就会被中断。</p><p><strong>返回值</strong>：返回先前的信号处理函数指针，如果有错误则返回SIG_ERR(-1)。</p><p>下面的情况可以产生Signal：</p><ul><li>按下CTRL+C产生SIGINT</li><li>硬件中断，如除0，非法内存访问（SIGSEV）等等</li><li>Kill函数可以对进程发送Signal</li><li>Kill命令。实际上是对Kill函数的一个包装</li><li>软件中断。如当Alarm Clock超时（SIGURG），当Reader中止之后又向管道写数据（SIGPIPE），等等</li></ul><p>Signals:</p><table><thead><tr><th align="center">Signal</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">SIGABRT</td><td align="center">由调用abort函数产生，进程非正常退出</td></tr><tr><td align="center">SIGALRM</td><td align="center">用alarm函数设置的timer超时或setitimer函数设置的interval timer超时</td></tr><tr><td align="center">SIGBUS</td><td align="center">某种特定的硬件异常，通常由内存访问引起</td></tr><tr><td align="center">SIGCANCEL</td><td align="center">由Solaris Thread Library内部使用，通常不会使用</td></tr><tr><td align="center">SIGCHLD</td><td align="center">进程Terminate或Stop的时候，SIGCHLD会发送给它的父进程。缺省情况下该Signal会被忽略</td></tr><tr><td align="center">SIGCONT</td><td align="center">当被stop的进程恢复运行的时候，自动发送</td></tr><tr><td align="center">SIGEMT</td><td align="center">和实现相关的硬件异常</td></tr><tr><td align="center">SIGFPE</td><td align="center">数学相关的异常，如被0除，浮点溢出，等等</td></tr><tr><td align="center">SIGFREEZE</td><td align="center">Solaris专用，Hiberate或者Suspended时候发送</td></tr><tr><td align="center">SIGHUP</td><td align="center">发送给具有Terminal的Controlling Process，当terminal被disconnect时候发送</td></tr><tr><td align="center">SIGILL</td><td align="center">非法指令异常</td></tr><tr><td align="center">SIGINFO</td><td align="center">BSD signal。由Status Key产生，通常是CTRL+T。发送给所有Foreground Group的进程</td></tr><tr><td align="center">SIGINT</td><td align="center">由Interrupt Key产生，通常是CTRL+C或者DELETE。发送给所有ForeGround Group的进程</td></tr><tr><td align="center">SIGIO</td><td align="center">异步IO事件</td></tr><tr><td align="center">SIGIOT</td><td align="center">实现相关的硬件异常，一般对应SIGABRT</td></tr><tr><td align="center">SIGKILL</td><td align="center">无法处理和忽略。中止某个进程</td></tr><tr><td align="center">SIGLWP</td><td align="center">由Solaris Thread Libray内部使用</td></tr><tr><td align="center">SIGPIPE</td><td align="center">在reader中止之后写Pipe的时候发送</td></tr><tr><td align="center">SIGPOLL</td><td align="center">当某个事件发送给Pollable Device的时候发送</td></tr><tr><td align="center">SIGPROF</td><td align="center">Setitimer指定的Profiling Interval Timer所产生</td></tr><tr><td align="center">SIGPWR</td><td align="center">和系统相关。和UPS相关。</td></tr><tr><td align="center">SIGQUIT</td><td align="center">输入Quit Key的时候（CTRL+\）发送给所有Foreground Group的进程</td></tr><tr><td align="center">SIGSEGV</td><td align="center">非法内存访问</td></tr><tr><td align="center">SIGSTKFLT</td><td align="center">Linux专用，数学协处理器的栈异常</td></tr><tr><td align="center">SIGSTOP</td><td align="center">中止进程。无法处理和忽略。</td></tr><tr><td align="center">SIGSYS</td><td align="center">非法系统调用</td></tr><tr><td align="center">SIGTERM</td><td align="center">请求中止进程，kill命令缺省发送</td></tr><tr><td align="center">SIGTHAW</td><td align="center">Solaris专用，从Suspend恢复时候发送</td></tr><tr><td align="center">SIGTRAP</td><td align="center">实现相关的硬件异常。一般是调试异常</td></tr><tr><td align="center">SIGTSTP</td><td align="center">Suspend Key，一般是Ctrl+Z。发送给所有Foreground Group的进程</td></tr><tr><td align="center">SIGTTIN</td><td align="center">当Background Group的进程尝试读取Terminal的时候发送</td></tr><tr><td align="center">SIGTTOU</td><td align="center">当Background Group的进程尝试写Terminal的时候发送</td></tr><tr><td align="center">SIGURG</td><td align="center">当out-of-band data接收的时候可能发送</td></tr><tr><td align="center">SIGUSR1</td><td align="center">用户自定义signal 1</td></tr><tr><td align="center">SIGUSR2</td><td align="center">用户自定义signal 2</td></tr><tr><td align="center">SIGVTALRM</td><td align="center">setitimer函数设置的Virtual Interval Timer超时的时候</td></tr><tr><td align="center">SIGWAITING</td><td align="center">Solaris Thread Library内部实现专用</td></tr><tr><td align="center">SIGWINCH</td><td align="center">当Terminal的窗口大小改变的时候，发送给Foreground Group的所有进程</td></tr><tr><td align="center">SIGXCPU</td><td align="center">当CPU时间限制超时的时候</td></tr><tr><td align="center">SIGXFSZ</td><td align="center">进程超过文件大小限制</td></tr><tr><td align="center">SIGXRES</td><td align="center">Solaris专用，进程超过资源限制的时候发送</td></tr></tbody></table><p><strong>注意</strong></p><ul><li>不要使用低级的或者STDIO.H的IO函数</li><li>不要使用对操作</li><li>不要进行系统调用</li><li>不是浮点信号的时候不要用longjmp</li><li>signal函数是由ISO C定义的。因为ISO C不涉及多进程，进程组以及终端I/O等，所以他对信号的定义非常含糊，以至于对UNIX系统而言几乎毫无用处。</li><li>备注：因为signal的语义与现实有关，所以最好使用sigaction函数替代本函数</li></ul><p>当某个信号出现时，系统有三种处理方式： </p><ul><li>忽略信号：大多数信号使用，但SIGKIL和SIGSTOP不能被忽略 </li><li>捕捉信号：通知内核在某种信号发生时，调用一个用户函数 </li><li>执行系统默认动作：异常终止(abort)、退出(exit)、忽略(ignore)、停 止(stop)或继续(continue)</li></ul><p>*<em>功能 *</em></p><ul><li>发送信号：发送进程把信号送到指定进程信号域的某一位上，如目标进程正在一个可被中断的优先级上睡眠，核心便将其唤醒 </li><li>预置对信号的处理方式：进程处于核心态时，即使受到软中断也不予理睬；只有当它返回到用户态后，才处理软中断信号 </li><li>收受信号的进程按事先规定完成对相应事件的处理</li></ul><h3 id="进程的软中断通信——函数的使用"><a href="#进程的软中断通信——函数的使用" class="headerlink" title="进程的软中断通信——函数的使用"></a>进程的软中断通信——函数的使用</h3><ul><li><p>向一个进程或一组进程发送一个信号：int kill(pid, sig)<br> pid&gt;0时，核心将信号发送给进程pid<br> pid&lt;0时，核心将信号发送给与发送进程同组的所有进程<br> pid=-1时，核心将信号发送给所有用户标识符真正等于发送进程的有 效用户标识号的进程</p></li><li><p>预置信号接收后的处理方式：signal(sig, function)<br> function=1时，屏蔽该类信号<br> function=0时，收到sig信号后终止自己<br> function为非0、非1类整数时，执行用户设置的软中断处理程序</p></li></ul><h3 id="Linux进程间通信—管道和有名管道"><a href="#Linux进程间通信—管道和有名管道" class="headerlink" title="Linux进程间通信—管道和有名管道"></a>Linux进程间通信—管道和有名管道</h3><ul><li>管道用于具有亲缘关系进程间的通信<ul><li>管道是半双工的，数据只能单向流动（双方通信需建立两个管道）</li><li>管道只能用于父子进程或兄弟进程之间</li><li>管道对于管道两端的进程而言就是一个文件，并单独构成一种文件 系统，存在于内存中</li><li>写管道的内容添加在管道缓冲区的末尾，读管道则从缓冲区头部读 出</li></ul></li><li>有名管道在普通管道具备功能基础上，通过给管道命名的 方法变成管道文件，允许无亲缘关系进程间通过访问管道 文件进行通信</li></ul><h4 id="无名管道的使用"><a href="#无名管道的使用" class="headerlink" title="无名管道的使用"></a>无名管道的使用</h4><ul><li>int pipefd[2]; int pipe(pipefd); /*创建无名管道*/<br> pipefd[0]只能用于读;  pipe[1]只能用于写</li></ul><p>pipe函数定义中的fd参数是一个大小为2的一个数组类型的指针。该函数成功时返回0，并将一对打开的文件描述符值填入fd参数指向的数组。失败时返回 -1并设置errno。</p><p>通过pipe函数创建的这两个文件描述符 fd[0] 和 fd[1] 分别构成管道的两端，往 fd[1] 写入的数据可以从 fd[0] 读出。并且 fd[1] 一端只能进行写操作，fd[0] 一端只能进行读操作，不能反过来使用。要实现双向数据传输，可以使用两个管道。</p><p>默认情况下，这一对文件描述符都是阻塞的。此时，如果我们用read系统调用来读取一个空的管道，则read将被阻塞，知道管道内有数据可读；如果我们用write系统调用往一个满的管道中写数据，则write也将被阻塞，直到管道有足够的空闲空间可用(read读取数据后管道中将清除读走的数据)。当然，用户可自行将 fd[0] 和 fd[1] 设置为非阻塞的。</p><p>如果管道的写端文件描述符 fd[1] 的引用计数减少至0，即没有任何进程需要往管道中写入数据，则对该管道的读端文件描述符 fd[0] 的read操作将返回0(管道内不存在数据的情况)，即读到了文件结束标记(EOF，End Of File)；反之，如果管道的读端文件描述符 fd[0] 的引用计数减少至0，即没有任何进程需要从管道读取数据，则针对该管道的写端文件描述符 fd[1] 的write操作将失败，并引发SIGPIPE信号(往读端被关闭的管道或socket连接中写数据)。</p><p>管道内部传输的数据是字节流，这和TCP字节流的概念相同。但它们又存在细微的差别。应用层程序能往一个TCP连接中写入多少字节的数据，取决于对方接受窗口的大小和本端的拥塞窗口的大小。而管道的话本身拥有一个容量限制，它规定如果管道的写端应用程序不将管道中数据读走的话，该管道最多还能被写入多少字节的数据。管道容量的大小默认是65536字节。我们也可以使用fcntl函数来修改管道容量。</p><div align="center"><img width="500" src="/2019/12/02/进程的软中断和管道通信/2.jpg"></div><ol><li><p>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。</p></li><li><p>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</p></li><li><p>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</p></li></ol><ul><li>将数据写入管道：write() <ul><li>函数原型:<code>int write(int handle, void *buf, int nbyte)</code></li><li>管道长度受到限制，管道满时写入操作将被阻塞，直到管道中的 数据被读取 </li><li>fcntl()可将管道设置为非阻塞模式</li></ul></li><li>从管道读取数据：read() <ul><li>函数原型:<code>ssize_t read   (int fd, void *buf, size_t count);</code></li><li>返回值：成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0。</li><li>参数：参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移。注意这个读写位置和使用C标准I/O库时的读写位置有可能不同，这个读写位置是记在内核中的，而使用C标准I/O库时的读写位置是用户空间I/O缓冲区中的位置。比如用fgetc读一个字节，fgetc有可能从内核中预读1024个字节到I/O缓冲区中，再返回第一个字节，这时该文件在内核中记录的读写位置是1024，而在FILE结构体中记录的读写位置是1。注意返回值类型是ssize_t，表示有符号的size_t，这样既可以返回正的字节数、0（表示到达文件末尾）也可以返回负值-1（表示出错）。<br>read函数返回时，返回值说明了buf中前多少个字节是刚读上来的。有些情况下，实际读到的字节数（返回值）会小于请求读的字节数count，例如：读常规文件时，在读到count个字节之前已到达文件末尾。例如，距文件末尾还有30个字节而请求读100个字节，则read返回30，下次read将返回0。</li><li>当数据被读取后，数据将自动被管道清除 </li><li>不能由一个进程向多个进程同时传递同一个数据 </li><li>fcntl()可将管道读模式设置为非阻塞模式 </li></ul></li><li>关闭管道：close()<ul><li>函数原型:<code>int close(int fd);</code></li><li>返回值：成功返回0，出错返回-1并设置errno</li><li>参数fd是要关闭的文件描述符。需要说明的是，当一个进程终止时，内核对该进程所有尚未关闭的文件描述符调用close关闭，所以即使用户程序不调用close，在终止时内核也会自动关闭它打开的所有文件。但是对于一个长年累月运行的程序（比如网络服务器），打开的文件描述符一定要记得关闭，否则随着打开的文件越来越多，会占用大量文件描述符和系统资源。</li><li>关闭读端口时，在管道上进行写操作的进程将收到SIGPIPE信号 </li><li>关闭写端口时，进行读操作的read()函数将返回0</li></ul></li></ul><h4 id="管道通信的使用—命名管道的创建与读写"><a href="#管道通信的使用—命名管道的创建与读写" class="headerlink" title="管道通信的使用—命名管道的创建与读写"></a>管道通信的使用—命名管道的创建与读写</h4><ul><li><p>创建命名管道： </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int mknod(const char *path, mode_t mod, dev_t dev)； </span><br><span class="line">int mkfifo(const char *path, mode_t mode)；</span><br></pre></td></tr></table></figure></li><li><p>命名管道必须先调用open()将其打开 </p><ul><li>同时用读写方式(O_RDWR)打开时，一定不会导致阻塞 </li><li>以只读方式(O_RDONLY)打开时，调用open()函数的进程将会被 阻塞直到有写方打开管道 </li><li>以写方式(O_WRONLY)打开时，阻塞直到有读方打开管道</li></ul></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>实现进程简单控制和利用管道通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  //exex、fork头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;  //signal头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  //wait头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;  //wait头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  //exit头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; //mutex头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pipefd[<span class="number">2</span>];   <span class="comment">/*创建无名管道,pipefd[0]只能用于读;  pipe[1]只能用于写*/</span></span><br><span class="line"><span class="keyword">int</span> child_1, child_2;  <span class="comment">//用于存储创建的子进程pid</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;  <span class="comment">//进程互斥锁，避免抢占打印输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill_child1</span><span class="params">()</span> </span>&#123; <span class="comment">//父进程杀死子进程1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Child process 1 is killed by parent!\n"</span>);</span><br><span class="line">close(pipefd[<span class="number">1</span>]);  <span class="comment">//关闭管道写端</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">//子进程1退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill_child2</span><span class="params">()</span> </span>&#123; <span class="comment">//父进程杀死子进程2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Child process 2 is killed by parent!\n"</span>);</span><br><span class="line">close(pipefd[<span class="number">0</span>]);  <span class="comment">//关闭管道读端</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">//子进程2退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill_childprocess</span><span class="params">()</span> </span>&#123;  <span class="comment">//父进程捕捉到中断信号，用系统调用Kill()向两个子进 程发出信号</span></span><br><span class="line"><span class="keyword">if</span> (kill(child_1, SIGUSR1) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Kill child1 process error!\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (kill(child_2, SIGUSR1) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Kill child2 process error!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rtn; </span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>); <span class="comment">//初始化mutex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建管道 </span></span><br><span class="line"><span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Create a nameless pipe error!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建第一个子进程</span></span><br><span class="line"><span class="keyword">switch</span> (child_1 = fork())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> - <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Create child process failed!\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">close(pipefd[<span class="number">0</span>]);  <span class="comment">//子进程1关闭读端</span></span><br><span class="line">signal(SIGINT, SIG_IGN);  <span class="comment">//SIGINT:由Interrupt Key产生，通常是CTRL+C或者DELETE。</span></span><br><span class="line"> <span class="comment">//发送给所有ForeGround Group的进程</span></span><br><span class="line">signal(SIGUSR1, kill_child1);   <span class="comment">// 设置进程处理信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">//死循环里每秒通过管道发送信号给子进程2</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">write(pipefd[<span class="number">1</span>], (<span class="keyword">void</span>*)&amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I have send you %d times!\n"</span>, i);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建第二个子进程</span></span><br><span class="line"><span class="keyword">switch</span> (child_2 = fork())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Create child process failed!\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">close(pipefd[<span class="number">1</span>]);  <span class="comment">//子进程关闭写端</span></span><br><span class="line">signal(SIGINT, SIG_IGN);  <span class="comment">//SIGINT:由Interrupt Key产生，通常是CTRL+C或者DELETE。</span></span><br><span class="line"> <span class="comment">//发送给所有ForeGround Group的进程</span></span><br><span class="line">signal(SIGUSR1, kill_child2);   <span class="comment">// 设置进程处理信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">//死循环里每秒通过管道发送信号给子进程2</span></span><br><span class="line">read(pipefd[<span class="number">0</span>], (<span class="keyword">void</span>*)&amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I have received your message %d times!\n"</span>, i);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal(SIGINT,kill_childprocess);  <span class="comment">//当捕捉到中断信号后</span></span><br><span class="line"><span class="comment">//父进程用系统调用Kill()向两个子进 程发出信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等到两个子进程结束</span></span><br><span class="line">waitpid(child_1, &amp;rtn, <span class="number">0</span>);</span><br><span class="line">waitpid(child_2, &amp;rtn, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭管道</span></span><br><span class="line">close(pipefd[<span class="number">0</span>]);</span><br><span class="line">close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Parent Process is killed!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linux进程管理命令——进程查看&quot;&gt;&lt;a href=&quot;#Linux进程管理命令——进程查看&quot; class=&quot;headerlink&quot; title=&quot;Linux进程管理命令——进程查看&quot;&gt;&lt;/a&gt;Linux进程管理命令——进程查看&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ps命令：报告进程标识、用户、CPU时间消耗及其他属性 &lt;ul&gt;
&lt;li&gt;命令单独使用可以看到前台执行的进程；后台进程可以使用带参 数的ps命令（如ps -ax）&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程" scheme="http://yorxika.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="Linux" scheme="http://yorxika.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>动态规划习题</title>
    <link href="http://yorxika.github.io/2019/12/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%A0%E9%A2%98/"/>
    <id>http://yorxika.github.io/2019/12/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%A0%E9%A2%98/</id>
    <published>2019-12-02T08:42:59.000Z</published>
    <updated>2019-12-12T12:49:20.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="矩阵链乘法"><a href="#矩阵链乘法" class="headerlink" title="矩阵链乘法"></a>矩阵链乘法</h2><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p>本节给出了一个关于矩阵链相乘问题的动态规划算法。给定一个n个矩阵&lt;A1,A2,……,An&gt;的矩阵链，要计算它们的乘积A1*A2*A3……An。矩阵乘法满足结合律，所以通过加括号，一个矩阵链的乘法可以按照不同的顺序进行。例如，4个矩阵的矩阵链，共有5种加括号的方式：<a id="more"></a></p><div align="center"><img width="200" src="/2019/12/02/动态规划习题/矩阵乘法0.png"></div><p>加括号的方式对矩阵链乘法的时间代价产生巨大的影响。我们先来分析两个矩阵相乘的时间代价。下面的代码给出了两个矩阵相乘的标准算法。</p><div align="center"><img width="300" src="/2019/12/02/动态规划习题/矩阵乘法1.png"></div><p>两个矩阵A和B只有相容，即A的列数等于B的行数时，才能相乘。如果A是 p×q 矩阵，B是 q×r 矩阵，那么乘积C是 p×r 矩阵。分析上面的代码，矩阵乘法的时间代价主要由最内层循环的标量乘法的次数决定，一共需要做 pqr 次标量乘法。</p><p>现在考虑计算矩阵链乘法的时间代价。以3个矩阵为例， 它们的维数分别为10×100、100×5和5×50，有以下两种加括号的方式：</p><ul><li>按((A1·A2)·A3)的顺序计算<br> 先(A1·A2)计算，需要做10×100×5 = 5000次标量乘法，得到的结果矩阵的维度为10×5；再与A3相乘，需要做10×5×50 = 2500次标量乘法。总共需要做5000+2500 = 7500次标量乘法。</li><li>按(A1·(A2·A3))的顺序计算<br> 先计算(A2·A3)，需要做100×5×50 = 25000次标量乘法，得到的结果矩阵的维度为100×50;A1再与(A2·A3的结果相乘，需要做10×100×50 = 50000次标量乘法。总共需要做25000+50000 = 75000次标量乘法。</li></ul><p>可以看到，第(2)种计算顺序的时间代价是第(1)种顺序的10倍。</p><p><strong>矩阵链乘法问题</strong>:给定一个n个矩阵的矩阵链，矩阵Ai的维度为 (1 ≤ i ≤ n)，求一个最优的加括号方案，使得计算矩阵A1*A2*A3……An乘积所需要的标量乘法次数最少。<br>矩阵A1的维度为p0*p1，A2的维度为p1*p2，… …。以此类推，矩阵An的维度为pn-1*pn。矩阵的维度可以构成一个n+1元的数组{p0,p1……,pn}。以这个数组作为算法输入。<br>令P(n)表示n个矩阵的矩阵链的所有加括号的方案的数量。当n =1时，由于只有一个矩阵，所以P(1) = 1。当n ≥ 2时，可以先将矩阵链划分为两个子链&lt;A1,……Ak&gt;和&lt;Ak+1……An&gt;，其中k = 1,2,…, n-1，对两个子链加括号又是规模更小的子问题，因此矩阵链乘法问题满足最优子结构。由此，我们可以得到</p><div align="center"><img width="300" src="/2019/12/02/动态规划习题/矩阵乘法2.png"></div><p>易知道,P(n) = O(2^n)。显然，遍历所有加括号的方案，并不是一个明智的选择，这样的算法至少有一个指数增长的时间复杂度。现在我们用动态规划方法来求解这个问题。</p><p>用m[i, j]表示计算矩阵链&lt;A1,A2,……,An&gt;所需标量乘法次数的最小值。如果i = j，矩阵链中只有一个矩阵，显然m[i, j] = 0。对于i &lt; j 的情况，上文提到，可以先将矩阵链划分为两个子链&lt;Ai,Ai+1,……,Ak&gt;和&lt;Ak+1,Ak+2,……,Aj&gt;。左子链的乘积是一个矩阵，右子链的乘积是一个矩阵。假设两个子链的最优解已知，它们分别为m[i, k]和m[k+1, j ]，并且可以知道两个子链的结果相乘需要次pi-1·pk·pj 标量乘法。于是，可以得到m[i,j] = m[i,k] + m[k + 1,j] + pi-1·pk·pj。<br>矩阵链的划分点k可以取值i, i+1,…, j-1，我们需要检查k的所有可能的取值情况，并从中找到最优解。于是有</p><div align="center"><img width="400" src="/2019/12/02/动态规划习题/矩阵乘法3.png"></div><p>我们已经确立了问题的最优子结构，现在要合理安排子问题的求解顺序。子问题的规模是用相应的子链中矩阵的个数来度量的。我们要计算m[i, j]，只依赖于更短的子链的求解结果。因此，我们可以按照长度递增的顺序求解矩阵链乘法问题。另外，还需要在求解过程中记录下每个子问题的最优解的分割点位置k。以下是代码。</p><div align="center"><img width="500" src="/2019/12/02/动态规划习题/矩阵乘法4.png"></div><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>T15.2-1 对矩阵链&lt;5,10,3,12,5,50,6&gt;，求矩阵链最有括号化方案</p><!--more--><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String [] A = &#123;<span class="string">"A0"</span>,<span class="string">"A1"</span>,<span class="string">"A2"</span>,<span class="string">"A3"</span>,<span class="string">"A4"</span>,<span class="string">"A5"</span>,<span class="string">"A6"</span>&#125;;<span class="comment">//六个矩阵A1～A6 但是伪码是从下标1开始计算，因此在首位填充0</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> [] p = &#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">50</span>,<span class="number">6</span>&#125;;  <span class="comment">//矩阵维数为p[i-1]*p[i]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[][] matrix_chain_order(<span class="keyword">int</span> [] p,<span class="keyword">int</span> [][] matrix,<span class="keyword">int</span> [][] brakcet,<span class="keyword">int</span> n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">matrix[i][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n- len + <span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">matrix[i][j] = Integer.MAX_VALUE; <span class="comment">//设置为无穷大</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j - <span class="number">1</span>; k++)&#123;</span><br><span class="line"><span class="keyword">int</span> mulTimes = matrix[i][k] + matrix[k + <span class="number">1</span>][j] + p[i - <span class="number">1</span>]*p[k]*p[j];</span><br><span class="line"><span class="keyword">if</span>(mulTimes &lt; matrix[i][j])&#123;</span><br><span class="line">matrix[i][j] = mulTimes;</span><br><span class="line">brakcet[i][j] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n;j++)</span><br><span class="line">System.out.print(matrix[i][j] + <span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;= n;j++)</span><br><span class="line">System.out.print(brakcet[i][j] + <span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> brakcet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_optimal_parens</span><span class="params">(<span class="keyword">int</span> [][] brakcet,<span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i == j)</span><br><span class="line">System.out.print(A[i]);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">System.out.print(<span class="string">"("</span>);</span><br><span class="line">print_optimal_parens(brakcet,i,brakcet[i][j]);</span><br><span class="line">print_optimal_parens(brakcet,brakcet[i][j] + <span class="number">1</span>,j);</span><br><span class="line">System.out.print(<span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> [][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>][<span class="number">7</span>];</span><br><span class="line"><span class="keyword">int</span> [][] brakcet = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>][<span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">6</span> ; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;= <span class="number">6</span> ;j++)</span><br><span class="line">matrix[i][j] = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">brakcet = matrix_chain_order(p,matrix,brakcet,<span class="number">6</span>);</span><br><span class="line">print_optimal_parens(brakcet,<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><blockquote><p>0 150 330 405 1655 2010<br>2147483647 0 360 330 2430 1950<br>2147483647 2147483647 0 180 930 1770<br>2147483647 2147483647 2147483647 0 3000 1860<br>2147483647 2147483647 2147483647 2147483647 0 1500<br>2147483647 2147483647 2147483647 2147483647 2147483647 0 </p><p>0 1 2 2 4 2<br>0 0 2 2 2 2<br>0 0 0 3 4 4<br>0 0 0 0 4 4<br>0 0 0 0 0 5<br>0 0 0 0 0 0  </p><p>((A1A2)((A3A4)(A5A6)))</p></blockquote><h2 id="最优二叉搜索树"><a href="#最优二叉搜索树" class="headerlink" title="最优二叉搜索树"></a>最优二叉搜索树</h2><h3 id="笔记-1"><a href="#笔记-1" class="headerlink" title="笔记"></a>笔记</h3><p>二叉搜索树满足如下性质：假设x xx是二叉搜索树中的一个结点。如果l ll是x xx的左子树的一个结点，那么l.key≤x.key l.key ≤ x.keyl.key≤x.key。如果r rr是x xx的右子树的一个结点，那么r.key≥x.key r.key ≥ x.keyr.key≥x.key。<br>也就是说，二叉搜索树中的任意一个结点，它的左子树中的所有结点都不大于它，它的右子树中的所有结点都不小于它。下图给出了一个二叉搜索树的例子。</p><div align="center"><img width="200" src="/2019/12/02/动态规划习题/二叉搜索树0.png"></div><p><strong>最优二叉搜索树</strong>(Optimal Binary Search Tree)问题描述如下。给定一个n nn个不同关键字的已排序的序列K[1..n]=&lt;k1,k2,…,kn&gt;（因此k1&lt;k2&lt;…&lt;kn），我们希望用这些关键字构造一个二叉搜索树。对每个关键字ki,都有一个概率pi表示其搜索概率。搜索过程中有可能遇到不在K[1..n]中的元素，因此我们还有n+1个元素的“伪关键字”序列D[0..n]=&lt;d0,d1,d2,…,dn&gt; ，表示搜索过程中可能遇到的所有不在K[1..n] K[1..n]K[1..n]中的元素。d0表示所有小于k1的元素；dn 表示所有大于kn 的元素；对i=1,2,…,n−1 i = 1, 2, …, n-1，di表示所有在ki到ki+1之间的元素。对每个伪关键字di，也有一个概率qi 表示对应的搜索概率。在二叉搜索树中，伪关键字di 必然出现在叶结点上，关键字ki 必然出现在非叶结点上。每次搜索要么成功（找到某个关键字ki），要么失败（找到某个伪关键字di）。关键字和伪关键字的概率满足：</p><div align="center"><img width="150" src="/2019/12/02/动态规划习题/二叉搜索树1.png"></div><p>假定一次搜索的代价等于访问的结点数，也就是此次搜索找到的结点在二叉搜索树中的深度再加1 11。给定一棵二叉搜索树T TT，我们可以确定进行一次搜索的期望代价。</p><div align="center"><img width="350" src="/2019/12/02/动态规划习题/二叉搜索树2.png"></div><p>其中depthT表示一个结点在二叉搜索树T中的深度。</p><p>对于一组给定的关键字和伪关键字，以及它们对应的概率，我们希望构造一棵期望搜索代价最小的二叉搜索树，这称之为最优二叉搜索树。现在我们用动态规划方法来求解最优二叉搜索树问题。</p><p>首先我们描述最优二叉搜索树问题的最优子结构：假设由关键字子序列K[i..j]=&lt;ki,…,kj&gt; 和伪关键字子序列D[i−1..j]=&lt;di−1,…,dj&gt; 构成的一棵最优二叉搜索树以kr(i≤r≤j)为根结点。那么它的左子树由子序列K[i..r−1]和D[i−1..r−1]构成，这颗左子树显然也是一棵最优二叉搜索树。同样，它的右子树由子序列K[r+1..j]和D[r..j]构成，这颗右子树显然也是一棵最优二叉搜索树。<br>这里有一个值得注意的细节—空子树。如果包含子序列K[i..j]的最优二叉搜索树以ki为根结点。根据最优子结构性质，它的左子树包含子序列K[i..i−1]，这个子序列不包含任何关键字。但请注意，左子树仍然包含一个伪关键字di−1。同理，如果选择kj为根结点，那么右子树也不包含任何关键字，而只包含一个伪关键字dj。<br>用e[i,j] 表示包含关键字子序列K[i..j]=&lt;ki,…,kj&gt; 的最优二叉搜索树的期望搜索代价。我们最终希望计算出e[1,n]。<br>对于j=i−1的情况，由于子树只包含伪关键字di−1 ，所以期望搜索代价为e[i,i−1]=qi−1。<br>当j≥i时，我们要遍历以ki,ki+1,…,kj作为根结点的情况，然后从中选择期望搜索代价最小的情况作为子问题的最优解。假设选择kr(i≤r≤j)作为根结点，那么子序列K[i..r−1]构成的最优二叉搜索树作为左子树，左子树的期望搜索代价为e[i,r−1]；子序列K[r+1..j]构成的最优二叉搜索树作为右子树，右子树的期望搜索代价为e[r+1,j]。<br>当一棵子树链接到一个根结点上时，子树中所有结点的深度都增加了1 ，那么这棵子树的期望搜索代价的增加值为它的所有结点的概率之和。对于一棵包含子序列K[i..j]的子树，所有结点的概率之和为</p><div align="center"><img width="200" src="/2019/12/02/动态规划习题/二叉搜索树3.png"></div>接上文，若kr(i≤r≤j)作为包含关键字子序列K[i..j]的最优二叉搜索树的根结点，可以得到如下公式e[i,j]=pr+(e[i,r−1]+w[i,r−1])+(e[r+1,j]+w[r+1,j]) 由于w[i,j]=w[i,r−1]+pr+w[r+1,j]，所以上式可重写为e[i,j]=e[i,r−1]+e[r+1,j]+w[i,j]我们要遍历以ki,ki+1,…,kj作为根结点的情况，并选择期望搜索代价最小的情况作为子问题的最优解。于是我们可以得到下面的递归式。<div align="center"><img width="350" src="/2019/12/02/动态规划习题/二叉搜索树4.png"></div><p>e[i,j]给出了最优二叉搜索树子问题的期望搜索代价。我们还需要记录最优二叉搜索树子问题的根结点，用root[i,j]来记录。<br>根据上文给出的递归式，我们可以采用自下而上的动态规划方法来求解最优二叉搜索树问题。下面给出了伪代码。</p><div align="center"><img width="500" src="/2019/12/02/动态规划习题/二叉搜索树5.png"></div><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>T15.5-2:若7 77个关键字的概率如下所示，求其最优二叉搜索树的结构和代价。</p><table><thead><tr><th align="center">i</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th></tr></thead><tbody><tr><td align="center">pi</td><td align="center"></td><td align="center">0.04</td><td align="center">0.06</td><td align="center">0.08</td><td align="center">0.02</td><td align="center">0.10</td><td align="center">0.12</td><td align="center">0.14</td></tr><tr><td align="center">qi</td><td align="center">0.06</td><td align="center">0.06</td><td align="center">0.06</td><td align="center">0.06</td><td align="center">0.05</td><td align="center">0.05</td><td align="center">0.05</td><td align="center">0.05</td></tr></tbody></table><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">optimal_bst</span><span class="params">(<span class="keyword">double</span> [] p,<span class="keyword">double</span> [] q,<span class="keyword">double</span> [][] e,<span class="keyword">double</span> [][] w, <span class="keyword">int</span> [][] root)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = p.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">e[i][i-<span class="number">1</span>] = q[i-<span class="number">1</span>];</span><br><span class="line">w[i][i-<span class="number">1</span>] = q[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=n;l++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">1</span>;start&lt;=n-l+<span class="number">1</span>;start++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> end = start + l -<span class="number">1</span>;</span><br><span class="line">w[start][end] = w[start][end-<span class="number">1</span>] + p[end] + q[end];</span><br><span class="line">e[start][end] = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> r = start;r&lt;=end;r++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> t = e[start][r-<span class="number">1</span>] + e[r+<span class="number">1</span>][end]  + w[start][end];</span><br><span class="line"><span class="keyword">if</span>(t&lt;e[start][end])</span><br><span class="line">&#123;</span><br><span class="line">e[start][end] = t;</span><br><span class="line">root[start][end] = r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> [][] root,<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == -<span class="number">1</span>)</span><br><span class="line">System.out.println(<span class="string">"k"</span> + root[a][b] + <span class="string">"为根"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r = root[a][b];</span><br><span class="line"><span class="comment">//左子树</span></span><br><span class="line"><span class="keyword">if</span>(r == a)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"d"</span> + (a - <span class="number">1</span>) + <span class="string">"是k"</span> + a + <span class="string">"d的左孩子"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"k"</span> + root[a][r-<span class="number">1</span>] + <span class="string">"是k"</span> + r +<span class="string">"的左孩子"</span>);</span><br><span class="line">print(root,a,r-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右子树</span></span><br><span class="line"><span class="keyword">if</span>(r == b)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"d"</span> + b + <span class="string">"是k"</span> + b + <span class="string">"的右孩子"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"k"</span> + root[r+<span class="number">1</span>][b] + <span class="string">"是k"</span> + r + <span class="string">"的右孩子"</span>);</span><br><span class="line">print(root,r+<span class="number">1</span>,b,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> [] p1 = &#123;<span class="number">0</span>,<span class="number">0.04</span>,<span class="number">0.06</span>,<span class="number">0.08</span>,<span class="number">0.02</span>,<span class="number">0.10</span>,<span class="number">0.12</span>,<span class="number">0.14</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> [] q1 = &#123;<span class="number">0.06</span>,<span class="number">0.06</span>,<span class="number">0.06</span>,<span class="number">0.06</span>,<span class="number">0.05</span>,<span class="number">0.05</span>,<span class="number">0.05</span>,<span class="number">0.05</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> [] p = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">double</span> [] q = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">8</span>];</span><br><span class="line">System.arraycopy(p1,<span class="number">0</span>,p,<span class="number">0</span>,<span class="number">8</span>);</span><br><span class="line">System.arraycopy(q1,<span class="number">0</span>,q,<span class="number">0</span>,<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> [][] e = <span class="keyword">new</span> <span class="keyword">double</span>[n+<span class="number">2</span>][n+<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> [][] root = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">double</span> [][] w = <span class="keyword">new</span> <span class="keyword">double</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">optimal_bst(p,q,e,w,root);</span><br><span class="line">print(root,<span class="number">1</span>,n,-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><blockquote><p>k5为根<br>k2是k5的左孩子<br>k1是k2的左孩子<br>d0是k1d的左孩子<br>d1是k1的右孩子<br>k3是k2的右孩子<br>d2是k3d的左孩子<br>k4是k3的右孩子<br>d3是k4d的左孩子<br>d4是k4的右孩子<br>k7是k5的右孩子<br>k6是k7的左孩子<br>d5是k6d的左孩子<br>d6是k6的右孩子<br>d7是k7的右孩子</p></blockquote><p>最优二叉搜索树如下所示。期望搜索代价为3.12。</p><div align="center"><img width="400" src="/2019/12/02/动态规划习题/二叉搜索树6.png"></div><div align="center"><img width="500" src="/2019/12/02/动态规划习题/二叉搜索树7.png"></div><div align="center"><img width="500" src="/2019/12/02/动态规划习题/二叉搜索树8.png"></div><div align="center"><img width="500" src="/2019/12/02/动态规划习题/二叉搜索树9.png"></div><p>图片及部分内容来自<a href="https://blog.csdn.net/yangtzhou" target="_blank" rel="noopener">yangtzhou</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;h2 id=&quot;矩阵链乘法&quot;&gt;&lt;a href=&quot;#矩阵链乘法&quot; class=&quot;headerlink&quot; title=&quot;矩阵链乘法&quot;&gt;&lt;/a&gt;矩阵链乘法&lt;/h2&gt;&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;p&gt;本节给出了一个关于矩阵链相乘问题的动态规划算法。给定一个n个矩阵&amp;lt;A1,A2,……,An&amp;gt;的矩阵链，要计算它们的乘积A1*A2*A3……An。矩阵乘法满足结合律，所以通过加括号，一个矩阵链的乘法可以按照不同的顺序进行。例如，4个矩阵的矩阵链，共有5种加括号的方式：&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法导论" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="算法" scheme="http://yorxika.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LRU缓存机制</title>
    <link href="http://yorxika.github.io/2019/12/01/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://yorxika.github.io/2019/12/01/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
    <published>2019-12-01T15:57:16.000Z</published>
    <updated>2019-12-12T12:47:06.749Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第146题LRU缓存机制</p><blockquote><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<a id="more"></a><br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><p>示例:</p><p>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );</p><p>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // 返回  1<br>cache.put(3, 3);    // 该操作会使得密钥 2 作废<br>cache.get(2);       // 返回 -1 (未找到)<br>cache.put(4, 4);    // 该操作会使得密钥 1 作废<br>cache.get(1);       // 返回 -1 (未找到)<br>cache.get(3);       // 返回  3<br>cache.get(4);       // 返回  4</p></blockquote><hr><h3 id="硬件实现的4路组相联-LRU算法"><a href="#硬件实现的4路组相联-LRU算法" class="headerlink" title="硬件实现的4路组相联 + LRU算法"></a>硬件实现的4路组相联 + LRU算法</h3><p>参考组原实验mooc</p><p>输入输出引脚图：</p><div align="center"><img width="800" src="/2019/12/01/LRU缓存机制/3.jpg"></div><p>8个cache槽分2组4路：</p><div align="center"><img width="800" src="/2019/12/01/LRU缓存机制/1.jpg"></div><p>替换算法LRU：</p><div align="center"><img width="800" src="/2019/12/01/LRU缓存机制/2.jpg"></div><p>测试图：</p><div align="center"><img width="800" src="/2019/12/01/LRU缓存机制/4.jpg"></div><h3 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h3><h4 id="哈希链表实现"><a href="#哈希链表实现" class="headerlink" title="哈希链表实现"></a>哈希链表实现</h4><p>来源<a href="https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/" target="_blank" rel="noopener">题解</a></p><p>LRU 算法实际上是让你设计数据结构：首先要接收一个 capacity 参数作为缓存的最大容量，然后实现两个 API，一个是 put(key, val) 方法存入键值对，另一个是 get(key) 方法获取 key 对应的 val，如果 key 不存在则返回 -1。</p><p>注意哦，get 和 put 方法必须都是 O(1)O(1) 的时间复杂度，我们举个具体例子来看看 LRU 算法怎么工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 缓存容量为 2 */</span></span><br><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 你可以把 cache 理解成一个队列</span></span><br><span class="line"><span class="comment">// 假设左边是队头，右边是队尾</span></span><br><span class="line"><span class="comment">// 最近使用的排在队头，久未使用的排在队尾</span></span><br><span class="line"><span class="comment">// 圆括号表示键值对 (key, val)</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// cache = [(1, 1)]</span></span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// cache = [(2, 2), (1, 1)]</span></span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回 1</span></span><br><span class="line"><span class="comment">// cache = [(1, 1), (2, 2)]</span></span><br><span class="line"><span class="comment">// 解释：因为最近访问了键 1，所以提前至队头</span></span><br><span class="line"><span class="comment">// 返回键 1 对应的值 1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// cache = [(3, 3), (1, 1)]</span></span><br><span class="line"><span class="comment">// 解释：缓存容量已满，需要删除内容空出位置</span></span><br><span class="line"><span class="comment">// 优先删除久未使用的数据，也就是队尾的数据</span></span><br><span class="line"><span class="comment">// 然后把新的数据插入队头</span></span><br><span class="line">cache.get(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line"><span class="comment">// cache = [(3, 3), (1, 1)]</span></span><br><span class="line"><span class="comment">// 解释：cache 中不存在键为 2 的数据</span></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">4</span>);    </span><br><span class="line"><span class="comment">// cache = [(1, 4), (3, 3)]</span></span><br><span class="line"><span class="comment">// 解释：键 1 已存在，把原始值 1 覆盖为 4</span></span><br><span class="line"><span class="comment">// 不要忘了也要将键值对提前到队头</span></span><br></pre></td></tr></table></figure><p>从流程里可以看到，不需要设计计数器来实现对每次未命中的cache槽做计数+1，淘汰时将数值最大的淘汰。<br>在put时将元素放到了队头，每次get都会将元素提前，我们要做的就是把队尾元素替换掉。</p><p>LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：</p><div align="center"><img width="300" src="/2019/12/01/LRU缓存机制/5.jpg"></div><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key,val;</span><br><span class="line">    <span class="keyword">public</span> Node next,prior;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head,tail ; <span class="comment">//头尾结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">//链表元素数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);  <span class="comment">//头尾虚结点</span></span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prior = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再头部添加结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        x.next = head.next;</span><br><span class="line">        x.prior = head;</span><br><span class="line">        head.next.prior = x;</span><br><span class="line">        head.next = x;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除链表中的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        x.prior.next = x.next;</span><br><span class="line">        x.next.prior = x.prior;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表中最后一个节点，并返回该节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前链表没有结点</span></span><br><span class="line">        <span class="keyword">if</span>(tail.prior == head)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node last = tail.prior;</span><br><span class="line">        remove(last);</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  HashMap&lt;Integer ,Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> DoubleList cache; <span class="comment">//双向链表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val = map.get(key).val;</span><br><span class="line">        <span class="comment">//利用put方法把数据提前</span></span><br><span class="line">        put(key,val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先把新节点 x 做出来</span></span><br><span class="line">        Node x = <span class="keyword">new</span> Node(key, val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 删除旧的节点，新的插到头部</span></span><br><span class="line">            cache.remove(map.get(key));</span><br><span class="line">            cache.addFirst(x);</span><br><span class="line">            <span class="comment">// 更新 map 中对应的数据</span></span><br><span class="line">            map.put(key, x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (capacity == cache.getSize()) &#123;</span><br><span class="line">                <span class="comment">// 删除链表最后一个数据</span></span><br><span class="line">                Node last = cache.removeLast();</span><br><span class="line">                map.remove(last.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 直接添加到头部</span></span><br><span class="line">            cache.addFirst(x);</span><br><span class="line">            map.put(key, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有序字典"><a href="#有序字典" class="headerlink" title="有序字典"></a>有序字典</h4><p>来源<a href="https://leetcode-cn.com/problems/lru-cache/solution/lru-huan-cun-ji-zhi-by-leetcode/" target="_blank" rel="noopener">题解</a></p><p>利用了LinkedHashMap这样一种数据结构<br>在构造器里第三个参数accessOrder,设置为false表示不是访问顺序而是插入顺序存储的，这也是默认值，表示LinkedHashMap中存储的顺序是按照调用put方法插入的顺序进行排序的;true则是按照<strong>访问顺序</strong>，访问过后的元素会到链表的末尾。</p><p>0.75F表示负载因子<br>HashMap有一个初始容量大小，默认是16<br>static final int DEAFULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16<br>为了减少冲突概率，当HashMap的数组长度达到一个临界值就会触发扩容，把所有元素rehash再放回容器中，这是一个非常耗时的操作。<br>而这个临界值由负载因子和当前的容量大小来决定：<br>DEFAULT_INITIAL_CAPACITY<em>DEFAULT_LOAD_FACTOR<br>即默认情况下数组长度是16</em>0.75=12时，触发扩容操作。<br>所以使用hash容器时尽量预估自己的数据量来设置初始值。<br>在理想情况下，使用随机哈希吗，节点出现的频率在hash桶中遵循泊松分布，同时给出了桶中元素的个数和概率的对照表。<br>从上表可以看出当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为负载因子，每个碰撞位置的链表长度超过8个是几乎不可能的。<br>hash容器指定初始容量尽量为2的幂次方。<br>HashMap负载因子为0.75是空间和时间成本的一种折中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRUCache 对象会以如下语句构造和调用:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自Leetcode第146题LRU缓存机制&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。&lt;/p&gt;
&lt;p&gt;获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数据结构设计" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="设计" scheme="http://yorxika.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="cache" scheme="http://yorxika.github.io/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>加油站</title>
    <link href="http://yorxika.github.io/2019/11/30/%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    <id>http://yorxika.github.io/2019/11/30/%E5%8A%A0%E6%B2%B9%E7%AB%99/</id>
    <published>2019-11-30T15:39:45.000Z</published>
    <updated>2019-12-12T12:50:42.179Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第134题加油站</p><blockquote><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。<br>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。<br>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。<a id="more"></a></p><p>说明: </p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。<br>示例 1:</li></ul><p>输入:<br>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]</p><p>输出: 3</p><p>解释:<br>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油<br>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油<br>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油<br>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油<br>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油<br>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>因此，3 可为起始索引。</p></blockquote><hr><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>这题其实和之前的53题<a href="https://yorxika.github.io/2019/11/05/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/">最大子序和是一样的</a></p><p>先考虑每个站点能剩多少油 那么就是 get[i] - cost[i]，因而能不能环形一圈就是判断所有的剩余的油加起来的值是否大于0<br>接下来找从哪出发能环绕一圈。如果当前结点的耗油量为负，或者总的耗油量为负，那么就考虑下一个位置作为起点。因为从题目我们可以知道如果题目有解，该答案即为唯一答案，因而如果在总剩余油量≥0的情况下，唯一解的每一步剩余油量都是≥0的，如果是等于0的话，就不会是唯一解了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">//位置</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rest = <span class="number">0</span>; <span class="comment">//剩余油量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; gas.length; i++)&#123;</span><br><span class="line">        rest += gas[i] - cost[i];</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sum += gas[i] - cost[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum = gas[i] - cost[i];</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rest&gt;= <span class="number">0</span>? pos : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双重循环"><a href="#双重循环" class="headerlink" title="双重循环"></a>双重循环</h4><p>最简单的无非就是求差后，对每一个元素从该位置开始进行遍历，当剩余油量小于0时continue，直到找到所求.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">//位置</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> [] rest  = <span class="keyword">new</span> <span class="keyword">int</span>[gas.length]; <span class="comment">//剩余油量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; gas.length; i++)&#123;</span><br><span class="line">        rest[i] += gas[i] - cost[i];</span><br><span class="line">        sum += rest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; gas.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rest[i] &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i ; j &lt; i + gas.length; j++)&#123;</span><br><span class="line">            sum += rest[j % gas.length];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第134题加油站&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。&lt;br&gt;你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。&lt;br&gt;如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>克隆图</title>
    <link href="http://yorxika.github.io/2019/11/30/%E5%85%8B%E9%9A%86%E5%9B%BE/"/>
    <id>http://yorxika.github.io/2019/11/30/%E5%85%8B%E9%9A%86%E5%9B%BE/</id>
    <published>2019-11-30T14:46:56.000Z</published>
    <updated>2019-12-12T12:50:50.754Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第133题克隆图</p><blockquote><p>给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值 val（Int） 和其邻居的列表（list[Node]）。</p></blockquote><a id="more"></a><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p>class Node {<br>    public int val;<br>    public List<node> neighbors;</node></p><pre><code>public Node() {}public Node(int _val,List&lt;Node&gt; _neighbors) {    val = _val;    neighbors = _neighbors;}</code></pre><p>};</p><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>这题的本质就是对图的遍历，在遍历时怎么把图的邻居添加进去。</p><p>首先对图进行一个 BFS，把所有节点 new 出来，不处理 neighbors，并且把所有的节点存到 map 中。<br>然后再对图做一个 BFS，因为此时所有的节点已经创建了，只需要更新所有节点的 neighbors。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//队列用来判断是否遍历完所有结点</span></span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//map key值为原结点，val值为克隆结点</span></span><br><span class="line">    Node new_node = <span class="keyword">new</span> Node(node.val, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">    queue.offer(node);</span><br><span class="line">    <span class="comment">//头结点入队</span></span><br><span class="line">    map.put(node, new_node);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (Node n : cur.neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(n)) &#123;</span><br><span class="line">                <span class="comment">//不包含的结点加入到map里</span></span><br><span class="line">                queue.offer(n);</span><br><span class="line">                <span class="comment">//同把该结点入队</span></span><br><span class="line">                Node tmp = <span class="keyword">new</span> Node(n.val, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">                map.put(n, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(cur).neighbors.add(map.get(n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>同样利用一个map来存储原结点和克隆结点，接着对第一个结点进行深度优先搜索，出口为当所有结点都在map时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    HashMap&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;Node,Node&gt;();</span><br><span class="line">    node = dfs(node,map);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">dfs</span><span class="params">(Node node,HashMap&lt;Node,Node&gt; map)</span></span>&#123;</span><br><span class="line">   <span class="comment">//当所有结点都在map里时退出递归</span></span><br><span class="line">    Node aNode = <span class="keyword">new</span> Node(node.val,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    map.put(node,aNode);</span><br><span class="line">    <span class="keyword">for</span>(Node neighbours : node.neighbors)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(neighbours))</span><br><span class="line">            <span class="comment">//如果没有包含此结点，从此结点一直往下遍历</span></span><br><span class="line">            neighbours = dfs(neighbours,map);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果包含了此结点，返回其克隆结点</span></span><br><span class="line">            neighbours = map.get(neighbours);</span><br><span class="line">        aNode.neighbors.add(neighbours);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> aNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第133题克隆图&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值 val（Int） 和其邻居的列表（list[Node]）。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="图" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%9B%BE/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="图" scheme="http://yorxika.github.io/tags/%E5%9B%BE/"/>
    
      <category term="深度优先搜索" scheme="http://yorxika.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>排序链表</title>
    <link href="http://yorxika.github.io/2019/11/30/%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://yorxika.github.io/2019/11/30/%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2019-11-30T01:39:03.000Z</published>
    <updated>2019-12-12T12:51:04.202Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第148题排序链表</p><blockquote><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p>示例 1:</p><p>输入: 4-&gt;2-&gt;1-&gt;3<br>输出: 1-&gt;2-&gt;3-&gt;4 <a id="more"></a></p></blockquote><hr><h4 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h4><p>将所有结点放入一个Hashset里，最后依次取出最小值，倒数第二个用例时超时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    Set&lt;ListNode&gt; list = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        list.add(p1);</span><br><span class="line">        <span class="comment">//System.out.print(p1);</span></span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//Iterator&lt;Map.Entry&lt;ListNode,Integer&gt;&gt;  it = list.entrySet().iterator();</span></span><br><span class="line">    <span class="keyword">while</span> (!list.isEmpty())&#123;</span><br><span class="line">        Iterator&lt;ListNode&gt;  it = list.iterator();</span><br><span class="line">        ListNode p2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> val = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            ListNode temp = it.next();</span><br><span class="line">            <span class="keyword">if</span>(temp.val &lt; val)&#123;</span><br><span class="line">                p2 = temp;</span><br><span class="line">                val = temp.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            newHead.val = p2.val;</span><br><span class="line">            k++;</span><br><span class="line">            p1 = newHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p1.next = p2;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        list.remove(p2);</span><br><span class="line">    &#125;</span><br><span class="line">    p1.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归归并排序"><a href="#递归归并排序" class="headerlink" title="递归归并排序"></a>递归归并排序</h4><p>来自<a href="https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/" target="_blank" rel="noopener">题解</a></p><blockquote><p>通过递归实现链表归并排序，有以下两个环节：</p></blockquote><blockquote><ul><li>分割 cut 环节： 找到当前链表中点，并从中点将链表断开（以便在下次递归 cut 时，链表片段拥有正确边界）；<ul><li>我们使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。<ul><li>找到中点 slow 后，执行 slow.next = None 将链表切断。</li><li>递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 tmp(因为链表是从 slow 切断的)。</li></ul></li><li>cut 递归终止条件： 当head.next == None时，说明只有一个节点了，直接返回此节点。</li></ul></li><li>合并 merge 环节： 将两个排序链表合并，转化为一个排序链表。<ul><li>双指针法合并，建立辅助ListNode h 作为头部。</li><li>设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。</li><li>返回辅助ListNode h 作为头部的下个节点 h.next。</li><li>时间复杂度 O(l + r)，l, r 分别代表两个链表长度。</li></ul></li><li>当题目输入的 head == None 时，直接返回None。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode fast = head.next,slow = head;</span><br><span class="line">    <span class="comment">//声明两个快慢指针</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode tmp = slow.next;</span><br><span class="line">    <span class="comment">//此时temp是中点后一个结点</span></span><br><span class="line">    <span class="comment">//若是偶数结点，tmp在中点偏右</span></span><br><span class="line">    <span class="comment">//奇数结点，tmp在中点后一个</span></span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//切割链表</span></span><br><span class="line">    ListNode left = sortList(head);</span><br><span class="line">    ListNode right = sortList(tmp);</span><br><span class="line">    <span class="comment">//递归分割左右链表</span></span><br><span class="line">    ListNode h = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//头结点作为合并链表的开始</span></span><br><span class="line">    ListNode res = h;</span><br><span class="line">    <span class="keyword">while</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//合并过程</span></span><br><span class="line">        <span class="keyword">if</span>(left.val &lt; right.val)&#123;</span><br><span class="line">            h.next = left;</span><br><span class="line">            left = left.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            h.next = right;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h.next;</span><br><span class="line">    &#125;</span><br><span class="line">    h.next = left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表转为数组排序后在转回链表"><a href="#链表转为数组排序后在转回链表" class="headerlink" title="链表转为数组排序后在转回链表"></a>链表转为数组排序后在转回链表</h4><p>来自评论区，首先将链表转为数组，对数组做排序后在放回链表里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        list.add(p1.val);</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    p1 = head;</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">        head.val = it.next();</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自Leetcode第148题排序链表&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: 4-&amp;gt;2-&amp;gt;1-&amp;gt;3&lt;br&gt;输出: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="链表" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="链表" scheme="http://yorxika.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="归并" scheme="http://yorxika.github.io/tags/%E5%BD%92%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>后缀表达式求值</title>
    <link href="http://yorxika.github.io/2019/11/29/%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <id>http://yorxika.github.io/2019/11/29/%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</id>
    <published>2019-11-29T15:33:36.000Z</published>
    <updated>2019-12-12T12:51:15.024Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第150题逆波兰表达式求值</p><blockquote><p>根据逆波兰表示法，求表达式的值。</p><p>有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><a id="more"></a><p>说明：</p><p>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。<br>示例 1：</p><p>输入: [“2”, “1”, “+”, “3”, “*”]<br>输出: 9<br>解释: ((2 + 1) * 3) = 9</p></blockquote><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>老题目了，操作数压栈，运算符2个操作数出栈，运算后在压栈.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">"+"</span>)) &#123;</span><br><span class="line">            stack.push(stack.pop() + stack.pop());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">            stack.push(-stack.pop() + stack.pop());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">            stack.push(stack.pop() * stack.pop());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = stack.pop();</span><br><span class="line">            stack.push(stack.pop() / num1);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(Integer.parseInt(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第150题逆波兰表达式求值&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根据逆波兰表示法，求表达式的值。&lt;/p&gt;
&lt;p&gt;有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="栈" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%88/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="栈" scheme="http://yorxika.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>第十行</title>
    <link href="http://yorxika.github.io/2019/11/28/%E7%AC%AC%E5%8D%81%E8%A1%8C/"/>
    <id>http://yorxika.github.io/2019/11/28/%E7%AC%AC%E5%8D%81%E8%A1%8C/</id>
    <published>2019-11-28T15:24:14.000Z</published>
    <updated>2019-12-12T12:51:26.694Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第195题第10行</p><blockquote><p>给定一个文本文件 file.txt，请只打印这个文件中的第十行。<a id="more"></a></p></blockquote><h3 id="三种解法"><a href="#三种解法" class="headerlink" title="三种解法"></a>三种解法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail -n +10 file.txt | head -n 1</span><br><span class="line">sed -n <span class="string">'10p'</span> file.txt</span><br><span class="line">awk <span class="string">'NR==10 &#123;print $0&#125;'</span> file.txt</span><br></pre></td></tr></table></figure><h4 id="tail命令和head命令"><a href="#tail命令和head命令" class="headerlink" title="tail命令和head命令"></a>tail命令和head命令</h4><p>tail命令显示最后一组文件行。默认情况下，它显示文件的最后10行，但是也是使用命令行参数更改数字，使用tail –h查看命令行参数，截图如下：</p><div align="center"><img width="600" src="https://img-blog.csdn.net/20161123103714273?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></div><p>如果K前有+，则表示显示除开头K行外所有行</p><p>head命令显示开头的一组文件行。默认情况下，它显示文件的前10行。通过head –h命令查看参数截图：</p><div align="center"><img width="600" src="https://img-blog.csdn.net/20161123103740312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></div><h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p><strong>说明</strong>：<br>1.从文件中读取数据，StreamEDitor流（行）编辑器，逐行处理文本；<br>Sed 是一个脚本型的编译器，是非交互式的编辑器<br>2.模式空间（将一行数据加载到内存，进行处理），默认不编辑源文件，仅对模式空间中的数据处理，将处理的数据输出到屏幕</p><p>用法：<br>&nbsp;&nbsp;&nbsp;&nbsp;一般用法：<br>&nbsp;&nbsp;&nbsp;&nbsp;sed [-neri] ‘指令’ file…<br>&nbsp;&nbsp;&nbsp;&nbsp;sed -f scriptsfile file…<br>选项：<br>&nbsp;&nbsp;&nbsp;&nbsp;-n 安静模式，只有经过Sed处理的行才显示出来，其他不显示<br>&nbsp;&nbsp;&nbsp;&nbsp;-e 表示直接在命令行模式上进行Sed操作（默认选项）;<br>&nbsp;&nbsp;&nbsp;&nbsp;   进行多项编辑，即对输入行应用多条sed命令时使用<br>&nbsp;&nbsp;&nbsp;&nbsp;-f 将Sed的操作写在一个文件里，用的时候“-f filename”就可以按照内容进行Sed操作<br>&nbsp;&nbsp;&nbsp;&nbsp;-r 使Sed支持扩展正则表达式(预设支持基础正则表达式)<br>&nbsp;&nbsp;&nbsp;&nbsp;-i 直接修改读取的文件内容，而不是输出到终端<br>&nbsp;&nbsp;&nbsp;&nbsp;sed 编辑指令的格式如下 :<br>              [address1[,address2]]function[argument]<br>&nbsp;&nbsp;&nbsp;&nbsp;==addres (指定需要操作的行)==<br>&nbsp;&nbsp;&nbsp;&nbsp;1. n1,n2    例：1,100 表示1至100行<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n1行开始，n2行结束<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理n1行开始到n2行结束的数据<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$符号表示文件最后一行<br>&nbsp;&nbsp;&nbsp;&nbsp;2. /RegExp/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配正则表达式<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理正则表达式匹配的行的数据<br>&nbsp;&nbsp;&nbsp;&nbsp;3. /pattern1/,/pattern2/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pattern1匹配到为行开始<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pattern2匹配到为行结束<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理pattern1,到pattern2之间所有行数据<br>&nbsp;&nbsp;&nbsp;&nbsp;4. n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定第n行的<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理指定第n行的数据<br>&nbsp;&nbsp;&nbsp;&nbsp;5. n1,+n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n1 为行开始<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+n 开始行向后n行<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理行开始到向后n行的数据<br>&nbsp;&nbsp;&nbsp;&nbsp;==function(可对数据处理的动作(sed内定函数))==<br>&nbsp;&nbsp;&nbsp;&nbsp;d 删除符合条件的行<br>&nbsp;&nbsp;&nbsp;&nbsp;D 删除模板块的第一行<br>&nbsp;&nbsp;&nbsp;&nbsp;h 拷贝模板块的内容到内存中的缓冲区<br>&nbsp;&nbsp;&nbsp;&nbsp;H 追加模板块的内容到内存中的缓冲区<br>&nbsp;&nbsp;&nbsp;&nbsp;g 获得内存缓冲区的内容，并替代当前模板块中的文本<br>&nbsp;&nbsp;&nbsp;&nbsp;G 获得内存缓冲区的内容，并追加到当前模板块文本的后面<br>&nbsp;&nbsp;&nbsp;&nbsp;p 显示符合条件的行<br>&nbsp;&nbsp;&nbsp;&nbsp;P (大写) 打印模板块的第一行<br>&nbsp;&nbsp;&nbsp;&nbsp;q 退出Sed<br>&nbsp;&nbsp;&nbsp;&nbsp;l 列表不能打印字符的清单<br>&nbsp;&nbsp;&nbsp;&nbsp;n 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。<br>&nbsp;&nbsp;&nbsp;&nbsp;N 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码<br>&nbsp;&nbsp;&nbsp;&nbsp;a &quot;string” 在指定的行后面追加新行，内容为”string”<br>&nbsp;&nbsp;&nbsp;&nbsp;i &quot;string” 在指定的行前面插入新行，内容为”string”<br>&nbsp;&nbsp;&nbsp;&nbsp;c &quot;string” 将处理的数据行,取代内容为”string”<br>&nbsp;&nbsp;&nbsp;&nbsp;r file 将指定文件的内容天骄到符合条件的行后<br>&nbsp;&nbsp;&nbsp;&nbsp;w file 将指定范围内的内容另存至指定的文件中<br>&nbsp;&nbsp;&nbsp;&nbsp;W file （大写）写并追加模板块的第一行到file末尾。<br>&nbsp;&nbsp;&nbsp;&nbsp;s/pattern/string/修饰符 查找并替换，默认只替换每行第一次被模式匹配到的字符串<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修饰符：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g 表示行内全面替换。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p 表示打印行。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w 表示把行写入一个文件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x 表示互换模板块中的文本和缓冲区中的文本。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y 表示把一个字符翻译为另外的字符（但是不用于正则表达式）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\1 子串匹配标记<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp; 已匹配字符串标记<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i 忽略大小写<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特别说明: s///,s###,s@@@都可以，当所使用的分割符号与内容中显示<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;的相同时，需使用转义字符转义 ,\1,\2：成组匹配，\1表示匹配第一<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;个‘(’，\2表示匹配第二个‘(’<br>&nbsp;&nbsp;&nbsp;&nbsp;b lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾<br>&nbsp;&nbsp;&nbsp;&nbsp;t label if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾<br>&nbsp;&nbsp;&nbsp;&nbsp;T label 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾<br>&nbsp;&nbsp;&nbsp;&nbsp;! 表示后面的命令对所有没有被选定的行发生作用。<br>&nbsp;&nbsp;&nbsp;&nbsp;= 打印当前行号码。<br>&nbsp;&nbsp;&nbsp;&nbsp;# 把注释扩展到下一个换行符以前</p><h4 id="awk操作"><a href="#awk操作" class="headerlink" title="awk操作"></a>awk操作</h4><p>awk [-F|-f] ‘BEGIN{}{command1; command2} END{}’ file<br>[-F|-f]   大参数，-F指定分隔符，-f调用脚本<br>‘  ‘          引用代码块<br>//           匹配代码块，可以是字符串或正则表达式<br>{}           命令代码块，包含一条或多条命令<br>；          多条命令使用分号分隔</p><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">awk -F : <span class="string">'&#123;print $1&#125;'</span> passwd  <span class="comment">###指定分隔符为： ，输出第一列</span></span><br><span class="line">awk -F : <span class="string">'BEGIN&#123;print '</span>hello<span class="string">'&#125;&#123;print $2&#125;'</span> passwd   <span class="comment">###指定分隔符为：，在输出前加上hello，输出第二列【hello在第一行】</span></span><br><span class="line">awk -F : <span class="string">'BEGIN&#123;n=1&#125;&#123;print $2,n&#125;'</span> passwd   <span class="comment">###指定分隔符为：，在输出的第二列每一行后面都输出n的值1</span></span><br><span class="line">awk -F : <span class="string">'BEGIN&#123;n=1&#125;&#123;print $2,n++&#125;'</span> passwd   <span class="comment">###n的值每一行会加1</span></span><br><span class="line">awk -F : <span class="string">'BEGIN&#123;n=1&#125;&#123;print n++，$1&#125;'</span> passwd   <span class="comment">###相当于序号</span></span><br><span class="line">awk -F : <span class="string">'BEGIN&#123;n=1&#125;&#123;print n++,$1&#125;END&#123;print "over"&#125;'</span> passwd <span class="comment">###指定分隔符为：，在第一列每一行开头加上n的值，n每行+1，在最后一行输出over</span></span><br><span class="line">awk -F : <span class="string">'BEGIN&#123;n=1&#125;&#123;print n++,$1&#125;END&#123;print NR&#125;'</span> passwd  <span class="comment">###指定分隔符为：，在第一列每一行开头加上n的值，n每行+1，最后一行输出有多少行</span></span><br><span class="line">awk -F : <span class="string">'BEGIN&#123;n=1&#125;&#123;print n++,$1&#125;END&#123;print NF&#125;'</span> passwd  <span class="comment">###指定分隔符为：，在第一列每一行开头加上n的值，n每行+1，最后一行输出有多少列</span></span><br><span class="line">awk <span class="string">'/bash/&#123;print&#125;'</span> passwd  <span class="comment">###输出包含bash的内容</span></span><br><span class="line">awk -F : <span class="string">'/bash/&#123;print $1&#125;'</span> passwd  <span class="comment">###输出包含bash的第一列</span></span><br><span class="line">awk -F : <span class="string">'NR==3&#123;print $1&#125;'</span> passwd <span class="comment">###输出第三行第一列</span></span><br><span class="line">awk -F : <span class="string">'NR&gt;=4&amp;&amp;NR&lt;=6&#123;print&#125;'</span> passwd <span class="comment">###输出4-6行</span></span><br><span class="line">awk -F : <span class="string">'NR==4||NR==6&#123;PRINT&#125;'</span> passwd  <span class="comment">###输出第四行和第六行</span></span><br><span class="line">awk <span class="string">'BEGIN&#123;a=34;print a+12&#125;'</span>   <span class="comment">###得到a的值46</span></span><br><span class="line">awk <span class="string">'/^[^a-d]/&#123;print&#125;'</span> passwd  <span class="comment">###输出除了以a-d开头的</span></span><br><span class="line">awk <span class="string">'/^r|bash$/&#123;print&#125;'</span> passwd  <span class="comment">###输出以r开头，或许以bash结尾的</span></span><br><span class="line">awk <span class="string">'/^r/&amp;&amp;/bash$/&#123;print&#125;'</span> passwd  <span class="comment">###并且</span></span><br><span class="line">awk -F : <span class="string">'$6~/bin$/&#123;print&#125;'</span> passwd <span class="comment">###以：为分隔符，输出第六列以bin结尾的</span></span><br><span class="line">awk -F : <span class="string">'$6!~/\&lt;bin$/&#123;print&#125;'</span> passwd  <span class="comment">###输出第六列不是以bin结尾且bin前面没有内容的【非贪婪模式】</span></span><br><span class="line">awk -F : <span class="string">'BEGIN=&#123;N=0&#125;$6!~/^\/home/&amp;&amp;$7~/bash$/&#123;print $1;N++&#125;END&#123;print N&#125;'</span> /etc/passwd <span class="comment">###并统计个数</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第195题第10行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个文本文件 file.txt，请只打印这个文件中的第十行。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="命令行" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="Bash" scheme="http://yorxika.github.io/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>杨辉三角II</title>
    <link href="http://yorxika.github.io/2019/11/28/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/"/>
    <id>http://yorxika.github.io/2019/11/28/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/</id>
    <published>2019-11-28T14:28:11.000Z</published>
    <updated>2019-12-12T12:51:52.505Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第119题杨辉三角II</p><blockquote><p>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。<br>示例:</p><p>输入: 3<br>输出: [1,3,3,1]<br>进阶：</p><p>你可以优化你的算法到 O(k) 空间复杂度吗？<a id="more"></a></p></blockquote><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>思路同上一题杨辉三角，按序求出第0行到第N行，返回第N行即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rowIndex;i++)&#123;</span><br><span class="line">        List&lt;Integer&gt; subList=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">2</span>) &#123;<span class="comment">//前两行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                subList.add(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(subList);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            subList.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">                Integer twoSum=list.get(i-<span class="number">1</span>).get(j-<span class="number">1</span>)+list.get(i-<span class="number">1</span>).get(j);</span><br><span class="line">                subList.add(twoSum);</span><br><span class="line">            &#125;</span><br><span class="line">            subList.add(<span class="number">1</span>);</span><br><span class="line">            list.add(subList);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> list.get(rowIndex - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h4><p>只用当前行，从当前行构造出下一行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    cur.add(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = cur.get(j);</span><br><span class="line">            cur.set(j, pre + cur.get(j));</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h4><p>杨辉三角第n行第k列的值为：<br>C(n,k) =n!/(k!(n−k)!)=(n∗(n−1)∗(n−2)∗…(n−k+1))/k!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> n = rowIndex;</span><br><span class="line">    <span class="keyword">long</span> pre = <span class="number">1</span>;</span><br><span class="line">    ans.add(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; k &lt;= (n + <span class="number">1</span>) /<span class="number">2</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">long</span> cur = pre * (n - k + <span class="number">1</span>) / k;</span><br><span class="line">        ans.add((<span class="keyword">int</span>) cur);</span><br><span class="line">        pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;k &lt;=n; k++)&#123;</span><br><span class="line">        ans.add(ans.get(n - k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h4><p>评论区看到的2333</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">pre33</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Integer[][] list = <span class="keyword">new</span> Integer[][]&#123;</span><br><span class="line">        &#123;<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">7</span>,<span class="number">21</span>,<span class="number">35</span>,<span class="number">35</span>,<span class="number">21</span>,<span class="number">7</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">28</span>,<span class="number">56</span>,<span class="number">70</span>,<span class="number">56</span>,<span class="number">28</span>,<span class="number">8</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">36</span>,<span class="number">84</span>,<span class="number">126</span>,<span class="number">126</span>,<span class="number">84</span>,<span class="number">36</span>,<span class="number">9</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">45</span>,<span class="number">120</span>,<span class="number">210</span>,<span class="number">252</span>,<span class="number">210</span>,<span class="number">120</span>,<span class="number">45</span>,<span class="number">10</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">11</span>,<span class="number">55</span>,<span class="number">165</span>,<span class="number">330</span>,<span class="number">462</span>,<span class="number">462</span>,<span class="number">330</span>,<span class="number">165</span>,<span class="number">55</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">12</span>,<span class="number">66</span>,<span class="number">220</span>,<span class="number">495</span>,<span class="number">792</span>,<span class="number">924</span>,<span class="number">792</span>,<span class="number">495</span>,<span class="number">220</span>,<span class="number">66</span>,<span class="number">12</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">13</span>,<span class="number">78</span>,<span class="number">286</span>,<span class="number">715</span>,<span class="number">1287</span>,<span class="number">1716</span>,<span class="number">1716</span>,<span class="number">1287</span>,<span class="number">715</span>,<span class="number">286</span>,<span class="number">78</span>,<span class="number">13</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">14</span>,<span class="number">91</span>,<span class="number">364</span>,<span class="number">1001</span>,<span class="number">2002</span>,<span class="number">3003</span>,<span class="number">3432</span>,<span class="number">3003</span>,<span class="number">2002</span>,<span class="number">1001</span>,<span class="number">364</span>,<span class="number">91</span>,<span class="number">14</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">15</span>,<span class="number">105</span>,<span class="number">455</span>,<span class="number">1365</span>,<span class="number">3003</span>,<span class="number">5005</span>,<span class="number">6435</span>,<span class="number">6435</span>,<span class="number">5005</span>,<span class="number">3003</span>,<span class="number">1365</span>,<span class="number">455</span>,<span class="number">105</span>,<span class="number">15</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">16</span>,<span class="number">120</span>,<span class="number">560</span>,<span class="number">1820</span>,<span class="number">4368</span>,<span class="number">8008</span>,<span class="number">11440</span>,<span class="number">12870</span>,<span class="number">11440</span>,<span class="number">8008</span>,<span class="number">4368</span>,<span class="number">1820</span>,<span class="number">560</span>,<span class="number">120</span>,<span class="number">16</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">17</span>,<span class="number">136</span>,<span class="number">680</span>,<span class="number">2380</span>,<span class="number">6188</span>,<span class="number">12376</span>,<span class="number">19448</span>,<span class="number">24310</span>,<span class="number">24310</span>,<span class="number">19448</span>,<span class="number">12376</span>,<span class="number">6188</span>,<span class="number">2380</span>,<span class="number">680</span>,<span class="number">136</span>,<span class="number">17</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">18</span>,<span class="number">153</span>,<span class="number">816</span>,<span class="number">3060</span>,<span class="number">8568</span>,<span class="number">18564</span>,<span class="number">31824</span>,<span class="number">43758</span>,<span class="number">48620</span>,<span class="number">43758</span>,<span class="number">31824</span>,<span class="number">18564</span>,<span class="number">8568</span>,<span class="number">3060</span>,<span class="number">816</span>,<span class="number">153</span>,<span class="number">18</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">19</span>,<span class="number">171</span>,<span class="number">969</span>,<span class="number">3876</span>,<span class="number">11628</span>,<span class="number">27132</span>,<span class="number">50388</span>,<span class="number">75582</span>,<span class="number">92378</span>,<span class="number">92378</span>,<span class="number">75582</span>,<span class="number">50388</span>,<span class="number">27132</span>,<span class="number">11628</span>,<span class="number">3876</span>,<span class="number">969</span>,<span class="number">171</span>,<span class="number">19</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">20</span>,<span class="number">190</span>,<span class="number">1140</span>,<span class="number">4845</span>,<span class="number">15504</span>,<span class="number">38760</span>,<span class="number">77520</span>,<span class="number">125970</span>,<span class="number">167960</span>,<span class="number">184756</span>,<span class="number">167960</span>,<span class="number">125970</span>,<span class="number">77520</span>,<span class="number">38760</span>,<span class="number">15504</span>,<span class="number">4845</span>,<span class="number">1140</span>,<span class="number">190</span>,<span class="number">20</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">21</span>,<span class="number">210</span>,<span class="number">1330</span>,<span class="number">5985</span>,<span class="number">20349</span>,<span class="number">54264</span>,<span class="number">116280</span>,<span class="number">203490</span>,<span class="number">293930</span>,<span class="number">352716</span>,<span class="number">352716</span>,<span class="number">293930</span>,<span class="number">203490</span>,<span class="number">116280</span>,<span class="number">54264</span>,<span class="number">20349</span>,<span class="number">5985</span>,<span class="number">1330</span>,<span class="number">210</span>,<span class="number">21</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">22</span>,<span class="number">231</span>,<span class="number">1540</span>,<span class="number">7315</span>,<span class="number">26334</span>,<span class="number">74613</span>,<span class="number">170544</span>,<span class="number">319770</span>,<span class="number">497420</span>,<span class="number">646646</span>,<span class="number">705432</span>,<span class="number">646646</span>,<span class="number">497420</span>,<span class="number">319770</span>,<span class="number">170544</span>,<span class="number">74613</span>,<span class="number">26334</span>,<span class="number">7315</span>,<span class="number">1540</span>,<span class="number">231</span>,<span class="number">22</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">253</span>,<span class="number">1771</span>,<span class="number">8855</span>,<span class="number">33649</span>,<span class="number">100947</span>,<span class="number">245157</span>,<span class="number">490314</span>,<span class="number">817190</span>,<span class="number">1144066</span>,<span class="number">1352078</span>,<span class="number">1352078</span>,<span class="number">1144066</span>,<span class="number">817190</span>,<span class="number">490314</span>,<span class="number">245157</span>,<span class="number">100947</span>,<span class="number">33649</span>,<span class="number">8855</span>,<span class="number">1771</span>,<span class="number">253</span>,<span class="number">23</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">24</span>,<span class="number">276</span>,<span class="number">2024</span>,<span class="number">10626</span>,<span class="number">42504</span>,<span class="number">134596</span>,<span class="number">346104</span>,<span class="number">735471</span>,<span class="number">1307504</span>,<span class="number">1961256</span>,<span class="number">2496144</span>,<span class="number">2704156</span>,<span class="number">2496144</span>,<span class="number">1961256</span>,<span class="number">1307504</span>,<span class="number">735471</span>,<span class="number">346104</span>,<span class="number">134596</span>,<span class="number">42504</span>,<span class="number">10626</span>,<span class="number">2024</span>,<span class="number">276</span>,<span class="number">24</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">25</span>,<span class="number">300</span>,<span class="number">2300</span>,<span class="number">12650</span>,<span class="number">53130</span>,<span class="number">177100</span>,<span class="number">480700</span>,<span class="number">1081575</span>,<span class="number">2042975</span>,<span class="number">3268760</span>,<span class="number">4457400</span>,<span class="number">5200300</span>,<span class="number">5200300</span>,<span class="number">4457400</span>,<span class="number">3268760</span>,<span class="number">2042975</span>,<span class="number">1081575</span>,<span class="number">480700</span>,<span class="number">177100</span>,<span class="number">53130</span>,<span class="number">12650</span>,<span class="number">2300</span>,<span class="number">300</span>,<span class="number">25</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">26</span>,<span class="number">325</span>,<span class="number">2600</span>,<span class="number">14950</span>,<span class="number">65780</span>,<span class="number">230230</span>,<span class="number">657800</span>,<span class="number">1562275</span>,<span class="number">3124550</span>,<span class="number">5311735</span>,<span class="number">7726160</span>,<span class="number">9657700</span>,<span class="number">10400600</span>,<span class="number">9657700</span>,<span class="number">7726160</span>,<span class="number">5311735</span>,<span class="number">3124550</span>,<span class="number">1562275</span>,<span class="number">657800</span>,<span class="number">230230</span>,<span class="number">65780</span>,<span class="number">14950</span>,<span class="number">2600</span>,<span class="number">325</span>,<span class="number">26</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">27</span>,<span class="number">351</span>,<span class="number">2925</span>,<span class="number">17550</span>,<span class="number">80730</span>,<span class="number">296010</span>,<span class="number">888030</span>,<span class="number">2220075</span>,<span class="number">4686825</span>,<span class="number">8436285</span>,<span class="number">13037895</span>,<span class="number">17383860</span>,<span class="number">20058300</span>,<span class="number">20058300</span>,<span class="number">17383860</span>,<span class="number">13037895</span>,<span class="number">8436285</span>,<span class="number">4686825</span>,<span class="number">2220075</span>,<span class="number">888030</span>,<span class="number">296010</span>,<span class="number">80730</span>,<span class="number">17550</span>,<span class="number">2925</span>,<span class="number">351</span>,<span class="number">27</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">28</span>,<span class="number">378</span>,<span class="number">3276</span>,<span class="number">20475</span>,<span class="number">98280</span>,<span class="number">376740</span>,<span class="number">1184040</span>,<span class="number">3108105</span>,<span class="number">6906900</span>,<span class="number">13123110</span>,<span class="number">21474180</span>,<span class="number">30421755</span>,<span class="number">37442160</span>,<span class="number">40116600</span>,<span class="number">37442160</span>,<span class="number">30421755</span>,<span class="number">21474180</span>,<span class="number">13123110</span>,<span class="number">6906900</span>,<span class="number">3108105</span>,<span class="number">1184040</span>,<span class="number">376740</span>,<span class="number">98280</span>,<span class="number">20475</span>,<span class="number">3276</span>,<span class="number">378</span>,<span class="number">28</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">29</span>,<span class="number">406</span>,<span class="number">3654</span>,<span class="number">23751</span>,<span class="number">118755</span>,<span class="number">475020</span>,<span class="number">1560780</span>,<span class="number">4292145</span>,<span class="number">10015005</span>,<span class="number">20030010</span>,<span class="number">34597290</span>,<span class="number">51895935</span>,<span class="number">67863915</span>,<span class="number">77558760</span>,<span class="number">77558760</span>,<span class="number">67863915</span>,<span class="number">51895935</span>,<span class="number">34597290</span>,<span class="number">20030010</span>,<span class="number">10015005</span>,<span class="number">4292145</span>,<span class="number">1560780</span>,<span class="number">475020</span>,<span class="number">118755</span>,<span class="number">23751</span>,<span class="number">3654</span>,<span class="number">406</span>,<span class="number">29</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">30</span>,<span class="number">435</span>,<span class="number">4060</span>,<span class="number">27405</span>,<span class="number">142506</span>,<span class="number">593775</span>,<span class="number">2035800</span>,<span class="number">5852925</span>,<span class="number">14307150</span>,<span class="number">30045015</span>,<span class="number">54627300</span>,<span class="number">86493225</span>,<span class="number">119759850</span>,<span class="number">145422675</span>,<span class="number">155117520</span>,<span class="number">145422675</span>,<span class="number">119759850</span>,<span class="number">86493225</span>,<span class="number">54627300</span>,<span class="number">30045015</span>,<span class="number">14307150</span>,<span class="number">5852925</span>,<span class="number">2035800</span>,<span class="number">593775</span>,<span class="number">142506</span>,<span class="number">27405</span>,<span class="number">4060</span>,<span class="number">435</span>,<span class="number">30</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">31</span>,<span class="number">465</span>,<span class="number">4495</span>,<span class="number">31465</span>,<span class="number">169911</span>,<span class="number">736281</span>,<span class="number">2629575</span>,<span class="number">7888725</span>,<span class="number">20160075</span>,<span class="number">44352165</span>,<span class="number">84672315</span>,<span class="number">141120525</span>,<span class="number">206253075</span>,<span class="number">265182525</span>,<span class="number">300540195</span>,<span class="number">300540195</span>,<span class="number">265182525</span>,<span class="number">206253075</span>,<span class="number">141120525</span>,<span class="number">84672315</span>,<span class="number">44352165</span>,<span class="number">20160075</span>,<span class="number">7888725</span>,<span class="number">2629575</span>,<span class="number">736281</span>,<span class="number">169911</span>,<span class="number">31465</span>,<span class="number">4495</span>,<span class="number">465</span>,<span class="number">31</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">32</span>,<span class="number">496</span>,<span class="number">4960</span>,<span class="number">35960</span>,<span class="number">201376</span>,<span class="number">906192</span>,<span class="number">3365856</span>,<span class="number">10518300</span>,<span class="number">28048800</span>,<span class="number">64512240</span>,<span class="number">129024480</span>,<span class="number">225792840</span>,<span class="number">347373600</span>,<span class="number">471435600</span>,<span class="number">565722720</span>,<span class="number">601080390</span>,<span class="number">565722720</span>,<span class="number">471435600</span>,<span class="number">347373600</span>,<span class="number">225792840</span>,<span class="number">129024480</span>,<span class="number">64512240</span>,<span class="number">28048800</span>,<span class="number">10518300</span>,<span class="number">3365856</span>,<span class="number">906192</span>,<span class="number">201376</span>,<span class="number">35960</span>,<span class="number">4960</span>,<span class="number">496</span>,<span class="number">32</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">33</span>,<span class="number">528</span>,<span class="number">5456</span>,<span class="number">40920</span>,<span class="number">237336</span>,<span class="number">1107568</span>,<span class="number">4272048</span>,<span class="number">13884156</span>,<span class="number">38567100</span>,<span class="number">92561040</span>,<span class="number">193536720</span>,<span class="number">354817320</span>,<span class="number">573166440</span>,<span class="number">818809200</span>,<span class="number">1037158320</span>,<span class="number">1166803110</span>,<span class="number">1166803110</span>,<span class="number">1037158320</span>,<span class="number">818809200</span>,<span class="number">573166440</span>,<span class="number">354817320</span>,<span class="number">193536720</span>,<span class="number">92561040</span>,<span class="number">38567100</span>,<span class="number">13884156</span>,<span class="number">4272048</span>,<span class="number">1107568</span>,<span class="number">237336</span>,<span class="number">40920</span>,<span class="number">5456</span>,<span class="number">528</span>,<span class="number">33</span>,<span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(pre33.list[rowIndex]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第119题杨辉三角II&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。&lt;br&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: 3&lt;br&gt;输出: [1,3,3,1]&lt;br&gt;进阶：&lt;/p&gt;
&lt;p&gt;你可以优化你的算法到 O(k) 空间复杂度吗？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>SOCKET编程</title>
    <link href="http://yorxika.github.io/2019/11/28/SOCKET%E7%BC%96%E7%A8%8B/"/>
    <id>http://yorxika.github.io/2019/11/28/SOCKET%E7%BC%96%E7%A8%8B/</id>
    <published>2019-11-27T17:35:33.000Z</published>
    <updated>2019-12-12T12:49:47.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Socket套接字介绍"><a href="#Socket套接字介绍" class="headerlink" title="Socket套接字介绍"></a>Socket套接字介绍</h3><p>网络应用程序是由通信进程对组成，每对互相通信的应用程序进程互相发送报文，他们之间的通信必须通过下面的网络来进行。为了将应用程序和底层的网络通信协议屏蔽开来，采用套接字（Socket）这样一个抽象概念来作为应用程序和底层网络之间的应用程序编程接口（API）。<a id="more"></a><br>因为网络应用程序是进程之间的通信，为了唯一的标识通信对等方的通信进程，套接字必须包含2种信息：(1) 通信对等方的网络地址。(2) 通信对等方的进程号，通常叫端口号。<br>就像Unix操作系统下有一套实现TCP/IP网络通信协议的开发接口：BSD Sockets一样，在Windows操作系统下，也提供了一套网络通信协议的开发接口，称为Windows Sockets或简称Winsock。<br>Winsock 是通过动态链接库的方式提供给软件开发者，而且从Windows 95以后已经被集成到了Windows操作系统中。<br>Winsock主要经历了2个版本：Winsock 1.1和Winsock 2.0。Winsock 2.0是Winsock 1.1的扩展，它向下完全兼容。<br>Winsock同时包括了16位和32位的编程接口，16位的Windows Socket 2应用程序使用的动态链接库是WINSOCK.DLL，而32位的Windows Socket应用程序使用WSOCK32.DLL（Winsock 1.1版）和WS2_32.DLL（Winsock 2.0版）。另外，使用Winsock API时要包含头文件winsock.h（Winsock 1.1版）或winsock2.h（Winsock 2.0版）。</p><h3 id="Socket套接字编程原理"><a href="#Socket套接字编程原理" class="headerlink" title="Socket套接字编程原理"></a>Socket套接字编程原理</h3><h4 id="Socket的2种类型"><a href="#Socket的2种类型" class="headerlink" title="Socket的2种类型"></a>Socket的2种类型</h4><p>Socket是一个抽象概念，代表了通信双方的端点（Endpoint），通信双方通过Socket发送或接收数据。<br>在Winsock里，用数据类型SOCKET作为Windows Sockets对象的句柄，就好像一个窗口的句柄HWND、一个打开的文件的文件指针一样。下面我们会看到，在Winsock API的许多函数里，都会用到SOCKET类型的参数。<br>Socket有2种类型：</p><ul><li>流类型（Stream Sockets）。<br>流式套接字提供了一种可靠的、面向连接的数据传输方法，使用传输控制协议TCP。</li><li>数据报类型（Datagram Sockets）。<br>数据报套接字提供了一种不可靠的、非连接的数据包传输方式，使用用户数据报协议UDP。</li></ul><h4 id="Socket-I-O的2种模式"><a href="#Socket-I-O的2种模式" class="headerlink" title="Socket I/O的2种模式"></a>Socket I/O的2种模式</h4><p>一个SOCKET句柄可以看成代表了一个I/O设备。在Windows Sockets里，有2种I/O模式：</p><ul><li>阻塞式I/O（blocking I/O）<br>在阻塞方式下，收发数据的函数在调用后一直要到传送完毕或者出错才能完成，在阻塞期间，除了等待网络操作的完成不能进行任何操作。阻塞式I/O是一个Winsock API函数的缺省行为。</li><li>非阻塞式I/O（non-blocking I/O）<br>对于非阻塞方式，Winsock API函数被调用后立即返回；当网络操作完成后，由Winsock给应用程序发送消息（Socket Notifications）通知操作完成，这时应用程序可以根据发送的消息中的参数对消息做出响应。Winsock提供了2种异步接受数据的方法：一种方法是使用BSD类型的函数select（），另外一种方法是使用Winsock提供的专用函数WSAAsyncSelect（）。</li></ul><h4 id="使用数据报套接字"><a href="#使用数据报套接字" class="headerlink" title="使用数据报套接字"></a>使用数据报套接字</h4><p>首先，客户机和服务器都要创建一个数据报套接字。接着，服务器调用bind（）函数给套接字分配一个公认的端口。一旦服务器将公认的端口分配给了套接字，客户机和服务器都能使用sendto（）和revfron（）来传递数据报。通信完毕调用closesocket（）来关闭套接字。流程如图2.1所示：</p><div align="center"><img width="600" src="/2019/11/28/SOCKET编程/1.jpg"></div><h4 id="使用流式套接字"><a href="#使用流式套接字" class="headerlink" title="使用流式套接字"></a>使用流式套接字</h4><p>由于流式套接字使用的是基于连接的协议，所以你必须首先建立连接，而后才能从数据流中读出数据，而不是从一个数据报或一个记录中读出数据，其流程如图2.2所示。</p><div align="center"><img width="600" src="/2019/11/28/SOCKET编程/2.jpg"></div><h3 id="套接字部分库函数列表"><a href="#套接字部分库函数列表" class="headerlink" title="套接字部分库函数列表"></a>套接字部分库函数列表</h3><h4 id="WSAStartup（）"><a href="#WSAStartup（）" class="headerlink" title="WSAStartup（）"></a>WSAStartup（）</h4><p><strong>函数原型</strong><br>int WSAStartup (WORD wVersionRequested,  LPWSADATA  lpWSAData  );</p><p><strong>参数</strong><br>wVersionRequested<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 表示欲使用的Windows Sockets API版本；这是个WORD类型的整数，高字节定义的是次版本号，低字节定义的是主版本号。<br>lpWSAData<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 指向WSAData资料的指针。WSAData是结构数据类型，描述了关于Windows Sockecs底层实现的相关信息。<br>&nbsp;&nbsp;&nbsp;&nbsp;<br><strong>返回值</strong><br>函数执行成功返回0，失败则返回如下错误代码：<br>&nbsp;&nbsp;&nbsp;&nbsp;WSASYSNOTREADY：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 底层网络子系统没有准备好。<br>&nbsp;&nbsp;&nbsp;&nbsp;WSAVERNOTSUPPORTED：Winsock版本信息号不支持。WSAEINPROGRESS：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 阻塞式Winsock1.1存在于进程中。<br>&nbsp;&nbsp;&nbsp;&nbsp;WSAEPROCLIM：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 已经达到Winsock使用量的上限。<br>&nbsp;&nbsp;&nbsp;&nbsp;WSAEFAULT：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpWSAData不是一个有效的指针。<br>&nbsp;&nbsp;&nbsp;&nbsp;<br><strong>函数功能</strong><br>这个函数是应用程序应该第一个调用的Winsock API函数，以完成一系列初始化的工作。</p><p><strong>相关数据结构</strong><br>WSADATA的定义如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;typedef struct WSAData {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WORD&nbsp;&nbsp;&nbsp;&nbsp;wVersion;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WORD &nbsp;&nbsp;&nbsp;&nbsp;wHighVersion;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;szDescription[WSADESCRIPTION_LEN+1];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char &nbsp;&nbsp;&nbsp;&nbsp;szSystemStatus[WSASYS_STATUS_LEN+1];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iMaxSockets;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iMaxUdpDg;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char FAR * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lpVendorInfo;<br>} WSADATA, FAR * LPWSADATA;<br>其中，各结构成员的含义为:<br>wVersion<br>&nbsp;&nbsp;&nbsp;&nbsp;应用程序应该使用的Winsock版本号。<br>wHighVersion<br>&nbsp;&nbsp;&nbsp;&nbsp;DLL所支持的最高版本号。通常应该等于wVersion。<br>szDescription<br>&nbsp;&nbsp;&nbsp;&nbsp;以0结尾的ASCII字符串，关于Winsock底层实现的描述信息。<br>szSystemStatus<br>&nbsp;&nbsp;&nbsp;&nbsp;以0结尾的ASCII字符串，关于Winsock底层状态或者配置信息。<br>iMaxSockets<br>&nbsp;&nbsp;&nbsp;&nbsp;一个进程最多可使用的套接字数，仅用于Winsock1.1，Winsock 2.0应该忽略该成员。<br>iMaxUdpDg<br>&nbsp;&nbsp;&nbsp;&nbsp;最大的UDP报文大小，仅用于Winsock1.1，Winsock 2.0应该忽略该成员。对于Winsock 2.0，应该使用getsockopt函数取得SO_MAX_MSG_SIZE。<br>lpVendorInfo<br>&nbsp;&nbsp;&nbsp;&nbsp;Winsock开发厂商信息，仅用于Winsock1.1，Winsock 2.0应该忽略该成员。对于Winsock 2.0，应该使用getsockopt函数取得PVD_CONFIG。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock.h&gt;</span></span></span><br><span class="line"><span class="comment">//对于Winsock 2, include &lt;winsock2.h&gt;</span></span><br><span class="line"></span><br><span class="line">WSADATA  wsaData;</span><br><span class="line"><span class="keyword">int</span> nRc = WSAStartup(<span class="number">0x0101</span>, &amp; wsaData);</span><br><span class="line"><span class="keyword">if</span>(nRc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//Winsock初始化错误</span></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(wsaData.wVersion != <span class="number">0x0101</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//版本支持不够</span></span><br><span class="line"><span class="comment">//报告错误给用户，清除Winsock，返回</span></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WSACleanup();</span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="socket（）"><a href="#socket（）" class="headerlink" title="socket（）"></a>socket（）</h4><p><strong>函数原型</strong><br>SOCKET socket(int af, int type,    int protocol);</p><p><strong>参数</strong><br>af<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 指定地址族（address family），一般填AF_INET（使用Internet地址）。<br>type<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 指定SOCKET的类型：SOCK_STREAM（流类型），SOCK_DGRAM（数据报类型）。<br>protocol<br>&nbsp;&nbsp;&nbsp;&nbsp;[in]    指定af参数指定的地址族所使用的具体一个协议。建议设为0，那么它就会根据地址格式和SOCKET类型，自动为你选择一个合适的协议。另外2个常用的值为：IPPROTO_UDP和IPPROTO_TCP。<br><strong>返回值</strong><br>函数执行成功返回一个新的SOCKET，失败则返回INVALID_SOCKET。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>所有的通信在建立之前都要创建一个SOCKET。</p><p>示例代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="comment">//创建数据报socket</span></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SCOKET udpSock = socket(AF_INET, </span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="comment">//创建流socket</span></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SCOKET tcpSock = socket(AF_INET, </span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SOCK_STREAM, IPPROTO_TCP);</span><br></pre></td></tr></table></figure><h4 id="bind（）"><a href="#bind（）" class="headerlink" title="bind（）"></a>bind（）</h4><p><strong>函数原型</strong><br>int bind(SOCKET s, const struct sockaddr FAR* name, int namelen);</p><p><strong>参数</strong><br>s<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 一个需要绑定的SOCKET，例如用socket函数创建的SOCKET。<br>name<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 指向描述通信对象地址信息的结构体sockaddr的指针。在该结构体中可以指定地址族（一般为 AF_INET）、主机的地址和端口。通常把主机地址指定为INADDR_ANY（一个主机可能有多个网卡）。<br>namelen<br>&nbsp;&nbsp;&nbsp;&nbsp;[in]    name指针指向的结构体的长度。<br><strong>返回值</strong><br>函数执行成功返回0，失败则返回SOCKET_ERROR。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>成功地创建了一个SOCKET后，用bind函数将SOCKET和主机地址绑定。</p><p><strong>相关数据结构</strong><br>struct sockaddr {<br>&nbsp;&nbsp;&nbsp;&nbsp;u_short         sa_family;<br>&nbsp;&nbsp;&nbsp;&nbsp;char         sa_data[14];<br>};<br>sa_family<br>地址族，比如AF_INET，2个字节大小。<br>sa_data<br>用来存放地址和端口，14个字节大小。<br>sockaddr结构是一个通用的结构（因为Winsock支持的协议族不只是TCP/IP）。对TCP/IP协议，用如下结构来定义地址和端口。<br>struct sockaddr_in {<br>&nbsp;&nbsp;&nbsp;&nbsp;short             sin_family;<br>&nbsp;&nbsp;&nbsp;&nbsp;u_short            sin_port;<br>&nbsp;&nbsp;&nbsp;&nbsp;struct  in_addr    sin_addr;<br>&nbsp;&nbsp;&nbsp;&nbsp;char             sin_zero[8];<br>};<br>sin_family<br>&nbsp;&nbsp;&nbsp;&nbsp;地址族，设为AF_INET。<br>sin_port<br>&nbsp;&nbsp;&nbsp;&nbsp;端口号。如果端口号为0，Winsock会自动为应用程序分配一个值在1024-5000间的一个端口号，所以客户端一般把sin_port设为0。<br>sin_addr<br>&nbsp;&nbsp;&nbsp;&nbsp;为in_addr结构类型，用来指定IP地址。通常把主机地址指定为INADDR_ANY（一个主机可能有多个网卡）。结构in_addr下面介绍。<br>sin_zero<br>&nbsp;&nbsp;&nbsp;&nbsp;8字节的数组，值全为0。这个8个字节用来填充结构sockaddr_in，使其大小等于结构sockaddr（16字节）。<br>结构in_addr用来指定IP地址，其定义为：<br>struct in_addr {<br>&nbsp;union {<br>&nbsp;&nbsp;&nbsp;&nbsp;struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;<br>&nbsp;&nbsp;&nbsp;&nbsp;struct { u_short s_w1,s_w2; } S_un_w;<br>&nbsp;&nbsp;&nbsp;&nbsp; u_long S_addr;<br>&nbsp;} S_un;<br>};<br>对于IP地址10.14.25.90，sockaddr_in结构中的sin_addr可以这样赋值：<br>sin_addr. S_un .S_un_b. s_b1 = 10;<br>sin_addr. S_un .S_un_b. s_b2 = 14;<br>sin_addr. S_un .S_un_b. s_b3 = 25;<br>sin_addr. S_un .S_un_b. s_b4 = 90;<br>或者<br>sin_addr. S_un . S_un_w. s_w1 = (14&lt;&lt;8)|10;<br>sin_addr. S_un . S_un_w. s_w2 = (90&lt;&lt;8)|25;<br>或者<br>sin_addr. S_un . S_addr = (90&lt;&lt;24)|(25&lt;&lt;16)|(14&lt;&lt;8)|10;<br>或者<br>sin_addr. S_un . S_addr = inet_addr(“10.14.25.90”);<br>这里的inet_addr函数可以将字符串形式的IP地址转换为unsigned long形式的值。</p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SOCKET sServSock;</span><br><span class="line">sockaddr_in addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建socket</span></span><br><span class="line">sServSock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line"><span class="comment">//htons和htonl函数把主机字节顺序转换为网络字节顺序，分别用于//短整型和长整型数据</span></span><br><span class="line">addr.sin_port = htons(<span class="number">5050</span>);</span><br><span class="line">addr.sin_addr.S_un.S_addr = htonl(INADDR_ANY); </span><br><span class="line"></span><br><span class="line"><span class="comment">// LPSOCKADDR类型转换是必须的</span></span><br><span class="line"><span class="keyword">int</span> nRc = bind(sServSock, (LPSOCKADDR)&amp;addr, <span class="keyword">sizeof</span>(addr) );</span><br></pre></td></tr></table></figure><h4 id="listen（）"><a href="#listen（）" class="headerlink" title="listen（）"></a>listen（）</h4><p><strong>函数原型</strong><br>int listen (SOCKET s,  int backlog);</p><p><strong>参数</strong><br>s<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 一个已经绑定但未连接的SOCKET。<br>backlog<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 等待连接的队列的长度，可取SOMAXCONN。如果某个客户程序要求连接的时候，服务器已经与其他客户程序连接，则后来的连接请求会放在等待队列中，等待服务器空闲时再与之连接。当等待队列达到最大长度（backlog指定的值）时，再来的连接请求都将被拒绝。<br><strong>返回值</strong><br>函数执行成功返回0，失败则返回SOCKET_ERROR。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>对于服务器的程序，当申请到SOCKET,并将通信对象指定为INADDR_ANY之后，就应该等待一个客户机的程序来要求连接，listen函数就是把一个SOCKET设置为这个状态。</p><h4 id="accept（）"><a href="#accept（）" class="headerlink" title="accept（）"></a>accept（）</h4><p><strong>函数原型</strong><br>SOCKET accept (SOCKET s, struct sockaddr FAR* addr,<br>int FAR* addrlen );</p><p><strong>参数</strong><br>s<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 一个已经处于listen状态的SOCKET。<br>addr<br>&nbsp;&nbsp;&nbsp;&nbsp;[out] 指向sockaddr结构体的指针，里面包含了客户端的地址和端口。<br>addrlen<br>&nbsp;&nbsp;&nbsp;&nbsp;[out] int型指针，指向的内容为addr指针指向的结构体的长度。<br><strong>返回值</strong><br>如果函数执行成功，会建立并返回一个新的SOCKET来与对方通信，新建的SOCKET与原来的SOCKET（函数的第一个参数s）有相同的特性，包括端口号。原来的SOCKET继续等待其他的连接请求。而新生成的SOCKET才是与客户端通信的实际SOCKET。所以一般将参数中的SOCKET称作“监听”SOCKET，它只负责接受连接，不负责通话；而对于函数返回的SOCKET，把它称作“会话”SOCKET，它负责与客户端通话。<br>如果失败则返回INVALID_SOCKET。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>accept函数从等待连接的队列中取第一个连接请求，并且创建一个新的SOCKET来负责与客户端会话。</p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">SOCKET sServSock;<span class="comment">//服务器监听socket</span></span><br><span class="line">sockaddr_in addr;</span><br><span class="line"><span class="keyword">int</span> nSockErr;</span><br><span class="line"><span class="keyword">int</span> nNumConns = <span class="number">0</span>;<span class="comment">//当前请求连接数</span></span><br><span class="line">SOCKET sConns[<span class="number">5</span>];<span class="comment">//会话SOCKET数组</span></span><br><span class="line">sockaddr ConnAddrs[<span class="number">5</span>];<span class="comment">//请求连接的客户端地址</span></span><br><span class="line"><span class="keyword">int</span> nAddrLen;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务器监听socket</span></span><br><span class="line">sServSock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">5050</span>);</span><br><span class="line">addr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( bind(sServSock,(LPSOCKADDR)&amp;addr,<span class="keyword">sizeof</span>(addr)) == </span><br><span class="line">SOCKET_ERROR )</span><br><span class="line">&#123;</span><br><span class="line">nSockErr = WSAGetLastError();</span><br><span class="line"><span class="comment">//绑定出错处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//监听客户端请求连接</span></span><br><span class="line"><span class="keyword">if</span>( listen(sServSock, <span class="number">2</span>)  ==  SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">nSockErr = WSAGetLastError();</span><br><span class="line"><span class="comment">//出错处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( nNumConns &lt; <span class="number">5</span>)&#123;</span><br><span class="line"><span class="comment">//每当收到客户端连接请求，创建新的会话SOCKET，保存在///sConns数组中</span></span><br><span class="line"><span class="comment">//客户端地址保存在ConnAddrs数组中</span></span><br><span class="line">sConns[nNumConns] = accept(sServSock, </span><br><span class="line">ConnAddrs[nNumConns], &amp;nAddrLen);</span><br><span class="line"><span class="keyword">if</span>(sConns[nNumConns] == INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line">nSockErr = WSAGetLastError();</span><br><span class="line"><span class="comment">//创建会话SOCKET出错处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建会话SOCKET成功，启动新的线程与客户端会话</span></span><br><span class="line">StartNewHandlerThread(sConns[nNumConns]);</span><br><span class="line"><span class="comment">//当前请求连接数+1</span></span><br><span class="line">nNumConns ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="connect（）"><a href="#connect（）" class="headerlink" title="connect（）"></a>connect（）</h4><p><strong>函数原型</strong><br>int connect (SOCKET s, const struct sockaddr FAR* name,<br> int  namelen );</p><p><strong>参数</strong><br>s<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 一个未连接SOCKET，一般是由socket函数建立的。<br>name<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 同bind函数。<br>namelen<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 同bind函数。<br><strong>返回值</strong><br>函数执行成功返回0，失败则返回SOCKET_ERROR。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>向对方主动提出连接请求。</p><h4 id="send（）"><a href="#send（）" class="headerlink" title="send（）"></a>send（）</h4><p><strong>函数原型</strong><br>int send (SOCKET s, char * buf, int len ,int flags);<br>【参数】<br>s<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 一个已经连接的SOCKET。<br>buf<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 指向要传输的数据的缓冲区的指针。<br>len<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] buf的长度。<br>flags<br>&nbsp;&nbsp;&nbsp;&nbsp;[in]指定函数调用的方式。一般取0。<br><strong>返回值</strong><br>函数执行成功返回发送的字节数（可能小于len），失败则返回SOCKET_ERROR。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>通过已经连接的SOCKET发送数据。</p><h4 id="recv（）"><a href="#recv（）" class="headerlink" title="recv（）"></a>recv（）</h4><p><strong>函数原型</strong><br>int recv (SOCKET s, char * buf, int len ,int flags);</p><p><strong>参数</strong><br>s<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 一个已经连接的SOCKET。<br>buf<br>&nbsp;&nbsp;&nbsp;&nbsp;[out] 指向接收数据的缓冲区的指针。<br>len<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] buf的长度。<br>flags<br>&nbsp;&nbsp;&nbsp;&nbsp;[in]指定函数调用的方式。一般取0。<br><strong>返回值</strong><br>函数执行成功返回接收到数据的字节数。如果失败则返回SOCKET_ERROR。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>通过已经连接的SOCKET接收数据。当读到的数据字节少于规定接受的数目（len）时，就把数据全部接收，并返回实际接收到的字节数；当读到的数据多于规定的值时，在流方式下剩余的数据由下个recv读出，在数据报方式下多余的数据被丢弃。</p><h4 id="sendto（）"><a href="#sendto（）" class="headerlink" title="sendto（）"></a>sendto（）</h4><p><strong>函数原型</strong><br>int sendto (SOCKET s, char * buf, int len ,int flags,<br>struct sockaddr_in * to, int tolen);</p><p><strong>参数</strong><br>s<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 一个SOCKET(可能已连接)。<br>buf<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 指向要传输的数据的缓冲区的指针。<br>len<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] buf的长度。<br>flags<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 指定函数调用的方式。一般取0。<br>to<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 指向目标地址结构体的指针。<br>tolen<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 目标地址结构体的长度。<br><strong>返回值</strong><br>函数执行成功返回发送的字节数（可能小于len），失败则返回SOCKET_ERROR。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>该函数一般用于通过无连接的SOCKET发送数据报文，报文的接受者由to参数指定。</p><h4 id="recvfrom（）"><a href="#recvfrom（）" class="headerlink" title="recvfrom（）"></a>recvfrom（）</h4><p><strong>函数原型</strong><br>int recvfrom (SOCKET s, char * buf, int len ,int flags,<br>struct sockaddr_in * from, int * fromlen);<br><strong>参数</strong><br>s<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 一个已经绑定的SOCKET。<br>buf<br>&nbsp;&nbsp;&nbsp;&nbsp;[out] 指向接收数据的缓冲区的指针。<br>len<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] buf的长度。<br>flags<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 指定函数调用的方式。一般取0。<br>from<br>&nbsp;&nbsp;&nbsp;&nbsp;[out] 指向源地址结构体的指针。<br>fromlen<br>&nbsp;&nbsp;&nbsp;&nbsp;[in/out] 源地址结构体的长度。<br><strong>返回值</strong><br>函数执行成功返回发送的字节数（可能小于len），失败则返回SOCKET_ERROR。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>该函数一般用于通过无连接的SOCKET接收数据报文，报文的发送者由from参数指定。</p><h4 id="closesocket（）"><a href="#closesocket（）" class="headerlink" title="closesocket（）"></a>closesocket（）</h4><p><strong>函数原型</strong><br>int closesocket (SOCKET s,);</p><p><strong>参数</strong><br>s<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 要关闭的SOCKET。<br><strong>返回值</strong><br>函数执行成功返回0，失败则返回SOCKET_ERROR。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>关闭指定的SOCKET。</p><h3 id="Windows-Socket-2的扩展特性"><a href="#Windows-Socket-2的扩展特性" class="headerlink" title="Windows Socket 2的扩展特性"></a>Windows Socket 2的扩展特性</h3><h4 id="Winsock-2-0简介"><a href="#Winsock-2-0简介" class="headerlink" title="Winsock 2.0简介"></a>Winsock 2.0简介</h4><p>Winsock 1.1原先设计的时候把API限定在TCP/IP的范畴里，它不象Berkerly模型那样支持多种协议。而Winsock 2.0正规化了一些其它的协议（如ATM、IPX/SPX和DECNet协议）的API。<br>Winsock 2.0之所以能支持多种协议，是因为Winsock 2.0在Windows Sockets DLL和底层协议栈之间定义了一个SPI（Service Provider Interface）接口，这样，通过一个Windows Sockets DLL可以同时访问底层不同厂商的协议栈。<br>Winsock 2.0不仅允许多种协议栈的并存，而且从理论上讲，它还允许创造一个与网络协议无关的应用程序。Winsock 2.0可以基于服务的需要透明地选择协议，应用程序可以适用于不同的网络名和网络地址。<br>Winsock 2.0还扩展了它的API函数集，当然Winsock 2.0是向下兼容的，可以把Winsock 1.1的代码原封不动地用在Winsock 2.0中。</p><h4 id="Winsock-2-0新特性"><a href="#Winsock-2-0新特性" class="headerlink" title="Winsock 2.0新特性"></a>Winsock 2.0新特性</h4><p>下面列出了一些Winsock 2.0的重要新特性：</p><ul><li>多重协议支持：SPI接口使得新的协议可以被支持。</li><li>传输协议独立：根据服务提供不同的协议。</li><li>多重命名空间：根据需要的服务和解析的主机名选择协议。</li><li>分散和聚集：  从多个缓冲区接受和发送数据。</li><li>重叠I/O和事件对象：增强吞吐量。</li><li>服务质量（Qos）：协商和跟踪网络带宽。</li><li>条件接受：可以选择性地决定是否接受连接。</li><li>Socket共享：多个进程可以共享一个SOKCKET句柄。</li></ul><h4 id="Winsock-2-0新增函数"><a href="#Winsock-2-0新增函数" class="headerlink" title="Winsock 2.0新增函数"></a>Winsock 2.0新增函数</h4><p>下面列出了一些Winsock 2.0的重要新增函数：</p><ul><li>WSAAccept（）：accept（）函数的扩展版本，支持条件接受和套接字分组。</li><li>WASCloseEvent（）：释放一个时间对象。</li><li>WSAConnect（）：connect（）函数的扩展版本，支持连接数据交换和Qos规范。</li><li>WSACreatEvent（）：创建一个事件对象。</li><li>WSADuplicateSocket（）：为一个共享套接字创建一个新的套接字。</li><li>WSAEnumNetworkEvents（）：检查是否有网络事件发生。</li><li>WSAEnumProtocols（）：得到每个可用的协议的信息。</li><li>WSAEventSelect（）：把一个网络事件和一个事件对象连接。</li><li>WSAGetOverlappedResu（）：得到重叠操作的完成状态。</li><li>WSAHtonl（）：htonl（）函数的扩展版本。</li><li>WSAHtons（）：htons（）函数的扩展版本。</li><li>WSAIoctl（）：ioctlsocket（）函数允许重叠操作的扩展版本。</li><li>WSANtohl（）：ntohl（）函数的扩展版本。</li><li>WSANtohs（）：ntohs（）函数的扩展版本。</li><li>WSARecv（）：recv（）的扩展版本，支持分散/聚集/重叠I/O。</li><li>WSARecvDisconnect（）：终止套接字的接受操作。</li><li>WSARecvFrom（）：recvfrom（）的扩展版本，支持分散/聚集/重叠I/O。</li><li>WSAResetEvent（）：重新初始化事件对象。</li><li>WSASend（）：send（）的扩展版本，支持分散/聚集/重叠I/O。</li><li>WSARecvDisconnect（）：终止套接字的接受操作。</li><li>WSASendDisconnect（）：终止套接字的发送操作。</li><li>WSASendTo（）：sendto（）的扩展版本，支持分散/聚集/重叠I/O。</li><li>WSASetEvent（）：设置事件对象。</li><li>WSASocket（）：socket（）函数的扩展版本。它以一个PROTOCOL_INFO结构作为输入参数，并且允许创建重叠套接字，还允许创建套接字组。</li><li>WSAWaitForMultipleEvents（）：阻塞多个事件对象。<br>关于这些函数的具体细节，请查阅MSDN。 </li></ul><h3 id="基于SOCKET实现的小型web服务器"><a href="#基于SOCKET实现的小型web服务器" class="headerlink" title="基于SOCKET实现的小型web服务器"></a>基于SOCKET实现的小型web服务器</h3><p>项目划分为启动，配置，服务器收发3个模块。</p><h4 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h4><p>start部分用于启动服务器，并在启动后可关闭服务器。</p><p>start.cpp代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"server.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭服务器线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closeServer</span><span class="params">(Server *server)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"If you want to close server, please input exit"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> Exit;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; Exit;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (Exit == <span class="string">"exit"</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//到这里意味着要关闭服务器</span></span><br><span class="line">(*server).~Server();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Server server;</span><br><span class="line"><span class="keyword">if</span> (server.WinsockStartup() == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (server.ServerStartup() == <span class="number">-1</span> ) <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"><span class="keyword">if</span> (server.ListenStartup() == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line"><span class="function">thread <span class="title">closeThread</span><span class="params">(closeServer, &amp;server)</span></span>;</span><br><span class="line">closeThread.detach();</span><br><span class="line"><span class="keyword">if</span> (server.ServerWork() == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务器收发"><a href="#服务器收发" class="headerlink" title="服务器收发"></a>服务器收发</h4><p>server部分实现了服务器绑定IP端口,监听并接收HTTP请求，并建立连接，传送文件的功能。</p><p>server.h代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">SOCKET ServerSocket;  <span class="comment">//服务器socket</span></span><br><span class="line">sockaddr_in ServerAddr;<span class="comment">//服务器端IP地址</span></span><br><span class="line"><span class="keyword">char</span>* RecvBuf;  <span class="comment">//接受缓冲区</span></span><br><span class="line"><span class="keyword">char</span>* SendBuf;  <span class="comment">//发送缓冲区</span></span><br><span class="line"><span class="keyword">int</span> SocketNums;<span class="comment">//socket总数</span></span><br><span class="line"></span><br><span class="line">fd_set rfds;<span class="comment">//用于检查socket是否有数据到来的的文件描述符</span></span><br><span class="line">fd_set wfds;<span class="comment">//用于检查socket是否可以发送的文件描述符</span></span><br><span class="line"></span><br><span class="line">mutex lockRecBuf;  <span class="comment">//写接收缓冲区信号灯</span></span><br><span class="line">mutex lockRecBuf2;  <span class="comment">//读接收缓冲区信号灯</span></span><br><span class="line">mutex sendHeader;  <span class="comment">//发送报文头部信号灯</span></span><br><span class="line">mutex sendMessage;  <span class="comment">//发送报文主体信号灯</span></span><br><span class="line">mutex ClosedList;  <span class="comment">//失效队列信号灯</span></span><br><span class="line">mutex ClosedList2;  <span class="comment">//失效队列信号灯</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;SOCKET&gt;* threadsessions; <span class="comment">//线程队列</span></span><br><span class="line"><span class="built_in">list</span>&lt;SOCKET&gt;* SocketList;  <span class="comment">//当前的会话socket队列</span></span><br><span class="line"><span class="built_in">list</span>&lt;SOCKET&gt;* ClosedSocketList; <span class="comment">//所有已失效的会话socket队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">Server(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">virtual</span> ~Server(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closeServer</span><span class="params">()</span></span>; <span class="comment">//关闭服务器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RecvMessage</span><span class="params">(SOCKET socket)</span></span>;  <span class="comment">//从SOCKET接受消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(SOCKET socket, <span class="built_in">string</span> msg)</span></span>;  <span class="comment">//向SOCKET发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">endWith</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fullStr, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; endStr)</span></span>; <span class="comment">//判断是否以特定格式结尾</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WinsockStartup</span><span class="params">()</span></span>;  <span class="comment">//初始化Winsock</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ServerStartup</span><span class="params">()</span></span>;  <span class="comment">//初始化Server，包括创建SOCKET，绑定到IP和PORT</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListenStartup</span><span class="params">()</span></span>;  <span class="comment">//开始监听客户端请求</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ServerWork</span><span class="params">()</span></span>;  <span class="comment">//收客户机请求 连接并生成会话socket</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddSocket</span><span class="params">(SOCKET socket)</span></span>;  <span class="comment">//将新的会话SOCKET加入队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddClosedSocket</span><span class="params">(SOCKET socket)</span></span>; <span class="comment">//将失效的会话SOCKET加入失效队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveClosedSocket</span><span class="params">(SOCKET socket)</span></span>;  <span class="comment">//将失效的SOCKET从会话SOCKET队列删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveClosedSocket</span><span class="params">()</span></span>;  <span class="comment">//将所有失效的SOCKET从会话SOCKET队列删除</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>server.cpp代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;streambuf&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"server.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">Server::Server(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;RecvBuf = <span class="keyword">new</span> <span class="keyword">char</span>[Config::BufferLength]; <span class="comment">//初始化接受缓冲区</span></span><br><span class="line"><span class="built_in">memset</span>(<span class="keyword">this</span>-&gt;RecvBuf, <span class="string">'\0'</span>, Config::BufferLength); <span class="comment">// 并设置为0</span></span><br><span class="line"><span class="keyword">this</span>-&gt;SendBuf = <span class="keyword">new</span> <span class="keyword">char</span>[Config::BufferLength]; <span class="comment">//初始化发送缓冲区</span></span><br><span class="line"><span class="built_in">memset</span>(<span class="keyword">this</span>-&gt;SendBuf, <span class="string">'\0'</span>, Config::BufferLength); <span class="comment">// 并设置为0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;SocketList = <span class="keyword">new</span> <span class="built_in">list</span>&lt;SOCKET&gt;();  <span class="comment">//初始化有关List和Map</span></span><br><span class="line"><span class="keyword">this</span>-&gt;ClosedSocketList = <span class="keyword">new</span> <span class="built_in">list</span>&lt;SOCKET&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Server::~Server(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;RecvBuf != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//释放接收缓冲区</span></span><br><span class="line"><span class="built_in">free</span>(<span class="keyword">this</span>-&gt;RecvBuf);</span><br><span class="line"><span class="keyword">this</span>-&gt;RecvBuf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"RecvBuf has been free!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;SendBuf != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//释放接收缓冲区</span></span><br><span class="line"><span class="built_in">free</span>(<span class="keyword">this</span>-&gt;SendBuf);</span><br><span class="line"><span class="keyword">this</span>-&gt;SendBuf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"SendBuf has been free!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭服务器端socket</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ServerSocket != <span class="literal">NULL</span>) &#123;</span><br><span class="line">closesocket(<span class="keyword">this</span>-&gt;ServerSocket);</span><br><span class="line"><span class="keyword">this</span>-&gt;ServerSocket = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ServerSocket has been closed!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭所有会话socket并释放会话队列</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;SocketList != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;SOCKET&gt;::iterator it = <span class="keyword">this</span>-&gt;SocketList-&gt;begin(); it != <span class="keyword">this</span>-&gt;SocketList-&gt;end(); it++)</span><br><span class="line">closesocket(*it); <span class="comment">//关闭会话</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;SocketList;  <span class="comment">//释放队列</span></span><br><span class="line"><span class="keyword">this</span>-&gt;SocketList = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"SocketList has been deleted!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放失效会话队列</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ClosedSocketList != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;SOCKET&gt;::iterator it = <span class="keyword">this</span>-&gt;ClosedSocketList-&gt;begin(); it != <span class="keyword">this</span>-&gt;ClosedSocketList-&gt;end(); it++)</span><br><span class="line">closesocket(*it);</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;ClosedSocketList;</span><br><span class="line"><span class="keyword">this</span>-&gt;ClosedSocketList = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ClosedSocketList has been deleted!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WSACleanup(); <span class="comment">//清理winsock 运行环境</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否以某一特定后缀名结尾</span></span><br><span class="line"><span class="keyword">bool</span> Server::endWith(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fullStr, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; endStr) &#123;</span><br><span class="line"><span class="keyword">if</span> (endStr.size() &gt; fullStr.size())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> indexFull = fullStr.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> indexEnd = endStr.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (indexEnd &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fullStr[indexFull] != endStr[indexEnd])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">indexFull--;</span><br><span class="line">indexEnd--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化Winsock</span></span><br><span class="line"><span class="keyword">int</span> Server::WinsockStartup() &#123;</span><br><span class="line"></span><br><span class="line">WSADATA wsaData;<span class="comment">//用于返回Winsock的环境信息   </span></span><br><span class="line"><span class="keyword">int</span> nRc = WSAStartup(<span class="number">0x0202</span>, &amp;wsaData);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nRc) &#123;</span><br><span class="line"><span class="comment">//Winsock初始化失败</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"WSAstartup error!\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断返回的Winsock版本号</span></span><br><span class="line"><span class="keyword">if</span> (wsaData.wVersion != <span class="number">0x0202</span>) &#123; <span class="comment">//如果版本不对</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Server's winsock version error!"</span>;</span><br><span class="line">WSACleanup();  <span class="comment">//清除Winsock</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Server's winsock startup success!\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化Server</span></span><br><span class="line"><span class="keyword">int</span> Server::ServerStartup() &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input the ServerAddr: "</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; Config::ServerAddr;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\rPlease input the ServerPort: "</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; Config::ServerPort;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Server mainpath is:"</span> &lt;&lt;Config::mainPath &lt;&lt; <span class="string">" now"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Do you want to change it: y/n "</span>;</span><br><span class="line"><span class="keyword">char</span> changePath;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; changePath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (changePath == <span class="string">'Y'</span> || changePath == <span class="string">'y'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input the new server mainpath:"</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; Config::mainPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 TCP socket</span></span><br><span class="line"><span class="keyword">this</span>-&gt;ServerSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ServerSocket == INVALID_SOCKET) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Server create socket error!!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Server TCP socket create OK!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bind socket to Server's IP and port 5050</span></span><br><span class="line"><span class="keyword">this</span>-&gt;ServerAddr.sin_family = AF_INET;</span><br><span class="line"><span class="keyword">this</span>-&gt;ServerAddr.sin_port = htons(Config::ServerPort);</span><br><span class="line"><span class="keyword">this</span>-&gt;ServerAddr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);</span><br><span class="line"><span class="keyword">int</span> nRC = bind(<span class="keyword">this</span>-&gt;ServerSocket, (LPSOCKADDR) &amp; (<span class="keyword">this</span>-&gt;ServerAddr), <span class="keyword">sizeof</span>(<span class="keyword">this</span>-&gt;ServerAddr));</span><br><span class="line"><span class="keyword">if</span> (nRC == SOCKET_ERROR) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Server socket bind error!\n"</span>;</span><br><span class="line">closesocket(<span class="keyword">this</span>-&gt;ServerSocket);</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Server socket bind ok!\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///关闭服务器线程</span></span><br><span class="line"><span class="keyword">int</span> Server::closeServer() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"If you want to close server, please input exit"</span> &lt;&lt;<span class="built_in">endl</span> ;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> Exit;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; Exit;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (Exit == <span class="string">"exit"</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//到这里意味着要关闭服务器</span></span><br><span class="line"><span class="keyword">this</span>-&gt;~Server();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始监听过程，等待客户的连接</span></span><br><span class="line"><span class="keyword">int</span> Server::ListenStartup() &#123;</span><br><span class="line"><span class="keyword">int</span> nRC = listen(<span class="keyword">this</span>-&gt;ServerSocket, Config::MaxConnetion);</span><br><span class="line"><span class="keyword">if</span> (nRC == SOCKET_ERROR) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Server socket listen error!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">closesocket(<span class="keyword">this</span>-&gt;ServerSocket);</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Server socket listen ok!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将新的会话socket加入队列</span></span><br><span class="line"><span class="keyword">void</span> Server::AddSocket(SOCKET socket) &#123;</span><br><span class="line"><span class="keyword">if</span> (socket != INVALID_SOCKET) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;SocketList-&gt;insert(<span class="keyword">this</span>-&gt;SocketList-&gt;end(), socket);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将失效的会话socket加入失效队列</span></span><br><span class="line"><span class="keyword">void</span> Server::AddClosedSocket(SOCKET socket) &#123;</span><br><span class="line"><span class="keyword">if</span> (socket != INVALID_SOCKET) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;ClosedSocketList-&gt;insert(<span class="keyword">this</span>-&gt;ClosedSocketList-&gt;end(), socket);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将失效的socket从会话socket队列删除</span></span><br><span class="line"><span class="keyword">void</span> Server::RemoveClosedSocket(SOCKET socket) &#123;</span><br><span class="line"><span class="keyword">if</span> (socket != INVALID_SOCKET) &#123;</span><br><span class="line"><span class="built_in">list</span>&lt;SOCKET&gt;::iterator it = find(<span class="keyword">this</span>-&gt;SocketList-&gt;begin(), <span class="keyword">this</span>-&gt;SocketList-&gt;end(), socket);</span><br><span class="line"><span class="keyword">if</span> (it != <span class="keyword">this</span>-&gt;SocketList-&gt;end()) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;SocketList-&gt;erase(it);</span><br><span class="line"><span class="comment">//closesocket(*it);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有失效的socket从会话socket队列删除</span></span><br><span class="line"><span class="keyword">void</span> Server::RemoveClosedSocket() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;SOCKET&gt;::iterator it = <span class="keyword">this</span>-&gt;ClosedSocketList-&gt;begin(); it != <span class="keyword">this</span>-&gt;ClosedSocketList-&gt;end(); it++) &#123;</span><br><span class="line"><span class="comment">/*if ((*it) != INVALID_SOCKET) &#123;</span></span><br><span class="line"><span class="comment">if (it != this-&gt;SocketList-&gt;end())</span></span><br><span class="line"><span class="comment">this-&gt;SocketList-&gt;erase(it);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">this</span>-&gt;RemoveClosedSocket(*it);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向socket发送消息</span></span><br><span class="line"><span class="keyword">void</span> Server::SendMessage(SOCKET socket, <span class="built_in">string</span> msg) &#123;</span><br><span class="line"><span class="keyword">int</span> rtn = send(socket, msg.c_str(), msg.length(), <span class="number">0</span>);</span><br><span class="line">unique_lock&lt;mutex&gt;closedList(<span class="keyword">this</span>-&gt;ClosedList2, defer_lock);</span><br><span class="line"><span class="keyword">if</span> (rtn == SOCKET_ERROR) &#123;<span class="comment">//发送数据错误</span></span><br><span class="line">closedList.lock();</span><br><span class="line"><span class="keyword">this</span>-&gt;AddClosedSocket(socket);</span><br><span class="line">closedList.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从socket接受消息</span></span><br><span class="line"><span class="keyword">void</span> Server::RecvMessage(SOCKET socket) &#123;</span><br><span class="line"></span><br><span class="line">unique_lock&lt;mutex&gt;writeRecBuf(<span class="keyword">this</span>-&gt;lockRecBuf, defer_lock);  <span class="comment">//接收资源写信号灯</span></span><br><span class="line">unique_lock&lt;mutex&gt;readRecBuf(<span class="keyword">this</span>-&gt;lockRecBuf2, defer_lock);  <span class="comment">//接收资源读信号灯</span></span><br><span class="line">unique_lock&lt;mutex&gt;sendHeader(<span class="keyword">this</span>-&gt;sendHeader, defer_lock);  <span class="comment">//发送报文头部信号灯</span></span><br><span class="line">unique_lock&lt;mutex&gt;sendMessage(<span class="keyword">this</span>-&gt;sendMessage, defer_lock);  <span class="comment">//发送报文主体信号灯</span></span><br><span class="line">unique_lock&lt;mutex&gt;closedList(<span class="keyword">this</span>-&gt;ClosedList, defer_lock);  <span class="comment">//发送报文主体信号灯</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//writeRecBuf.lock();   //写RecBuf时需要上锁</span></span><br><span class="line"><span class="keyword">char</span>* RecvBufn = <span class="keyword">new</span> <span class="keyword">char</span>[Config::BufferLength];</span><br><span class="line"><span class="built_in">memset</span>(RecvBufn, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(RecvBufn)); <span class="comment">//缓存清零</span></span><br><span class="line"><span class="keyword">int</span> receivedBytes = recv(socket, RecvBufn, Config::BufferLength, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//writeRecBuf.unlock();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果会话SOCKET有数据到来，则接受客户的数据</span></span><br><span class="line"><span class="keyword">if</span> (receivedBytes == SOCKET_ERROR) &#123;    <span class="comment">//接受数据错误</span></span><br><span class="line"><span class="comment">/*receivedBytes = WSAGetLastError();</span></span><br><span class="line"><span class="comment">cout &lt;&lt; "Thread falied!" &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">return;*/</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; "ReceiveBytes == -1,Receive Error!" &lt;&lt; endl;</span></span><br><span class="line">closedList.lock();</span><br><span class="line"><span class="keyword">this</span>-&gt;AddClosedSocket(socket);</span><br><span class="line">closedList.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (receivedBytes == <span class="number">0</span>) &#123; <span class="comment">//对方断开连接</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; "ReceiveBytes ==0,Server disconnected!" &lt;&lt; std::endl;</span></span><br><span class="line">closedList.lock();</span><br><span class="line"><span class="keyword">this</span>-&gt;AddClosedSocket(socket);</span><br><span class="line">closedList.unlock();</span><br><span class="line"><span class="comment">//return;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "\r\n" &lt;&lt; RecvBuf;</span></span><br><span class="line"><span class="comment">//找到报文头部</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> fullPath;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> respondHttpHeader, clientHttpHeader;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> statusCode, firstHeader, typeStr, lengthStr;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">regex <span class="title">regRequest</span><span class="params">(<span class="string">R"(([A-Z]+) (.*?) HTTP/\d\.\d)"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::smatch matchRst;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> strRecv, strSend;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> method;</span><br><span class="line">    <span class="built_in">std</span>:<span class="built_in">string</span> url;</span><br><span class="line"></span><br><span class="line">respondHttpHeader = <span class="string">""</span>;</span><br><span class="line">statusCode = Config::Ok;</span><br><span class="line">firstHeader = <span class="string">"HTTP/1.1 200 OK\r\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到HTTP报文头部</span></span><br><span class="line"><span class="comment">//readRecBuf.lock();  //读RecBuf时需要上锁</span></span><br><span class="line">strRecv.assign(RecvBufn);</span><br><span class="line"><span class="keyword">size_t</span> headerEnd = strRecv.find(<span class="string">"\r\n\r\n"</span>);</span><br><span class="line">clientHttpHeader = strRecv.substr(<span class="number">0</span>, headerEnd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//正则表达式提取关键字method(GET,POST),url</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::regex_search(clientHttpHeader, matchRst, regRequest)) &#123;</span><br><span class="line">method = matchRst[<span class="number">1</span>].str();</span><br><span class="line">url = matchRst[<span class="number">2</span>].str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; url.size(); i++) &#123;</span><br><span class="line"><span class="comment">//替换成windows路径</span></span><br><span class="line"><span class="keyword">if</span> (url[i] == <span class="string">'/'</span>)</span><br><span class="line">url[i] = <span class="string">'\\'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fullPath = Config::mainPath + url; <span class="comment">//完整路径</span></span><br><span class="line"><span class="comment">//writeRecBuf.unlock();</span></span><br><span class="line"><span class="comment">//readRecBuf.unlock();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Client http header:\r\n"</span> &lt;&lt; clientHttpHeader.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\r\nmethod:"</span> &lt;&lt; method.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"url:"</span> &lt;&lt; url.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sendHeader.lock();  //发送报文头部信号灯</span></span><br><span class="line"></span><br><span class="line">DWORD ftyp;</span><br><span class="line">ftyp = GetFileAttributesA(fullPath.c_str());</span><br><span class="line"><span class="keyword">if</span> ((ftyp &amp; FILE_ATTRIBUTE_DIRECTORY) &amp;&amp; (!INVALID_FILE_ATTRIBUTES)) &#123;</span><br><span class="line"><span class="comment">//如果是一个目录，打开该目录下的索引index.html</span></span><br><span class="line">fullPath = fullPath + <span class="string">"\\index.html"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FILE* infile = fopen(fullPath.c_str(), <span class="string">"rb"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!infile) &#123;</span><br><span class="line"><span class="comment">//文件不存在</span></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span>发送自定义404页面</span></span><br><span class="line">infile = fopen((Config::mainPath + <span class="string">"\\404.html"</span>).c_str(), <span class="string">"rb"</span>);</span><br><span class="line">statusCode = Config::Error;</span><br><span class="line">firstHeader = <span class="string">"HTTP/1.1 404 Not Found\r\n"</span>;</span><br><span class="line">typeStr = <span class="string">"Content-Type: text/html\r\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".html"</span>) || endWith(url, <span class="string">"htm"</span>))</span><br><span class="line">typeStr = <span class="string">"Content-Type: text/html\r\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".txt"</span>))</span><br><span class="line">typeStr = <span class="string">"Content-Type: text /plain\r\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".jpg"</span>))</span><br><span class="line">typeStr = <span class="string">"Content-Type: image/jpeg\r\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".jpeg"</span>) || endWith(url, <span class="string">".png"</span>))</span><br><span class="line">typeStr = <span class="string">"Content-Type: image/"</span> + (url.substr(url.rfind(<span class="string">'.'</span>) + <span class="number">1</span>)) + <span class="string">"\r\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".ico"</span>))</span><br><span class="line">typeStr = <span class="string">"Content-Type: image/x-icon\r\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".css"</span>))</span><br><span class="line">typeStr = <span class="string">"Content-Type: text/css\r\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".gif"</span>))</span><br><span class="line">typeStr = <span class="string">"Content-Type: image/gif\r\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".png"</span>))</span><br><span class="line">typeStr = <span class="string">"Content-Type: image/png\r\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".js"</span>))</span><br><span class="line">typeStr = <span class="string">"Content-Type: application/javascript\r\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".eot"</span>))</span><br><span class="line">typeStr = <span class="string">"Content-Type: application/vnd.ms-fontobject\r\n"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(endWith(url,<span class="string">".mp3"</span>))</span><br><span class="line">typeStr = <span class="string">"Content-Type: audio/mpeg\r\n"</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (infile != <span class="literal">NULL</span>)  <span class="comment">//文件存在，但是不支持解析</span></span><br><span class="line">fclose(infile);</span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span>发送自定义501页面</span></span><br><span class="line">infile = fopen((Config::mainPath + <span class="string">"\\501.html"</span>).c_str(), <span class="string">"rb"</span>);</span><br><span class="line">statusCode = Config::Error;</span><br><span class="line">firstHeader = <span class="string">"HTTP/1.1 501 Not Implemented\r\n"</span>;</span><br><span class="line">typeStr = <span class="string">"Content-Type: text/html\r\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件大小</span></span><br><span class="line">fseek(infile, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">fseek(infile, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="keyword">int</span> fileLength = ftell(infile);</span><br><span class="line"><span class="comment">//文件指针归位</span></span><br><span class="line">fseek(infile, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">respondHttpHeader = firstHeader + typeStr + <span class="string">"Content-Length: "</span> + <span class="built_in">std</span>::to_string(fileLength) + <span class="string">"\r\n"</span> + <span class="string">"Server: CServer_HTTP1.1\r\n"</span> + <span class="string">"Connection: close\r\n"</span> + <span class="string">"\r\n"</span>;</span><br><span class="line"><span class="comment">//发送报文头部</span></span><br><span class="line">   <span class="comment">//send(socket, respondHttpHeader.c_str, respondHttpHeader.length(), 0);</span></span><br><span class="line"><span class="keyword">this</span>-&gt;SendMessage(socket, respondHttpHeader);</span><br><span class="line"><span class="comment">//sendHeader.unlock();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"respond http header:"</span> &lt;&lt; respondHttpHeader.c_str();</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送请求的文件</span></span><br><span class="line"><span class="comment">//sendMessage.lock();</span></span><br><span class="line"><span class="keyword">int</span> bufReadNum;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">//缓存清零</span></span><br><span class="line"><span class="built_in">memset</span>(RecvBufn, <span class="number">0</span>, <span class="keyword">sizeof</span>(RecvBufn));</span><br><span class="line">bufReadNum = fread(RecvBufn, <span class="number">1</span>, Config::BufferLength, infile);</span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == (send(socket, RecvBufn, bufReadNum, <span class="number">0</span>)))</span><br><span class="line">&#123;<span class="comment">//发送失败</span></span><br><span class="line"><span class="comment">//rtn = SOCKET_ERROR;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"File: "</span> &lt;&lt; url &lt;&lt; <span class="string">" transfer error!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (feof(infile))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">fclose(infile);</span><br><span class="line"><span class="comment">//memset(RecvBufn, '\0', Config::BufferLength);//清除接受缓冲区</span></span><br><span class="line"><span class="comment">//sendMessage.unlock();</span></span><br><span class="line"><span class="keyword">if</span> (RecvBufn != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">delete</span>(RecvBufn);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"File: "</span> &lt;&lt; fullPath &lt;&lt; <span class="string">" transfer successful!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//writeRecBuf.unlock();</span></span><br><span class="line"><span class="comment">//closesocket(socket);</span></span><br><span class="line"><span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">100</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受客户端发来的请求连接并生成会话socket</span></span><br><span class="line"><span class="keyword">int</span> Server::ServerWork() &#123;</span><br><span class="line"></span><br><span class="line">u_long blockMode = Config::uNonBlock;</span><br><span class="line"><span class="keyword">int</span> rtn;</span><br><span class="line"><span class="comment">//nThread.MemberProc = &amp;Server::RecvMessage;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将ServerSocket设为非阻塞模式以监听客户连接请求</span></span><br><span class="line"><span class="keyword">if</span> ((rtn = ioctlsocket(<span class="keyword">this</span>-&gt;ServerSocket, FIONBIO, &amp;blockMode) == SOCKET_ERROR)) &#123; <span class="comment">//FIONBIO：允许或禁止套接口s的非阻塞模式。</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Set Server unblockMode error!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//等到客户端的连接请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置socket集</span></span><br><span class="line"><span class="comment">//FD_ZERO(fd_set *fdset);将指定的文件描述符集清空，在对文件描述符集合进行设置前，必须对其进行初始化，</span></span><br><span class="line"><span class="comment">//如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的。</span></span><br><span class="line">FD_ZERO(&amp;<span class="keyword">this</span>-&gt;rfds);  </span><br><span class="line">FD_ZERO(&amp;<span class="keyword">this</span>-&gt;wfds);</span><br><span class="line"></span><br><span class="line"><span class="comment">//FD_SET(fd_set *fdset);用于在文件描述符集合中增加一个新的文件描述符。</span></span><br><span class="line"><span class="comment">//把serverSocket加入到rfds，等待用户连接请求</span></span><br><span class="line">FD_SET(<span class="keyword">this</span>-&gt;ServerSocket, &amp;<span class="keyword">this</span>-&gt;rfds);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把当前的会话socket加入到rfds,等待用户数据的到来;加到wfds，等待socket可发送数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;SOCKET&gt;::iterator it = <span class="keyword">this</span>-&gt;SocketList-&gt;begin(); it != <span class="keyword">this</span>-&gt;SocketList-&gt;end(); it++) &#123;</span><br><span class="line">FD_SET(*it, &amp;rfds);</span><br><span class="line">FD_SET(*it, &amp;wfds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待用户连接请求或用户数据到来或会话socke可发送数据</span></span><br><span class="line"><span class="comment">//返回有可读或可写的socket的总数</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">this</span>-&gt;SocketNums = select(<span class="number">0</span>, &amp;<span class="keyword">this</span>-&gt;rfds, &amp;<span class="keyword">this</span>-&gt;wfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) == SOCKET_ERROR)</span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Select socket nums error!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时有客户端请求到来</span></span><br><span class="line">sockaddr_in ClientAddr;  <span class="comment">//客户端IP地址</span></span><br><span class="line"><span class="keyword">int</span> AddrLen = <span class="keyword">sizeof</span>(ClientAddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查srvSocket是否收到用户连接请求</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;SocketNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(<span class="keyword">this</span>-&gt;ServerSocket, &amp;rfds)) &#123;  <span class="comment">//检查有socket就绪</span></span><br><span class="line"><span class="keyword">this</span>-&gt;SocketNums--;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生会话socket</span></span><br><span class="line">SOCKET sockket = accept(<span class="keyword">this</span>-&gt;ServerSocket, (LPSOCKADDR) &amp; (ClientAddr), &amp;AddrLen);</span><br><span class="line"><span class="keyword">if</span> (sockket == INVALID_SOCKET) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Server accept error!\n"</span>;</span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line"><span class="comment">/*closesocket(this-&gt;ServerSocket);</span></span><br><span class="line"><span class="comment">WSACleanup();</span></span><br><span class="line"><span class="comment">return -1;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将socket设为非阻塞模式以监听客户连接请求</span></span><br><span class="line"><span class="keyword">if</span> (ioctlsocket(sockket, FIONBIO, &amp;blockMode) == SOCKET_ERROR) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Set accept socket unbolockmode error!\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将产生的会话SOCKET保存在SocketList中</span></span><br><span class="line">getpeername(sockket, (struct sockaddr*) &amp; ClientAddr, &amp;AddrLen);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Receive Ip:"</span> &lt;&lt; inet_ntoa(ClientAddr.sin_addr) &lt;&lt; <span class="string">" from Port:"</span> &lt;&lt; ntohs(ClientAddr.sin_port) &lt;&lt; <span class="string">" request"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">""</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;AddSocket(sockket);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Server accept success!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收用户请求</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;SocketNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//遍历socket队列，检查是否有数据到来</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;SOCKET&gt;::iterator it = <span class="keyword">this</span>-&gt;SocketList-&gt;begin(); it != <span class="keyword">this</span>-&gt;SocketList-&gt;end(); it++) &#123;</span><br><span class="line"><span class="keyword">if</span> (*it != INVALID_SOCKET) &#123;</span><br><span class="line"><span class="comment">//FD_ISSET(int fd,fd_set *fdset);用于测试指定的文件描述符是否在该集合中。</span></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(*it, &amp;rfds)) &#123;  <span class="comment">//某会话socket有数据到来</span></span><br><span class="line">SOCKADDR_IN RequestSocket;</span><br><span class="line"><span class="keyword">int</span> socketAddrLen = <span class="keyword">sizeof</span>(RequestSocket);</span><br><span class="line">getpeername(*it, (struct sockaddr*) &amp; RequestSocket, &amp;socketAddrLen);</span><br><span class="line"><span class="comment">/*cout &lt;&lt; "Receive Ip:" &lt;&lt; inet_ntoa(RequestSocket.sin_addr) &lt;&lt; " from Port:" &lt;&lt; ntohs(RequestSocket.sin_port) &lt;&lt; " request";</span></span><br><span class="line"><span class="comment">cout &lt;&lt; "" &lt;&lt; endl;*/</span></span><br><span class="line"><span class="function">thread <span class="title">talkThread</span><span class="params">(&amp;Server::RecvMessage, <span class="built_in">std</span>::ref(*<span class="keyword">this</span>), *it)</span></span>;  <span class="comment">//开启一个新的线程来处理这一个客户的请求</span></span><br><span class="line">talkThread.detach();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从socketList里删掉已经关闭的socket</span></span><br><span class="line"><span class="keyword">this</span>-&gt;RemoveClosedSocket();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>config 配置了一些常用变量</p><p>config.h代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ServerPort;  <span class="comment">//服务器端口号</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> ClientPort;   <span class="comment">//客户端端口</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">string</span> ServerAddr;   <span class="comment">//服务器IP地址</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MaxConnetion;  <span class="comment">//最大连接数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BufferLength;   <span class="comment">//缓冲区大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">string</span> mainPath; <span class="comment">//虚拟主路径</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> Ok;  <span class="comment">//客户端请求成功</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> Error;   <span class="comment">//客户端语法错误，服务端尚未实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> NotFound;   <span class="comment">//文件不存在</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> HttpVersion;   <span class="comment">//HTTP版本</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u_long uNonBlock;  <span class="comment">//SOCKET阻塞模式</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Config();</span><br><span class="line">~Config();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>config.cpp代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Config::Config()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Config::~Config()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> Config::ServerPort = <span class="number">5050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Config::ClientPort = <span class="number">8080</span>;</span><br><span class="line"><span class="built_in">string</span> Config::ServerAddr = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Config::MaxConnetion = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Config::BufferLength = <span class="number">65535</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Config::Ok= <span class="string">"200 OK"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Config::Error = <span class="string">"501 Not Implemented"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Config::NotFound = <span class="string">"404 Not Found"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Config::HttpVersion = <span class="string">"HTTP/1.1 "</span>;</span><br><span class="line"><span class="keyword">const</span> u_long Config::uNonBlock = <span class="number">1</span>;  <span class="comment">//SOCKET为非阻塞模式</span></span><br><span class="line"><span class="built_in">string</span> Config::mainPath = <span class="string">"D:\\html\\"</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Socket套接字介绍&quot;&gt;&lt;a href=&quot;#Socket套接字介绍&quot; class=&quot;headerlink&quot; title=&quot;Socket套接字介绍&quot;&gt;&lt;/a&gt;Socket套接字介绍&lt;/h3&gt;&lt;p&gt;网络应用程序是由通信进程对组成，每对互相通信的应用程序进程互相发送报文，他们之间的通信必须通过下面的网络来进行。为了将应用程序和底层的网络通信协议屏蔽开来，采用套接字（Socket）这样一个抽象概念来作为应用程序和底层网络之间的应用程序编程接口（API）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yorxika.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>只出现一次的数字II</title>
    <link href="http://yorxika.github.io/2019/11/27/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97II/"/>
    <id>http://yorxika.github.io/2019/11/27/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97II/</id>
    <published>2019-11-27T15:37:58.000Z</published>
    <updated>2019-12-12T12:52:17.067Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第137题只出现一次的数字II</p><blockquote><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><a id="more"></a><p>示例 1:</p><p>输入: [2,2,3,2]<br>输出: 3</p></blockquote><hr><h4 id="排序后遍历"><a href="#排序后遍历" class="headerlink" title="排序后遍历"></a>排序后遍历</h4><p>思路同136题，排序后遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> len = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length ;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[i + <span class="number">1</span>] &amp;&amp; nums[i + <span class="number">1</span>] == nums[i + <span class="number">2</span>]) &#123;</span><br><span class="line">            i += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] != nums[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>来源<a href="https://leetcode-cn.com/problems/single-number-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--31/" target="_blank" rel="noopener">题解</a></p><p><strong>将问题一般化</strong></p><p>给一个数组，每个元素都出现 k ( k &gt; 1) 次，除了一个数字只出现 p 次(p &gt;= 1, p % k !=0)，找到出现 p 次的那个数。<br>考虑其中的一个 bit<br>为了计数 k 次，我们必须要 m 个比特，其中 2^m &gt;=k，也就是 m &gt;= log2k。<br>假设我们 m 个比特依次是 x_mx_{m-1}…x_2x_1x 。<br>开始全部初始化为 0。00…00。<br>然后扫描所有数字的当前 bit 位，用 i 表示当前的 bit。</p><p>假如例子是 1 2 6 1 1 2 2 3 3 3, 3 个 1, 3 个 2, 3 个 3,1 个 6<br>1 0 0 1<br>2 0 1 0<br>6 1 1 0<br>1 0 0 1<br>1 0 0 1<br>2 0 1 0<br>2 0 1 0<br>3 0 1 1<br>3 0 1 1<br>3 0 1 1<br>初始 状态 00…00。<br>第一次遇到 1 , m 个比特依次是 00…01。<br>第二次遇到 1 , m 个比特依次是 00…10。<br>第三次遇到 1 , m 个比特依次是 00…11。<br>第四次遇到 1 , m 个比特依次是 00..100。</p><p>x1 的变化规律就是遇到 1 变成 1 ，再遇到 1 变回 0。遇到 0 的话就不变。<br>所以 x1 = x1 ^ i，可以用异或来求出 x1 。<br>那么 x2…xm 怎么办呢？<br>x2 的话，当遇到 1 的时候，如果之前 x1 是 0，x2 就不变。如果之前 x1 是 1，对应于上边的第二次遇到 1 和第四次遇到 1。 x2 从 0 变成 1 和 从 1 变成 0。<br>所以 x2 的变化规律就是遇到 1 同时 x1 是 1 就变成 1，再遇到 1 同时 x1 是 1 就变回 0。遇到 0 的话就不变。和 x1 的变化规律很像，所以同样可以使用异或。<br>x2 = x2 ^ (i &amp; x1)，多判断了 x1 是不是 1。<br>x3，x4 … xm 就是同理了，xm = xm ^ (xm-1 &amp; … &amp; x1 &amp; i) 。<br>再说直接点，上边其实就是模拟了每次加 1 的时候，各个比特位的变化。所以高位 xm 只有当低位全部为 1 的时候才会得到进位 1 。</p><p>00 -&gt; 01 -&gt; 10 -&gt; 11 -&gt; 00</p><p>上边有个问题，假设我们的 k = 3，那么我们应该在 10 之后就变成 00，而不是到 11。<br>所以我们需要一个 mask ，当没有到达 k 的时候和 mask进行与操作是它本身，当到达 k 的时候和 mask 相与就回到 00…000。<br>根据上边的要求构造 mask，假设 k 写成二进制以后是 km…k2k1。<br>mask = ~(y1 &amp; y2 &amp; … &amp; ym),<br>如果kj = 1，那么yj = xj<br>如果 kj = 0，yj = ~xj 。</p><p>举两个例子。</p><p>k = 3: 写成二进制，k1 = 1, k2 = 1, mask = ~(x1 &amp; x2);</p><p>k = 5: 写成二进制，k1 = 1, k2 = 0, k3 = 1, mask = ~(x1 &amp; ~x2 &amp; x3);</p><p>很容易想明白，当 x1x2…xm 达到 k1k2…km 的时候因为我们要把 x1x2…xm 归零。我们只需要用 0 和每一位进行与操作就回到了 0。<br>所以我们只需要把等于 0 的比特位取反，然后再和其他所有位相与就得到 1 ，然后再取反就是 0 了。<br>如果 x1x2…xm 没有达到 k1k2…km ，那么求出来的结果一定是 1，这样和原来的 bit 位进行与操作的话就保持了原来的数。<br>总之，最后我们的代码就是下边的框架。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">    xm ^= (xm-<span class="number">1</span> &amp; ... &amp; x1 &amp; i);</span><br><span class="line">    xm-<span class="number">1</span> ^= (xm-<span class="number">2</span> &amp; ... &amp; x1 &amp; i);</span><br><span class="line">    .....</span><br><span class="line">    x1 ^= i;</span><br><span class="line">    </span><br><span class="line">    mask = ~(y1 &amp; y2 &amp; ... &amp; ym) where yj = xj <span class="keyword">if</span> kj = <span class="number">1</span>, and yj = ~xj <span class="keyword">if</span> kj = <span class="number">0</span> (j = <span class="number">1</span> to m).</span><br><span class="line"></span><br><span class="line">    xm &amp;= mask;</span><br><span class="line">    ......</span><br><span class="line">    x1 &amp;= mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>考虑全部 bit</strong></p><p>假如例子是 1 2 6 1 1 2 2 3 3 3, 3 个 1, 3 个 2, 3 个 3,1 个 6<br>1 0 0 1<br>2 0 1 0<br>6 1 1 0<br>1 0 0 1<br>1 0 0 1<br>2 0 1 0<br>2 0 1 0<br>3 0 1 1<br>3 0 1 1<br>3 0 1 1<br>之前是完成了一个 bit 位，也就是每一列的操作。因为我们给的数是 int 类型，所以有 32 位。所以我们需要对每一位都进行计数。有了上边的分析，我们不需要再向解法三那样依次考虑每一位，我们可以同时对 32 位进行计数。<br>对于 k 等于 3 ，也就是这道题。我们可以用两个 int，x1 和 x2。x1 表示对于 32 位每一位计数的低位，x2 表示对于 32 位每一位计数的高位。通过之前的公式，我们利用位操作就可以同时完成计数了。</p><p><strong>返回什么</strong><br>最后一个问题，我们需要返回什么？<br>因为所有的数字都出现了 k 次，只有一个数字出现了 p 次。<br>因为 xm…x2x1 组合起来就是对于每一列 1 的计数。<br>如果 p = 1，那么如果出现一次的数字的某一位是 1 ，一定会使得 x1 ，也就是计数的最低位置的对应位为 1，所以我们把 x1 返回即可。对于上边的例子，就是 110 ，所以返回 6。<br>如果 p = 2，二进制就是 10，那么如果出现 2次的数字的某一位是 1 ，一定会使得 x2 的对应位变为 1，所以我们把 x2 返回即可。<br>如果 p = 3，二进制就是 11，那么如果出现 3次的数字的某一位是 1 ，一定会使得 x1 和x2的对应位都变为1，所以我们把 x1 或者 x2 返回即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = <span class="number">0</span>, x2 = <span class="number">0</span>, mask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">        x2 ^= x1 &amp; i;</span><br><span class="line">        x1 ^= i;</span><br><span class="line">        mask = ~(x1 &amp; x2);</span><br><span class="line">        x2 &amp;= mask;</span><br><span class="line">        x1 &amp;= mask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三进制运算"><a href="#三进制运算" class="headerlink" title="三进制运算"></a>三进制运算</h4><p>摸了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            ones = (ones ^ A[i]) &amp; ~twos;</span><br><span class="line">            twos = (twos ^ A[i]) &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第137题只出现一次的数字II&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="位运算" scheme="http://yorxika.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>环形链表II</title>
    <link href="http://yorxika.github.io/2019/11/26/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/"/>
    <id>http://yorxika.github.io/2019/11/26/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/</id>
    <published>2019-11-26T15:22:14.000Z</published>
    <updated>2019-12-12T12:52:43.951Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第142题环形链表II</p><blockquote><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。<br>示例 1：</p><a id="more"></a><p>输入：head = [3,2,0,-4], pos = 1<br>输出：tail connects to node index 1<br>解释：链表中有一个环，其尾部连接到第二个节点。</p></blockquote><hr><h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>思路同141环形链表，用一个set来判断，如果有重复的，直接返回该元素即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Set&lt;ListNode&gt; map = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.contains(head))</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            map.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>这题有个坑，和上一题不一样。<br>上一题条件宽松，在环里相遇即可，并且对初始步数无要求。<br>我在复用上一题代码时，因为初始步数的不一致，导致了最终在死循环里出不来。代码块里注释部分就是导致死循环的地方，尽管两个都能判断相遇成环，但是相遇点不一样，就为后来的找环入口算法带来了障碍。<br>或者注释部分用最开始的双指针代替也可。</p><p>数学解释：</p><blockquote><p>从 head 到入口点的距离设为 x，入口点到相遇点的距离设为 y，环的的长度设为 n。<br>假设 slow 指针走过的距离为 t，那么 fast 指针走过的一定是 slow 指针的 2 倍，也就是 2t。<br>slow 指针从 head 出发走了 x 的距离到达入口点，然后可能走了 k1 圈，然后再次回到入口点，再走了 y 的距离到达相遇点和 fast 指针相遇。<br>t = x + k1 * n + y<br>fast 指针同理，fast 指针从 head 出发走了 x 的距离到达入口点，然后可能走了 k2 圈，然后再次回到入口点，再走了 y 的距离到达相遇点和 slow 指针相遇。<br>2t = x + k2 * n + y<br>上边两个等式做一个差，可以得到<br>t = (k2 - k1) * n<br>设 k = k2 - k1 ，那么 t = k * n。<br>把 t = k * n 代入到第一个式子 t = x + k1 * n + y 中。<br>k * n = x + k1 * n + y<br>移项，x = (k - k1) * n - y<br>取出一个 n 和 y 结合，x = (k - k1 - 1) * n + (n - y)<br>左边的含义就是从 head 到达入口点。<br>右边的含义， n - y 就是从相遇点到入口点的距离，(k - k1 - 1) * n 就是转 (k - k1 - 1) 圈。<br>左边右边的含义结合起来就是，从相遇点走到入口点，然后转 (k - k1 - 1) 圈后再次回到入口点的这段时间，刚好就等于从 head 走向入口点的时间。<br>所以代码的话，我们只需要 meet 指针从相遇点出发的同时，让 head 指针也出发， head 指针和 meet 指针相遇的位置就是入口点了。</p></blockquote><p>通过上面的数学解释，在回顾最开始的代码，就知道了原因所在。最开始就异步，两个指针的步数不一致，也就破坏了后续的推导证明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*ListNode slow = head;</span></span><br><span class="line"><span class="comment">    ListNode fast = head.next;</span></span><br><span class="line"><span class="comment">    while (slow != fast) &#123;</span></span><br><span class="line"><span class="comment">        if (fast == null || fast.next == null) &#123;</span></span><br><span class="line"><span class="comment">            return null;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        slow = slow.next;</span></span><br><span class="line"><span class="comment">        fast = fast.next.next;</span></span><br><span class="line"><span class="comment">        if(fast == slow)</span></span><br><span class="line"><span class="comment">            break;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    ListNode fast = head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这时候已经相遇</span></span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自Leetcode第142题环形链表II&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。&lt;/p&gt;
&lt;p&gt;为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。&lt;/p&gt;
&lt;p&gt;说明：不允许修改给定的链表。&lt;br&gt;示例 1：&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="链表" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://yorxika.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="链表" scheme="http://yorxika.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>环形链表</title>
    <link href="http://yorxika.github.io/2019/11/26/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>http://yorxika.github.io/2019/11/26/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</id>
    <published>2019-11-26T14:40:38.000Z</published>
    <updated>2019-12-12T12:52:51.330Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第141题环形链表</p><blockquote><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><a id="more"></a><p>示例 1：</p><p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p></blockquote><hr><h4 id="丑陋的双指针"><a href="#丑陋的双指针" class="headerlink" title="丑陋的双指针"></a>丑陋的双指针</h4><p>用一个快指针，一个慢指针，快指针每次比慢指针多走1步，这样，如果有环的话两者迟早相遇。<br>但是写的时候循环条件选择不当，导致出现了3次空指针异常，最终加了几个if判断才过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    ListNode p1 = head,p2 = head;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="keyword">null</span> || p2.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        p2 = p2.next.next;</span><br><span class="line">        <span class="keyword">if</span> (p2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1.val == p2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>通过向哈希表里添加结点，每次询问是否包含此节点来判断是否成环.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Set&lt;ListNode&gt; map = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(head !=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.contains(head))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            map.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>来自<a href="https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode/" target="_blank" rel="noopener">题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自Leetcode第141题环形链表&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个链表，判断链表中是否有环。&lt;/p&gt;
&lt;p&gt;为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="链表" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://yorxika.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="链表" scheme="http://yorxika.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>两数之和</title>
    <link href="http://yorxika.github.io/2019/11/26/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yorxika.github.io/2019/11/26/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2019-11-26T14:15:49.000Z</published>
    <updated>2019-12-12T12:53:00.319Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第一题两数之和</p><blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><a id="more"></a><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><hr><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>暴力解法来自于2个半月之前，两轮循环遍历数组，找到目标元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>* res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numsSize; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums [j] == target) &#123;</span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">                res[<span class="number">1</span>] = j;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>来自于<a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/" target="_blank" rel="noopener">题解</a></p><p>建立哈希表存放元素值以及位置值，每次查找target - nums[i]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(complement))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(complement),i&#125;;</span><br><span class="line">        map.put(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="POJ上的两数之和"><a href="#POJ上的两数之和" class="headerlink" title="POJ上的两数之和"></a>POJ上的两数之和</h4><p>来自POJ2366题，提交WA，问题未知。</p><p>问题代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> len1 = in.nextInt();</span><br><span class="line">    <span class="keyword">int</span> [] A = <span class="keyword">new</span> <span class="keyword">int</span>[len1];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">    A[i] = in.nextInt();  <span class="comment">//数组A升序</span></span><br><span class="line">    <span class="keyword">int</span> len2 = in.nextInt();</span><br><span class="line">    <span class="keyword">int</span> [] B = <span class="keyword">new</span> <span class="keyword">int</span>[len2];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len2;i++)</span><br><span class="line">    B[i] = in.nextInt();  <span class="comment">//数组B降序</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 + len2 ; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> complement;</span><br><span class="line"><span class="keyword">if</span>(i &gt;= len1)&#123;</span><br><span class="line">temp = B[i - len1];</span><br><span class="line">complement = <span class="number">10000</span> - temp;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">temp = A[i];</span><br><span class="line">complement = <span class="number">10000</span> - A[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(complement))&#123;</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">map.put(temp,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">System.out.println(<span class="string">"YES"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.println(<span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第一题两数之和&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="哈希表" scheme="http://yorxika.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>买股票的最佳时机II</title>
    <link href="http://yorxika.github.io/2019/11/25/%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/"/>
    <id>http://yorxika.github.io/2019/11/25/%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/</id>
    <published>2019-11-25T12:37:03.000Z</published>
    <updated>2019-12-12T12:53:15.767Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第122题买股票的最佳时机II</p><blockquote><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><a id="more"></a><p>示例 1:</p><p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>       随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p></blockquote><hr><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>同<a href="https://yorxika.github.io/2019/11/18/%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/">买股票的最佳时机III</a>，采用状态机模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h4><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode/" target="_blank" rel="noopener">题解</a></p><blockquote><p>在这种情况下，我们可以简单地继续在斜坡上爬升并持续增加从连续交易中获得的利润，而不是在谷之后寻找每个峰值。最后，我们将有效地使用峰值和谷值，但我们不需要跟踪峰值和谷值对应的成本以及最大利润，但我们可以直接继续增加加数组的连续数字之间的差值，如果第二个数字大于第一个数字，我们获得的总和将是最大利润。</p></blockquote><p>即遍历整个股票交易日价格列表 price，策略是所有上涨交易日都买卖（赚到所有利润），所有下降交易日都不买卖（永不亏钱）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>])</span><br><span class="line">            maxprofit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第122题买股票的最佳时机II&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。&lt;/p&gt;
&lt;p&gt;注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的深度</title>
    <link href="http://yorxika.github.io/2019/11/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <id>http://yorxika.github.io/2019/11/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</id>
    <published>2019-11-25T08:44:02.000Z</published>
    <updated>2019-12-13T15:26:11.601Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第104题二叉树的深度</p><blockquote><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p></blockquote><h4 id="递归I"><a href="#递归I" class="headerlink" title="递归I"></a>递归I</h4><a id="more"></a><p>如果根结点不为空，递归遍历左右子树，并且深度+1，最后返回最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    backOrder(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        depth++;</span><br><span class="line">        max = Math.max(max, depth);</span><br><span class="line">        backOrder(root.left);</span><br><span class="line">        backOrder(root.right);</span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归II"><a href="#递归II" class="headerlink" title="递归II"></a>递归II</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">int</span> max<span class="constructor">Depth(TreeNode <span class="params">root</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (root<span class="operator"> == </span>null) &#123;</span><br><span class="line">     return <span class="number">0</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="built_in">int</span> left_height = max<span class="constructor">Depth(<span class="params">root</span>.<span class="params">left</span>)</span>;</span><br><span class="line">     <span class="built_in">int</span> right_height = max<span class="constructor">Depth(<span class="params">root</span>.<span class="params">right</span>)</span>;</span><br><span class="line">     return java.lang.<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(left_height, right_height) + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>来自<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode/" target="_blank" rel="noopener">题解</a>的评论区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(TreeNode node,<span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">            <span class="keyword">this</span>.height = height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        Stack&lt;Pair&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.add(<span class="keyword">new</span> Pair(root,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            Pair pair = stack.pop();</span><br><span class="line">            TreeNode pop = pair.node;</span><br><span class="line">            depth = depth&gt;pair.height?depth:pair.height;</span><br><span class="line">            <span class="keyword">if</span>(pop.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.add(<span class="keyword">new</span> Pair(pop.right,pair.height+<span class="number">1</span>)); <span class="comment">//right先一步进入栈中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pop.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.add(<span class="keyword">new</span> Pair(pop.left,pair.height+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自Leetcode第104题二叉树的深度&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，找出其最大深度。&lt;/p&gt;
&lt;p&gt;二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;递归I&quot;&gt;&lt;a href=&quot;#递归I&quot; class=&quot;headerlink&quot; title=&quot;递归I&quot;&gt;&lt;/a&gt;递归I&lt;/h4&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的层次遍历II</title>
    <link href="http://yorxika.github.io/2019/11/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86II/"/>
    <id>http://yorxika.github.io/2019/11/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86II/</id>
    <published>2019-11-24T16:15:13.000Z</published>
    <updated>2019-12-12T12:53:36.821Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第107题二叉树的层次遍历II</p><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><h4 id="Collections-reverse"><a href="#Collections-reverse" class="headerlink" title="Collections.reverse()"></a>Collections.reverse()<a id="more"></a></h4><p>最简单的是按照上一次的写法，加上Collections.reverse()即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">                  List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">          <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">          Queue&lt;TreeNode&gt; tree = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">          tree.add(root);</span><br><span class="line">          <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> ( !tree.isEmpty() ) &#123;</span><br><span class="line">              ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">              <span class="keyword">int</span> level_length = tree.size();</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level_length; ++i) &#123;</span><br><span class="line">                  TreeNode p1 = tree.remove();</span><br><span class="line">                  ans.get(level).add(p1.val);</span><br><span class="line">                  <span class="keyword">if</span> (p1.left != <span class="keyword">null</span>) tree.add(p1.left);</span><br><span class="line">                  <span class="keyword">if</span> (p1.right != <span class="keyword">null</span>) tree.add(p1.right);</span><br><span class="line">              &#125;</span><br><span class="line">              level++;</span><br><span class="line">          &#125;</span><br><span class="line">          Collections.reverse(ans);</span><br><span class="line">          <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>来自<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--23/" target="_blank" rel="noopener">题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    DFS(root, <span class="number">0</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode root, <span class="keyword">int</span> level, List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前层数还没有元素，先 new 一个空的列表</span></span><br><span class="line">    <span class="keyword">if</span> (ans.size() &lt;= level) &#123;</span><br><span class="line">        ans.add(<span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前值加入</span></span><br><span class="line">    ans.get(ans.size() - <span class="number">1</span> - level).add(root.val);</span><br><span class="line"></span><br><span class="line">    DFS(root.left, level + <span class="number">1</span>, ans);</span><br><span class="line">    DFS(root.right, level + <span class="number">1</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p>这个写法和102题没啥区别，就是把结点插在了头部，但是为啥用LinkedList的addfirst不行？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> levelNum = queue.size(); <span class="comment">// 当前层元素的个数</span></span><br><span class="line">        List&lt;Integer&gt; subList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelNum; i++) &#123;</span><br><span class="line">            TreeNode curNode = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (curNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                subList.add(curNode.val);</span><br><span class="line">                queue.offer(curNode.left);</span><br><span class="line">                queue.offer(curNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (subList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="number">0</span>, subList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自Leetcode第107题二叉树的层次遍历II&lt;/p&gt;
&lt;p&gt;给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）&lt;/p&gt;
&lt;h4 id=&quot;Collections-reverse&quot;&gt;&lt;a href=&quot;#Collections-reverse&quot; class=&quot;headerlink&quot; title=&quot;Collections.reverse()&quot;&gt;&lt;/a&gt;Collections.reverse()&lt;/h4&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的层次遍历</title>
    <link href="http://yorxika.github.io/2019/11/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <id>http://yorxika.github.io/2019/11/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</id>
    <published>2019-11-24T15:55:03.000Z</published>
    <updated>2019-12-12T12:53:28.861Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第102题二叉树的层次遍历</p><blockquote><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p></blockquote><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>习惯用栈写，出错了，遍历给出的顺序错了，应该改成队列的。<a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; tree = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    tree.add(root);</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( !tree.isEmpty() ) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">int</span> level_length = tree.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level_length; ++i) &#123;</span><br><span class="line">            TreeNode p1 = tree.remove();</span><br><span class="line">            ans.get(level).add(p1.val);</span><br><span class="line">            <span class="keyword">if</span> (p1.left != <span class="keyword">null</span>) tree.add(p1.left);</span><br><span class="line">            <span class="keyword">if</span> (p1.right != <span class="keyword">null</span>) tree.add(p1.right);</span><br><span class="line">        &#125;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>摸了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    levelHelper(res, root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelHelper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, TreeNode root, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (height &gt;= res.size()) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    res.get(height).add(root.val);</span><br><span class="line">    levelHelper(res, root.left, height+<span class="number">1</span>);</span><br><span class="line">    levelHelper(res, root.right, height+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第102题二叉树的层次遍历&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;迭代&quot;&gt;&lt;a href=&quot;#迭代&quot; class=&quot;headerlink&quot; title=&quot;迭代&quot;&gt;&lt;/a&gt;迭代&lt;/h4&gt;&lt;p&gt;习惯用栈写，出错了，遍历给出的顺序错了，应该改成队列的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>对称二叉树</title>
    <link href="http://yorxika.github.io/2019/11/24/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yorxika.github.io/2019/11/24/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2019-11-24T15:18:53.000Z</published>
    <updated>2019-12-12T12:53:54.056Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第101题对称二叉树</p><blockquote><p>给定一个二叉树，检查它是否是镜像对称的。</p></blockquote><hr><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isMirror(root, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (t1.val == t2.val)</span><br><span class="line">            &amp;&amp; isMirror(t1.right, t2.left)</span><br><span class="line">            &amp;&amp; isMirror(t1.left, t2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>来源<a href="https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode/" target="_blank" rel="noopener">题解</a></p><p>除了递归的方法外，我们也可以利用队列进行迭代。队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像。最初，队列中包含的是 root 以及 root。该算法的工作原理类似于 BFS，但存在一些关键差异。每次提取两个结点并比较它们的值。然后，将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p><p>业转载请联系作者获得授权，非商业转载请注明出处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        TreeNode t1 = q.poll();</span><br><span class="line">        TreeNode t2 = q.poll();</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1.val != t2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        q.add(t1.left);</span><br><span class="line">        q.add(t2.right);</span><br><span class="line">        q.add(t1.right);</span><br><span class="line">        q.add(t2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>按自己思路写了一个，用栈的结构，效率低了好多。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    stack.push(root);  <span class="comment">//根结点两次入栈，方便后续比较</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode t1 = stack.pop();  <span class="comment">//出栈</span></span><br><span class="line">        TreeNode t2 = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1.val != t2.val) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        stack.push(t1.left);  <span class="comment">//入栈</span></span><br><span class="line">        stack.push(t2.right);</span><br><span class="line">        stack.push(t1.right);</span><br><span class="line">        stack.push(t2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自Leetcode第101题对称二叉树&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，检查它是否是镜像对称的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h4 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h4&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>复原IP地址</title>
    <link href="http://yorxika.github.io/2019/11/23/%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/"/>
    <id>http://yorxika.github.io/2019/11/23/%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/</id>
    <published>2019-11-23T15:24:13.000Z</published>
    <updated>2019-12-12T12:54:06.503Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第93题复原IP地址</p><blockquote><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>示例:</p><p>输入: “25525511135”<br>输出: [“255.255.11.135”, “255.255.111.35”]<a id="more"></a></p></blockquote><hr><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>4层循环遍历解决所有情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    StringBuilder ip = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">1</span> ; a &lt; <span class="number">4</span> ; ++ a)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">1</span> ; b &lt; <span class="number">4</span> ; ++ b)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span> ; c &lt; <span class="number">4</span> ; ++ c)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span> ; d &lt; <span class="number">4</span> ; ++ d)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a + b + c + d == s.length() )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> n1 = Integer.parseInt(s.substring(<span class="number">0</span>, a));</span><br><span class="line">                        <span class="keyword">int</span> n2 = Integer.parseInt(s.substring(a, a+b));</span><br><span class="line">                        <span class="keyword">int</span> n3 = Integer.parseInt(s.substring(a+b, a+b+c));</span><br><span class="line">                        <span class="keyword">int</span> n4 = Integer.parseInt(s.substring(a+b+c));</span><br><span class="line">                        <span class="keyword">if</span>(n1 &lt;= <span class="number">255</span> &amp;&amp; n2 &lt;= <span class="number">255</span> &amp;&amp; n3 &lt;= <span class="number">255</span> &amp;&amp; n4 &lt;= <span class="number">255</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            ip.append(n1).append(<span class="string">'.'</span>).append(n2)</span><br><span class="line">                                    .append(<span class="string">'.'</span>).append(n3).append(<span class="string">'.'</span>).append(n4);</span><br><span class="line">                            <span class="keyword">if</span>(ip.length() == s.length() + <span class="number">3</span>) ret.add(ip.toString());</span><br><span class="line">                            ip.delete(<span class="number">0</span>, ip.length());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>来自<a href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/fu-yuan-ipdi-zhi-by-leetcode/" target="_blank" rel="noopener">题解</a></p><ul><li>遍历三个有效位置curr_pos 以放置点。<ul><li>检查从上一个点到现在点中间的部分是否有效 :</li><li>是 :<ul><li>放置该点。</li><li>检查全部 3个点是否放好:<ul><li>是 :<ul><li>将结果添加到输出列表中。</li></ul></li><li>否 :<ul><li>继续放下一个点 backtrack(curr_pos, dots - 1)。</li></ul></li></ul></li><li>回溯，移除最后一个点。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"> String s;</span><br><span class="line"> LinkedList&lt;String&gt; segments = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"> ArrayList&lt;String&gt; output = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(String segment)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if the current segment is valid :</span></span><br><span class="line"><span class="comment">   1. less or equal to 255      </span></span><br><span class="line"><span class="comment">   2. the first character could be '0' </span></span><br><span class="line"><span class="comment">   only if the segment is equal to '0'</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">int</span> m = segment.length();</span><br><span class="line">   <span class="keyword">if</span> (m &gt; <span class="number">3</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">return</span> (segment.charAt(<span class="number">0</span>) != <span class="string">'0'</span>) ? (Integer.valueOf(segment) &lt;= <span class="number">255</span>) : (m == <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update_output</span><span class="params">(<span class="keyword">int</span> curr_pos)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   Append the current list of segments </span></span><br><span class="line"><span class="comment">   to the list of solutions</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   String segment = s.substring(curr_pos + <span class="number">1</span>, n);</span><br><span class="line">   <span class="keyword">if</span> (valid(segment)) &#123;</span><br><span class="line">     segments.add(segment);</span><br><span class="line">     output.add(String.join(<span class="string">"."</span>, segments));</span><br><span class="line">     segments.removeLast();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> prev_pos, <span class="keyword">int</span> dots)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   prev_pos : the position of the previously placed dot</span></span><br><span class="line"><span class="comment">   dots : number of dots to place</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="comment">// The current dot curr_pos could be placed </span></span><br><span class="line">   <span class="comment">// in a range from prev_pos + 1 to prev_pos + 4.</span></span><br><span class="line">   <span class="comment">// The dot couldn't be placed </span></span><br><span class="line">   <span class="comment">// after the last character in the string.</span></span><br><span class="line">   <span class="keyword">int</span> max_pos = Math.min(n - <span class="number">1</span>, prev_pos + <span class="number">4</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> curr_pos = prev_pos + <span class="number">1</span>; curr_pos &lt; max_pos; curr_pos++) &#123;</span><br><span class="line">     String segment = s.substring(prev_pos + <span class="number">1</span>, curr_pos + <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">if</span> (valid(segment)) &#123;</span><br><span class="line">       segments.add(segment);  <span class="comment">// place dot</span></span><br><span class="line">       <span class="keyword">if</span> (dots - <span class="number">1</span> == <span class="number">0</span>)      <span class="comment">// if all 3 dots are placed</span></span><br><span class="line">         update_output(curr_pos);  <span class="comment">// add the solution to output</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">         backtrack(curr_pos, dots - <span class="number">1</span>);  <span class="comment">// continue to place dots</span></span><br><span class="line">       segments.removeLast();  <span class="comment">// remove the last placed dot </span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="摸"><a href="#摸" class="headerlink" title="摸"></a>摸</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">    List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    int n = s.<span class="built_in">length</span>();</span><br><span class="line">    backtrack(<span class="number">0</span>, <span class="string">""</span>, <span class="number">4</span>, s, res, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void backtrack(int <span class="built_in">i</span>, String tmp, int flag, String s, List&lt;String&gt; res, int n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">i</span> == n &amp;&amp; flag == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(tmp.substring(<span class="number">0</span>, tmp.<span class="built_in">length</span>() - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="built_in">i</span>; <span class="built_in">j</span> &lt; <span class="built_in">i</span> + <span class="number">3</span>; <span class="built_in">j</span>++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">j</span> &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">i</span> == <span class="built_in">j</span> &amp;&amp; s.charAt(<span class="built_in">j</span>) == <span class="string">'0'</span>) &#123;</span><br><span class="line">                backtrack(<span class="built_in">j</span> + <span class="number">1</span>, tmp + s.charAt(<span class="built_in">j</span>) + <span class="string">"."</span>, flag - <span class="number">1</span>, s, res, n);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Integer.parseInt(s.substring(<span class="built_in">i</span>, <span class="built_in">j</span> + <span class="number">1</span>)) &lt;= <span class="number">255</span>)</span><br><span class="line">                backtrack(<span class="built_in">j</span> + <span class="number">1</span>, tmp + s.substring(<span class="built_in">i</span>, <span class="built_in">j</span> + <span class="number">1</span>) + <span class="string">"."</span>, flag - <span class="number">1</span>, s, res, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自Leetcode第93题复原IP地址&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: “25525511135”&lt;br&gt;输出: [“255.255.11.135”, “255.255.111.35”]&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="回溯" scheme="http://yorxika.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>反转链表II</title>
    <link href="http://yorxika.github.io/2019/11/22/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/"/>
    <id>http://yorxika.github.io/2019/11/22/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/</id>
    <published>2019-11-22T13:21:11.000Z</published>
    <updated>2019-12-12T12:54:44.283Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第92题反转链表II</p><blockquote><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL <a id="more"></a></p></blockquote><hr><h4 id="憨批写法"><a href="#憨批写法" class="headerlink" title="憨批写法"></a>憨批写法</h4><p>写的时候没考虑到一些特殊条件，用了太多的if了判断特殊情况，但是用时0ms，击败了100% hhh</p><p>思路就是找到要交换的部分，然后切开，交换那部分链表，在重新连接即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || m ==<span class="number">1</span> &amp;&amp; n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//找到前一个结点</span></span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p2 = p1.next;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        <span class="comment">//找到末尾结点</span></span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newHead,newCur;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">1</span>)</span><br><span class="line">        newHead = head;</span><br><span class="line">    <span class="keyword">else</span> newHead = p1.next;</span><br><span class="line">    newCur = p2;</span><br><span class="line">    p2 = p2.next;</span><br><span class="line">    newCur.next = <span class="keyword">null</span>;</span><br><span class="line">    newCur = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(m != <span class="number">1</span>)</span><br><span class="line">    p1.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(newHead != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode temp = newHead.next;</span><br><span class="line">        newHead.next = newCur;</span><br><span class="line">        newCur = newHead;</span><br><span class="line">        newHead = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">1</span>)</span><br><span class="line">        p1 = newCur;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p1.next = newCur;</span><br><span class="line">    <span class="keyword">while</span>(newCur.next != <span class="keyword">null</span>)</span><br><span class="line">        newCur = newCur.next;</span><br><span class="line">    newCur.next = p2;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简洁"><a href="#简洁" class="headerlink" title="简洁"></a>简洁</h4><p>在<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/zhao-dao-mhao-jie-dian-de-qian-yi-ge-jie-dian-zai-/" target="_blank" rel="noopener">题解</a>里找到了一个写的相对比较简洁的代码，思路大概是差不多的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode tail = head;  <span class="comment">// tail 记录首个需要翻转的节点</span></span><br><span class="line">        ListNode pre = head;   <span class="comment">// pre 记录首个需要翻转的节点的前一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; ++i) <span class="comment">// 用 pre 记录翻转序列的前一个节点, tail 记录翻转序列的头一个节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre = tail;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n -= m; <span class="comment">// 新的 n 记录需要翻转的次数</span></span><br><span class="line">        ListNode sub_head = tail;  <span class="comment">// 记录需翻转的字串的头节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n-- != <span class="number">0</span>)&#123; <span class="comment">// 翻转子串</span></span><br><span class="line">            ListNode h = tail.next;</span><br><span class="line">            tail.next = h.next;</span><br><span class="line">            h.next = sub_head;</span><br><span class="line">            sub_head = h;</span><br><span class="line">            <span class="keyword">if</span>(m != <span class="number">1</span>) <span class="comment">// 若不是从第一个节点就开始翻转,则进行子串头节点的拼接操作</span></span><br><span class="line">                pre.next = sub_head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m != <span class="number">1</span>) <span class="comment">// 若不是从首节点开始翻转,直接返回原头结点</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">return</span> sub_head; <span class="comment">// 否则表示从首节点开始翻转,返回新的头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第92题反转链表II&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。&lt;/p&gt;
&lt;p&gt;说明:&lt;br&gt;1 ≤ m ≤ n ≤ 链表长度。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2, n = 4&lt;br&gt;输出: 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="链表" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="链表" scheme="http://yorxika.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>反转链表</title>
    <link href="http://yorxika.github.io/2019/11/22/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yorxika.github.io/2019/11/22/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2019-11-22T13:05:18.000Z</published>
    <updated>2019-12-12T12:54:49.428Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第206题反转链表</p><blockquote><p>反转一个单链表。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<a id="more"></a><br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p></blockquote><hr><h4 id="初次提交"><a href="#初次提交" class="headerlink" title="初次提交"></a>初次提交</h4><p>一开始做的时候直接想着把链表形成一个闭环，然后通过这个闭环从最后一个结点逐一找到前一个结点，提交后用时击败了5.75%的用户，在二重循环里浪费了太多的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    ListNode p2;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    p1.next = head;</span><br><span class="line">    ListNode newHead = p1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len; i ++)&#123;</span><br><span class="line">        p2 = p1;</span><br><span class="line">        <span class="keyword">for</span>(;p2.next != p1;p2 = p2.next);</span><br><span class="line">        p2.next = head;</span><br><span class="line">        p1.next = p2;</span><br><span class="line">        <span class="keyword">if</span>(p2.next.next == p2)&#123;</span><br><span class="line">            p2.next.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode p1 = <span class="keyword">null</span>;</span><br><span class="line">    ListNode P2 = head;</span><br><span class="line">    <span class="keyword">while</span> (P2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode nextTemp = P2.next;</span><br><span class="line">        P2.next = p1;</span><br><span class="line">        p1 = P2;</span><br><span class="line">        P2 = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>来源<a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode/" target="_blank" rel="noopener">题解</a></p><p>假设链表是[1, 2, 3, 4, 5]从最底层最后一个reverseList(5)来看</p><ul><li>返回了5这个节点</li><li>reverseList(4)中</li><li>p为5</li><li>head.next.next = head 相当于 5 -&gt; 4</li><li>现在节点情况为 4 -&gt; 5 -&gt; 4</li><li>head.next = null,切断4 -&gt; 5 这一条，现在只有 5 -&gt; 4</li><li>返回（return）p为5，5 -&gt; 4</li><li>返回上一层reverseList(3)</li><li>处理完后返回的是4 -&gt; 3</li><li>依次向上</li></ul><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ListNode reverseList(ListNode<span class="built_in"> head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">(head</span> == null ||<span class="built_in"> head</span>.<span class="keyword">next</span> == null) <span class="keyword">return</span><span class="built_in"> head</span>;</span><br><span class="line">    ListNode p = reverseList<span class="built_in">(head</span>.<span class="keyword">next</span>);</span><br><span class="line">   <span class="built_in"> head</span>.<span class="keyword">next</span>.<span class="keyword">next</span> =<span class="built_in"> head</span>;</span><br><span class="line">   <span class="built_in"> head</span>.<span class="keyword">next</span> = null;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第206题反转链表&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;反转一个单链表。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;br&gt;输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="链表" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="链表" scheme="http://yorxika.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>格雷编码</title>
    <link href="http://yorxika.github.io/2019/11/22/%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/"/>
    <id>http://yorxika.github.io/2019/11/22/%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/</id>
    <published>2019-11-22T12:28:48.000Z</published>
    <updated>2019-12-12T12:55:04.741Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第89题格雷编码</p><blockquote><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p><p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。<a id="more"></a></p></blockquote><hr><h4 id="套公式"><a href="#套公式" class="headerlink" title="套公式"></a>套公式</h4><p>其实看题目描述会吐槽这是什么玩意，但是格雷码是数电里出现过的。<br>数电第一章1.4.2节格雷码公式：<br>设二进制数B = Bn-1 Bn-2 …… B1 B0<br>则其格雷码 G = Gn-1 Gn-2 …… G1 G0<br>且 Gn-1 = Bn-1<br>   Gi = Bi+1 ^ Bi<br>即最高位保留，其它位是当前位和它的高一位进行异或操作。<br>而在这题中，题目是输入 n 代表n位二进制位，输出其编码系统。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>&lt;&lt;n; ++i)</span><br><span class="line">        ret.add(i ^ i&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第89题格雷编码&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。&lt;/p&gt;
&lt;p&gt;给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>解码方法</title>
    <link href="http://yorxika.github.io/2019/11/21/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <id>http://yorxika.github.io/2019/11/21/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</id>
    <published>2019-11-21T14:48:39.000Z</published>
    <updated>2019-12-12T12:55:13.590Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第91题解码方法</p><blockquote><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p><p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>给定一个只包含数字的非空字符串，请计算解码方法的总数。<a id="more"></a></p><p>示例 1:</p><p>输入: “12”<br>输出: 2<br>解释: 它可以解码为 “AB”（1 2）或者 “L”（12）。</p></blockquote><hr><h4 id="自顶向下动态规划"><a href="#自顶向下动态规划" class="headerlink" title="自顶向下动态规划"></a>自顶向下动态规划</h4><p>一开始从前往后推的动态规划写错了，在处理当前位为“0”时没处理好，现在想想，如果当前位为“0”，那么dp[i] = dp[i - 2] 即可。<br>利用动态规划,dp[i]表示当前位置至往前的字符串共有多少种表示方式。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">    dp[len] = <span class="number">1</span> ; <span class="comment">//</span></span><br><span class="line">    <span class="comment">//如果最后一个数字不等于0，就初始化为1</span></span><br><span class="line">    <span class="keyword">if</span>(s.charAt(len - <span class="number">1</span>) != <span class="string">'0'</span>)</span><br><span class="line">        dp[len - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span> ; i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">'0'</span> )</span><br><span class="line">            <span class="comment">//当前数字为0，构成不了任何字母，跳过</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> ans1 = dp[i + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//保存后一串字符串的解码个数</span></span><br><span class="line">        <span class="keyword">int</span> ans2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ten = (s.charAt(i) - <span class="string">'0'</span>) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> one = s.charAt(i + <span class="number">1</span>) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(ten + one &lt;= <span class="number">26</span>)</span><br><span class="line">            ans2 = dp[i + <span class="number">2</span>];</span><br><span class="line">        dp[i] = ans1 + ans2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自底向上动态规划"><a href="#自底向上动态规划" class="headerlink" title="自底向上动态规划"></a>自底向上动态规划</h4><p>这题的测试用例什么奇葩，给我整了那么多的边界条件，我人都傻了。<br>101 输出2<br>100 输出0<br>00 输出0<br>这题就是在疯狂测试边界条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)&#123;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((s.charAt(i - <span class="number">1</span>) == <span class="string">'2'</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">'1'</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">                    dp[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i] = dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == <span class="string">'0'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans1 = dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> ans2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ten = (s.charAt(i - <span class="number">1</span>) - <span class="string">'0'</span>) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> one = s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>( ten &gt; <span class="number">0</span> &amp;&amp; ten + one &lt;= <span class="number">26</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">                ans2 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> ans2 = dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = ans1 + ans2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态规划优化"><a href="#动态规划优化" class="headerlink" title="动态规划优化"></a>动态规划优化</h4><p>来源<a href="https://leetcode-cn.com/problems/decode-ways/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-2-3/" target="_blank" rel="noopener">题解</a></p><p>只需要 2 空间个就够了，更新的时候，指针移动一下即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> (s.charAt(len - <span class="number">1</span>) != <span class="string">'0'</span>) &#123;</span><br><span class="line">        cur = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">'0'</span>) &#123;</span><br><span class="line">            end = cur;<span class="comment">//end 前移</span></span><br><span class="line">            cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans1 = cur;</span><br><span class="line">        <span class="keyword">int</span> ans2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ten = (s.charAt(i) - <span class="string">'0'</span>) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> one = s.charAt(i + <span class="number">1</span>) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (ten + one &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">            ans2 = end;</span><br><span class="line">        &#125;</span><br><span class="line">        end = cur; <span class="comment">//end 前移</span></span><br><span class="line">        cur = ans1 + ans2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第91题解码方法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一条包含字母 A-Z 的消息通过以下方式进行了编码：&lt;/p&gt;
&lt;p&gt;‘A’ -&amp;gt; 1&lt;br&gt;‘B’ -&amp;gt; 2&lt;br&gt;…&lt;br&gt;‘Z’ -&amp;gt; 26&lt;br&gt;给定一个只包含数字的非空字符串，请计算解码方法的总数。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>子集</title>
    <link href="http://yorxika.github.io/2019/11/21/%E5%AD%90%E9%9B%86/"/>
    <id>http://yorxika.github.io/2019/11/21/%E5%AD%90%E9%9B%86/</id>
    <published>2019-11-21T13:45:06.000Z</published>
    <updated>2019-12-12T12:55:40.337Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第78题子集</p><blockquote><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。<br>示例:</p><p>输入: nums = [1,2,3]<br>输出:<a id="more"></a><br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p></blockquote><hr><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>同第77题组合，修改第77题的代码，从1 组合到n即可。<br>注意要加上空集。</p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">( <span class="keyword">int</span> first,ArrayList&lt;Integer&gt; curr,<span class="keyword">int</span> k,<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.size() == k)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = first;i &lt;= nums.length - k + curr.size() + <span class="number">1</span> ; ++i) &#123;</span><br><span class="line">        curr.add(nums[i - <span class="number">1</span>]);</span><br><span class="line">        backtrack(i + <span class="number">1</span>, curr,k,nums);</span><br><span class="line">        curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> k,<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    backtrack(<span class="number">1</span>,<span class="keyword">new</span> ArrayList&lt;Integer&gt;(),k,nums);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</span><br><span class="line">        combine(i + <span class="number">1</span>,nums);</span><br><span class="line">    &#125;</span><br><span class="line">    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>思路来自<a href="https://leetcode-cn.com/problems/subsets/solution/hui-su-die-dai-wei-yan-ma-qing-xi-si-lu-zhu-xing-f/" target="_blank" rel="noopener">题解</a></p><p>对于[1,2,3][1,2,3]，可用三位二进制表示是否选择对应下标的数组元素。则有8种组合方式。</p><ul><li>初始化数组长度nn，最终结果的长度res_len=1&lt;&lt;n，此处位运算表示的是2^n。</li><li>对于每种结果，对于i在遍历区间[0,res_len)中:<ul><li>初始化中间结果cur=[]</li><li>从数组第一位到最后一位进行遍历，对于j在遍历区间[0,n)中：<ul><li>若满足条件i&gt;&gt;j&amp;1，表示第j位是否为1，若满足，则将该位元素加入中间结果cur中</li></ul></li><li>将cur加入res</li></ul></li><li>返回res</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span> &lt;&lt; len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((i &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                cur.add(nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第78题子集&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;说明：解集不能包含重复的子集。&lt;br&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: nums = [1,2,3]&lt;br&gt;输出:&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="位运算" scheme="http://yorxika.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="回溯" scheme="http://yorxika.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>验证回文串</title>
    <link href="http://yorxika.github.io/2019/11/21/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://yorxika.github.io/2019/11/21/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</id>
    <published>2019-11-21T12:52:06.000Z</published>
    <updated>2019-12-12T12:56:13.597Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第125题验证回文串</p><blockquote><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p>说明：本题中，我们将空字符串定义为有效的回文串。</p><a id="more"></a><p>示例 1:</p><p>输入: “A man, a plan, a canal: Panama”<br>输出: true</p></blockquote><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>头尾两个指针，遇到空格直接跳过，遇到大写字母转为小写字母比对即可。</p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] cs = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="string">'0'</span> &lt;= cs[i] &amp;&amp; cs[i] &lt;= <span class="string">'9'</span>) || (<span class="string">'a'</span> &lt;= cs[i] &amp;&amp; cs[i] &lt;= <span class="string">'z'</span>)) &#123;</span><br><span class="line">            cs[cnt++] = cs[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= cs[i] &amp;&amp; cs[i] &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">            cs[cnt++] = (<span class="keyword">char</span>) (cs[i] - <span class="string">'A'</span> + <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt--;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; cnt) <span class="keyword">if</span> (cs[j++] != cs[cnt--]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自Leetcode第125题验证回文串&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。&lt;/p&gt;
&lt;p&gt;说明：本题中，我们将空字符串定义为有效的回文串。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="字符串" scheme="http://yorxika.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://yorxika.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="回文" scheme="http://yorxika.github.io/tags/%E5%9B%9E%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>只出现一次的数字</title>
    <link href="http://yorxika.github.io/2019/11/21/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yorxika.github.io/2019/11/21/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2019-11-20T16:01:56.000Z</published>
    <updated>2019-12-12T12:56:22.909Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第136题只出现一次的数字</p><blockquote><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><a id="more"></a><p>示例 1:</p><p>输入: [2,2,1]<br>输出: 1</p></blockquote><hr><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>最开始是想用哈希表来做的，但是还是有点不熟，就用了一个链表，然而在查找结点，删除结点上花费了太多的时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lenth = nums.length;</span><br><span class="line">    List&lt;Integer&gt; flag = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenth ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            flag.add(nums[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(flag.contains(nums[i]))&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = flag.indexOf(nums[i]);</span><br><span class="line">            flag.remove(pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            flag.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>利用快速排序，在一次遍历找到落单的元素，然而还是很慢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == nums.length - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[i + <span class="number">1</span>])</span><br><span class="line">            i +=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] != nums[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>来源<a href="https://leetcode-cn.com/problems/single-number/solution/xue-suan-fa-jie-guo-xiang-dui-yu-guo-cheng-bu-na-y/" target="_blank" rel="noopener">题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer i : nums) &#123;</span><br><span class="line">        Integer count = map.get(i);</span><br><span class="line">        count = count == <span class="keyword">null</span> ? <span class="number">1</span> : ++count;</span><br><span class="line">        map.put(i, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : map.keySet()) &#123;</span><br><span class="line">        Integer count = map.get(i);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// can't find it.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h4><p>在电路和汇编里见到过的，利用异或求单一的一个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (nums.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            ans = ans ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第136题只出现一次的数字&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="哈希" scheme="http://yorxika.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>十字路口信号灯</title>
    <link href="http://yorxika.github.io/2019/11/20/%E5%8D%81%E5%AD%97%E8%B7%AF%E5%8F%A3%E4%BF%A1%E5%8F%B7%E7%81%AF/"/>
    <id>http://yorxika.github.io/2019/11/20/%E5%8D%81%E5%AD%97%E8%B7%AF%E5%8F%A3%E4%BF%A1%E5%8F%B7%E7%81%AF/</id>
    <published>2019-11-20T15:19:29.000Z</published>
    <updated>2019-12-12T12:52:37.141Z</updated>
    
    <content type="html"><![CDATA[<p>有两条道路双向两个车道，即每条路每个方向只有一个车道，两条道路十字交叉。假设车辆只能向前直行，而不允许转弯和后退。如果有4辆车几乎同时到达这个十字路口，如图（a）所示；相互交叉地停下来，如图（b），此时4辆车都将不能继续向前，这是一个典型的死锁问题。从操作系统原理的资源分配观点，如果4辆车都想驶过十字路口，那么对资源的要求如下：<a id="more"></a></p><ul><li>向北行驶的车1需要象限a和b；</li><li>向西行驶的车2需要象限b和c；</li><li>向南行驶的车3需要象限c和d；</li><li>向东行驶的车4需要象限d和a。</li></ul><p><img src="https://img-blog.csdn.net/20161030120134081" alt></p><h4 id="双向同行"><a href="#双向同行" class="headerlink" title="双向同行"></a>双向同行</h4><p>上课的时候写的，允许同时双向通行，三向通行的先摸了</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"pthreadVC2.lib"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">操作系统十字路口信号灯作业：</span></span><br><span class="line"><span class="comment">目前仅支持南北方向或者东西方向同时通行</span></span><br><span class="line"><span class="comment">采用3个信号灯判断，其中1个信号灯用于为东西方向或者南北方向的车辆抢占路口</span></span><br><span class="line"><span class="comment">剩下2个信号灯表示某个方向有车辆到来</span></span><br><span class="line"><span class="comment">利用随机数来模拟不同时刻从不同方向到达路口的车辆</span></span><br><span class="line"><span class="comment">例：当东方向有车辆到来，此车辆是第一个到达路口的，占据了路口，每当东西方向有车辆过来就允许通行</span></span><br><span class="line"><span class="comment">直到东西方向没有车辆到来，才允许南北方向的车辆通行</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：为产生车辆的总数，设置最大值为65535</span></span><br><span class="line"><span class="comment">输出：产生的随机车辆通过路口的情况</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//5个互斥信号灯</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex_road; <span class="comment">//道路信号灯</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex_we;  <span class="comment">//西到东方向信号灯</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex_ns; <span class="comment">//南北方向信号灯</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//进程数组，用于保存所有车辆进程</span></span><br><span class="line"><span class="keyword">pthread_t</span> car[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//车辆数计数</span></span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化南北方向和东西方向到达路口的车辆数</span></span><br><span class="line"><span class="keyword">int</span> numOfWE = <span class="number">0</span>, numOfNS = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前各个方向上的车辆ID</span></span><br><span class="line"><span class="comment">/*int current_north;</span></span><br><span class="line"><span class="comment">int current_south;</span></span><br><span class="line"><span class="comment">int current_east;</span></span><br><span class="line"><span class="comment">int current_west;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//车辆队列，用于描述从各个方向到达的车辆</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread[MAX];</span><br><span class="line"><span class="keyword">int</span> num[MAX];  <span class="comment">//车辆序号</span></span><br><span class="line"><span class="keyword">int</span> front; <span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">int</span> rear; <span class="comment">//尾指针</span></span><br><span class="line"><span class="keyword">int</span> count; <span class="comment">//队列里的车辆数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>() &#123;</span><br><span class="line">front = rear = count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//车辆入队</span></span><br><span class="line">count++;</span><br><span class="line">rear = (rear + <span class="number">1</span>) % MAX;</span><br><span class="line">num[rear] = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;<span class="comment">//车辆出队</span></span><br><span class="line">count--;</span><br><span class="line">front = (front + <span class="number">1</span>) % MAX;</span><br><span class="line"><span class="keyword">return</span> num[front];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4个方向的车辆队列</span></span><br><span class="line"><span class="built_in">queue</span> car_south;</span><br><span class="line"><span class="built_in">queue</span> car_east;</span><br><span class="line"><span class="built_in">queue</span> car_north;</span><br><span class="line"><span class="built_in">queue</span> car_west;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">car_from_west</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> current_west;</span><br><span class="line"><span class="keyword">time_t</span> start, end;  <span class="comment">//计时变量</span></span><br><span class="line"><span class="keyword">double</span> lastTimes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (car_west.count &gt; <span class="number">0</span>)</span><br><span class="line"> current_west = car_west.pop();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第 %d  辆车从西方向到达路口\n"</span>, current_west);</span><br><span class="line"></span><br><span class="line">start = clock();  <span class="comment">//开始计时</span></span><br><span class="line"></span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;mutex_we);</span><br><span class="line">numOfWE++;</span><br><span class="line"><span class="keyword">if</span>(numOfWE == <span class="number">1</span>)  <span class="comment">//东西方向到达路口的第一辆车先抢占道路</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex_road);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex_we);</span><br><span class="line"></span><br><span class="line">end = clock();</span><br><span class="line">lastTimes = (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第 %d  辆车从西方向到达路口等待了 %lfs 并从东方向离开路口\n"</span>, current_west,lastTimes);</span><br><span class="line">pthread_mutex_lock(&amp;mutex_we);</span><br><span class="line">numOfWE--;</span><br><span class="line"><span class="keyword">if</span>(numOfWE == <span class="number">0</span>) <span class="comment">//如果东西方向上没有车了，解锁信号灯</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex_road);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex_we);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">car_from_east</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> current_east;</span><br><span class="line"><span class="keyword">time_t</span> start, end;  <span class="comment">//计时变量</span></span><br><span class="line"><span class="keyword">double</span> lastTimes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (car_east.count &gt; <span class="number">0</span>)</span><br><span class="line">current_east = car_east.pop();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第 %d  辆车从东方向到达路口\n"</span>, current_east);</span><br><span class="line"></span><br><span class="line">start = clock();  <span class="comment">//开始计时</span></span><br><span class="line"></span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;mutex_we);</span><br><span class="line">numOfWE++;</span><br><span class="line"><span class="keyword">if</span> (numOfWE == <span class="number">1</span>)  <span class="comment">//东西方向到达路口的第一辆车先抢占道路</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex_road);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex_we);</span><br><span class="line"></span><br><span class="line">end = clock();</span><br><span class="line">lastTimes = (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第 %d  辆车从东方向到达路口等待了 %lfs 并从西方向离开路口\n"</span>, current_east, lastTimes);</span><br><span class="line">pthread_mutex_lock(&amp;mutex_we);</span><br><span class="line">numOfWE--;</span><br><span class="line"><span class="keyword">if</span> (numOfWE == <span class="number">0</span>) <span class="comment">//如果东西方向上没有车了，解锁信号灯</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex_road);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex_we);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">car_from_south</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> current_south;</span><br><span class="line"><span class="keyword">time_t</span> start, end;  <span class="comment">//计时变量</span></span><br><span class="line"><span class="keyword">double</span> lastTimes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (car_south.count &gt; <span class="number">0</span>)</span><br><span class="line">current_south = car_south.pop();</span><br><span class="line"></span><br><span class="line">start = clock();  <span class="comment">//开始计时</span></span><br><span class="line"></span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第 %d  辆车从南方向到达路口\n"</span>, current_south);</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;mutex_ns);</span><br><span class="line">numOfNS++;</span><br><span class="line"><span class="keyword">if</span> (numOfNS == <span class="number">1</span>)  <span class="comment">//南北方向到达路口的第一辆车先抢占道路</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex_road);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex_ns);</span><br><span class="line"></span><br><span class="line">end = clock();</span><br><span class="line">lastTimes = (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第 %d  辆车从南方向到达路口等待了 %lfs 并从北方向离开路口\n"</span>, current_south,lastTimes);</span><br><span class="line">pthread_mutex_lock(&amp;mutex_ns);</span><br><span class="line">numOfNS--;</span><br><span class="line"><span class="keyword">if</span> (numOfNS == <span class="number">0</span>) <span class="comment">//如果南北方向上没有车了，解锁信号灯</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex_road);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex_ns);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">car_from_north</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> current_north;</span><br><span class="line"><span class="keyword">time_t</span> start, end;  <span class="comment">//计时变量</span></span><br><span class="line"><span class="keyword">double</span> lastTimes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(car_north.count &gt; <span class="number">0</span>)</span><br><span class="line">current_north = car_north.pop();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第 %d  辆车从北方向到达路口\n"</span>, current_north);</span><br><span class="line"></span><br><span class="line">start = clock();  <span class="comment">//开始计时</span></span><br><span class="line"></span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;mutex_ns);</span><br><span class="line">numOfNS++;</span><br><span class="line"><span class="keyword">if</span> (numOfNS == <span class="number">1</span>)  <span class="comment">//南北方向到达路口的第一辆车先抢占道路</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex_road);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex_ns);</span><br><span class="line"></span><br><span class="line">end = clock();</span><br><span class="line">lastTimes = (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第 %d  辆车从北方向到达路口等待了 %lfs 并从南方向离开路口\n"</span>, current_north,lastTimes);</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;mutex_ns);</span><br><span class="line">numOfNS--;</span><br><span class="line"><span class="keyword">if</span> (numOfNS == <span class="number">0</span>) <span class="comment">//如果南北方向上没有车了，解锁信号灯</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex_road);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex_ns);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化信号灯</span></span><br><span class="line">pthread_mutex_init(&amp;mutex_road,<span class="literal">NULL</span>);</span><br><span class="line">pthread_mutex_init(&amp;mutex_we, <span class="literal">NULL</span>);</span><br><span class="line">pthread_mutex_init(&amp;mutex_ns, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*printf("\n以n表示从北方向到达路口的车辆，s表示南方，w表示西方，e表示东方");*/</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入到达路口的车辆总数："</span>);</span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;len);</span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"开始产生随机车辆队列\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"--------------------------------------------------\n"</span>);</span><br><span class="line"><span class="keyword">int</span> Car = <span class="number">0</span>;  <span class="comment">//随机数用于标记产生的车辆是从哪个方向到达路口</span></span><br><span class="line"><span class="comment">//创建线程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">Car = rand() % <span class="number">4</span>;</span><br><span class="line"><span class="keyword">switch</span> (Car)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: &#123;  <span class="comment">//0表示从西方向到达路口</span></span><br><span class="line">car_west.push(i + <span class="number">1</span>);</span><br><span class="line">car[size++] = car_west.thread[car_west.front];</span><br><span class="line">pthread_create(&amp;car_west.thread[car_west.front],<span class="literal">NULL</span>, car_from_west, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: &#123;  <span class="comment">//1表示从东方向到达路口</span></span><br><span class="line">car_east.push(i + <span class="number">1</span>);</span><br><span class="line">car[size++] = car_east.thread[car_east.front];</span><br><span class="line">pthread_create(&amp;car_east.thread[car_east.rear],<span class="literal">NULL</span>, car_from_east, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: &#123;  <span class="comment">//2表示从南方向到达路口</span></span><br><span class="line">car_south.push(i + <span class="number">1</span>);</span><br><span class="line">car[size++] = car_south.thread[car_south.rear];</span><br><span class="line">pthread_create(&amp;car_south.thread[car_south.rear],<span class="literal">NULL</span>, car_from_south, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: &#123;  <span class="comment">//3表示从北方向到达路口</span></span><br><span class="line">car_north.push(i + <span class="number">1</span>);</span><br><span class="line">car[size++] = car_north.thread[car_north.rear];</span><br><span class="line">pthread_create(&amp;car_north.thread[car_north.rear],<span class="literal">NULL</span>, car_from_north, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入进程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">pthread_join(car[i], <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有两条道路双向两个车道，即每条路每个方向只有一个车道，两条道路十字交叉。假设车辆只能向前直行，而不允许转弯和后退。如果有4辆车几乎同时到达这个十字路口，如图（a）所示；相互交叉地停下来，如图（b），此时4辆车都将不能继续向前，这是一个典型的死锁问题。从操作系统原理的资源分配观点，如果4辆车都想驶过十字路口，那么对资源的要求如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://yorxika.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程" scheme="http://yorxika.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>颜色分类</title>
    <link href="http://yorxika.github.io/2019/11/19/%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"/>
    <id>http://yorxika.github.io/2019/11/19/%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</id>
    <published>2019-11-19T08:05:59.000Z</published>
    <updated>2019-12-12T12:56:32.850Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第75题颜色分类</p><blockquote><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p><a id="more"></a><p>示例:</p><p>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]</p></blockquote><hr><h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><p>直接调用库函数<code>Arrays.sort(nums);</code>就完事了</p><h4 id="2次遍历"><a href="#2次遍历" class="headerlink" title="2次遍历"></a>2次遍历</h4><p>一次遍历先统计3个球的总数，二次遍历重写数组</p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> nums0 = <span class="number">0</span>,nums1 = <span class="number">0</span>,nums2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)</span><br><span class="line">            nums0++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)</span><br><span class="line">            nums1++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">2</span>)</span><br><span class="line">            nums2++;</span><br><span class="line">    &#125;</span><br><span class="line">    nums1 += nums0;</span><br><span class="line">    nums2 += nums1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; nums0)</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; nums1)</span><br><span class="line">            nums[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums[i] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。<br>沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。</p><ul><li>初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx &lt; p0] = 0.</li><li>初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx &gt; p2] = 2.</li><li>初始化当前考虑的元素序号 ：curr = 0.</li><li>While curr &lt;= p2 :<ul><li>若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。</li><li>若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。</li><li>若 nums[curr] = 1 ：将指针curr右移。</li></ul></li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">int</span> p0 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//0的边界指针</span></span><br><span class="line">      <span class="keyword">int</span> p2 = nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//2的边界指针</span></span><br><span class="line">      <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//当前数组指针</span></span><br><span class="line">      <span class="keyword">while</span>(cur &lt;= p2)&#123;</span><br><span class="line"><span class="comment">//3种交换情况</span></span><br><span class="line">          <span class="keyword">if</span>(nums[cur] == <span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">int</span> tmp = nums[p0];</span><br><span class="line">              nums[p0++] = nums[cur];</span><br><span class="line">              nums[cur++] = tmp;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[cur] == <span class="number">2</span>)&#123;</span><br><span class="line">              <span class="keyword">int</span> tmp = nums[p2];</span><br><span class="line">              nums[p2--] = nums[cur];</span><br><span class="line">              nums[cur] = tmp;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              cur++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第75题颜色分类&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。&lt;/p&gt;
&lt;p&gt;此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。&lt;/p&gt;
&lt;p&gt;注意:&lt;br&gt;不能使用代码库中的排序函数来解决这道题。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://yorxika.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="排序" scheme="http://yorxika.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>搜索二维矩阵</title>
    <link href="http://yorxika.github.io/2019/11/19/%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <id>http://yorxika.github.io/2019/11/19/%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</id>
    <published>2019-11-19T07:46:49.000Z</published>
    <updated>2019-12-12T12:56:50.245Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第74题搜索二维矩阵</p><blockquote><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。<a id="more"></a><br>示例 1:</li></ul><p>输入:<br>matrix = [<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>target = 3<br>输出: true</p></blockquote><hr><h4 id="二分查找1"><a href="#二分查找1" class="headerlink" title="二分查找1"></a>二分查找1</h4><p>标准的二分查找模板，做这题时先想着确定所在行，最后在确定所在列。<br>提交的时候遇到了坑，对特殊情况的考虑不周全。</p><p>AC的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>] == <span class="keyword">null</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> midRow ;</span><br><span class="line">    <span class="keyword">int</span> leftRow = <span class="number">0</span>, rightRow = row - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (leftRow &lt;= rightRow)&#123;</span><br><span class="line">        <span class="comment">//确定行号</span></span><br><span class="line">        midRow = (leftRow + rightRow) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix[midRow][<span class="number">0</span>] &lt;= target &amp;&amp; matrix[midRow][col - <span class="number">1</span>] &gt;= target)&#123;</span><br><span class="line">            <span class="keyword">int</span> midCol = <span class="number">0</span>;</span><br><span class="line">            leftRow = <span class="number">0</span>;</span><br><span class="line">            rightRow = col - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (leftRow &lt;= rightRow)&#123;</span><br><span class="line">                midCol = (leftRow + rightRow) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(matrix[midRow][midCol] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(matrix[midRow][midCol] &lt; target)&#123;</span><br><span class="line">                    leftRow = midCol + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    rightRow = midCol - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(matrix[midRow][col - <span class="number">1</span>] &lt; target)&#123;</span><br><span class="line">            leftRow = midRow + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[midRow][<span class="number">0</span>] &gt; target)&#123;</span><br><span class="line">            rightRow = midRow - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="压缩成为一维数组"><a href="#压缩成为一维数组" class="headerlink" title="压缩成为一维数组"></a>压缩成为一维数组</h4><p>来源<a href="https://leetcode-cn.com/problems/search-a-2d-matrix/solution/sou-suo-er-wei-ju-zhen-by-leetcode/" target="_blank" rel="noopener">题解</a></p><p>输入的 m x n 矩阵可以视为长度为 m x n的有序数组。<br>则row = idx // n ， col = idx % n。</p><p>算法：</p><ul><li>初始化左右序号，left = 0 和 right = m x n - 1。</li><li>While left &lt; right :<ul><li>选取虚数组最中间的序号作为中间序号: pivot_idx = (left + right) / 2。<ul><li>该序号对应于原矩阵中的 row = pivot_idx // n行 col = pivot_idx % n 列, 由此可以拿到中间元素pivot_element。该元素将虚数组分为两部分。</li><li>比较 pivot_element 与 target 以确定在哪一部分进行进一步查找。</li></ul></li></ul></li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 二分查找</span></span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> pivotIdx, pivotElement;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    pivotIdx = (left + right) / <span class="number">2</span>;</span><br><span class="line">    pivotElement = matrix[pivotIdx / n][pivotIdx % n];</span><br><span class="line">    <span class="keyword">if</span> (target == pivotElement) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (target &lt; pivotElement) right = pivotIdx - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> left = pivotIdx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="筛选法"><a href="#筛选法" class="headerlink" title="筛选法"></a>筛选法</h4><p>来源<a href="https://leetcode-cn.com/problems/search-a-2d-matrix/solution/java-shai-xuan-by-longchenghuang/" target="_blank" rel="noopener">题解</a></p><p>从右上角开始比对，如果大于target，就可以往左前进一列，如果小于target，就往下走一行。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从右上角开始，比较target与右上角的数据的大小，如果大于target，就可以往左进一行，如果小于target，就可以往下走一行</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;m &amp;&amp; j&gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &gt; target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第74题搜索二维矩阵&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每行中的整数从左到右按升序排列。&lt;/li&gt;
&lt;li&gt;每行的第一个整数大于前一行的最后一个整数。&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="二分查找" scheme="http://yorxika.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>买股票的最佳时机III</title>
    <link href="http://yorxika.github.io/2019/11/18/%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/"/>
    <id>http://yorxika.github.io/2019/11/18/%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/</id>
    <published>2019-11-18T12:28:06.000Z</published>
    <updated>2019-11-18T13:07:42.001Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第123题买股票的最佳时机III</p><blockquote><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<a id="more"></a></p><p>示例 1:</p><p>输入: [3,3,5,0,0,3,1,4]<br>输出: 6<br>解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p></blockquote><h4 id="状态机模板"><a href="#状态机模板" class="headerlink" title="状态机模板"></a>状态机模板</h4><p>解法来自<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/" target="_blank" rel="noopener">题解</a></p><p>采用一个3维数组dp[n][k][2]来标记股票的交易情况。<br>比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。<br>我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。</p><p>基础框架:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">base case：</span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">0</span>] = dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">//因为 i 是从 <span class="number">0</span> 开始的，所以 i = <span class="number">-1</span> 意味着还没有开始，这时候的利润当然是 <span class="number">0</span> 。</span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">1</span>] = dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line">还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。</span><br><span class="line"></span><br><span class="line">状态转移方程：</span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">//解释：今天我没有持有股票，有两种可能：</span><br><span class="line">要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；</span><br><span class="line">要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">//解释：今天我持有着股票，有两种可能：</span><br><span class="line">要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；</span><br><span class="line">要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。</span><br></pre></td></tr></table></figure><p>那么构建的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.length == <span class="number">0</span> || prices.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max_k = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][max_k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i  == <span class="number">0</span>) &#123; <span class="comment">/*处理 base case */</span></span><br><span class="line">                dp[i][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][k][<span class="number">1</span>] = - prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][k][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">0</span>], dp[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][k][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">1</span>], dp[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 穷举了 n × max_k × 2 个状态，正确。</span></span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][max_k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="状态机精简"><a href="#状态机精简" class="headerlink" title="状态机精简"></a>状态机精简</h4><p>用s0代表初始状态，初始时钱是 0。dp_i_1_1代表第一次买入后当前的钱，dp_i_1_0代表第一次卖出后当前的前，dp_i_2_1代表第二次买入后当前的钱，dp_i_2_0代表第二次卖出后当前的钱。</p><p>然后我们只需要更新每天的这四个状态即可。</p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.length == <span class="number">0</span> || prices.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//进行初始化，第一天 dp_i_1_1 将股票买入，其他状态全部初始化为最小值</span></span><br><span class="line">    <span class="keyword">int</span> dp_i_1_1 = -prices[<span class="number">0</span>],dp_i_1_0 = Integer.MIN_VALUE,dp_i_2_1 = Integer.MIN_VALUE,dp_i_2_0 = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;++i) &#123;</span><br><span class="line">        dp_i_1_1 = Math.max(dp_i_1_1, -prices[i]); <span class="comment">//买入价格更低的股</span></span><br><span class="line">        dp_i_1_0 = Math.max(dp_i_1_0, dp_i_1_1+prices[i]); <span class="comment">//卖出当前股，或者不操作</span></span><br><span class="line">        dp_i_2_1 = Math.max(dp_i_2_1, dp_i_1_0-prices[i]); <span class="comment">//第二次买入，或者不操作</span></span><br><span class="line">        dp_i_2_0 = Math.max(dp_i_2_0, dp_i_2_1+prices[i]); <span class="comment">//第二次卖出，或者不操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(<span class="number">0</span>,dp_i_2_0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第123题买股票的最佳时机III&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。&lt;/p&gt;
&lt;p&gt;注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="有限状态机" scheme="http://yorxika.github.io/tags/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>三角形最小路径和</title>
    <link href="http://yorxika.github.io/2019/11/18/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://yorxika.github.io/2019/11/18/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</id>
    <published>2019-11-18T12:13:48.000Z</published>
    <updated>2019-11-18T12:22:56.925Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第120题三角形最小路径和</p><blockquote><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p>例如，给定三角形：</p><a id="more"></a><p>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p></blockquote><hr><h4 id="自顶向下的动态规划"><a href="#自顶向下的动态规划" class="headerlink" title="自顶向下的动态规划"></a>自顶向下的动态规划</h4><p>首先先确定倒数第二层的最短路径，在依次往上推。<br>缺点就是用时有点长，用时13ms，击败了6.51%的用户</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(triangle.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minStep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = triangle.size() - <span class="number">2</span> ; i&gt;=<span class="number">0</span> ; i --)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; triangle.get(i).size(); j++) &#123;</span><br><span class="line">            minStep = Math.min(triangle.get(i + <span class="number">1</span>).get(j),triangle.get(i + <span class="number">1</span>).get(j + <span class="number">1</span>)) + triangle.get(i).get(j);</span><br><span class="line">            triangle.get(i).set(j,minStep);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="O-n-时间复杂度"><a href="#O-n-时间复杂度" class="headerlink" title="O(n)时间复杂度"></a>O(n)时间复杂度</h4><p>思路和上一个是一样的，但是就是因为开拓了O(n)的数组，可以大大缩短访问时间，减少了List的get访问次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = triangle.size();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) dp[i] = triangle.get(row - <span class="number">1</span>).get(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">            dp[j] = Math.min(dp[j], dp[j + <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第120题三角形最小路径和&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。&lt;/p&gt;
&lt;p&gt;例如，给定三角形：&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>买卖股票的最佳时机</title>
    <link href="http://yorxika.github.io/2019/11/18/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>http://yorxika.github.io/2019/11/18/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</id>
    <published>2019-11-18T06:11:21.000Z</published>
    <updated>2019-12-12T12:57:43.262Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第121题买卖股票的最佳时机</p><blockquote><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><a id="more"></a><p>示例 1:</p><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p></blockquote><hr><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>和之前做的最长连续子序和一样，首先先将价格转化为对比前一天的利润，即 dp[i] = dp[i] - dp[i-1]，接着就转化为求连续最长子序和这个问题了。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.length == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> []dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; prices.length; i++)</span><br><span class="line">        dp[i] = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> thisSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">        thisSum += dp[i];</span><br><span class="line">        <span class="keyword">if</span>(thisSum &lt; <span class="number">0</span>)</span><br><span class="line">            thisSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(thisSum &gt; maxSum)</span><br><span class="line">            maxSum = thisSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h4><p>来自<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode/" target="_blank" rel="noopener">题解</a></p><p>对比我自己写的，我想复杂了。<br>求最大利润的话，只用求最大价格与最小价格之间的差即可，那么可以通过一次遍历求出数组里的最大利润。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; minprice)</span><br><span class="line">            minprice = prices[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit)</span><br><span class="line">            maxprofit = prices[i] - minprice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第121题买卖股票的最佳时机&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;
&lt;p&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;
&lt;p&gt;注意你不能在买入股票前卖出股票。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>矩阵置零</title>
    <link href="http://yorxika.github.io/2019/11/18/%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"/>
    <id>http://yorxika.github.io/2019/11/18/%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/</id>
    <published>2019-11-18T02:40:44.000Z</published>
    <updated>2019-12-12T12:57:10.885Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第73题矩阵置零</p><blockquote><p>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p></blockquote><h4 id="统计行列"><a href="#统计行列" class="headerlink" title="统计行列"></a>统计行列</h4><p>最开始是遍历写的，就不放上来了，统计需要置零的行与列，最后再统一置零<a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> R = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> C = matrix[<span class="number">0</span>].length;</span><br><span class="line">    List&lt;Integer&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; cols = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记要设为零的行和列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                rows.add(i);</span><br><span class="line">                cols.add(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次遍历数组，并使用行和列集更新元素。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rows.contains(i) || cols.contains(j)) &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0-1-空间复杂度"><a href="#0-1-空间复杂度" class="headerlink" title="0(1)空间复杂度"></a>0(1)空间复杂度</h4><p>来源<a href="https://leetcode-cn.com/problems/set-matrix-zeroes/solution/ju-zhen-zhi-ling-by-leetcode/" target="_blank" rel="noopener">题解</a></p><p>算法:</p><ul><li>遍历整个矩阵，如果 cell[i][j] == 0 就将第 i 行和第 j 列的第一个元素标记。</li><li>第一行和第一列的标记是相同的，都是 cell[0][0]，所以需要一个额外的变量告知第一列是否被标记，同时用 cell[0][0] 继续表示第一行的标记。</li><li>然后，从第二行第二列的元素开始遍历，如果第 r 行或者第 c 列被标记了，那么就将 cell[r][c] 设为 0。这里第一行和第一列的作用就相当于方法一中的 row_set 和 column_set 。 </li><li>然后我们检查是否 cell[0][0] == 0 ，如果是则赋值第一行的元素为零。</li><li>然后检查第一列是否被标记，如果是则赋值第一列的元素为零。</li></ul><h4 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h4><p>来源<a href="https://leetcode-cn.com/problems/set-matrix-zeroes/solution/javaji-bai-100ti-jie-by-chiyuxing-2/" target="_blank" rel="noopener">题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前一行为0标志</span></span><br><span class="line">    <span class="keyword">boolean</span> isLastRowZero = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i ++) &#123;</span><br><span class="line">        <span class="comment">// 当前行为0标志</span></span><br><span class="line">        <span class="keyword">boolean</span> isCurrRowZero = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                isCurrRowZero = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 纵向上一个值不是零，说明纵向第一次出现零，需要把纵向前面的值都置为零</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; matrix[i - <span class="number">1</span>][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k ++) &#123;</span><br><span class="line">                        matrix[k][j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 纵向上一个值如果为零，则把纵向的零延伸到此行</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; matrix[i - <span class="number">1</span>][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果上一行为零标志为真,则上一行这个位置置为零（纵向为零的判断在上面处理过，所以到这里才可以设置为0）</span></span><br><span class="line">            <span class="keyword">if</span> (isLastRowZero) &#123;</span><br><span class="line">                matrix[i - <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isLastRowZero = isCurrRowZero;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理最后一行为零的情况</span></span><br><span class="line">    <span class="keyword">if</span> (isLastRowZero) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].length; i ++) &#123;</span><br><span class="line">            matrix[matrix.length - <span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自Leetcode第73题矩阵置零&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;统计行列&quot;&gt;&lt;a href=&quot;#统计行列&quot; class=&quot;headerlink&quot; title=&quot;统计行列&quot;&gt;&lt;/a&gt;统计行列&lt;/h4&gt;&lt;p&gt;最开始是遍历写的，就不放上来了，统计需要置零的行与列，最后再统一置零&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>爬楼梯</title>
    <link href="http://yorxika.github.io/2019/11/16/%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://yorxika.github.io/2019/11/16/%E7%88%AC%E6%A5%BC%E6%A2%AF/</id>
    <published>2019-11-16T08:23:57.000Z</published>
    <updated>2019-12-12T12:58:07.147Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第70题爬楼梯</p><blockquote><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。<a id="more"></a><br>示例 2：</p><p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol></blockquote><hr><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>标准的动态规划题，转移方程为dp[i] = dp[i - 1] + dp[i - 2];</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span> ; i &lt;= n ; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题解里的花活"><a href="#题解里的花活" class="headerlink" title="题解里的花活"></a>题解里的花活</h4><p>在官方<a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode/" target="_blank" rel="noopener">题解</a>里还提到了斐波那契数、用矩阵求斐波那契数、斐波那契数公式，这些都在509题 斐波那契数里整了，就先略过了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第70题爬楼梯&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;p&gt;注意：给定 n 是一个正整数。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>不同路径II</title>
    <link href="http://yorxika.github.io/2019/11/16/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
    <id>http://yorxika.github.io/2019/11/16/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</id>
    <published>2019-11-16T08:00:20.000Z</published>
    <updated>2019-12-12T12:58:15.373Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第63题不同路径II</p><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<a id="more"></a><br>网格中的障碍物和空位置分别用 1 和 0 来表示。<br>示例 1:</p><p>输入:<br>[<br>  [0,0,0],<br> [0,1,0],<br> [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p><ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol></blockquote><hr><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>同62题一样，都是套的动态规划模板，当有障碍时dp直接设置为0就行</p><p>代码在前面两个for循环里可以优化，当flag == 1时，就可以直接break了，后续可以直接为0</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[obstacleGrid.length][obstacleGrid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; obstacleGrid.length ; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] != <span class="number">1</span> &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; obstacleGrid[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i] != <span class="number">1</span> &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span> &amp;&amp; flag == <span class="number">0</span>)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; obstacleGrid.length;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; obstacleGrid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j] != <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[obstacleGrid.length][obstacleGrid[<span class="number">0</span>].length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第63题不同路径II&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>不同路径</title>
    <link href="http://yorxika.github.io/2019/11/15/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://yorxika.github.io/2019/11/15/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</id>
    <published>2019-11-15T09:11:37.000Z</published>
    <updated>2019-12-12T12:57:58.318Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第62题不同路径</p><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><a id="more"></a><p>示例 1:</p><p>输入: m = 3, n = 2<br>输出: 3<br>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右</li></ol></blockquote><hr><h4 id="二维动态规划"><a href="#二维动态规划" class="headerlink" title="二维动态规划"></a>二维动态规划</h4><p>同第64题，用dp[i][j]表示到第(i,j)位置时有多少种走法<br>则 dp[i][j] = dp[i - 1][j] + dp[i][j - 1];<br>同时初始化第一行和第一列的的值均为1即可。</p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i ++ )</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m ; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; n ; j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一维动态规划"><a href="#一维动态规划" class="headerlink" title="一维动态规划"></a>一维动态规划</h4><p>同64题，将列数设置为dp的数组长度，从行开始遍历，则当前位置的步数等于左边的步数 + 上一行同一列位置的步数 即为 dp[j] += dp[j-1] ;</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[j] += dp[j-<span class="number">1</span>] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h4><p>假设：向右走是1，向下走是2<br>可行的方案就变成了：112 121 211<br>到这里是不是就有点儿眼熟了？这不就是一串数字的排列组合问题吗！<br>m是多少，就有m-1个数字1；n是多少，就有n-1个数字2<br>所以，我们就用这样的方式，把一个虚假的路径问题转化成了一串只有1和2的数字排列组合问题</p><p>即最终解可表示为C(m + n - 2, m - 1)</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = n + m - <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">int</span> k = m - <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        res = res * (N - k + i) / i;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第62题不同路径&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>最小路径和</title>
    <link href="http://yorxika.github.io/2019/11/15/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://yorxika.github.io/2019/11/15/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</id>
    <published>2019-11-15T08:39:32.000Z</published>
    <updated>2019-12-12T12:58:30.745Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第64题最小路径和</p><blockquote><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例:</p><a id="more"></a><p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p></blockquote><hr><h4 id="二维动态规划"><a href="#二维动态规划" class="headerlink" title="二维动态规划"></a>二维动态规划</h4><p>采用一个二维数组dp[][]来标记到右下角时的最小路径。<br>则dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + arr[i][j],意为到第(i,j)个格子的最短路径等于从上方或者左边的格子的最短路径 加上 到当前格子所需的路径<br>这样的话只需对dp[][]做初始化即可。<br>最开始dp[0][0] = arr[0][0],作为左上角格子走的步数，接下来初始化第一行，第一行等于从左边走的路径加上arr[0][i],即 dp[0][i] = dp[0][i - 1] + grid[0][i]<br>同理初始化第一列为 dp[i][0] = dp[i-1][0] + grid[i][0];</p><p>这样的话写出的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = grid.length;</span><br><span class="line">    <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(row == <span class="number">0</span> || col == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; row;i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; col ; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j&lt; col ; j++)</span><br><span class="line">            dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]) + grid[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一维动态规划"><a href="#一维动态规划" class="headerlink" title="一维动态规划"></a>一维动态规划</h4><p>来源<a href="https://leetcode-cn.com/problems/minimum-path-sum/solution/zui-xiao-lu-jing-he-by-leetcode/" target="_blank" rel="noopener">题解</a></p><p>在上个解法中，我们可以用一个一维数组来代替二维数组，dp数组的大小和行大小相同。这是因为对于某个固定状态，只需要<strong>考虑下方和右侧</strong>的节点。首先初始化 dp数组最后一个元素是右下角的元素值，然后我们向左移更新每个 dp(j) 为：<br>dp[j] - min(dp[j],dp[j+1]) + arr[i][j]<br>我们对于每一行都重复这个过程，然后向上一行移动，计算完成后 dp(0) 就是最后的结果。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid[<span class="number">0</span>].length];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = grid.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = grid[<span class="number">0</span>].length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == grid.length - <span class="number">1</span> &amp;&amp; j != grid[<span class="number">0</span>].length - <span class="number">1</span>)</span><br><span class="line">   <span class="comment">//在最后一行的其他列，来自右边的路径</span></span><br><span class="line">                dp[j] = grid[i][j] +  dp[j + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">   <span class="comment">//上移到上一行</span></span><br><span class="line">                dp[j] = grid[i][j] + dp[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j != grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">   <span class="comment">//左移</span></span><br><span class="line">                dp[j] = grid[i][j] + Math.min(dp[j], dp[j + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[j] = grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不用任何额外存储空间的动态规划"><a href="#不用任何额外存储空间的动态规划" class="headerlink" title="不用任何额外存储空间的动态规划"></a>不用任何额外存储空间的动态规划</h4><p>同二维一致，不过是在原数组上存储，grid[i][j] = grid[i][j] + mid(grid[i-1][j],grid[i][j-1])</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = grid.length;</span><br><span class="line">    <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; row ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; col ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>)</span><br><span class="line">                grid[i][j] = grid[i][j] + grid[i][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>)</span><br><span class="line">                grid[i][j] = grid[i][j] + grid[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j != <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>)</span><br><span class="line">                grid[i][j] = grid[i][j] + Math.min(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第64题最小路径和&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。&lt;/p&gt;
&lt;p&gt;说明：每次只能向下或者向右移动一步。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列</title>
    <link href="http://yorxika.github.io/2019/11/14/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://yorxika.github.io/2019/11/14/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</id>
    <published>2019-11-14T14:30:37.000Z</published>
    <updated>2019-12-12T12:58:37.564Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第509题斐波那契数列</p><blockquote><p>斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>给定 N，计算 F(N)。</p><a id="more"></a><p>示例 1：</p><p>输入：2<br>输出：1<br>解释：F(2) = F(1) + F(0) = 1 + 0 = 1.</p></blockquote><hr><h4 id="递归公式"><a href="#递归公式" class="headerlink" title="递归公式"></a>递归公式</h4><p>就按公式来呗，用长度为3的数组保存</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] FIB = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(N-- &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        FIB[<span class="number">1</span>] = FIB[<span class="number">0</span>] + FIB[<span class="number">1</span>];</span><br><span class="line">        FIB[<span class="number">0</span>] = FIB[<span class="number">1</span>] - FIB[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> FIB[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h4><p>提前存好结果，查表输出结果</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] FIB = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">144</span>,<span class="number">233</span>,<span class="number">377</span>,<span class="number">610</span>,<span class="number">987</span>,<span class="number">1597</span>,<span class="number">2584</span>,<span class="number">4181</span>,<span class="number">6765</span>,<span class="number">10946</span>,<span class="number">17711</span>,<span class="number">28657</span>,<span class="number">46368</span>,<span class="number">75025</span>,<span class="number">121393</span>,<span class="number">196418</span>,<span class="number">317811</span>,<span class="number">514229</span>,<span class="number">832040</span>,<span class="number">1346269</span>,<span class="number">2178309</span>,<span class="number">3524578</span>,<span class="number">5702887</span>,<span class="number">9227465</span>,<span class="number">14930352</span>,<span class="number">24157817</span>,<span class="number">39088169</span>,<span class="number">63245986</span>,<span class="number">102334155</span>,<span class="number">165580141</span>,<span class="number">267914296</span>,<span class="number">433494437</span>,<span class="number">701408733</span>,<span class="number">1134903170</span>,<span class="number">1836311903</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> FIB[N-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h4><p>来源于上学期做的一个电路小实验</p><p>斐波那契(Fibonacci)数列中每项数值都是其两个直接前项的和，其生成规则如下公式1所示：</p><div align="center"><img width="600" src="https://pic.leetcode-cn.com/29ce09975fddbb57caa6c3b2f238dd7b2da45ba976aa748b7c9e82c770716ee1-2.jpg"></div><p>1.求Fibonacci数的矩阵算法<br>  首先，对于数列的初始条件对应公式2的矩阵运算：<br>   <div align="center"><br><img width="600" src="https://pic.leetcode-cn.com/32e6f5abec0d264956f93cb345a9d1ff516a851039b19fd5cc464c3d0f53e523-3.jpg"></div></p><p>   更一般化地，有公式3：<br> <div align="center"><br><img width="600" src="https://pic.leetcode-cn.com/4d62f2d3b268eb9a3a8906c6d2b5473bc7e176ead6fbac2089c98313149a6394-4.jpg"></div></p>   所以，根据递推关系可以得到公式4：  <div align="center"><img width="600" src="https://pic.leetcode-cn.com/ee83089756860a33fe029da4d147a92e3ff9b9f7643d73e254c35df4fd3a8e57-5.jpg"></div> <div align="center"><img width="600" src="https://pic.leetcode-cn.com/bf0e8c007d27ee7b7247bd1601b296d3f656ac9a9fdef01e24f9aaef1861b4ab-7.jpg"></div><p>2.算法描述</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Fibonacci()&#123;</span><br><span class="line"><span class="keyword">For</span> (<span class="attribute">i</span>=5 downto 0)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="attribute">Start</span>==0) then </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span> (n[i]==1) then <span class="attribute">Start</span>=1; </span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">Else</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span> (n[i]==1) </span><br><span class="line">then <span class="attribute">X</span>=X2•A; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> <span class="attribute">X</span>=X2; &#125;</span><br><span class="line">&#125;</span><br><span class="line">return(X);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] X = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span>[][] A = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    String bin_n = Integer.toBinaryString(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bin_n.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(start == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bin_n.charAt(i) == <span class="string">'1'</span>)</span><br><span class="line">                start = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(bin_n.charAt(i) == <span class="string">'1'</span>) &#123;</span><br><span class="line">                X = multiplyPower(X, <span class="number">2</span>);</span><br><span class="line">                X = multiply(X,A);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                X = multiplyPower(X, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> X[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵快速幂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] multiply(<span class="keyword">int</span> [][]a,<span class="keyword">int</span>[][]b)&#123;</span><br><span class="line">        <span class="keyword">int</span>[][]arr=<span class="keyword">new</span> <span class="keyword">int</span>[a.length][b[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;a[<span class="number">0</span>].length;k++)&#123;</span><br><span class="line">                    arr[i][j]+=a[i][k]*b[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] multiplyPower(<span class="keyword">int</span>[][]a,<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] res=<span class="keyword">new</span> <span class="keyword">int</span>[a.length][a[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;res[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j)</span><br><span class="line">                    res[i][j]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">                res=multiply(res,a);</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            a=multiply(a,a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第509题斐波那契数列&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：&lt;/p&gt;
&lt;p&gt;F(0) = 0,   F(1) = 1&lt;br&gt;F(N) = F(N - 1) + F(N - 2), 其中 N &amp;gt; 1.&lt;br&gt;给定 N，计算 F(N)。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>组合</title>
    <link href="http://yorxika.github.io/2019/11/13/%E7%BB%84%E5%90%88/"/>
    <id>http://yorxika.github.io/2019/11/13/%E7%BB%84%E5%90%88/</id>
    <published>2019-11-13T15:32:14.000Z</published>
    <updated>2019-12-12T12:56:02.182Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第77题组合</p><blockquote><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:</p><p>输入: n = 4, k = 2<br>输出:<a id="more"></a><br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p></blockquote><hr><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>首先遍历从 first 到 n 的所有整数，将整数 i 添加到现有组合 curr 中，然后继续回溯向组合中添加更多整数，当组合完成，添加到输出中，并移去 i ，实现回溯。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> totals;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; output = <span class="keyword">new</span> LinkedList();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">( <span class="keyword">int</span> first,LinkedList&lt;Integer&gt; curr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.size() == totals)</span><br><span class="line">        output.add(<span class="keyword">new</span> LinkedList(curr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = first;i &lt; n + <span class="number">1</span> ; ++i) &#123;</span><br><span class="line">        curr.add(i);</span><br><span class="line">        backtrack(i + <span class="number">1</span>, curr);</span><br><span class="line">        curr.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    totals = k;</span><br><span class="line">    backtrack(<span class="number">1</span>,<span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><p>优化for循环，没必要遍历到 n ，而是遍历到 n - k + output.size + 1,k - temp.size ( ) 代表我们还需要的数字个数。因为我们最后取到了 n，所以还要加 1。</p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> totals;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">( <span class="keyword">int</span> first,ArrayList&lt;Integer&gt; curr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.size() == totals)&#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = first;i &lt;= n - totals + curr.size() + <span class="number">1</span> ; ++i) &#123;</span><br><span class="line">        curr.add(i);</span><br><span class="line">        backtrack(i + <span class="number">1</span>, curr);</span><br><span class="line">        curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    totals = k;</span><br><span class="line">    backtrack(<span class="number">1</span>,<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>来源于<a href="https://leetcode-cn.com/problems/combinations/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-1-9/" target="_blank" rel="noopener">题解</a></p><p>完全按照解回溯的思想改成迭代。我们思考一下，回溯其实有三个过程。</p><ul><li>for 循环结束，也就是 i == n + 1，然后回到上一层的 for 循环</li><li>temp.size() == k，也就是所需要的数字够了，然后把它加入到结果中。</li><li>每个 for 循环里边，进入递归，添加下一个数字</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        temp.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        temp.set(i, temp.get(i)+ <span class="number">1</span>); <span class="comment">//当前数字加 1</span></span><br><span class="line">        <span class="comment">//当前数字大于 n，对应回溯法的 i == n + 1，然后回到上一层</span></span><br><span class="line">        <span class="keyword">if</span> (temp.get(i) &gt; n) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        <span class="comment">// 当前数字个数够了</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == k - <span class="number">1</span>) &#123; </span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        <span class="comment">//进入更新下一个数字</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">//把下一个数字置为上一个数字，类似于回溯法中的 start</span></span><br><span class="line">            temp.set(i, temp.get(i-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代II"><a href="#迭代II" class="headerlink" title="迭代II"></a>迭代II</h4><p>来源于<a href="https://leetcode-cn.com/problems/combinations/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-1-9/" target="_blank" rel="noopener">题解</a></p><p>找 k 个数，我们可以先找出 1 个的所有结果，然后在 1 个的所有结果再添加 1 个数，变成 2 个，然后依次迭代，直到有 k 个数。</p><div align="center"><img width="700" src="https://pic.leetcode-cn.com/363a6d288eecc5a6a3d78f78a0895aacc3e3f5388b20256e914ddeaf0d58c3ca-image.png"></div><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || k == <span class="number">0</span> || k &gt; n) <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="comment">//个数为 1 的所有可能</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span> - k; i++) res.add(Arrays.asList(i));</span><br><span class="line">    <span class="comment">//第一层循环，从 2 到 k</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; tmp = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">//第二层循环，遍历之前所有的结果</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : res) &#123;</span><br><span class="line">            <span class="comment">//第三次循环，对每个结果进行扩展</span></span><br><span class="line">            <span class="comment">//从最后一个元素加 1 开始，然后不是到 n ，而是和解法一的优化一样</span></span><br><span class="line">            <span class="comment">//(k - (i - 1） 代表当前已经有的个数，最后再加 1 是因为取了 n</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = list.get(list.size() - <span class="number">1</span>) + <span class="number">1</span>; m &lt;= n - (k - (i - <span class="number">1</span>)) + <span class="number">1</span>; m++) &#123;</span><br><span class="line">                List&lt;Integer&gt; newList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(list);</span><br><span class="line">                newList.add(m);</span><br><span class="line">                tmp.add(newList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合公式"><a href="#组合公式" class="headerlink" title="组合公式"></a>组合公式</h4><p>C ( n, k ) = C ( n - 1, k - 1) + C ( n - 1, k )<br>从 n 个数字选 k 个，我们把所有结果分为两种，包含第 n 个数和不包含第 n 个数。这样的话，就可以把问题转换成：</p><ul><li>从 n - 1 里边选 k - 1 个，然后每个结果加上 n</li><li>从 n - 1 个里边直接选 k 个。</li></ul><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == n || k == <span class="number">0</span>) &#123;</span><br><span class="line">        List&lt;Integer&gt; row = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            row.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(row));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n - 1 里边选 k - 1 个</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = combine(n - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//每个结果加上 n</span></span><br><span class="line">    result.forEach(e -&gt; e.add(n));</span><br><span class="line">    <span class="comment">//把 n - 1 个选 k 个的结果也加入</span></span><br><span class="line">    result.addAll(combine(n - <span class="number">1</span>, k));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第77题组合&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: n = 4, k = 2&lt;br&gt;输出:&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="回溯" scheme="http://yorxika.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>插入区间</title>
    <link href="http://yorxika.github.io/2019/11/12/%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <id>http://yorxika.github.io/2019/11/12/%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</id>
    <published>2019-11-12T12:59:29.000Z</published>
    <updated>2019-12-12T12:58:45.590Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第57题插入区间</p><blockquote><p>给出一个无重叠的 ，按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><a id="more"></a><p>示例 1:</p><p>输入: intervals = [[1,3],[6,9]], newInterval = [2,5]<br>输出: [[1,5],[6,9]]</p></blockquote><hr><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>同合并区间，就是要注意当intervals为空时，可以直接返回newInterval</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span> []&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans.add(newInterval);</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> [][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length + <span class="number">1</span>][<span class="number">2</span>] ;</span><br><span class="line">    System.arraycopy(intervals,<span class="number">0</span>,matrix,<span class="number">0</span>,intervals.length);</span><br><span class="line">    matrix[intervals.length] = newInterval;</span><br><span class="line">    <span class="comment">//根据二维数组第一个数字大小按每一行整体排序</span></span><br><span class="line">    Arrays.sort(matrix, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] ints, <span class="keyword">int</span>[] t1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ints[<span class="number">0</span>] - t1[<span class="number">0</span>] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; matrix.length)&#123;</span><br><span class="line">        <span class="keyword">int</span> left = matrix[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = matrix[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//合并区间，判断right 是否比下一个区间的左值大</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; matrix.length  &amp;&amp; right&gt;= matrix[i][<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="comment">//重新对right赋值</span></span><br><span class="line">            right = Math.max(right,matrix[i][<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;left,right&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入后合并"><a href="#插入后合并" class="headerlink" title="插入后合并"></a>插入后合并</h4><p>注意到初始数组是<strong>无重叠的 ，按照区间起始端点排序的</strong>，因而可以先找到要插入的地方，然后前后合并即可。<br>具体思路见注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先通过二分查找找到要插入的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">midSearch</span><span class="params">(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = intervals.length;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (start&lt;end)&#123;</span><br><span class="line">            mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(intervals[mid][<span class="number">0</span>]&lt;newInterval[<span class="number">0</span>])</span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//计数，计算合并多少了个区间</span></span><br><span class="line">        <span class="keyword">int</span>[] buffer = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        buffer[<span class="number">0</span>] = newInterval[<span class="number">0</span>];</span><br><span class="line">        buffer[<span class="number">1</span>] = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> place = midSearch(intervals,newInterval);<span class="comment">//找到插入位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//向后合并</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(temp = place;temp&lt;intervals.length;temp++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(buffer[<span class="number">1</span>]&lt;intervals[temp][<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这时候temp如果不和place相等，说明插入的区间的右值比后续若干区间的左值都大</span></span><br><span class="line">        <span class="comment">//这时候要更新新的区间右值</span></span><br><span class="line">        <span class="keyword">if</span>(temp!=place)&#123;</span><br><span class="line">            buffer[<span class="number">1</span>] = Math.max(intervals[temp-<span class="number">1</span>][<span class="number">1</span>],buffer[<span class="number">1</span>]);</span><br><span class="line">            count += temp - place;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向前合并</span></span><br><span class="line">        <span class="keyword">if</span> (place!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//如果插入点前一位置的右值比插入区间的左值大</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[place-<span class="number">1</span>][<span class="number">1</span>]&gt;=buffer[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">//那么更新合并区间的左值和右值</span></span><br><span class="line">                buffer[<span class="number">0</span>] = intervals[place-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                buffer[<span class="number">1</span>] = Math.max(intervals[place-<span class="number">1</span>][<span class="number">1</span>],buffer[<span class="number">1</span>]);</span><br><span class="line">                <span class="comment">//同时插入点倒退，合并数+1；</span></span><br><span class="line">                place--;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//储存结果</span></span><br><span class="line">        <span class="keyword">int</span> target;</span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length - count + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(target = <span class="number">0</span>;target&lt;place;target++)&#123;</span><br><span class="line">            result[target][<span class="number">0</span>] = intervals[target][<span class="number">0</span>];</span><br><span class="line">            result[target][<span class="number">1</span>] = intervals[target][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        result[target][<span class="number">0</span>] = buffer[<span class="number">0</span>];</span><br><span class="line">        result[target][<span class="number">1</span>] = buffer[<span class="number">1</span>];</span><br><span class="line">        target++;</span><br><span class="line">        <span class="keyword">for</span>(;temp&lt;intervals.length;temp++,target++)&#123;</span><br><span class="line">            result[target][<span class="number">0</span>] = intervals[temp][<span class="number">0</span>];</span><br><span class="line">            result[target][<span class="number">1</span>] = intervals[temp][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常规思考"><a href="#常规思考" class="headerlink" title="常规思考"></a>常规思考</h4><p>来自<a href="https://leetcode-cn.com/problems/insert-interval/solution/chang-gui-si-kao-by-powcai/" target="_blank" rel="noopener">题解</a></p><blockquote><p>先考虑三种极端情况：</p><ul><li>intervals为空</li><li>newInterval[1] &lt; intervals[0][0],直接插入第一个位置</li><li>newInterval[0] &gt; intervals[-1][1],直接插入最后一个位置</li></ul><p>下面就要考虑重叠情况了</p><p>我们目标就是找到和newInterval相关那几个区间.</p><p>首先,左边,当newInterval[0] &gt; intervals[i][1]说明没有和该区间没有重叠部分,继续遍历下一个区间,比如intervals = [[1,3],[6,9]], newInterval = [2,5]</p><p>然后,再看右边,这里有个情况,就是 当intervals[i][0] &gt; newInterval[1]说明newInterval没有和任何区间重合,比如intervals = [[1,3],[6,9]], newInterval = [4,5],直接插入即可.</p><p>接下来我们要找右边重合区域,当while i &lt; n and newInterval[1] &gt;= intervals[i][0]说明有重叠部分,记录左边最大值!</p><p>最后把数组拼接一下即可!</p></blockquote><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">       List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; intervals.length &amp;&amp; newInterval[<span class="number">0</span>] &gt; intervals[i][<span class="number">1</span>]) &#123;</span><br><span class="line">            res.add(intervals[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newInterval[<span class="number">0</span>], newInterval[<span class="number">1</span>]&#125;;</span><br><span class="line"><span class="comment">//合并右边</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; intervals.length &amp;&amp; newInterval[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">            tmp[<span class="number">0</span>] = Math.min(tmp[<span class="number">0</span>], intervals[i][<span class="number">0</span>]);</span><br><span class="line">            tmp[<span class="number">1</span>] = Math.max(tmp[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(tmp);</span><br><span class="line"><span class="comment">//添加剩余部分</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; intervals.length) &#123;</span><br><span class="line">            res.add(intervals[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第57题插入区间&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给出一个无重叠的 ，按照区间起始端点排序的区间列表。&lt;/p&gt;
&lt;p&gt;在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="排序" scheme="http://yorxika.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>螺旋矩阵II</title>
    <link href="http://yorxika.github.io/2019/11/12/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/"/>
    <id>http://yorxika.github.io/2019/11/12/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/</id>
    <published>2019-11-12T12:14:28.000Z</published>
    <updated>2019-12-12T12:59:07.604Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第59题螺旋矩阵II</p><blockquote><p>给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><a id="more"></a><p>输入: 3<br>输出:<br>[<br> [ 1, 2, 3 ],<br> [ 8, 9, 4 ],<br> [ 7, 6, 5 ]<br>]</p></blockquote><hr><h4 id="层填充"><a href="#层填充" class="headerlink" title="层填充"></a>层填充</h4><p>思路和54题是一样的</p><p>对于每层，我们从左上方开始以顺时针的顺序填充所有元素，假设当前层左上角坐标是 (r1, c1)，右下角坐标是 (r2, c2)。</p><p>首先，遍历上方的所有元素 (r1, c)，按照 c = c1,…,c2 的顺序。然后遍历右侧的所有元素 (r, c2)，按照r = r1+1,…,r2 的顺序。如果这一层有四条边（也就是 r1 &lt; r2 并且 c1 &lt; c2 ），我们以下图所示的方式遍历下方的元素和左侧的元素。</p><div align="center"><img width="700" src="https://pic.leetcode-cn.com/21f4b738d3a221048ab021a8c663083b51c76a2d922c91019d6b5f514881688b-54_spiralmatrix.png"></div><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> [][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> r1 = <span class="number">0</span>, r2 = matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c1 = <span class="number">0</span>, c2 = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = c1; c &lt;= c2; c++) &#123;</span><br><span class="line">            matrix[r1][c] = count;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = r1 + <span class="number">1</span>; r &lt;= r2; r++) &#123;</span><br><span class="line">            matrix[r][c2] = count;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r1 &lt; r2 &amp;&amp; c1 &lt; c2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = c2 - <span class="number">1</span>; c &gt; c1; c--) &#123;</span><br><span class="line">                matrix[r2][c] = count;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = r2; r &gt; r1; r--) &#123;</span><br><span class="line">                matrix[r][c1] = count;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r1++;</span><br><span class="line">        r2--;</span><br><span class="line">        c1++;</span><br><span class="line">        c2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><blockquote><p>绘制螺旋轨迹路径，我们发现当路径超出界限或者进入之前访问过的单元格时，会顺时针旋转方向。<br>假设数组有 R 行 C 列，seen[r][c] 表示第 r 行第 c 列的单元格之前已经被访问过了。当前所在位置为 (r, c)，前进方向是 di。我们希望访问所有 R x C 个单元格。<br>当我们遍历整个矩阵，下一步候选移动位置是 (cr, cc)。如果这个候选位置在矩阵范围内并且没有被访问过，那么它将会变成下一步移动的位置；否则，我们将前进方向顺时针旋转之后再计算下一步的移动位置。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> [][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4次转向的方向</span></span><br><span class="line">    <span class="keyword">int</span> [] dir_i = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> [] dir_j = &#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//定义行数和列数</span></span><br><span class="line">    <span class="keyword">int</span> row = n;</span><br><span class="line">    <span class="keyword">int</span> cols = n;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">// 方向索引</span></span><br><span class="line">    <span class="keyword">int</span> pos_i = <span class="number">0</span>, pos_j = -<span class="number">1</span> ; <span class="comment">//位置索引</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; n * n + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//获得当前遍历行或列的长度</span></span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span> || index == <span class="number">2</span>)</span><br><span class="line">            len = cols;</span><br><span class="line">        <span class="keyword">else</span> len = row;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            <span class="comment">//遍历行or列</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算当前位置</span></span><br><span class="line">            pos_i = pos_i + dir_i[index];</span><br><span class="line">            pos_j = pos_j + dir_j[index];</span><br><span class="line">            matrix[pos_i][pos_j] = count;</span><br><span class="line">            count ++ ;</span><br><span class="line">            <span class="keyword">if</span>(count == n * n + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> matrix;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span> || index == <span class="number">2</span>)</span><br><span class="line">            <span class="comment">//更新边界值</span></span><br><span class="line">            row--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span> || index == <span class="number">3</span>)</span><br><span class="line">            cols--;</span><br><span class="line"></span><br><span class="line">        index = (index + <span class="number">1</span>) % <span class="number">4</span>; <span class="comment">// 换向</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第59题螺旋矩阵II&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>合并区间</title>
    <link href="http://yorxika.github.io/2019/11/11/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <id>http://yorxika.github.io/2019/11/11/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</id>
    <published>2019-11-11T08:54:10.000Z</published>
    <updated>2019-12-12T12:58:54.614Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第56题合并区间</p><blockquote><p>给出一个区间的集合，请合并所有重叠的区间。</p><p>示例 1:</p><p>输入: [[1,3],[2,6],[8,10],[15,18]]<br>输出: [[1,6],[8,10],[15,18]]<br>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<a id="more"></a></p></blockquote><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>思路很简单，就是先将数组按照左边有序的顺序排列，一开始我自己还写了一个排序算法，运行时间大大增加，傻了，放着现成的不用</p><p><a href="https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode/" target="_blank" rel="noopener">题解</a>里采用了lamda表达式的方法，而且list和数组的转换很赞</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span> []&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    <span class="comment">//Arrays.sort(intervals,(a,b) -&gt; a[0] - b[0]);</span></span><br><span class="line">    <span class="comment">// 根据二维数组第一个数字大小按每一行整体排序</span></span><br><span class="line">    Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] ints, <span class="keyword">int</span>[] t1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ints[<span class="number">0</span>] - t1[<span class="number">0</span>] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; intervals.length)&#123;</span><br><span class="line">        <span class="keyword">int</span> left = intervals[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//合并区间，判断right 是否比下一个区间的左值大</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.length  &amp;&amp; right&gt;= intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="comment">//重新对right赋值</span></span><br><span class="line">            right = Math.max(right,intervals[i][<span class="number">1</span>]);</span><br><span class="line">i++；</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;left,right&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己的原代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span> []&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    sort(intervals);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; intervals.length)&#123;</span><br><span class="line">        <span class="keyword">int</span> left = intervals[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//合并区间，判断right 是否比下一个区间的左值大</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.length  &amp;&amp; right&gt;= intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="comment">//重新对right赋值</span></span><br><span class="line">            right = Math.max(right,intervals[i][<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;left,right&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span> <span class="params">(<span class="keyword">int</span> [][] intervals)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = intervals.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; len ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt; intervals[j][<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp1 = intervals[i][<span class="number">0</span>];</span><br><span class="line">                intervals[i][<span class="number">0</span>] = intervals[j][<span class="number">0</span>];</span><br><span class="line">                intervals[j][<span class="number">0</span>] = temp1;</span><br><span class="line">                <span class="keyword">int</span> temp2 = intervals[i][<span class="number">1</span>];</span><br><span class="line">                intervals[i][<span class="number">1</span>] = intervals[j][<span class="number">1</span>];</span><br><span class="line">                intervals[j][<span class="number">1</span>] = temp2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行时间1ms"><a href="#执行时间1ms" class="headerlink" title="执行时间1ms"></a>执行时间1ms</h4><p>在看用时分布时，看了一下用时为1ms的代码，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计数用来表示合并了多少个区间</span></span><br><span class="line">        <span class="keyword">int</span> mergeCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;intervals.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&gt;=intervals[j][<span class="number">0</span>] &amp;&amp; intervals[i][<span class="number">0</span>]&lt;=intervals[j][<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">//开始合并区间的讨论</span></span><br><span class="line">                    <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&gt;intervals[j][<span class="number">1</span>])&#123;</span><br><span class="line">                        <span class="comment">//(i,0) &lt; (j,0) &lt; (j,1) &lt; (i,1)</span></span><br><span class="line">                        intervals[j][<span class="number">1</span>] = intervals[i][<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;intervals[j][<span class="number">0</span>])&#123;</span><br><span class="line">                        <span class="comment">//(i,0) &lt; (i,1) &lt; (j,0) &lt; (j,1)</span></span><br><span class="line">                        intervals[j][<span class="number">0</span>] = intervals[i][<span class="number">0</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    intervals[i] = <span class="keyword">null</span>;</span><br><span class="line">                    mergeCount++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length-mergeCount][];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;j&lt;intervals.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[j] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                result[i++] =intervals[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自Leetcode第56题合并区间&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给出一个区间的集合，请合并所有重叠的区间。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: [[1,3],[2,6],[8,10],[15,18]]&lt;br&gt;输出: [[1,6],[8,10],[15,18]]&lt;br&gt;解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="排序" scheme="http://yorxika.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>搜索旋转排序数组II</title>
    <link href="http://yorxika.github.io/2019/11/11/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/"/>
    <id>http://yorxika.github.io/2019/11/11/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/</id>
    <published>2019-11-11T02:43:56.000Z</published>
    <updated>2019-12-12T12:59:12.364Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第81题搜索旋转排序数组II</p><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p><p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p><p>示例 1:<a id="more"></a></p><p>输入: nums = [2,5,6,0,0,1,2], target = 0<br>输出: true</p></blockquote><h4 id="不正经解法"><a href="#不正经解法" class="headerlink" title="不正经解法"></a>不正经解法</h4><p>在做题的时候想到是不是可以用库函数来解决，想到String类里有方法indexOf(char)，但是在提交时失败了，因为所要查找的target可能是2位数及其以上，于是改用contains.(Integer.toString(target)) ,在倒数第二个测试用例时出错了。<br>经过排查发现，target是4764，而在nums里有-4764，转化为String之后调用contains自然而然的就会返回true了。<br>还是不死心，在Array类的方法里看到有Arrays.binarySearch这个函数，最终成功解决了，但是提交时用时才打败了23.52%的用户，按理而言时间复杂度不应该这么高才对。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="keyword">return</span> Arrays.binarySearch(nums,target) &gt; -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>与33题不同的是，这题允许数据重复，因而当有重复数字，会存在A[mid] = A[end]的情况。此时右半序列A[mid-1 : end]可能是sorted，也可能并没有sorted，所以当A[mid] = A[end] != target时，无法排除一半的序列，而只能排除掉A[end]，搜寻A[start : end-1]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length,left = <span class="number">0</span>,right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right])&#123;</span><br><span class="line">            <span class="comment">//此时是在发生了旋转的区域</span></span><br><span class="line">            <span class="comment">//如果中间的数小于最右边的数，则右半段是有序的，</span></span><br><span class="line">            <span class="comment">//如果中间数大于最右边数，则左半段是有序的，</span></span><br><span class="line">            <span class="comment">//我们只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，</span></span><br><span class="line">            <span class="comment">//这样就可以确定保留哪半边了，</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> right-- ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照题解的，稍微的改了一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length,left = <span class="number">0</span>,right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right])&#123;</span><br><span class="line">            <span class="comment">//此时是在发生了旋转的区域</span></span><br><span class="line">            <span class="comment">//如果中间的数小于最右边的数，则右半段是有序的，</span></span><br><span class="line">            <span class="comment">//如果中间数大于最右边数，则左半段是有序的，</span></span><br><span class="line">            <span class="comment">//我们只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，</span></span><br><span class="line">            <span class="comment">//这样就可以确定保留哪半边了，</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> right-- ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left] == target;</span><br><span class="line">    <span class="comment">//夹逼以后，还要判断一下，是不是 target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第81题搜索旋转排序数组II&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。&lt;/p&gt;
&lt;p&gt;编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="二分" scheme="http://yorxika.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>跳跃游戏II</title>
    <link href="http://yorxika.github.io/2019/11/10/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/"/>
    <id>http://yorxika.github.io/2019/11/10/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/</id>
    <published>2019-11-10T08:02:32.000Z</published>
    <updated>2019-12-12T12:59:36.487Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第45题跳跃游戏II</p><blockquote><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。<a id="more"></a><br>示例:</p><p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p></blockquote><h4 id="自底向上的贪心"><a href="#自底向上的贪心" class="headerlink" title="自底向上的贪心"></a>自底向上的贪心</h4><p>思路同<strong>跳跃游戏</strong>一题里一样，先用一个变量maxLength记录能到达的最远位置，再用变量end记录能到达的最远位置边界，steps记录步数。<br>则每当到达边界end的时候，将end更新为新的maxLength，并且steps++。<br>因为在一次遍历i 到 end 的时候，我们总能找到到达新的最远距离的方法。</p><p>提交的时候遇到坑了，在for循环里，i 是应该要小于 nums.length - 1的，少了末尾。因为在最开始第0个位置的时候，step已经加1了。如果是最后一步刚好到达末尾，steps并不用加1。如果是i &lt; nums.length ，i到最后时进入if语句，steps会 + 1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        maxLength = Math.max(maxLength, i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(i == end)&#123;</span><br><span class="line">            end = maxLength;</span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自顶向下的贪心"><a href="#自顶向下的贪心" class="headerlink" title="自顶向下的贪心"></a>自顶向下的贪心</h4><p>来自<a href="https://leetcode-cn.com/problems/jump-game-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-10/" target="_blank" rel="noopener">题解</a></p><p>我们知道最终要到达最后一个位置，然后我们找前一个位置，遍历数组，找到能到达它的位置，离它最远的就是要找的位置。然后继续找上上个位置，最后到了第 0 个位置就结束了。</p><p>至于离它最远的位置，其实我们从左到右遍历数组，第一个满足的位置就是我们要找的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> position = nums.length - <span class="number">1</span>; <span class="comment">//要找的位置</span></span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (position != <span class="number">0</span>) &#123; <span class="comment">//是否到了第 0 个位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; position; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= position - i) &#123;</span><br><span class="line">                position = i; <span class="comment">//更新要找的位置</span></span><br><span class="line">                steps++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第45题跳跃游戏II&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个非负整数数组，你最初位于数组的第一个位置。&lt;/p&gt;
&lt;p&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p&gt;
&lt;p&gt;你的目标是使用最少的跳跃次数到达数组的最后一个位置。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="贪心" scheme="http://yorxika.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>跳跃游戏</title>
    <link href="http://yorxika.github.io/2019/11/10/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <id>http://yorxika.github.io/2019/11/10/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</id>
    <published>2019-11-10T07:10:06.000Z</published>
    <updated>2019-12-12T12:59:44.375Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第55题跳跃游戏</p><blockquote><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。<br>示例 1:<a id="more"></a></p><p>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p></blockquote><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>来自<a href="https://leetcode-cn.com/problems/jump-game/solution/tiao-yue-you-xi-by-leetcode/" target="_blank" rel="noopener">题解</a></p><p>模拟从第一个位置跳到最后位置的所有方案。从第一个位置开始，模拟所有可以跳到的位置，然后从当前位置重复上述操作，当没有办法继续跳的时候，就回溯。<br>缺点是会超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJumpFromPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> furthestJump = Math.min(position + nums[position], nums.length - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//列举所有可能的跳法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nextPosition = furthestJump; nextPosition &gt; position; nextPosition--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canJumpFromPosition(nextPosition, nums)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canJumpFromPosition(<span class="number">0</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自顶向下的动态规划"><a href="#自顶向下的动态规划" class="headerlink" title="自顶向下的动态规划"></a>自顶向下的动态规划</h4><p>来自<a href="https://leetcode-cn.com/problems/jump-game/solution/tiao-yue-you-xi-by-leetcode/" target="_blank" rel="noopener">题解</a></p><p>定义：能到达最后一个位置的坐标为好坐标，反之为坏坐标。<br>自顶向下的动态规划可以理解成回溯法的一种优化。我们发现当一个坐标已经被确定为好 / 坏之后，结果就不会改变了，这意味着我们可以记录这个结果，每次不用重新计算。</p><p>因此，对于数组中的每个位置，我们记录当前坐标是好 / 坏，记录在数组 memo 中，定义元素取值为 GOOD ，BAD，UNKNOWN。这种方法被称为记忆化。</p><p>步骤：</p><ul><li>初始化 memo 的所有元素为 UNKNOWN，除了最后一个显然是 GOOD （自己一定可以跳到自己）</li><li>优化递归算法，每步回溯前先检查这个位置是否计算过（当前值为：GOOD / BAD）<ul><li>如果已知直接返回结果 True / False</li><li>否则按照之前的回溯步骤计算</li></ul></li><li>计算完毕后，将结果存入memo表中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [] memo; <span class="comment">// 用0，1，-1三态来定义未知，好与坏</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span> position , <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">     <span class="comment">//如果当前位置并非位置，返回状态是否是好位置</span></span><br><span class="line">     <span class="keyword">if</span> (memo[position] != <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> memo[position] == <span class="number">1</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> furthestJump = Math.min(position + nums[position],nums.length - <span class="number">1</span>);</span><br><span class="line">     <span class="comment">//如果能到最后位置，则为好位置</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> nextPosition = position + <span class="number">1</span> ; nextPosition &lt;= furthestJump ; nextPosition++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(canJump(nextPosition,nums))&#123;</span><br><span class="line">             memo[position] = <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//否则记为坏位置</span></span><br><span class="line">     memo[position] = -<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     memo = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">     memo[nums.length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> canJump(<span class="number">0</span> , nums);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="自底向上的动态规划"><a href="#自底向上的动态规划" class="headerlink" title="自底向上的动态规划"></a>自底向上的动态规划</h4><p>来自<a href="https://leetcode-cn.com/problems/jump-game/solution/tiao-yue-you-xi-by-leetcode/" target="_blank" rel="noopener">题解</a></p><p>自底向上和自顶向下动态规划的区别就是消除了回溯，在实际使用中，自底向下的方法有更好的时间效率因为我们不再需要栈空间，可以节省很多缓存开销。更重要的事，这可以让之后更有优化的空间。回溯通常是通过反转动态规划的步骤来实现的。</p><p>这是由于我们每次只会向右跳动，意味着如果我们从右边开始动态规划，每次查询右边节点的信息，都是已经计算过了的，不再需要额外的递归开销，因为我们每次在 memo 表中都可以找到结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Index &#123;</span><br><span class="line">    GOOD, BAD, UNKNOWN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Index[] memo = <span class="keyword">new</span> Index[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; memo.length; i++) &#123;</span><br><span class="line">            memo[i] = Index.UNKNOWN;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[memo.length - <span class="number">1</span>] = Index.GOOD;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> furthestJump = Math.min(i + nums[i], nums.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= furthestJump; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (memo[j] == Index.GOOD) &#123;</span><br><span class="line">                    memo[i] = Index.GOOD;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[<span class="number">0</span>] == Index.GOOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自顶向下的贪心"><a href="#自顶向下的贪心" class="headerlink" title="自顶向下的贪心"></a>自顶向下的贪心</h4><p>当我们把代码改成自底向上的模式，我们会有一个重要的发现，从某个位置出发，我们只需要找到第一个标记为 GOOD 的坐标（由跳出循环的条件可得），也就是说找到最左边的那个坐标。如果我们用一个单独的变量来记录最左边的 GOOD 位置，我们就可以避免搜索整个数组，进而可以省略整个 memo 数组。</p><p>从右向左迭代，对于每个节点我们检查是否存在一步跳跃可以到达 GOOD 的位置（currPosition + nums[currPosition] &gt;= leftmostGoodIndex）。如果可以到达，当前位置也标记为 GOOD ，同时，这个位置将成为新的最左边的 GOOD 位置，一直重复到数组的开头，如果第一个坐标标记为 GOOD 意味着可以从第一个位置跳到最后的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastPos = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + nums[i] &gt;= lastPos) &#123;</span><br><span class="line">            lastPos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastPos == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自底向上的贪心"><a href="#自底向上的贪心" class="headerlink" title="自底向上的贪心"></a>自底向上的贪心</h4><p>从第0个位置出发，如果当前位置可跳跃距离为n，意味着接下来n个位置都可以作为跳跃点。<br>接下来对这n个格子都跳一次，更新能到达的最远距离，如果能到最后位置，则返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; maxLength) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        maxLength = Math.max(maxLength,i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(maxLength &gt;= nums.length - <span class="number">1</span>)</span><br><span class="line">            <span class="comment">//如果最远可到达的位置大于数组长度，则可到达</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第55题跳跃游戏&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个非负整数数组，你最初位于数组的第一个位置。&lt;/p&gt;
&lt;p&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p&gt;
&lt;p&gt;判断你是否能够到达最后一个位置。&lt;br&gt;示例 1:&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="贪心" scheme="http://yorxika.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="回溯" scheme="http://yorxika.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>螺旋矩阵</title>
    <link href="http://yorxika.github.io/2019/11/09/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <id>http://yorxika.github.io/2019/11/09/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</id>
    <published>2019-11-09T07:41:45.000Z</published>
    <updated>2019-12-12T13:00:02.280Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第54题螺旋矩阵</p><blockquote><p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p><p>示例 1:</p><p>输入:<a id="more"></a><br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br>输出: [1,2,3,6,9,8,7,4,5]</p></blockquote><h4 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h4><p>从最外层向内部逐层遍历打印矩阵。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">int</span> xLength = matrix.length; <span class="comment">//定义x方向长度 即行数</span></span><br><span class="line">    <span class="keyword">int</span> yLength = matrix[<span class="number">0</span>].length; <span class="comment">//定义y方向长度 即列数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>; <span class="comment">// 初始化层数</span></span><br><span class="line">    <span class="keyword">int</span> TotalLevel = (Math.min(xLength,yLength) + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//初始化遍历总的层数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (level &lt; TotalLevel)&#123;</span><br><span class="line">        <span class="comment">//对应着最上层向右的第一次遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = level;j &lt; yLength - level;j++)&#123;</span><br><span class="line">            ans.add(matrix[level][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对应着第二次遍历从右上往右下</span></span><br><span class="line">        <span class="comment">//这时候的起点注意行数 + 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = level + <span class="number">1</span> ; j &lt; xLength - level ; j++)</span><br><span class="line">            ans.add(matrix[j][yLength - <span class="number">1</span> - level]);</span><br><span class="line">        <span class="comment">//右下往左下如果这一层只有1行，那么第一个循环已经将该行打印了</span></span><br><span class="line">        <span class="comment">// 这里就不需要打印了，即 xLength - 1 - level != level</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = yLength - level - <span class="number">2</span>; j &gt;= level &amp;&amp; xLength - <span class="number">1</span> - level != level;j--)</span><br><span class="line">            ans.add(matrix[xLength - level - <span class="number">1</span>][j]);</span><br><span class="line">        <span class="comment">//从左下往左上,如果这一层只有1列，那么第2个循环已经将该列打印了，</span></span><br><span class="line">        <span class="comment">// 这里不需要打印，即yLength - 1 - level != level</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = xLength - level - <span class="number">2</span> ; j &gt;= level + <span class="number">1</span> &amp;&amp; yLength - <span class="number">1</span> - level != level ;j--)</span><br><span class="line">            ans.add(matrix[j][level]);</span><br><span class="line">        level ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><p>来源<a href="https://leetcode-cn.com/problems/spiral-matrix/solution/luo-xuan-ju-zhen-by-leetcode/" target="_blank" rel="noopener">题解</a></p><blockquote><p>绘制螺旋轨迹路径，我们发现当路径超出界限或者进入之前访问过的单元格时，会顺时针旋转方向。<br>假设数组有 R 行 C 列，seen[r][c] 表示第 r 行第 c 列的单元格之前已经被访问过了。当前所在位置为 (r, c)，前进方向是 di。我们希望访问所有 R x C 个单元格。<br>当我们遍历整个矩阵，下一步候选移动位置是 (cr, cc)。如果这个候选位置在矩阵范围内并且没有被访问过，那么它将会变成下一步移动的位置；否则，我们将前进方向顺时针旋转之后再计算下一步的移动位置。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">      List ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">      <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">      <span class="keyword">int</span> R = matrix.length, C = matrix[<span class="number">0</span>].length;</span><br><span class="line">      <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[R][C];</span><br><span class="line"><span class="comment">//定义了4个方向数组，分别对应y+1 x+1 x-1 y-1</span></span><br><span class="line">      <span class="keyword">int</span>[] dr = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">      <span class="keyword">int</span>[] dc = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">      <span class="keyword">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>, di = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R * C; i++) &#123;</span><br><span class="line">          ans.add(matrix[r][c]);</span><br><span class="line">          seen[r][c] = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">int</span> cr = r + dr[di];</span><br><span class="line">          <span class="keyword">int</span> cc = c + dc[di];</span><br><span class="line">          <span class="keyword">if</span> (<span class="number">0</span> &lt;= cr &amp;&amp; cr &lt; R &amp;&amp; <span class="number">0</span> &lt;= cc &amp;&amp; cc &lt; C &amp;&amp; !seen[cr][cc])&#123;</span><br><span class="line">              r = cr;</span><br><span class="line">              c = cc;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//越界之后换向</span></span><br><span class="line">              di = (di + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">              r += dr[di];</span><br><span class="line">              c += dc[di];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="优化模拟"><a href="#优化模拟" class="headerlink" title="优化模拟"></a>优化模拟</h5><p>对题解的代码做了一定的优化，减少了空间使用度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="comment">//4次转向的方向</span></span><br><span class="line">    <span class="keyword">int</span> [] dir_i = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> [] dir_j = &#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//定义行数和列数</span></span><br><span class="line">    <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">// 方向索引</span></span><br><span class="line">    <span class="keyword">int</span> countsAll = row * cols;</span><br><span class="line">    <span class="keyword">int</span> pos_i = <span class="number">0</span>, pos_j = -<span class="number">1</span> ; <span class="comment">//位置索引</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; countsAll)&#123;</span><br><span class="line">        <span class="comment">//获得当前遍历行或列的长度</span></span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span> || index == <span class="number">2</span>)</span><br><span class="line">            len = cols;</span><br><span class="line">        <span class="keyword">else</span> len = row;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            <span class="comment">//遍历行or列</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算当前位置</span></span><br><span class="line">            pos_i = pos_i + dir_i[index];</span><br><span class="line">            pos_j = pos_j + dir_j[index];</span><br><span class="line">            ans.add(matrix[pos_i][pos_j]);</span><br><span class="line">            count ++ ;</span><br><span class="line">            <span class="keyword">if</span>(count == countsAll)</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span> || index == <span class="number">2</span>)</span><br><span class="line">        <span class="comment">//更新边界值</span></span><br><span class="line">            row--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span> || index == <span class="number">3</span>)</span><br><span class="line">            cols--;</span><br><span class="line"></span><br><span class="line">        index = (index + <span class="number">1</span>) % <span class="number">4</span>; <span class="comment">// 换向</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层遍历"><a href="#层遍历" class="headerlink" title="层遍历"></a>层遍历</h4><p>对于每层，我们从左上方开始以顺时针的顺序遍历所有元素，假设当前层左上角坐标是 (r1, c1)，右下角坐标是 (r2, c2)。</p><p>首先，遍历上方的所有元素 (r1, c)，按照 c = c1,…,c2 的顺序。然后遍历右侧的所有元素 (r, c2)，按照r = r1+1,…,r2 的顺序。如果这一层有四条边（也就是 r1 &lt; r2 并且 c1 &lt; c2 ），我们以下图所示的方式遍历下方的元素和左侧的元素。</p><div align="center"><img width="700" src="https://pic.leetcode-cn.com/21f4b738d3a221048ab021a8c663083b51c76a2d922c91019d6b5f514881688b-54_spiralmatrix.png"></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List &lt; Integer &gt; spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    List ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">int</span> r1 = <span class="number">0</span>, r2 = matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c1 = <span class="number">0</span>, c2 = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = c1; c &lt;= c2; c++) ans.add(matrix[r1][c]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = r1 + <span class="number">1</span>; r &lt;= r2; r++) ans.add(matrix[r][c2]);</span><br><span class="line">        <span class="keyword">if</span> (r1 &lt; r2 &amp;&amp; c1 &lt; c2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = c2 - <span class="number">1</span>; c &gt; c1; c--) ans.add(matrix[r2][c]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = r2; r &gt; r1; r--) ans.add(matrix[r][c1]);</span><br><span class="line">        &#125;</span><br><span class="line">        r1++;</span><br><span class="line">        r2--;</span><br><span class="line">        c1++;</span><br><span class="line">        c2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第54题螺旋矩阵&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入:&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>旋转链表</title>
    <link href="http://yorxika.github.io/2019/11/09/%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yorxika.github.io/2019/11/09/%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2019-11-09T07:02:19.000Z</published>
    <updated>2019-12-12T13:00:11.870Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第61题旋转链表</p><blockquote><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。<br>示例 1:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>解释:<br>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL <a id="more"></a></p></blockquote><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>不管移动多少步，如果先将链表连接成环，那么最后移动的步数就是 k%n 了，其中n是总的节点数。<br>这样的话新的头结点是在第n - k % n 个结点，而新的尾结点自然是在n - k % n - 1 个结点了，最后只需要将尾结点的next修改为null即可。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     ListNode next;</span><br><span class="line"></span><br><span class="line">     ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">         val = x;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">         <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">         ListNode preHead = head;</span><br><span class="line">         ListNode newTail = head;</span><br><span class="line"><span class="comment">//计算链表长度</span></span><br><span class="line">         <span class="keyword">while</span> (preHead.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">             n++;</span><br><span class="line">             preHead = preHead.next;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">//将链表闭合成环</span></span><br><span class="line">         preHead.next = head;</span><br><span class="line"><span class="comment">//找到新的尾结点</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k % n - <span class="number">1</span>; i++)</span><br><span class="line">             newTail = newTail.next;</span><br><span class="line"><span class="comment">//新的头结点就是新的尾结点的next</span></span><br><span class="line">         ListNode newHead = head;</span><br><span class="line">         newHead = newTail.next;</span><br><span class="line"><span class="comment">//修改新的尾结点的next</span></span><br><span class="line">         newTail.next = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">return</span> newHead;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第61题旋转链表&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。&lt;br&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, k = 2&lt;br&gt;输出: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL&lt;br&gt;解释:&lt;br&gt;向右旋转 1 步: 5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;NULL&lt;br&gt;向右旋转 2 步: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="链表" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="双指针" scheme="http://yorxika.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="链表" scheme="http://yorxika.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>单词搜索</title>
    <link href="http://yorxika.github.io/2019/11/08/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <id>http://yorxika.github.io/2019/11/08/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</id>
    <published>2019-11-08T12:29:22.000Z</published>
    <updated>2019-12-12T13:00:34.115Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第79题单词搜索</p><blockquote><p>给定一个二维网格和一个单词,找出该单词是否存在于网格中。<br>单词必须按照字母顺序,通过相邻的单元格内的字母构成,其中”相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。<br>示例<br>board =<br>[<br>[“A”‘,”B’,”c’,”E]<a id="more"></a><br>[“s’,”F’,”c’,”S”]<br>[“A’,”D’,”E’,”E’]<br>]</p><p>给定word=” ABCCED”,返回true<br>给定word=”sEE”,返回true<br>给定word=”ABCB”,返回fa1se</p></blockquote><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>来自<a href="https://leetcode-cn.com/problems/word-search/solution/zai-er-wei-ping-mian-shang-shi-yong-hui-su-fa-pyth/" target="_blank" rel="noopener">题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] marked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//        x-1,y</span></span><br><span class="line">    <span class="comment">// x,y-1  x,y    x,y+1</span></span><br><span class="line">    <span class="comment">//        x+1,y</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 盘面上有多少行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">// 盘面上有多少列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> String word;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[][] board;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        m = board.length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = board[<span class="number">0</span>].length;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">this</span>.word = word;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> board[i][j] == word.charAt(start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == word.charAt(start)) &#123;</span><br><span class="line">            marked[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> newX = i + direction[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> newY = j + direction[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (inArea(newX, newY) &amp;&amp; !marked[newX][newY]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(newX, newY, start + <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            marked[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第79题单词搜索&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个二维网格和一个单词,找出该单词是否存在于网格中。&lt;br&gt;单词必须按照字母顺序,通过相邻的单元格内的字母构成,其中”相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。&lt;br&gt;示例&lt;br&gt;board =&lt;br&gt;[&lt;br&gt;[“A”‘,”B’,”c’,”E]&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="回溯" scheme="http://yorxika.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>全排列II</title>
    <link href="http://yorxika.github.io/2019/11/08/%E5%85%A8%E6%8E%92%E5%88%97II/"/>
    <id>http://yorxika.github.io/2019/11/08/%E5%85%A8%E6%8E%92%E5%88%97II/</id>
    <published>2019-11-08T12:08:03.000Z</published>
    <updated>2019-12-12T13:00:43.301Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第47题全排列II</p><blockquote><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><p>示例:</p><p>输入: [1,1,2]<a id="more"></a><br>输出:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]</p></blockquote><h4 id="错误的回溯"><a href="#错误的回溯" class="headerlink" title="错误的回溯"></a>错误的回溯</h4><p>这题最开始做的时候是11天前，估计是对应着<strong>全排列</strong>那道题吧，按着那道题的代码改了，有重复的输出正确，没重复的反而输出错误了，emm磨蹭了很久，今天也没找到问题所在，摸了。</p><p>错误的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] used;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    nextPer(nums,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextPer</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="comment">//当start==arr.length-1时，说明子序列的长度为1，就不用再往下分子序列了</span></span><br><span class="line">    <span class="keyword">if</span>(start==arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">        List&lt;Integer&gt; temp_ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length ; i++)&#123;</span><br><span class="line">            temp_ans.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(temp_ans);</span></span><br><span class="line">        ans.add(temp_ans);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!used[i]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; arr[i] == arr[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//start代表的是每一个子序列的第一个位置，我们每一层递归的任务都只有一个：</span></span><br><span class="line">            <span class="comment">//枚举该层子序列第一个位置可以取的值</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[start];</span><br><span class="line">            arr[start] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//该层递归的子序列第一个位置已经确定了，所以又可以往下再分</span></span><br><span class="line">            nextPer(arr, start + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把第该层子序列第一个位置的值换成另外一个值，所以要交换回来</span></span><br><span class="line">            temp = arr[start];</span><br><span class="line">            arr[start] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line"></span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回溯-剪枝"><a href="#回溯-剪枝" class="headerlink" title="回溯 + 剪枝"></a>回溯 + 剪枝</h4><p>来源<a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/" target="_blank" rel="noopener">题解</a></p><blockquote><p>我们归纳出“剪枝”要满足的条件:</p><ul><li>1、在“同一层”,它不是“从左向右数”的第1个分支(标在下图①处);</li><li>2、当前已经选出的数与“同一层”前一个分支已经选出的数相等(标在下图②处);</li><li>3、“同一层”前一个分支已经选出的数在“当前分支”还未被使用(标在下图③处)</li></ul></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] used;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findPermuteUnique</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> depth, Stack&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                <span class="comment">// 修改 2：因为排序以后重复的数一定不会出现在开始，故 i &gt; 0</span></span><br><span class="line">                <span class="comment">// 和之前的数相等，并且之前的数还未使用过，只有出现这种情况，才会出现相同分支</span></span><br><span class="line">                <span class="comment">// 这种情况跳过即可</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                stack.add(nums[i]);</span><br><span class="line">                findPermuteUnique(nums, depth + <span class="number">1</span>, stack);</span><br><span class="line">                stack.pop();</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        findPermuteUnique(nums, <span class="number">0</span>, <span class="keyword">new</span> Stack&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第47题全排列II&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个可包含重复数字的序列，返回所有不重复的全排列。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: [1,1,2]&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="回溯" scheme="http://yorxika.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>第K个排列</title>
    <link href="http://yorxika.github.io/2019/11/08/%E7%AC%ACK%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>http://yorxika.github.io/2019/11/08/%E7%AC%ACK%E4%B8%AA%E6%8E%92%E5%88%97/</id>
    <published>2019-11-08T07:58:06.000Z</published>
    <updated>2019-12-12T13:00:48.261Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第60题第K个排列</p><blockquote><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，<br>给定 n 和 k，返回第 k 个排列。</p><a id="more"></a><p>说明：</p><p>给定 n 的范围是 [1, 9]。<br>给定 k 的范围是[1,  n!]。<br>示例 1:</p><p>输入: n = 3, k = 3<br>输出: “213”</p></blockquote><h4 id="TLE代码"><a href="#TLE代码" class="headerlink" title="TLE代码"></a>TLE代码</h4><p>按照之前全排列的代码，改了一下，但是由于生成的列表是无序的，因而我采取了将其排序的操作，但是这样的最后导致了超时。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextPer</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="comment">//当start==arr.length-1时，说明子序列的长度为1，就不用再往下分子序列了</span></span><br><span class="line">    <span class="keyword">if</span>(start==arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">        List&lt;Integer&gt; temp_ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length ; i++)&#123;</span><br><span class="line">            temp_ans.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(temp_ans);</span></span><br><span class="line">        ans.add(temp_ans);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="comment">//start代表的是每一个子序列的第一个位置，我们每一层递归的任务都只有一个：</span></span><br><span class="line">        <span class="comment">//枚举该层子序列第一个位置可以取的值</span></span><br><span class="line">        <span class="keyword">int</span> temp=arr[start];</span><br><span class="line">        arr[start]=arr[i];</span><br><span class="line">        arr[i]=temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//该层递归的子序列第一个位置已经确定了，所以又可以往下再分</span></span><br><span class="line">        nextPer(arr,start+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把第该层子序列第一个位置的值换成另外一个值，所以要交换回来</span></span><br><span class="line">        temp=arr[start];</span><br><span class="line">        arr[start]=arr[i];</span><br><span class="line">        arr[i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ans.size() ; i ++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i  + <span class="number">1</span>; j &lt; ans.size() ; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; ans.get(j).size(); k ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans.get(i).get(k) &lt; ans.get(j).get(k))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ans.get(i).get(k) &gt; ans.get(j).get(k))&#123;</span><br><span class="line">                    <span class="comment">//System.out.println(k + " " + ans.get(i).get(k) + " " + ans.get(j).get(k));</span></span><br><span class="line">                    List&lt;Integer&gt; temp = ans.get(i);</span><br><span class="line">                    ans.set(i,ans.get(j));</span><br><span class="line">                    ans.set(j,temp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)</span><br><span class="line">        nums[i - <span class="number">1</span>] = i;</span><br><span class="line">    nextPer(nums,<span class="number">0</span>);</span><br><span class="line">    sort(ans);</span><br><span class="line">    String result = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )&#123;</span><br><span class="line">        result += ans.get(k - <span class="number">1</span>).get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println(result);</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h4><p>思路来源<a href="https://leetcode-cn.com/problems/permutation-sequence/solution/zhe-ti-ru-guo-di-gui-jiu-zuo-fu-za-liao-qi-shi-shi/" target="_blank" rel="noopener">题解</a></p><blockquote><p>假设n=5,k=35,<br>n为5的全排列就是首位为1-5的如下排列的所有<br>1_,,,2,,,3,,,4,,,5,,,每个各有24个排列，组成12345的全排列<br>由于k=35&lt;48,也就是说第35个肯定在首位为2的全排列里边,所以第一个取2。<br>接下来就是考虑剩下1345这四个数的全排列里边取第k=35-24=11个，<br>1,,3,,4,,5,,每个各有6个排列，组成1345的全排列，<br>由于k=11&lt;12,也就是说第11个肯定在首位为3的全排列里边，所以第二个数取3<br>接下来就是考虑剩下145这三个数的全排列里边取第k=11-6=5个，<br>1,4,5,_每个各有2个排列，组成145的全排列<br>由于k=5&lt;6,也就是说第5个肯定在首位为5的全排列里边，所以第三个数取5<br>接下来就是考虑剩下14这两个数的排列里边取第k=5-4=1个<br>1_4_每个各有1个排列，组成14的排列，<br>由于k=1,所以第四个数取1<br>最后加上剩下的最后一个4，结果就是23514<br>结束。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StringBuilder nums = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> factor[] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>,<span class="number">720</span>,<span class="number">5040</span>,<span class="number">40320</span>,<span class="number">362880</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">            nums.append(i);</span><br><span class="line">        String answer = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> interval,loop_times = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; loop_times;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            --n;</span><br><span class="line">            interval = (k - <span class="number">1</span>) / factor[n];</span><br><span class="line">            answer += nums.charAt(interval);</span><br><span class="line">            nums = nums.deleteCharAt(interval);</span><br><span class="line">            k = k - interval * factor[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回溯-剪枝"><a href="#回溯-剪枝" class="headerlink" title="回溯 + 剪枝"></a>回溯 + 剪枝</h4><p>来自<a href="https://leetcode-cn.com/problems/permutation-sequence/solution/hui-su-jian-zhi-python-dai-ma-java-dai-ma-by-liwei/" target="_blank" rel="noopener">题解</a></p><p>大致思路其实是同上者</p><blockquote><ul><li>我们知道所求排列一定在叶子结点处得到。事实上，进入每一个分支的时候，我们都可以通过递归的层数，直接计算这一分支可以得到的叶子结点的个数。</li></ul><p>这是因为：进入一个分支的时候，我们可以根据已经选定的数的个数，进而确定还未选定的数的个数，然后计算阶乘，就知道这一个分支的叶子结点有多少个。</p><ul><li><p>2、如果 k 大于这一个分支将要产生的叶子结点数，直接跳过这个分支，即“剪枝”即可。</p></li><li><p>这是因为：即使你回溯去做，要设置状态，回溯回来的时候状态还要重置，但其实跳过的这个分支的叶子结点具体是啥我们并不关心。</p></li><li><p>3、如果 k 小于等于这一个分支将要产生的叶子结点数，那说明所求的全排列一定在这一个分支将要产生的叶子结点里，需要递归求解。</p></li><li><p>4、计算阶乘的时候，你可以使用循环计算，特别注意：0!=1，它表示了没有数可选的时候，即表示到达叶子结点了，排列数只剩下 1 个。</p></li><li><p>又因为题目中说“给定 nn 的范围是 [1,9]”，故可以实现把从 0 到 9 的阶乘计算好，放在一个数组里，可以根据索引直接获得阶乘值，见文后“代码 2”。</p></li></ul></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] = i + <span class="number">1</span>;</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] factorial = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>, <span class="number">40320</span>, <span class="number">362880</span>&#125;;</span><br><span class="line">        List&lt;String&gt; pre = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, used, n, k, <span class="number">0</span>, pre, factorial);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> depth, List&lt;String&gt; pre, <span class="keyword">int</span>[] factorial)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == n) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (String c : pre) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ps = factorial[n - <span class="number">1</span> - depth];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//确定递归层数的位置</span></span><br><span class="line">            <span class="keyword">if</span> (ps &lt; k) &#123;</span><br><span class="line">                k -= ps;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.add(nums[i] + <span class="string">""</span>);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> dfs(nums, used, n, k, depth + <span class="number">1</span>, pre, factorial);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果参数正确的话，代码不会走到这里</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第60题第K个排列&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。&lt;/p&gt;
&lt;p&gt;按大小顺序列出所有排列情况，并一一标记，&lt;br&gt;给定 n 和 k，返回第 k 个排列。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="回溯" scheme="http://yorxika.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>简化路径</title>
    <link href="http://yorxika.github.io/2019/11/07/%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
    <id>http://yorxika.github.io/2019/11/07/%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</id>
    <published>2019-11-07T13:09:11.000Z</published>
    <updated>2019-12-12T13:01:06.151Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第71题简化路径</p><blockquote><p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p><p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径 <a id="more"></a></p><p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。</p><p>示例 4：</p><p>输入：”/a/./b/../../c/“<br>输出：”/c”</p></blockquote><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>思路也简单，对输入字符串做一遍遍历,首先排除字符/，如果是路径文件夹名则入栈，如果是.. 且当前栈不为空则出栈。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    String[] s = path.split(<span class="string">"/"</span>);</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; s[i].equals(<span class="string">".."</span>))</span><br><span class="line">            stack.pop();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!s[i].equals(<span class="string">""</span>) &amp;&amp; !s[i].equals(<span class="string">"."</span>) &amp;&amp; !s[i].equals(<span class="string">".."</span>))</span><br><span class="line">            stack.push(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">    StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stack.size(); i++) &#123;</span><br><span class="line">        ans.append(<span class="string">"/"</span> + stack.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第71题简化路径&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。&lt;/p&gt;
&lt;p&gt;在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="字符串" scheme="http://yorxika.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="栈" scheme="http://yorxika.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>x的平方根</title>
    <link href="http://yorxika.github.io/2019/11/07/x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
    <id>http://yorxika.github.io/2019/11/07/x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</id>
    <published>2019-11-07T12:13:44.000Z</published>
    <updated>2019-12-12T13:00:56.404Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第69题x的平方根</p><blockquote><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。<a id="more"></a></p><p>示例 2:</p><p>输入: 8<br>输出: 2</p></blockquote><h4 id="不正经解法"><a href="#不正经解法" class="headerlink" title="不正经解法"></a>不正经解法</h4><p>最简单的就直接调用Math.sqrt()就行了，但这很明显不符合题意。<br>代码就一句:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)Math.sqrt(x);</span><br></pre></td></tr></table></figure><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>利用x/mid 来比较是否接近目标</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span> || x == <span class="number">1</span>)    <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;<span class="comment">//左边界</span></span><br><span class="line">    <span class="keyword">int</span> r = x;<span class="comment">//右边界</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid =  (r + l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> s = x / mid; <span class="comment">//用来判断mid大于目标还是小于目标，或等于目标</span></span><br><span class="line">        <span class="keyword">int</span> ss = x / (mid + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x / s == s) <span class="keyword">return</span> s; <span class="comment">//刚好是他的算术平方根</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; mid &amp;&amp; ss &lt; mid + <span class="number">1</span>) <span class="keyword">return</span> mid; <span class="comment">//例如6 在2的平方以及 3的平方之间  答案为2</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; mid) l = mid + <span class="number">1</span>; <span class="comment">//调整边界</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt; mid) r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也有用<strong>double</strong>类型来提高精度的</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (<span class="keyword">double</span>) x / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> right = x;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">int</span>)left &lt;(<span class="keyword">int</span>) right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mid * mid &gt; x)&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">            mid = (<span class="keyword">double</span>) (left + right) / <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">            mid = (<span class="keyword">double</span>) (left + right) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)mid ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h4><p>来源<a href="https://leetcode-cn.com/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/" target="_blank" rel="noopener">题解</a></p><p>关于<a href="https://baike.baidu.com/item/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95" target="_blank" rel="noopener">牛顿迭代法</a></p><blockquote><p>这种算法的原理很简单，我们仅仅是不断用 (x, f(x))的切线来逼近方程 x^2-a=0根。根号 a 实际上就是 x^2-a=0的一个正实根，这个函数的导数是 2x。也就是说，函数上任一点 (x,f(x)) 处的切线斜率是 2x。那么，x-f(x)/(2x)就是一个比 x 更接近的近似值。代入 f(x)=x^2-af得到 x-(x^2-a)/(2x)，也就是 (x+a/x)/2。</p></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">     s=x;</span><br><span class="line">     <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span>)(sqrts(x)));</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sqrts</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">      <span class="keyword">double</span> res = (x + s / x) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (res == x) &#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> sqrts(res);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第69题x的平方根&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实现 int sqrt(int x) 函数。&lt;/p&gt;
&lt;p&gt;计算并返回 x 的平方根，其中 x 是非负整数。&lt;/p&gt;
&lt;p&gt;由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="二分" scheme="http://yorxika.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的中序遍历</title>
    <link href="http://yorxika.github.io/2019/11/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://yorxika.github.io/2019/11/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2019-11-06T15:56:20.000Z</published>
    <updated>2019-12-12T13:03:29.625Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第94题二叉树的中序遍历</p><blockquote><p>给定一个二叉树，返回它的<strong>中序</strong>遍历。</p></blockquote><p>中序遍历就是<strong>左中右</strong>的顺序，就当复习一下数据结构里的内容了。<br>如果是栈的话，那就是根结点入栈，接着左子树入栈，直到左子树为空，在进行出栈操作，左子树出栈，根结点出栈，右子树入栈。<a id="more"></a></p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>很经典的递归写法。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">          midOrder(root);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">                  midOrder(root.left);</span><br><span class="line">              result.add(root.val);</span><br><span class="line">              <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">                  midOrder(root.right);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List &lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List &lt;Integer&gt; res = <span class="keyword">new</span> ArrayList &lt; &gt; ();</span><br><span class="line">    Stack &lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack &lt; &gt; ();</span><br><span class="line">    TreeNode current = root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = stack.pop();</span><br><span class="line">        res.add(current.val);</span><br><span class="line">        current = current.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="莫里斯遍历"><a href="#莫里斯遍历" class="headerlink" title="莫里斯遍历"></a>莫里斯遍历</h4><p>莫里斯遍历首先需要将二叉树线索化，关于<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/10810037?fr=aladdin" target="_blank" rel="noopener">线索二叉树</a></p><p><strong>思路</strong>：<br>记当前遍历的节点为 cur</p><ul><li>cur.left 为 null，保存 cur 的值，更新 cur = cur.right</li><li>cur.left 不为 null，找到 cur.left 这颗子树最右边的节点记做 last<ul><li>last.right 为 null，那么将 last.right = cur，更新 cur = cur.left</li><li>last.right 不为 null，说明之前已经访问过，第二次来到这里，表明当前子树遍历完成，保存 cur 的值，更新 cur = cur.right</li></ul></li></ul><p>图示及代码参考<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-2-6/" target="_blank" rel="noopener">题解</a></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//情况 1</span></span><br><span class="line">        <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ans.add(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//找左子树最右边的节点</span></span><br><span class="line">            TreeNode pre = cur.left;</span><br><span class="line">            <span class="keyword">while</span> (pre.right != <span class="keyword">null</span> &amp;&amp; pre.right != cur) &#123;</span><br><span class="line">                pre = pre.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况 2.1</span></span><br><span class="line">            <span class="keyword">if</span> (pre.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况 2.2</span></span><br><span class="line">            <span class="keyword">if</span> (pre.right == cur) &#123;</span><br><span class="line">                pre.right = <span class="keyword">null</span>; <span class="comment">//这里可以恢复为 null</span></span><br><span class="line">                ans.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第94题二叉树的中序遍历&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，返回它的&lt;strong&gt;中序&lt;/strong&gt;遍历。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;中序遍历就是&lt;strong&gt;左中右&lt;/strong&gt;的顺序，就当复习一下数据结构里的内容了。&lt;br&gt;如果是栈的话，那就是根结点入栈，接着左子树入栈，直到左子树为空，在进行出栈操作，左子树出栈，根结点出栈，右子树入栈。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
      <category term="递归" scheme="http://yorxika.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
      <category term="栈" scheme="http://yorxika.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>二进制求和</title>
    <link href="http://yorxika.github.io/2019/11/06/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/"/>
    <id>http://yorxika.github.io/2019/11/06/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</id>
    <published>2019-11-06T09:37:41.000Z</published>
    <updated>2019-12-12T13:03:10.965Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第67题二进制求和</p><blockquote><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p><p>输入为非空字符串且只包含数字 1 和 0。</p><a id="more"></a><p>示例 1:</p><p>输入: a = “11”, b = “1”<br>输出: “100”</p></blockquote><p>与上一题一样，从末位开始相加，考虑进位信息，字符串补长到一样长，不足位补0，最后考虑进位信息。</p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//是否进位 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = carry;</span><br><span class="line">        <span class="comment">// 获取字符串a对应的某一位的值 当i&lt;0是 sum+=0（向前补0） 否则将原值转为int</span></span><br><span class="line">        sum += (i &gt;= <span class="number">0</span> ? a.charAt(i) - <span class="string">'0'</span> : <span class="number">0</span>); </span><br><span class="line">        sum +=( j &gt;= <span class="number">0</span> ? b.charAt(j) - <span class="string">'0'</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//考虑carry和a.charAt(i)、b.charAt(j)</span></span><br><span class="line">        <span class="comment">//三者相加后10进制数分别可能为0,1,2,3</span></span><br><span class="line">        <span class="comment">//需要转成二进制</span></span><br><span class="line">        ans.append(sum % <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//进位信号只有2，3会产生</span></span><br><span class="line">        carry = sum / <span class="number">2</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断最后一次计算是否有进位  有则在最前面加上1 否则原样输出</span></span><br><span class="line">    ans.append(carry == <span class="number">1</span> ? carry : <span class="string">""</span>);</span><br><span class="line">    <span class="comment">//翻转后输出</span></span><br><span class="line">    <span class="keyword">return</span> ans.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第67题二进制求和&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定两个二进制字符串，返回他们的和（用二进制表示）。&lt;/p&gt;
&lt;p&gt;输入为非空字符串且只包含数字 1 和 0。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="字符串" scheme="http://yorxika.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>加一</title>
    <link href="http://yorxika.github.io/2019/11/06/%E5%8A%A0%E4%B8%80/"/>
    <id>http://yorxika.github.io/2019/11/06/%E5%8A%A0%E4%B8%80/</id>
    <published>2019-11-06T09:10:57.000Z</published>
    <updated>2019-12-12T13:02:34.100Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第66题加一</p><blockquote><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><a id="more"></a><p>示例 1:</p><p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。</p></blockquote><h4 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h4><p>很简单的一道题，直接从末尾加一，携带一个进位信号carry，如果和为10，那么digits[i] %= 10 ,carry = 1，不然循环加carry即可，最后判断最高位carry是否为1，为1说明当前值为1000000，需要对数组扩容。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = digits.length;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i -- )&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len - <span class="number">1</span>)&#123;</span><br><span class="line">        digits[i] = digits[i] + carry + <span class="number">1</span>;</span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            digits[i] = digits[i] + carry ;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(digits[i] == <span class="number">10</span>)&#123;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">        digits = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>  digits;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简洁"><a href="#简洁" class="headerlink" title="简洁"></a>简洁</h4><p>写法不简洁，来自<a href="https://leetcode-cn.com/problems/plus-one/solution/java-shu-xue-jie-ti-by-yhhzw/" target="_blank" rel="noopener">题解</a>有一个很简洁的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          digits[i]++;</span><br><span class="line">          digits[i] = digits[i] % <span class="number">10</span>;</span><br><span class="line"><span class="comment">//从ditis[i] != 0这一步就判断出了进位信号的结束</span></span><br><span class="line"><span class="comment">//在还有进位信号的时候，末尾起每位加一</span></span><br><span class="line"><span class="comment">//进位结束了返回digits即可</span></span><br><span class="line">          <span class="keyword">if</span> (digits[i] != <span class="number">0</span>) <span class="keyword">return</span> digits;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//这时ditis[0] = 0，意味着原先的数是999</span></span><br><span class="line"><span class="comment">//因而对其扩容，ditis[0]设置为1即可</span></span><br><span class="line">      digits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">      digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> digits;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第66题加一&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。&lt;/p&gt;
&lt;p&gt;最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。&lt;/p&gt;
&lt;p&gt;你可以假设除了整数 0 之外，这个整数不会以零开头。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>最大子序和</title>
    <link href="http://yorxika.github.io/2019/11/05/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>http://yorxika.github.io/2019/11/05/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</id>
    <published>2019-11-05T13:31:50.000Z</published>
    <updated>2019-12-12T13:01:36.282Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第53题最大子序和</p><blockquote><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<a id="more"></a></p></blockquote><p>这题上课讲过，思路是分治，分越过中点，没有越过中点，又分中点左边，中点右边，共3种情况。<br>不过写的时候忘记了，于是先采用了万能的循环遍历，在倒数第三个测试用例时TLE了，打扰了</p><h4 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h4><p>用O(n^2)的时间，即2个循环去遍历所有子序列的情况，最终保存最大值即可，方法简单，但是会超时。<br>坑在于max值的设置，要设置成Integer.MIN_VALUE，以及第2重循环，将上一个子序列的值保留下来。<br>但是这样的效率非常低，用时62ms，击败了7.70%用户2333.</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE ;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i ++ )&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; max)</span><br><span class="line">                max = sum ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; len ;j++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; max)</span><br><span class="line">                    max = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p><strong>思路</strong></p><ul><li>动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans</li><li>如果 sum &gt; 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字</li><li>如果 sum &lt;= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字</li><li>每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果</li></ul><p>[动图(<a href="https://leetcode-cn.com/problems/maximum-subarray/solution/hua-jie-suan-fa-53-zui-da-zi-xu-he-by-guanpengchn/)见" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray/solution/hua-jie-suan-fa-53-zui-da-zi-xu-he-by-guanpengchn/)见</a><br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">         <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             sum += num;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//这里包括了对sum 初始化为nums[0]</span></span><br><span class="line">             sum = num;</span><br><span class="line">         &#125;</span><br><span class="line">         ans = Math.max(ans, sum);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><p>思路见算法导论分治一节<br>数据结构与算法分析第二章P29<br>但是运行时间反而不如动态规划啊2333<br>代码来自：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> len = nums.length;</span><br><span class="line">      <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> maxSubArraySum(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxCrossingSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 一定会包含 nums[mid] 这个元素</span></span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> leftSum = Integer.MIN_VALUE;</span><br><span class="line">      <span class="comment">// 左半边包含 nums[mid] 元素，最多可以到什么地方</span></span><br><span class="line">      <span class="comment">// 走到最边界，看看最值是什么</span></span><br><span class="line">      <span class="comment">// 计算以 mid 结尾的最大的子数组的和</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &gt;= left; i--) &#123;</span><br><span class="line">          sum += nums[i];</span><br><span class="line">          <span class="keyword">if</span> (sum &gt; leftSum) &#123;</span><br><span class="line">              leftSum = sum;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> rightSum = Integer.MIN_VALUE;</span><br><span class="line">      <span class="comment">// 右半边不包含 nums[mid] 元素，最多可以到什么地方</span></span><br><span class="line">      <span class="comment">// 计算以 mid+1 开始的最大的子数组的和</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">          sum += nums[i];</span><br><span class="line">          <span class="keyword">if</span> (sum &gt; rightSum) &#123;</span><br><span class="line">              rightSum = sum;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> leftSum + rightSum;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxSubArraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">          <span class="keyword">return</span> nums[left];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> max3(maxSubArraySum(nums, left, mid),</span><br><span class="line">              maxSubArraySum(nums, mid + <span class="number">1</span>, right),</span><br><span class="line">              maxCrossingSum(nums, left, mid, right));</span><br><span class="line"><span class="comment">//返回左边最大或右边最大，或者跨越中点</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">max3</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">int</span> num3)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Math.max(num1, Math.max(num2, num3));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第53题最大子序和&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: [-2,1,-3,4,-1,2,1,-5,4],&lt;br&gt;输出: 6&lt;br&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="分治" scheme="http://yorxika.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>解数独</title>
    <link href="http://yorxika.github.io/2019/11/04/%E8%A7%A3%E6%95%B0%E7%8B%AC/"/>
    <id>http://yorxika.github.io/2019/11/04/%E8%A7%A3%E6%95%B0%E7%8B%AC/</id>
    <published>2019-11-04T14:19:38.000Z</published>
    <updated>2019-12-12T13:03:00.082Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第37题解数独</p><h4 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h4><p><strong><a href="https://leetcode-cn.com/problems/sudoku-solver/solution/jie-shu-du-by-leetcode/" target="_blank" rel="noopener">算法</a></strong></p><p>现在准备好写回溯函数了 <a id="more"></a><br>backtrack(row = 0, col = 0)。</p><ul><li><p>从最左上角的方格开始 row = 0, col = 0。直到到达一个空方格。</p></li><li><p>从1 到 9 迭代循环数组，尝试放置数字 d 进入 (row, col) 的格子。</p><ul><li><p>如果数字 d 还没有出现在当前行，列和子方块中：</p></li><li><p>将 d 放入 (row, col) 格子中。</p></li><li><p>记录下 d 已经出现在当前行，列和子方块中。</p></li><li><p>如果这是最后一个格子row == 8, col == 8 ：</p><ul><li>意味着已经找出了数独的解。</li></ul></li><li><p>否则</p><ul><li>放置接下来的数字。</li></ul></li><li><p>如果数独的解还没找到：将最后的数从 (row, col) 移除。</p></li></ul></li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// box size</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// row size</span></span><br><span class="line">    <span class="keyword">int</span> N = n * n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> [][] rows = <span class="keyword">new</span> <span class="keyword">int</span>[N][N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> [][] columns = <span class="keyword">new</span> <span class="keyword">int</span>[N][N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> [][] boxes = <span class="keyword">new</span> <span class="keyword">int</span>[N][N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[][] board;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> sudokuSolved = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">couldPlace</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Check if one could place a number d in (row, col) cell</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">int</span> idx = (row / n ) * n + col / n;</span><br><span class="line">        <span class="keyword">return</span> rows[row][d] + columns[col][d] + boxes[idx][d] == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeNumber</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Place a number d in (row, col) cell</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">int</span> idx = (row / n ) * n + col / n;</span><br><span class="line"></span><br><span class="line">        rows[row][d]++;</span><br><span class="line">        columns[col][d]++;</span><br><span class="line">        boxes[idx][d]++;</span><br><span class="line">        board[row][col] = (<span class="keyword">char</span>)(d + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNumber</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Remove a number which didn't lead to a solution</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">int</span> idx = (row / n ) * n + col / n;</span><br><span class="line">        rows[row][d]--;</span><br><span class="line">        columns[col][d]--;</span><br><span class="line">        boxes[idx][d]--;</span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeNextNumbers</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Call backtrack function in recursion</span></span><br><span class="line"><span class="comment">    to continue to place numbers</span></span><br><span class="line"><span class="comment">    till the moment we have a solution</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="comment">// if we're in the last cell</span></span><br><span class="line">        <span class="comment">// that means we have the solution</span></span><br><span class="line">        <span class="keyword">if</span> ((col == N - <span class="number">1</span>) &amp;&amp; (row == N - <span class="number">1</span>)) &#123;</span><br><span class="line">            sudokuSolved = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if not yet</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// if we're in the end of the row</span></span><br><span class="line">            <span class="comment">// go to the next row</span></span><br><span class="line">            <span class="keyword">if</span> (col == N - <span class="number">1</span>) backtrack(row + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// go to the next column</span></span><br><span class="line">            <span class="keyword">else</span> backtrack(row, col + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Backtracking</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="comment">// if the cell is empty</span></span><br><span class="line">        <span class="keyword">if</span> (board[row][col] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="comment">// iterate over all numbers from 1 to 9</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt; <span class="number">10</span>; d++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (couldPlace(d, row, col)) &#123;</span><br><span class="line">                    placeNumber(d, row, col);</span><br><span class="line">                    placeNextNumbers(row, col);</span><br><span class="line">                    <span class="comment">// if sudoku is solved, there is no need to backtrack</span></span><br><span class="line">                    <span class="comment">// since the single unique solution is promised</span></span><br><span class="line">                    <span class="keyword">if</span> (!sudokuSolved) removeNumber(d, row, col);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> placeNextNumbers(row, col);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init rows, columns and boxes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> num = board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (num != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> d = Character.getNumericValue(num);</span><br><span class="line">                    placeNumber(d, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Type 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 三个布尔数组 表明 行, 列, 还有 3*3 的方格的数字是否被使用过</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] rowUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[][] colUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[][][] boxUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; board.length; row++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; board[<span class="number">0</span>].length; col++) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = board[row][col] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">1</span> &lt;= num &amp;&amp; num &lt;= <span class="number">9</span>)&#123;</span><br><span class="line">                    rowUsed[row][num] = <span class="keyword">true</span>;</span><br><span class="line">                    colUsed[col][num] = <span class="keyword">true</span>;</span><br><span class="line">                    boxUsed[row/<span class="number">3</span>][col/<span class="number">3</span>][num] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归尝试填充数组 </span></span><br><span class="line">        recusiveSolveSudoku(board, rowUsed, colUsed, boxUsed, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recusiveSolveSudoku</span><span class="params">(<span class="keyword">char</span>[][]board, <span class="keyword">boolean</span>[][]rowUsed, <span class="keyword">boolean</span>[][]colUsed, <span class="keyword">boolean</span>[][][]boxUsed, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 边界校验, 如果已经填充完成, 返回true, 表示一切结束</span></span><br><span class="line">        <span class="keyword">if</span>(col == board[<span class="number">0</span>].length)&#123;</span><br><span class="line">            col = <span class="number">0</span>;</span><br><span class="line">            row++;</span><br><span class="line">            <span class="keyword">if</span>(row == board.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是空则尝试填充, 否则跳过继续尝试填充下一个位置</span></span><br><span class="line">        <span class="keyword">if</span>(board[row][col] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试填充1~9</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= <span class="number">9</span>; num++)&#123;</span><br><span class="line"><span class="comment">//确保当前位置不会冲突</span></span><br><span class="line">                <span class="keyword">boolean</span> canUsed = !(rowUsed[row][num] || colUsed[col][num] || boxUsed[row/<span class="number">3</span>][col/<span class="number">3</span>][num]);</span><br><span class="line">                <span class="keyword">if</span>(canUsed)&#123;</span><br><span class="line">                    rowUsed[row][num] = <span class="keyword">true</span>;</span><br><span class="line">                    colUsed[col][num] = <span class="keyword">true</span>;</span><br><span class="line">                    boxUsed[row/<span class="number">3</span>][col/<span class="number">3</span>][num] = <span class="keyword">true</span>;</span><br><span class="line">                    </span><br><span class="line">                    board[row][col] = (<span class="keyword">char</span>)(<span class="string">'0'</span> + num);</span><br><span class="line">                    <span class="keyword">if</span>(recusiveSolveSudoku(board, rowUsed, colUsed, boxUsed, row, col + <span class="number">1</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//填充失败，那么我们需要回溯。将原来尝试填充的地方改回来。</span></span><br><span class="line">                    board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">                    </span><br><span class="line">                    rowUsed[row][num] = <span class="keyword">false</span>;</span><br><span class="line">                    colUsed[col][num] = <span class="keyword">false</span>;</span><br><span class="line">                    boxUsed[row/<span class="number">3</span>][col/<span class="number">3</span>][num] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> recusiveSolveSudoku(board, rowUsed, colUsed, boxUsed, row, col + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><p>搜索+剪枝的方法其实是有在上学期的课设时做了的，但是emm完全忘了，挖个坑，有空填了</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 剪枝条件:我们应该选择的格子（'.'）在一行、一列和一个九宫格中可选数字最少的格子开始填数字。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于每行、每列和每个9宫格都可以用一个9位的2进制数字来标识该行（列，9宫格）那些数字可以填。</span></span><br><span class="line"><span class="comment">    用1表示可填0表示不可填</span></span><br><span class="line"><span class="comment">    如例题中第一行 ：["5","3",".",".","7",".",".",".","."]</span></span><br><span class="line"><span class="comment">    第一行中 有数字 5 3 7</span></span><br><span class="line"><span class="comment">                    下标    8  7  6  5  4  3  2  1  0</span></span><br><span class="line"><span class="comment">                二进制数    0  0  1  0  1  0  1  0  0</span></span><br><span class="line"><span class="comment">    一共有9行所以用9个int表示行row[9],同理9列col[9],9个9宫格cell[3][3]*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">int</span>[] row = <span class="keyword">new</span> <span class="keyword">int</span> [N], col = <span class="keyword">new</span> <span class="keyword">int</span> [N];</span><br><span class="line">    <span class="comment">//ones数组表示0~2^9 - 1的整数中二进制表示中1的个数:如ones[7] = 3 ones[8] = 1</span></span><br><span class="line">    <span class="comment">//map数组表示2的整数次幂中二进制1所在位置（从0开始） 如 map[1] = 0,map[2] = 1, map[4] = 2</span></span><br><span class="line">    <span class="keyword">int</span>[] ones = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> &lt;&lt; N], map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> &lt;&lt; N];</span><br><span class="line">    <span class="keyword">int</span>[][] cell = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">3</span>]; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> cnt = fill_state(board);</span><br><span class="line">        dfs(cnt, board);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) row[i] = col[i] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">                cell[i][j] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//以上2个循环把数组的数初始化为二进制表示8个1，即一开始所以格子都可填</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) map[<span class="number">1</span> &lt;&lt; i] = i;</span><br><span class="line">        <span class="comment">//统计0~2^9 - 1的整数中二进制表示中1的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j != <span class="number">0</span>; j ^= lowBit(j)) n++;</span><br><span class="line">            ones[i] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fill_state</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;    <span class="comment">//统计board数组空格('.')的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> t = board[i][j] - <span class="string">'1'</span>;</span><br><span class="line">                    <span class="comment">//数独中 i,j位置为数组，修改row col cell数组中状态</span></span><br><span class="line">                    change_state(i, j, t);  </span><br><span class="line">                &#125;<span class="keyword">else</span> cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cnt, <span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">10</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//剪枝，即找出当前所以空格可填数字个数最少的位置 记为x y</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> k = ones[get(i, j)];</span><br><span class="line">                    <span class="keyword">if</span>(k &lt; min)&#123;</span><br><span class="line">                        min = k;</span><br><span class="line">                        x = i;</span><br><span class="line">                        y = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历当前 x y所以可选数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = get(x, y); i != <span class="number">0</span>; i ^= lowBit(i))&#123;</span><br><span class="line">            <span class="keyword">int</span> t = map[lowBit(i)];</span><br><span class="line">            </span><br><span class="line">            change_state(x, y, t);</span><br><span class="line">            board[x][y] = (<span class="keyword">char</span>)(<span class="string">'1'</span> + t);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(dfs(cnt - <span class="number">1</span>, board)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//恢复现场</span></span><br><span class="line">            change_state(x, y, t);</span><br><span class="line">            board[x][y] = <span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change_state</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        row[x] ^= <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">        col[y] ^= <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">        cell[x / <span class="number">3</span>][y / <span class="number">3</span>] ^= <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> row[x] &amp; col[y] &amp; cell[x / <span class="number">3</span>][y / <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -x &amp; x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第37题解数独&lt;/p&gt;
&lt;h4 id=&quot;回溯法&quot;&gt;&lt;a href=&quot;#回溯法&quot; class=&quot;headerlink&quot; title=&quot;回溯法&quot;&gt;&lt;/a&gt;回溯法&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sudoku-solver/solution/jie-shu-du-by-leetcode/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;算法&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在准备好写回溯函数了&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="回溯" scheme="http://yorxika.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>字母异位词分组</title>
    <link href="http://yorxika.github.io/2019/11/03/%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <id>http://yorxika.github.io/2019/11/03/%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</id>
    <published>2019-11-03T12:04:15.000Z</published>
    <updated>2019-12-12T13:02:52.661Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第49题字母异位词分组</p><blockquote><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><p>示例:</p><p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”] <a id="more"></a><br>输出:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]<br>说明：</p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序。</li></ul></blockquote><p>一开始做的时候，想着通过建一个哈希表来描述一个字符串有的字母，但是没做出来，还是要多看看JAVA的Hash啊</p><h4 id="通用解法"><a href="#通用解法" class="headerlink" title="通用解法"></a>通用解法</h4><p>对于每个字符串，比较它们的每个字符出现的个数是否相等，相等的话就把它们放在一个 list 中去，作为一个类别。最外层写一个 for 循环然后一一比较就可以，还可以用一个等大的布尔型数组来记录当前字符串是否已经加入的了 list 。比较两个字符串的字符出现的次数可以用一个 HashMap。</p><p>缺点就是，超时了</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//used 数组记录当前字符串是否已经加入list</span></span><br><span class="line">    <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[strs.length];</span><br><span class="line"><span class="comment">//遍历string数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        List&lt;String&gt; temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">            temp = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            temp.add(strs[i]);</span><br><span class="line">            <span class="comment">//判断后续字符串是否字母出现次数一样</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; strs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!used[j]&amp;&amp;equals(strs[i], strs[j])) &#123;</span><br><span class="line">                    used[j] = <span class="keyword">true</span>;</span><br><span class="line">                    temp.add(strs[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ans.add(temp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(String string1, String string2)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//记录第一个字符串每个字符出现的次数，进行累加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; string1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash.containsKey(string1.charAt(i))) &#123;</span><br><span class="line">            hash.put(string1.charAt(i), hash.get(string1.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hash.put(string1.charAt(i), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//记录第一个字符串每个字符出现的次数，将之前的每次减 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; string2.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash.containsKey(string2.charAt(i))) &#123;</span><br><span class="line">            hash.put(string2.charAt(i), hash.get(string2.charAt(i)) - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断每个字符的次数是不是 0 ，不是的话直接返回 false</span></span><br><span class="line">    Set&lt;Character&gt; set = hash.keySet();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : set) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash.get(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来自<a href="https://leetcode-cn.com/problems/group-anagrams/solution/zi-mu-yi-wei-ci-fen-zu-by-leetcode/" target="_blank" rel="noopener">题解</a></p><h4 id="按计数分类"><a href="#按计数分类" class="headerlink" title="按计数分类"></a>按计数分类</h4><p><strong>思路</strong></p><p>当且仅当它们的字符计数（每个字符的出现次数）相同时，两个字符串是字母异位词。</p><p><strong>算法</strong></p><p>我们可以将每个字符串 s 转换为字符数 count，由26个非负整数组成，表示 a,b,c 的数量等。我们使用这些计数作为哈希映射的基础。</p><p>在 Java 中，我们的字符数 count 的散列化表示将是一个用 <strong>＃</strong> 字符分隔的字符串。例如，abbccc 将表示为 ＃1＃2＃3＃0＃0＃0 …＃0，其中总共有26个条目。 在 python 中，表示将是一个计数的元组。 例如，abbccc 将表示为 (1,2,3,0,0，…，0)，其中总共有 26 个条目。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//初始化HASH Map</span></span><br><span class="line">        Map&lt;String, List&gt; ans = <span class="keyword">new</span> HashMap&lt;String, List&gt;();</span><br><span class="line"><span class="comment">//count数组，标记出现的字母次数</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="comment">//foreach 遍历strs里的所有string</span></span><br><span class="line">        <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">    <span class="comment">//count数组初始化为0</span></span><br><span class="line">            Arrays.fill(count, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//统计字母出现次数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) count[c - <span class="string">'a'</span>]++;</span><br><span class="line"><span class="comment">//构造字符串</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                sb.append(<span class="string">'#'</span>);</span><br><span class="line">                sb.append(count[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            String key = sb.toString();</span><br><span class="line"><span class="comment">//如果key(即统计字母次数字符串)没有出现在Map里，就添加key</span></span><br><span class="line">            <span class="keyword">if</span> (!ans.containsKey(key)) ans.put(key, <span class="keyword">new</span> ArrayList());</span><br><span class="line"><span class="comment">//往Map里增加key、s的映射</span></span><br><span class="line">            ans.get(key).add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(ans.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排序数组分类"><a href="#排序数组分类" class="headerlink" title="排序数组分类"></a>排序数组分类</h4><p><strong>思路</strong></p><p>当且仅当它们的排序字符串相等时，两个字符串是字母异位词。</p><p><strong>算法</strong></p><p>维护一个映射 ans : {String -&gt; List}，其中每个键 K 是一个排序字符串，每个值是初始输入的字符串列表，排序后等于 K。</p><p>在 Java 中，我们将键存储为字符串，例如，code。 在 Python 中，我们将键存储为散列化元组，例如，(‘c’, ‘o’, ‘d’, ‘e’)。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Map&lt;String, List&gt; ans = <span class="keyword">new</span> HashMap&lt;String, List&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] ca = s.toCharArray();</span><br><span class="line">            Arrays.sort(ca);</span><br><span class="line">            String key = String.valueOf(ca);</span><br><span class="line">            <span class="keyword">if</span> (!ans.containsKey(key)) ans.put(key, <span class="keyword">new</span> ArrayList());</span><br><span class="line">            ans.get(key).add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(ans.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="正整数的唯一分解定理"><a href="#正整数的唯一分解定理" class="headerlink" title="正整数的唯一分解定理"></a>正整数的唯一分解定理</h4><blockquote><p>算术基本定理，又称为正整数的唯一分解定理，即：每个大于1的自然数，要么本身就是质数，要么可以写为2个以上的质数的积，而且这些质因子按大小排列之后，写法仅有一种方式。</p></blockquote><p>利用这个，我们把每个字符串都映射到一个正数上。</p><p>用一个数组存储质数 prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103}。</p><p>然后每个字符串的字符减去 ‘ a ‘ ，然后取到 prime 中对应的质数。把它们累乘。</p><p>例如 abc ，就对应 ‘a’ - ‘a’， ‘b’ - ‘a’， ‘c’ - ‘a’，即 0, 1, 2，也就是对应素数 2 3 5，然后相乘 2 * 3 * 5 = 30，就把 “abc” 映射到了 30。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    HashMap&lt;Integer, List&lt;String&gt;&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//每个字母对应一个质数</span></span><br><span class="line">    <span class="keyword">int</span>[] prime = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>, <span class="number">103</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//累乘得到 key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; strs[i].length(); j++) &#123;</span><br><span class="line">            key *= prime[strs[i].charAt(j) - <span class="string">'a'</span>];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (hash.containsKey(key)) &#123;</span><br><span class="line">            hash.get(key).add(strs[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            temp.add(strs[i]);</span><br><span class="line">            hash.put(key, temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(hash.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第49题字母异位词分组&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="哈希" scheme="http://yorxika.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>翻转图像</title>
    <link href="http://yorxika.github.io/2019/10/31/%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <id>http://yorxika.github.io/2019/10/31/%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/</id>
    <published>2019-10-31T10:56:10.000Z</published>
    <updated>2019-12-12T13:03:15.951Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第48题旋转图像</p><blockquote><p>给定一个 n × n 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p>说明：<a id="more"></a></p><p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像</p><p>示例 1:</p><p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p><p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p></blockquote><h4 id="两次翻转"><a href="#两次翻转" class="headerlink" title="两次翻转"></a>两次翻转</h4><p>这题没什么思路，规律没找到。<br>看了题解之后知道可以通过上下翻转一次，在通过对角线翻转一次即可完成。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line"><span class="comment">//上下翻转</span></span><br><span class="line"><span class="comment">// n/2代表矩阵的中间线，以实现对折翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i ++)&#123;</span><br><span class="line"><span class="comment">//保存欲翻转的当前行</span></span><br><span class="line">            <span class="keyword">int</span>[] tmp = matrix[i];</span><br><span class="line"><span class="comment">//整行翻转</span></span><br><span class="line">            matrix[i] = matrix[n - i - <span class="number">1</span>];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对角翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j= i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四数交换"><a href="#四数交换" class="headerlink" title="四数交换"></a>四数交换</h4><p>当然这题规律找出来了就是简单的四数交换，感谢<a href="https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-ti-jie-by-mu-yi-wei-lan/" target="_blank" rel="noopener">木苡微澜的题解</a></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将举证旋转90度的方法：</span></span><br><span class="line"><span class="comment"> * 矩阵例子：</span></span><br><span class="line"><span class="comment">  [ 5, 1, 9, 11],</span></span><br><span class="line"><span class="comment">  [ 2, 4, 8, 10],</span></span><br><span class="line"><span class="comment">  [13, 3, 6,  7],</span></span><br><span class="line"><span class="comment">  [15,14,12, 16]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> length = matrix.length;<span class="comment">// 给定的矩阵的边长</span></span><br><span class="line"><span class="keyword">int</span> lengthend = matrix.length;<span class="comment">// 每一圈中分好的块的末尾元素的行或者列的下标（具体圈具体分析）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 由外而内，逐个圈进行旋转 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt;= (length - <span class="number">1</span>) / <span class="number">2</span>; r++) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 创建一个临时数组作为中转站，存放每一个块的数据，注意由外而内每一个圈的块的元素数量不同，</span></span><br><span class="line"><span class="comment">        * 故临时数组长度不一样，用数理逻辑推出长度公式：length-2*r-1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[length-<span class="number">2</span>*r-<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*举例：（外圈情况）把第一个块元素放进临时数组temp中</span></span><br><span class="line"><span class="comment">        [ 5, 1, 9,  ], ==&gt; temp[]</span></span><br><span class="line"><span class="comment">        [           ],</span></span><br><span class="line"><span class="comment">        [           ],</span></span><br><span class="line"><span class="comment">        [           ]                    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123; <span class="comment">// 这个i是临时数组的下标</span></span><br><span class="line">        temp[i] = matrix[r][i + r];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*举例：（外圈情况）块[2,13,15]换到[5,1,9]的位置</span></span><br><span class="line"><span class="comment">        [ 5, 1, 9,  ],</span></span><br><span class="line"><span class="comment">        [ 2,        ],</span></span><br><span class="line"><span class="comment">        [13,        ],</span></span><br><span class="line"><span class="comment">        [15,        ]                     </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> + r; i &lt; lengthend; i++) &#123;</span><br><span class="line">        matrix[r][length - <span class="number">1</span> - i] = matrix[i][r];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*举例：（外圈情况）块[14,12,16]换到[2,13,15]的位置</span></span><br><span class="line"><span class="comment">        [           ],</span></span><br><span class="line"><span class="comment">        [ 2,        ],</span></span><br><span class="line"><span class="comment">        [13,        ],</span></span><br><span class="line"><span class="comment">        [15,14,12,16]                      </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> + r; i &lt; lengthend; i++) &#123;</span><br><span class="line">        matrix[i][r] = matrix[length - <span class="number">1</span> - r][i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*举例：（外圈情况）块[11,10,7]换到[14,12,16]的位置</span></span><br><span class="line"><span class="comment">        [        ,11],</span></span><br><span class="line"><span class="comment">        [        ,10],</span></span><br><span class="line"><span class="comment">        [        , 7],</span></span><br><span class="line"><span class="comment">        [  ,14,12,16]                       </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> + r; i &lt; lengthend; i++) &#123;</span><br><span class="line">        matrix[length - <span class="number">1</span> - r][i] = matrix[length - <span class="number">1</span> - i][length - <span class="number">1</span> - r];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*举例：（外圈情况）把临时数组temp中的元素放进第一个块中</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        temp[] ==&gt; [            ],</span></span><br><span class="line"><span class="comment">                    [            ],</span></span><br><span class="line"><span class="comment">                    [            ],</span></span><br><span class="line"><span class="comment">                    [            ]            </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= temp.length; i++) &#123;</span><br><span class="line">        matrix[length - i - <span class="number">1</span> - r][length - <span class="number">1</span> - r] = temp[temp.length - i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*进入下一圈之前，这一圈中分好的块的末尾元素的行或者列的下标缩小一位*/</span></span><br><span class="line">    lengthend -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将这几个循环写在一起就是这样</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line"><span class="comment">//由外而内，逐个圈进行旋转</span></span><br><span class="line">        <span class="keyword">int</span> len = matrix.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line"><span class="comment">//定义由外而内每一个圈的块的元素数量</span></span><br><span class="line">            <span class="keyword">int</span> lengthend = matrix.length - <span class="number">1</span> - <span class="number">2</span> * j;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthend; i++) &#123;</span><br><span class="line"><span class="comment">//然后开始4个数4个数的交换</span></span><br><span class="line"><span class="comment">//第一轮的4个数是4个角的数</span></span><br><span class="line"><span class="comment">//然后在往右移，以此类推</span></span><br><span class="line">                <span class="keyword">int</span> temp = matrix[j][i + j];</span><br><span class="line">                matrix[j][i + j] = matrix[matrix.length - <span class="number">1</span> - j - i][j];</span><br><span class="line">                matrix[matrix.length - <span class="number">1</span> - j - i][j] =  matrix[matrix.length - <span class="number">1</span> - j][matrix.length - <span class="number">1</span> - j - i];</span><br><span class="line">                matrix[matrix.length - <span class="number">1</span> - j][matrix.length - <span class="number">1</span> - j - i] = matrix[j + i][matrix.length - <span class="number">1</span> - j];</span><br><span class="line">                matrix[j + i][matrix.length - <span class="number">1</span> - j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第48题旋转图像&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个 n × n 的二维矩阵表示一个图像。&lt;/p&gt;
&lt;p&gt;将图像顺时针旋转 90 度。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="数组" scheme="http://yorxika.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>相同的树</title>
    <link href="http://yorxika.github.io/2019/10/30/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"/>
    <id>http://yorxika.github.io/2019/10/30/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</id>
    <published>2019-10-30T15:17:24.000Z</published>
    <updated>2019-12-12T13:01:44.106Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第100题相同的树</p><blockquote><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p></blockquote><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>最简单的比较根节点然后递归比较左子树和右子树，没有什么好说的。<a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果两个根节点都为空，那肯定是相等的</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 有一个不为空，那就不等了</span></span><br><span class="line">    <span class="keyword">if</span> (q == <span class="keyword">null</span> || p == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 都不为空，比较值</span></span><br><span class="line"><span class="comment">//然后开始递归比较左右子树</span></span><br><span class="line">    <span class="keyword">if</span> (p.val != q.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(p.right, q.right) &amp;&amp;</span><br><span class="line">            isSameTree(p.left, q.left);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h4><p>本来后面是想用两个栈写的，但是笔记本电池续航尿崩了，先看看题解里是怎么写的吧。</p><p>题解采用了<strong>双向队列</strong>，并不是栈，emm</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//根节点入栈(队列)</span></span><br><span class="line">        stack1.push(p);</span><br><span class="line">        stack2.push(q);</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty() &amp;&amp; !stack2.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈顶元素出栈</span></span><br><span class="line">            TreeNode a = stack1.pop();</span><br><span class="line">            TreeNode b = stack2.pop();</span><br><span class="line"><span class="comment">//比较出栈元素</span></span><br><span class="line">            <span class="keyword">if</span> (a == <span class="keyword">null</span> &amp;&amp; b == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span> &amp;&amp; b != <span class="keyword">null</span> &amp;&amp; a.val == b.val) &#123;</span><br><span class="line"><span class="comment">//值相等或者都为空将左右子树入栈</span></span><br><span class="line">                stack1.push(a.left);</span><br><span class="line">                stack1.push(a.right);</span><br><span class="line">                stack2.push(b.left);</span><br><span class="line">                stack2.push(b.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty() &amp;&amp; stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源Leetcode第100题相同的树&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定两个二叉树，编写一个函数来检验它们是否相同。&lt;/p&gt;
&lt;p&gt;如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h4&gt;&lt;p&gt;最简单的比较根节点然后递归比较左子树和右子树，没有什么好说的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
      <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
      <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
      <category term="递归" scheme="http://yorxika.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
</feed>
