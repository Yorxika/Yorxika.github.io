<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nameless Site</title>
  <icon>https://www.gravatar.com/avatar/ac88b61adfe8890cbf94b774785887f8</icon>
  <subtitle>But one day, you will stand before its decrepit gate,without really knowing why.</subtitle>
  <link href="http://yorxika.github.io/atom.xml" rel="self"/>
  
  <link href="http://yorxika.github.io/"/>
  <updated>2023-06-24T17:50:45.876Z</updated>
  <id>http://yorxika.github.io/</id>
  
  <author>
    <name>HMF</name>
    <email>774123033@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sat Jun 24 2023 08:00:00 GMT+0800 (GMT+08:00)</title>
    <link href="http://yorxika.github.io/2023/06/25/2023-06-24/"/>
    <id>http://yorxika.github.io/2023/06/25/2023-06-24/</id>
    <published>2023-06-24T17:49:28.000Z</published>
    <updated>2023-06-24T17:50:45.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日寄"><a href="#日寄" class="headerlink" title="日寄"></a>日寄</h2><span id="more"></span><p>船到桥头自然直还是桥到船头变林夕？</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;日寄&quot;&gt;&lt;a href=&quot;#日寄&quot; class=&quot;headerlink&quot; title=&quot;日寄&quot;&gt;&lt;/a&gt;日寄&lt;/h2&gt;</summary>
    
    
    
    <category term="杂谈" scheme="http://yorxika.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="http://yorxika.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="日寄" scheme="http://yorxika.github.io/tags/%E6%97%A5%E5%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>立黄昏</title>
    <link href="http://yorxika.github.io/2023/05/03/2023-05-03/"/>
    <id>http://yorxika.github.io/2023/05/03/2023-05-03/</id>
    <published>2023-05-02T19:18:03.000Z</published>
    <updated>2023-05-02T19:47:31.648Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Shall-we-talk"><a href="#Shall-we-talk" class="headerlink" title="Shall we talk"></a>Shall we talk</h3><p>频繁打开qq微信，却没有人给你发消息。打开微信点开却犹豫，是小丑？</p><span id="more"></span><p>和解一直以来是萦绕于脑内的一个词，在人生的每个阶段，做了很多错事，有恃无恐，一而再再二三的伤害。</p><ol><li><p>沉默的两个句号，很伤心。</p></li><li><p>换位思考，想想他人。</p></li><li><p>你又做错事了。</p></li><li><p>回应。</p></li></ol><p>红酥手。黄滕酒。满城春色宫墙柳。东风恶。欢情薄。一怀愁绪，几年离索。错错错。</p><p>春如旧。人空瘦。泪痕红浥鲛绡透。桃花落。闲池阁。山盟虽在，锦书难托。莫莫莫。</p><p>世情薄，人情恶，雨送黄昏花易落。晓风干，泪痕残。欲笺心事，独语斜阑。难难难。</p><p>人成各，今非昨，病魂常似秋千索。角声寒，夜阑珊。怕人寻问，咽泪装欢。瞒瞒瞒。</p><p>人间万事消磨尽，只有清香似旧时。</p><p>伤心桥下春波绿，曾是惊鸿照影来。</p><p>城南小陌又逢春，只见梅花不见人。</p><p>玉骨久成泉下土，墨痕犹鏁壁间尘。</p><p>不堪幽梦太匆匆。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Shall-we-talk&quot;&gt;&lt;a href=&quot;#Shall-we-talk&quot; class=&quot;headerlink&quot; title=&quot;Shall we talk&quot;&gt;&lt;/a&gt;Shall we talk&lt;/h3&gt;&lt;p&gt;频繁打开qq微信，却没有人给你发消息。打开微信点开却犹豫，是小丑？&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="http://yorxika.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="http://yorxika.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="日寄" scheme="http://yorxika.github.io/tags/%E6%97%A5%E5%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>23-04-02</title>
    <link href="http://yorxika.github.io/2023/04/02/2023-04-02/"/>
    <id>http://yorxika.github.io/2023/04/02/2023-04-02/</id>
    <published>2023-04-02T15:54:26.000Z</published>
    <updated>2023-06-24T17:48:58.300Z</updated>
    
    
    
    
    <category term="杂谈" scheme="http://yorxika.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="http://yorxika.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="日寄" scheme="http://yorxika.github.io/tags/%E6%97%A5%E5%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>【Incident Review】Debate about Leetcode NO.799</title>
    <link href="http://yorxika.github.io/2022/11/20/2022-11-20/"/>
    <id>http://yorxika.github.io/2022/11/20/2022-11-20/</id>
    <published>2022-11-20T13:50:02.000Z</published>
    <updated>2023-01-24T14:13:10.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h2><p>这文档或许可以称为一篇复盘文档吧。</p><span id="more"></span><h2 id="Cause"><a href="#Cause" class="headerlink" title="Cause"></a>Cause</h2><p>首先看起因。</p><p><a href="https://leetcode.cn/problems/champagne-tower/">799. 香槟塔</a></p><blockquote><p> 我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</p><p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p><p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。</p><p>现在当倾倒了非负整数杯香槟后，返回第 i 行 j 个玻璃杯所盛放的香槟占玻璃杯容积的比例（ i 和 j 都从0开始）。</p></blockquote><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">示例 1</span><span class="punctuation">:</span></span><br><span class="line"><span class="attribute">输入</span><span class="punctuation">:</span> <span class="string">poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1</span></span><br><span class="line"><span class="attribute">输出</span><span class="punctuation">:</span> <span class="string">0.00000</span></span><br><span class="line"><span class="attribute">解释</span><span class="punctuation">:</span> <span class="string">我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。</span></span><br></pre></td></tr></table></figure><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">示例 2</span><span class="punctuation">:</span></span><br><span class="line"><span class="attribute">输入</span><span class="punctuation">:</span> <span class="string">poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1</span></span><br><span class="line"><span class="attribute">输出</span><span class="punctuation">:</span> <span class="string">0.50000</span></span><br><span class="line"><span class="attribute">解释</span><span class="punctuation">:</span> <span class="string">我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。</span></span><br></pre></td></tr></table></figure><p>题目也比较简单，动规+模拟即可解决。一开始想着除了模拟外，能不能推出数学公式来解决这道题，不过后来发现是我想多了。题目是杨辉三角的变种，但公式推不出来，老实模拟就好。下面是解答。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">champagneTower</span><span class="params">(<span class="type">int</span> poured, <span class="type">int</span> query_row, <span class="type">int</span> query_glass)</span> &#123;</span><br><span class="line">    <span class="type">double</span>[][] ca = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">102</span>][<span class="number">102</span>];</span><br><span class="line">    ca[<span class="number">0</span>][<span class="number">0</span>] = (<span class="type">double</span>)poured;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt;= query_row; l++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt;= l; r++)&#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> (ca[l][r] - <span class="number">1.0</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(d &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ca[l+<span class="number">1</span>][r] += d;</span><br><span class="line">                ca[l+<span class="number">1</span>][r+<span class="number">1</span>] +=d;  </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(<span class="number">1.0</span>, ca[query_row][query_glass]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Detail"><a href="#Detail" class="headerlink" title="Detail"></a>Detail</h2><p>直接放聊天记录。</p><p><img src="/2022/11/20/2022-11-20/660.jpg" alt="Screenshot"></p><p><img src="/2022/11/20/2022-11-20/288.jpg" alt="Screenshot"></p><p><img src="/2022/11/20/2022-11-20/249.jpg" alt="Screenshot"></p><h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p>结局自然是以我被踢出群聊结束。</p><h2 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h2><p>很多思考的内容在傍晚的椭圆机上已经思考过了，现在也不大能保证还原当时的想法。</p><p>首先就是我为什么会“急了”。</p><p>现在想来，不外乎是以下几点：</p><ol><li><p>讨厌被不熟的人说教。就有那么一种感觉“你在教我做事？”我985计算机出身，两段大厂经历，至于被一个互联网的上臭鱼烂虾指指点点？尤其是对面可能还没毕业，或者才毕业2个月的情况。你寄吧谁啊。</p></li><li><p>无法理解的脑回路。面向过程的算法题能扯到面对对象，aop，执行效率高，易读性好，太好为人师了。</p></li><li><p>面对互联网常用语“急了”没有做到很好的应对。当下互联网上的争论很多是无意义的争论，面对这种没有意义的“急了”，万能解答“典”，“典中典”就可以怼回去了，而不是先自认“急了”，在继续在原问题上争辩，没有意义。</p></li></ol><blockquote><p>网络君子六艺：典、孝、急、乐、蚌、赢</p></blockquote><ol><li>好为人师，说教闭口不谈，实质性的内容也没谈多少，只谈谜语。OOP，AOP也没说出个所以然来。更有一种“刚学了一个概念，就出来装逼”的感觉。</li></ol><p>来自taisa的良言</p><blockquote><p>不熟的人和他来回3个回合就算我输了</p></blockquote><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p>写这篇复盘文档更多不是为了看这道题，或者这件事怎么怎么，更关心的是自己的思考。（虽然这里有的思考说一个月以前的了，hhhh）</p><h4 id="交付价值，不是交付需求-业务"><a href="#交付价值，不是交付需求-业务" class="headerlink" title="交付价值，不是交付需求(业务)"></a>交付价值，不是交付需求(业务)</h4><p>在交付需求的时候，有自己的思考or判断吗？对于一个需求，交到研发手上，为什么要做，要怎么做好，要做成怎样，这些其实还是值得我去思考的。但是或许是由于时间的原因，导致我没有很好的去履行有关方案，仅仅是接到需求，拿到手就去做了，其实还是可以更多的去思考要怎么<strong>做的更好</strong>。</p><p>这里的<strong>做的更好</strong>可以再补充一下，性能（各种耗时），交互（各种体验）。</p><p>时间忙是客观因素，需求A刚提测就来了需求B，疲于奔命忙着各种需求，带来了一系列问题，比如[没成长]，[心累时间忙]等。</p><p>那我在空闲之余，有完成我自己的承诺吗？现状梳理，文档沉淀，技术规划，性能or体验优化，很多事情都没有达成。</p><h4 id="从理想倒推，从现实延伸"><a href="#从理想倒推，从现实延伸" class="headerlink" title="从理想倒推，从现实延伸"></a>从理想倒推，从现实延伸</h4><p>持续打磨产品，体验优化。</p><p>体验竞品，学习优秀。</p><p>我所负责的模块要达到一个怎样的水平，达成一个怎样的目标？</p><h4 id="个人成长，未来规划"><a href="#个人成长，未来规划" class="headerlink" title="个人成长，未来规划"></a>个人成长，未来规划</h4><p>对不起，目前还没有什么规划。</p><p>接下来一年能做成怎样？</p><p>这里还是写一下吧。总归还是要用到的。不过也只是把文档上的内容搬了过来。</p><p>技术能力:</p><ol><li>可拓展</li><li>健壮</li><li>可复用：低耦合，高内聚，热插拔，面向接口编程</li><li>稳定</li></ol><p>业务能力：</p><ol><li>熟悉业务，无需多说</li><li>协调推动</li><li>判断力与优先级</li></ol><h4 id="控制情绪，坦诚清晰"><a href="#控制情绪，坦诚清晰" class="headerlink" title="控制情绪，坦诚清晰"></a>控制情绪，坦诚清晰</h4><blockquote><p>心平气和，理性沟通</p></blockquote><p>更多的时候还是善意假设，换位思考吧。不以恶意揣测他人。</p><p>想起一个badcase，在排查问题时对.remake过火了些。是的，资源包有问题，但这是<strong>从经验出发</strong>，我更想知道的是为什么会造成这个问题，是哪里出了错。</p><p>更之前的badcase无疑是打低评价。不管是情绪化还是怎样，还是要从实际出发，善意假设，不以恶意揣测他人。目光放长远，从他人角度出发。</p><p>心平气和，心平气和。</p><h4 id="人与人之间还是要少些攻击性"><a href="#人与人之间还是要少些攻击性" class="headerlink" title="人与人之间还是要少些攻击性"></a>人与人之间还是要少些攻击性</h4><p>人与人之间还是要少些攻击性，与自己和解，与他人和解，与世界和解。</p><p>有的玩笑能不开就不开，在玩笑的背后何尝又不是心酸血泪呢。</p><blockquote><p>我原本以为幽默就是幽默，但人微言轻的时候，幽默就成了搞笑，搞笑就容易被当成小丑。</p></blockquote><h4 id="不要从经验出发"><a href="#不要从经验出发" class="headerlink" title="不要从经验出发"></a>不要从经验出发</h4><p>经验或者说惯性有时还是很可怕的。在面对某一问题上时，我可以说按经验是xxx出了问题，但是这并不够，我更希望找到根本原因，哪一行代码写错了。</p><p>有时经验/惯性带来的伤害也是不小的。回想起在做需求时，按照经验这个地方应该这么写（线上就是这么写的），但是写完发现这里总会造成一个抖动，经验让我选择了相信这里的代码，并没有去怀疑他，然而最终发现还是这里出了问题。</p><p>另外一个经验/惯性带来的问题也是同样。历史代码里矩阵运算后乘了一个<code>scale</code>,但是经验没有告诉我在特定情况下这个<code>scale</code>总是1，而在我的场景下<code>scale</code>的值是可以变化的，进而产生了问题，经验就是这样带来了其他问题。</p><h4 id="非暴力沟通"><a href="#非暴力沟通" class="headerlink" title="非暴力沟通"></a>非暴力沟通</h4><ul><li>重要的事情说三点，比如三个论据，三个论点，三个观点等（最简单的结构化表达）</li><li>先说结论，再说过程和原因，然后再说结论。</li><li>说清楚<strong>What</strong>，<strong>How</strong>，<strong>Why</strong></li></ul><p>说回这里，互联网上有的争论确实是没有意义+浪费时间，典就完事了。</p><h4 id="挖掘事物背后的本质"><a href="#挖掘事物背后的本质" class="headerlink" title="挖掘事物背后的本质"></a>挖掘事物背后的本质</h4><p>深入底层，多看源码，不自嗨。</p><p>了解问题发生的原因<br>挖掘事物背后本质<br>寻找其他相似问题</p><h4 id="持续学习"><a href="#持续学习" class="headerlink" title="持续学习"></a>持续学习</h4><p>多读书，多学习，多看源码。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Before&quot;&gt;&lt;a href=&quot;#Before&quot; class=&quot;headerlink&quot; title=&quot;Before&quot;&gt;&lt;/a&gt;Before&lt;/h2&gt;&lt;p&gt;这文档或许可以称为一篇复盘文档吧。&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="http://yorxika.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="http://yorxika.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>观 CyberPunk EdgeRunnes 感</title>
    <link href="http://yorxika.github.io/2022/10/16/2022-10-16/"/>
    <id>http://yorxika.github.io/2022/10/16/2022-10-16/</id>
    <published>2022-10-16T14:47:05.000Z</published>
    <updated>2022-11-20T13:44:04.351Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚一口气把赛博朋克 边缘行者看完了，对于我这种“上了年纪”的人而言，后劲很大。</p><p>David，Lucy，Rebecca，Manie，Dorio，Kiwi。</p><p>潮汐退和涨</p><p>月冷风和霜</p><p>夜雨的狂想</p><p>野花的微香</p><p>伴我星夜里幻想</p><p>方知不用太紧张</p><p>To Be Continue 剩下的想写的时候在写吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨晚一口气把赛博朋克 边缘行者看完了，对于我这种“上了年纪”的人而言，后劲很大。&lt;/p&gt;
&lt;p&gt;David，Lucy，Rebecca，Manie，Dorio，Kiwi。&lt;/p&gt;
&lt;p&gt;潮汐退和涨&lt;/p&gt;
&lt;p&gt;月冷风和霜&lt;/p&gt;
&lt;p&gt;夜雨的狂想&lt;/p&gt;
&lt;p&gt;野花的微香&lt;</summary>
      
    
    
    
    <category term="杂谈" scheme="http://yorxika.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="http://yorxika.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>与自己和解</title>
    <link href="http://yorxika.github.io/2022/10/05/2022-10-05/"/>
    <id>http://yorxika.github.io/2022/10/05/2022-10-05/</id>
    <published>2022-10-05T14:20:54.000Z</published>
    <updated>2022-10-05T14:22:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>始于2022-10-05 22:21。</p><p>总是要与自己和解，与世界和解，那么我什么时候才会和解呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;始于2022-10-05 22:21。&lt;/p&gt;
&lt;p&gt;总是要与自己和解，与世界和解，那么我什么时候才会和解呢？&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂谈" scheme="http://yorxika.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="http://yorxika.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>日寄</title>
    <link href="http://yorxika.github.io/2022/10/03/2002-10-02/"/>
    <id>http://yorxika.github.io/2022/10/03/2002-10-02/</id>
    <published>2022-10-02T16:52:08.000Z</published>
    <updated>2022-10-03T15:07:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>始于2022-10-02 23时。</p><p>为什么会想起来写这些东西，俺也不知道。在国庆期间看到这样的朋友圈官宣，不过对他而言，倒也合理，了解接触不多，毕竟只是两年同学罢了。</p><p>想起20年还在深圳实习时，跟啊p躺在床上，有聊到有关事情，不过也很快结束了，他是正确的。</p><p>现在回忆20年的那个夏天，还是快乐的。</p><span id="more"></span><p>19年12月突如其来的疫情，蒙上了厚厚一层的阴影，乃至后面几年都没有摆脱疫情的阴霾。</p><p>因为疫情，武汉还没有达到解封的地步，学生自然而然的只能在家里开学上课，老师也同样的在家里给我们讲课。网课对于老师和同学们都是第一次，都是从未有过的尝试与体验，期间也闹出了不少笑话或事情。</p><p>在家里上网课的日子无非就是早上有课就起来听听，没有就继续睡，下午的课就搬个桌子在床上，对着笔记本开始上课。现在让我还有印象的网课恐怕也就只有寥寥几门了，JAVA的选修课，操作系统课设，编译原理，数据库。对着成绩单还能找到其他课，比如函数式，机器学习，嵌入式，人工智能，以及其实寒假时就开始的硬件综合训练，也就是五段流水CPU课设。</p><p>辜老师的课，不论是准备还是授课，都是很用心的，自然我上的也很认真，不过这门课有关内容还是太浅了，或许说是刚入门也不为过。操作系统课设给我留下的最大印象就是最后做一个任务管理器，要有GUI，有关代码直接百度，对着博客上的代码修修补补，学习GTK怎么写GUI，学习怎么调用系统api，便完成了。数据库这门课轮着几个老师上，这么重要的课，放在这么后面，到最后也是写写sql，做了一个带有GUI的汽车管理系统便交上去了。函数式只记得是其他几个同学后来生产实习的导师，机器学习是ACM班的老师上来着，全程板书，人工智能就记得了个KNN(?)，貌似还有个什么算法，其他的也没印象了，嵌入式无疑是最大的捡漏，实验也做不成，上上课了解下有关概念最后交个PPT就结课了。CPU课设也是拖了疫情的福，线上不用上FPGA开发板，工作量无疑少了一大截，尽管我们最终的团队成果还是有些简陋的。</p><p>最令人恼火的自然是编译原理这门课。老师网课讲的并不清楚，甚至还有过炸麦的情况，以至于那一节课的视频完全不能听，对学生的态度也是离谱，问题解释不清。在最后线上考试时还埋怨我们要求提前演练模拟下，还说什么不是辅导员要求巴拉巴拉，语气可见一斑。不过好在那次模拟考试也很争气，暴露出了不少问题，比如说半个小时还没发试卷等问题。或许这门课还有其他问题，但是我已经记不清了，那就让他过去吧。</p><p>在网课之余还有一件很重要的事情，就是生产实习。生产实习是要算学分的，但当时的我并不知道在实验室看看论文也能水到学分，加之年级微信群里又是各种实习招聘信息，我便开始刷题投简历准备实习。</p><p>经历了无数次失败之后，期间还有一次被阿里HR毙掉，或许是出于可怜等原因，曾经的未来组长给我发了offer，让我得以有机会实习。为什么说是曾经的未来组长呢，因为当我入职时，他已经不在M12中心了，活水去了CSIG。</p><p>拿到实习offer的我无疑是欢心的，在家里上网课被说整天呆在家里对着电脑没事干，不如出去打工，出去打工还能让老妈开心。也忘了是哪个时间点跟老大那帮人骂了一顿，虽然只骂了几句话，但是还是伤到了老大。具体情形在两年后的今天我也记不清了。</p><p>那会大概是5月份了吧，时间点也不太对的上了，记不清了。早上他们7点半上班，之后大概8点半左右起来，洗漱完毕去步行街口的肠粉店买份肠粉当早餐，吃完早餐便背着书包去图书馆开始做实验。因为那会网课大多陆陆续续已经结课了，只剩下实验需要完成。加之与家里人关系不好，白天也不好意思厚脸皮留在家里，便去了图书馆这个好去处。</p><p>想起来倒也好笑，记得刚回来那会也来过这个图书馆，图书馆是新建的，建成之后老的街道图书馆便被废弃了，大抵是要拆掉了。那会疫情还没爆发，或者说疫情还没严重，还去过几次图书馆，当时想着是寒假先把CPU课设做一部分，不然开学后可能没太多时间。但可能是缺乏资料，又或者其他什么原因，一开始没有明白课设要怎么做，便不做了，开始在馆里看CPP有关书籍，不过后面也没看完就是了。去图书馆没几次后来便不去了。</p><p>由于疫情的缘故，图书馆每天限50人入馆，入馆需要在微信小程序上预约方可入馆。图书馆早上9点开馆，签到入馆找个又插头的位置后即可开始自己的一天。这时的我一般都是在做各种实验中度过，JAVA实验，编译原理实验，操作系统课设，函数式实验，机器学习实验，人工智能实验，数据库课设，CPU实验。是的计科就是这么多实验，不过说是实验，对于计算机的学生而言，无非就是写代码，调试通过没有问题，完成题目要求罢了，最后交一份实验报告上去。换句话就是完成各种命题作文，不过最后的实验报告确实是某种意义上的命题作文，各种格式规范要求，图表要求等，令人头秃。</p><p>图书馆上午只开3个小时，应该没记错吧，在12点附近，还没到12点时便会有喇叭通知你图书馆即将闭馆，进行消杀，这时只能收拾走人。回去一般是不会回去的，但这时可能也不太饿，一般会去书城找个地方蹲着。是啊，突然想到，但没想明白，为什么书城不闭馆，不需要消杀，也不限流，不需要预约，可是图书馆却需要呢？</p><p>书城的一二楼是各种商铺，二楼有书城的真正入口，但是二楼的书籍类型是大多是各种杂志杂书之流，像意林青年文摘等，又或者是各种旅程攻略菜谱小学生读物啥的，没有几本名家书籍。从二楼入口进来往左走是一个电梯，可以上三楼。三楼也没有书，有售卖各种文体用品，我没有逛过都是匆匆走过，乘电梯直奔四楼。</p><p>电梯上来四楼之后，眼前大概有4个位置，是有提供桌椅，运气好可以坐在椅子上看书，不过大多数时候是没有位置的。往里走之后，就是各种书籍书柜，各种书籍，任君采撷。我在书城看了不少小说，可能也有一部分是19年的春节在书城看的。像东野圭吾的小说，就读了好多本，虽然现在很多都没印象了；余华的小说，读了《兄弟》，《在细雨中呼喊》，《第七天》，《四月三日事件》，《许三观卖血记》，印象最深刻的无疑是《兄弟》和《许三观卖血记》这两部小说，《第七天》应该是大学语文老师有提到过，有很多现实因素在里面，更像是一篇媒体记录(?)，不太清楚要怎么描述；还读了今何在的《未来：人类的征途》，读起来不错，但是当时似乎并没有完结；至于其他科幻小说/短篇，以及其他看过的书籍，已经没有太多印象了。</p><p>虽然说在书城看了这么多事，但是给我留下的一个印象就是拿着书小憩。中午找一本想看的书，坐在地上，看着看着就渐起睡意，迷糊中一手抓着手机，一手拿书，背着装有电脑的包，依靠在书架上，腿或伸开或盘着，便开始打盹。</p><p>到了大概1点45的时候，收拾好东西，把书放回原处，出发去图书馆。重复上午的流程，签到入馆，找位置，插电源，开始写代码，调试代码，直到图书馆5点闭馆。闭馆后自然还是去书城消磨剩下的时间，因为太早回去也是一个人闷在房间里。这时运气好可以在4楼电梯附近找到个空位置，掏出电脑继续未完成的事情，不过由于没有电源，这种情况也坚持不了多少。运气不好的话就只能找个地方看看书了。在书城呆个1-2小时，6-7点左右找家店吃饭便可以回去了。</p><p>至于回去之后是在房间里是怎么过的，我是真的忘了，一点印象也没了。那会游戏也脱坑了，实在想不起我在干嘛。不过唯一的印象在炎热的夏天，房间里没有风扇，一个人闷在房间里，就只有需要洗澡的时候出去洗澡，结束了又回来。往上睡觉的时候老大进来睡觉，是的，我占了他的房间，鸠占鹊巢了属于是，不过是分开床睡。我就这么一句话不说睡了过去，等第二天起来或许身上都是汗。然后又重复一样的日子。</p><p>这种日子持续没多久，大概1个月左右吧。在结束了实验之后，开始准备实习有关的内容。虽然面试时是面的Android岗，但最后让我去写iOS，于是开始补iOS的有关知识。笔记本虚拟机里装了个黑苹果，OC开始学起来，之后还顺带看了看swift。</p><p>大概是20年6月13日，也可能是12日，因为现在我印象中那是个周五，淘宝上买的行李箱到了，刚好也跟啊p联系说可以现在过去，洗了个澡收拾东西就投奔啊p去了。</p><p>见面后说了什么已经记不清了，第二天啊虎也过来了，三个高中舍友在一起欢乐的不行，一起在西丽附近逛，又是吃饭，记忆里当晚吃了份烧烤，点的生蚝以及烤串有些多，最后让啊虎打包回家了，哈哈哈。</p><p>晚上的活动没啥印象了，只记得两位王者开小号带我这个萌新在鱼塘炸鱼，不亦乐乎。</p><p>啊虎过来后的第二天是周一，啊p照常去上班了，可能是昨天喝了点小酒，啊虎感冒了，在西丽呆了一晚。醒来后我们日常继续打王者鱼塘炸鱼，中午去外卖打包了份烧鸭饭，便送啊虎回去了。</p><p>之后的几天无非就是继续学习iOS有关内容，看了看斯坦福的课，日子便来到了要去公司上班的时刻了。</p><p>那应该是个周四。早上7点45醒来，洗漱完毕去赶8点10分的班车。在西丽邮局门口排了长长一排队伍，上车后啊p跟司机师傅解释说我是新入职的，还没工卡，就找位置坐下去了。</p><p>班车把我们送在了某个停车点，又是跟着一群人走到了腾讯大厦楼下，啊p把我带到腾大后，因为他也有自己的工作，便先行离去了。</p><p>在腾大按照入职指引，来到2楼，找到HR窗口，拿到自己的工卡，token，便可以回工区了。在这期间还遇到了校交班的一位同学。</p><p>M12当时是在万利达6F，找到工位后，原本安排给我的工位给了另一位来的较早的实习生，而当时负责带我的mentor熊大也正好请假了。不过好在其他同事很热心，也很nice，帮助我完成了剩下的流程。期间我还记得电脑连不上WIFI，隔空投送也没有用，国栋就用U盘帮忙把IOA拷过来，剩下的就是装电话之类的流程了。</p><p>因为当时腾讯招的实习生太多了，卡座工位已经坐不下了，于是便让我坐在了饮水机附近的工位。工位前面有一块L形挡板，用于将工位和过道隔开，过道的另外一边应该是算法同学，挡板后是两张桌子，其中一张便是我的工位了，左边也是一位实习生，来自中大，在后端组，写go有关需求。工位后面便是饮水机，饮水机旁边是门，门后边是过道，可以通往厕所以及另外半层工区。</p><p>中午跟同事们一起去腾大吃饭，吃饭期间有聊到工作内容，一开始也是安排写iOS，不过后来下午因为俊野要休假，便让我回去写Android了。</p><p>实习期间的工作还是很轻松的，也没安排比较难的需求，整个工作节奏就是995这样。其实早上可以晚点来，我们是9点45开早会，在这个时间点之前到就行。晚上一般等8-9点的班车回去。</p><p>时间眨眼到了8月中，组长便让我准备转正答辩的事情，也没在让我做其他需求了。后面的日子就是写答辩PPT， 偶尔摸鱼看看面经，就过去了。</p><p>在实习的这两个半月间，还有其他事情，像出去一起团建，跟产品测试打交道，跟总监交流转正有关问题，跟其他部门的同学打交道，就不一一赘述了。</p><p>转正答辩结束后，就只安排了一个需求。在往后就是收拾东西准备离职了。</p><p>走的那一天或许是8月26日附近，早上到公司吃完早餐后，处理完剩下的事情，通知负责人上来收走电脑以及其他物品，去腾大归还工卡，领实习证明，就这样结束了实习的日子。</p><p>走出公司时还是上午，烈日当头，还没到12点，走到最近的公交站等公交车，坐上公交前往西丽，回到熟悉的出租屋。草草的吃完饭后开始躺平，再过了1-2天后就打包收拾东西回学校了。</p><p>其实当时有人说8月底要来深圳玩，不过因为一些事情鸽了。</p><p>回到学校，果然我又是第一个回来的。武汉封了大半年，宿舍内是各种积灰，难免少不了一顿大扫除。之后的日子里，程洋，远方，丁宝等人陆陆续续回到了学校，恢复了生气，又开始了快活的日子。</p><p>大四上的日子对我而言是极其快乐的，因为除了9月转正失败后一直在刷题背面经找工作，其他几个月都是过着醉生梦死的日子。那段时间里宿舍只有2个人，经常是睡到了12点以后才醒来点外卖决定要吃什么。外卖到了便东身去光体门口取。吃完外卖开始打游戏，困了便上床睡觉，实在是不可多得的日子。</p><p>那段日子想想其实也没什么事，对我而言工作后来已经找到了，公选课学分已经修满，整个学期下来无非就是生产实习答辩怼了老师，因为老师全程抓着我们报告的格式不妨，对内容不做评价；听了陈导屁用没有的动员会；上了几节形式与政策课，并完成有关作业。</p><p>日子就这么来到了寒假，寒假的话自然是不想回家的，于是便动身前往杭州实习。</p><p>To Be Contine</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;始于2022-10-02 23时。&lt;/p&gt;
&lt;p&gt;为什么会想起来写这些东西，俺也不知道。在国庆期间看到这样的朋友圈官宣，不过对他而言，倒也合理，了解接触不多，毕竟只是两年同学罢了。&lt;/p&gt;
&lt;p&gt;想起20年还在深圳实习时，跟啊p躺在床上，有聊到有关事情，不过也很快结束了，他是正确的。&lt;/p&gt;
&lt;p&gt;现在回忆20年的那个夏天，还是快乐的。&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="http://yorxika.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="http://yorxika.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>扑克牌中的顺子</title>
    <link href="http://yorxika.github.io/2020/09/08/%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/"/>
    <id>http://yorxika.github.io/2020/09/08/%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</id>
    <published>2020-09-07T17:05:48.000Z</published>
    <updated>2020-09-07T17:11:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode 面试题61 扑克牌中的顺子</p><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [1,2,3,4,5]</span></span><br><span class="line"><span class="section">输出: True</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [0,0,1,2,5]</span></span><br><span class="line"><span class="section">输出: True</span></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>输入数组长度为5,对数组做一次排序,之后遍历数组,记录中间数值为0的个数,以及如果有重复数值即可提前退出,否则用大小王的个数去填充相邻两个数之间要构成顺子需要的牌数,最后返回0的个数是否大于0即可.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">zero</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span> ; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            zero++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用大小王去填充中间的沟壑</span></span><br><span class="line">        zero -= nums[i + <span class="number">1</span>] - nums[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是00123那也能算是顺子，因为00能填充任意位置</span></span><br><span class="line">    <span class="keyword">return</span> zero &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>来自<a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/solution/mian-shi-ti-61-bu-ke-pai-zhong-de-shun-zi-ji-he-se/">Krahets</a></p><ul><li>遍历五张牌，遇到大小王（即 0 ）直接跳过。</li><li><strong>判别重复：</strong> 利用 Set 实现遍历判重， Set 的查找方法的时间复杂度为 O(1)；</li><li><strong>获取最大 / 最小的牌：</strong> 借助辅助变量 ma和 mi ，遍历统计即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; repeat = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, min = <span class="number">14</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 跳过大小王</span></span><br><span class="line">            max = Math.max(max, num); <span class="comment">// 最大牌</span></span><br><span class="line">            min = Math.min(min, num); <span class="comment">// 最小牌</span></span><br><span class="line">            <span class="keyword">if</span>(repeat.contains(num)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 若有重复，提前返回 false</span></span><br><span class="line">            repeat.add(num); <span class="comment">// 添加此牌至 Set</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max - min &lt; <span class="number">5</span>; <span class="comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode 面试题61 扑克牌中的顺子&lt;/p&gt;
&lt;p&gt;从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-刷题记录</title>
    <link href="http://yorxika.github.io/2020/09/02/%E5%89%91%E6%8C%87offer-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yorxika.github.io/2020/09/02/%E5%89%91%E6%8C%87offer-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2020-09-02T11:54:11.000Z</published>
    <updated>2020-09-15T15:59:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h3><p>最简单的用set判断</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.contains(x)) &#123;</span><br><span class="line">            set.add(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方题解，交换位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] != i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[nums[i]])&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            temp = nums[i];</span><br><span class="line">            nums[i] = nums[temp];</span><br><span class="line">            nums[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以排序后遍历，或者用新数组做桶标记。</p><h3 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h3><p>找对位置从左上角开始，大则左，小则下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> , y = col - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (x &lt; row &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        temp = matrix[x][y];</span><br><span class="line">        <span class="keyword">if</span> (temp == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp &gt; target) &#123;</span><br><span class="line">            y--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">space</span> <span class="operator">=</span> <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(space);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从头到尾打印链表"><a href="#从头到尾打印链表" class="headerlink" title="从头到尾打印链表"></a>从头到尾打印链表</h3><p>遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        list.add(head.val);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(list);</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; list.size() ; i++)&#123;</span><br><span class="line">        ans[i] = list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以考虑先直接将链表倒序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        node = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head=node;</span><br><span class="line">    &#125;</span><br><span class="line">    head=pre;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">        res[i] = head.val;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从前序与中序遍历构造二叉树"><a href="#从前序与中序遍历构造二叉树" class="headerlink" title="从前序与中序遍历构造二叉树"></a>从前序与中序遍历构造二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span>[] pre,in;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; inorder.length ; ++i) &#123;</span><br><span class="line">        map.put(inorder[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.in = inorder;</span><br><span class="line">    <span class="built_in">this</span>.pre = preorder;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>,pre.length,<span class="number">0</span>,inorder.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span> pS,<span class="type">int</span> pE,<span class="type">int</span> iS,<span class="type">int</span> iE)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pE == pS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[pS]); <span class="comment">//根节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> map.get(pre[pS]); <span class="comment">//中序遍历根节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> rootIndex - iS;</span><br><span class="line">    root.left = helper(pS + <span class="number">1</span>,pS + left + <span class="number">1</span>,iS,rootIndex);</span><br><span class="line">    root.right = helper(pS + <span class="number">1</span> + left,pE,rootIndex + <span class="number">1</span>,iE);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片判断，来自<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/luo-suo-de-javajian-dan-de-di-gui-by-acnesu/">题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面四行代码其实就是把数组转换成list</span></span><br><span class="line">        List&lt;Integer&gt; pre = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : preorder) pre.add(i);</span><br><span class="line">        List&lt;Integer&gt; in = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : inorder) in.add(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//其实这个函数就这一行</span></span><br><span class="line">        <span class="keyword">return</span> f(pre,in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode <span class="title function_">f</span><span class="params">(List pre, List in)</span>&#123;</span><br><span class="line">        <span class="comment">// 递归停止条件，就是遍历完了列表</span></span><br><span class="line">    <span class="keyword">if</span>(pre.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历的第一个，一定是root呀</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> (<span class="type">int</span>) pre.get(<span class="number">0</span>);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从中序遍历里面找到root的位置，酒吧中序遍历分成两部分了</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> in.indexOf(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//别问 问就是递归</span></span><br><span class="line">    root.left = f(pre.subList(<span class="number">1</span>,<span class="number">1</span>+index), </span><br><span class="line">                        in.subList(<span class="number">0</span>,index));</span><br><span class="line">    root.right = f(pre.subList(<span class="number">1</span>+index, pre.size()), </span><br><span class="line">                        in.subList(<span class="number">1</span>+index, in.size()) );</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：acnesu</span><br></pre></td></tr></table></figure><h3 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h3><p>一个栈用来入队，一个用来出队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; s1;</span><br><span class="line">    Stack&lt;Integer&gt; s2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        s2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        s1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s1.empty()) &#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s2.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="斐波纳契数列"><a href="#斐波纳契数列" class="headerlink" title="斐波纳契数列"></a>斐波纳契数列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fo</span> <span class="operator">=</span> <span class="number">0</span>, f1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        ans = (fo + f1) % <span class="number">1000000007</span> ;</span><br><span class="line">        fo = f1;</span><br><span class="line">        f1 = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fo</span> <span class="operator">=</span> <span class="number">1</span>, f1 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">        ans = (fo + f1) % <span class="number">1000000007</span> ;</span><br><span class="line">        fo = f1;</span><br><span class="line">        f1 = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; nums[left] &gt;= nums[right]) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[right])&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right])&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h3><p>DFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">char</span>[] ss ;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> col;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> row;</span><br><span class="line"><span class="keyword">private</span> <span class="type">char</span>[][] board;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">    ss = word.toCharArray();</span><br><span class="line">    <span class="built_in">this</span>.col = board.length;</span><br><span class="line">    <span class="built_in">this</span>.row = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="built_in">this</span>.board = board;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; col ; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; row ; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper(i,j,<span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= col || i &lt; <span class="number">0</span> || j &gt;= row || j &lt; <span class="number">0</span> || board[i][j] != ss[k]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == ss.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> board[i][j];</span><br><span class="line">    board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">check</span> <span class="operator">=</span> helper(i + <span class="number">1</span>, j, k + <span class="number">1</span>) || helper(i - <span class="number">1</span>, j, k + <span class="number">1</span>) ||</span><br><span class="line">            helper(i, j + <span class="number">1</span>, k + <span class="number">1</span>) ||helper(i , j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">    board[i][j] = temp;</span><br><span class="line">    <span class="keyword">return</span> check;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h3><p>DFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">counts</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span>[][] visited;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">    helper(<span class="number">0</span>,<span class="number">0</span>,m,n,k);</span><br><span class="line">    <span class="keyword">return</span> counts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> m,<span class="type">int</span> n,<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= m || x &lt; <span class="number">0</span> || y &gt;= n || y &lt; <span class="number">0</span> || calLimit(x, y) &gt; k || visited[x][y]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    counts++;</span><br><span class="line">    visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">    helper(x + <span class="number">1</span>,y,m,n,k);</span><br><span class="line">    helper(x - <span class="number">1</span>,y,m,n,k);</span><br><span class="line">    helper(x,y + <span class="number">1</span>,m,n,k);</span><br><span class="line">    helper(x,y - <span class="number">1</span>,m,n,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calLimit</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ans += x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ans += y % <span class="number">10</span>;</span><br><span class="line">        y /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题解里的优化点：</p><h4 id="数位之和计算："><a href="#数位之和计算：" class="headerlink" title="数位之和计算："></a>数位之和计算：</h4><p><img src="/2020/09/02/%E5%89%91%E6%8C%87offer-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/09/02/%E5%89%91%E6%8C%87offer-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20200902215909217.png" alt="image-20200902215909217"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? s_x + <span class="number">1</span> : s_x - <span class="number">8</span></span><br></pre></td></tr></table></figure><h5 id="搜索方向简化："><a href="#搜索方向简化：" class="headerlink" title="搜索方向简化："></a>搜索方向简化：</h5><ul><li><p><strong>数位和特点：</strong> 根据数位和增量公式得知，数位和每逢 <strong>进位</strong> 突变一次。</p></li><li><p>解的三角形结构：</p><ul><li>根据数位和特点，矩阵中 <strong>满足数位和的解</strong> 构成的几何形状形如多个 <strong>等腰直角三角形</strong> ，每个三角形的直角顶点位于 0, 10, 20, …0,10,20,… 等数位和突变的矩阵索引处 。</li><li>三角形内的解虽然都满足数位和要求，但由于机器人每步只能走一个单元格，而三角形间不一定是连通的，因此机器人不一定能到达，称之为 <strong>不可达解</strong> ；同理，可到达的解称为 <strong>可达解</strong> （本题求此解） 。</li></ul></li><li><p>结论：</p><p>根据可达解的结构，易推出机器人可</p><p>仅通过向右和向下移动，访问所有可达解。</p><ul><li><strong>三角形内部：</strong> 全部连通，易证；</li><li><strong>两三角形连通处：</strong> 若某三角形内的解为可达解，则必与其左边或上边的三角形连通（即相交），即机器人必可从左边或上边走进此三角形。</li></ul></li></ul><h3 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">        n = n - <span class="number">3</span>;</span><br><span class="line">        a = a * <span class="number">3</span>;</span><br><span class="line">        a = a % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) (a * n % <span class="number">1000000007</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制数中一的个数"><a href="#二进制数中一的个数" class="headerlink" title="二进制数中一的个数"></a>二进制数中一的个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        n &amp;= n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数值的整次方"><a href="#数值的整次方" class="headerlink" title="数值的整次方"></a>数值的整次方</h3><p>快速幂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span> / x;</span><br><span class="line">        b = -b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            ans *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        x *= x;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h3><p>双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> , right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; len &amp;&amp; nums[left] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &gt;= <span class="number">0</span> &amp;&amp; nums[right] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = temp;</span><br><span class="line">        right--;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="type">int</span> v1,v2;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        v1 = l1.val;</span><br><span class="line">        v2 = l2.val;</span><br><span class="line">        <span class="keyword">if</span> (v1 &lt;= v2) &#123;</span><br><span class="line">            head.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        head.next = l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        head.next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(B == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(A == <span class="literal">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(A);</span><br><span class="line">    TreeNode temp;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        temp = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.val == B.val) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> recur(temp,B);</span><br><span class="line">            <span class="keyword">if</span> (ans) &#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">z</span> <span class="operator">=</span> root.left;</span><br><span class="line">    root.left = mirrorTree(root.right);</span><br><span class="line">    root.right = mirrorTree(z);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) stack.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) stack.add(node.right);</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> node.left;</span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root.left);</span><br><span class="line">    queue.add(root.right);</span><br><span class="line">    TreeNode left,right;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        left = queue.poll();</span><br><span class="line">        right = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span> &amp;&amp; right.val == left.val) &#123;</span><br><span class="line">            queue.add(left.left);</span><br><span class="line">            queue.add(right.right);</span><br><span class="line">            queue.add(left.right);</span><br><span class="line">            queue.add(right.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="literal">null</span> ? <span class="literal">true</span> : recur(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode L, TreeNode R)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">null</span> &amp;&amp; R == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">null</span> || R == <span class="literal">null</span> || L.val != R.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> recur(L.left, R.right) &amp;&amp; recur(L.right, R.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] dx = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] dy = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] spiralOrder(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">counts</span> <span class="operator">=</span> <span class="number">0</span> ,end = rows * cols,dir = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[end];</span><br><span class="line">    <span class="keyword">while</span> (counts &lt; end) &#123;</span><br><span class="line">        ans[counts] = matrix[x][y];</span><br><span class="line">        matrix[x][y] = Integer.MIN_VALUE;</span><br><span class="line">        counts++;</span><br><span class="line">        <span class="comment">//在范围内，且数字没有修改过</span></span><br><span class="line">        <span class="keyword">if</span> (!inRange(x,y,dir,rows,cols) &amp;&amp; matrix[x + dx[dir]][y + dy[dir]] != Integer.MIN_VALUE) &#123;</span><br><span class="line">            x += dx[dir];</span><br><span class="line">            y += dy[dir];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dir++;</span><br><span class="line">            dir %= <span class="number">4</span>;</span><br><span class="line">            x += dx[dir];</span><br><span class="line">            y += dy[dir];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">inRange</span><span class="params">(<span class="type">int</span> x , <span class="type">int</span> y,<span class="type">int</span> k,<span class="type">int</span> row,<span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ddx</span> <span class="operator">=</span> x + dx[k], ddy = y + dy[k];</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> ddx &gt;= row || ddx &lt; <span class="number">0</span> || ddy &gt;= col || ddy &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] spiralOrder(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[rows * cols];</span><br><span class="line">    <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, down = rows - <span class="number">1</span> , left = <span class="number">0</span>,right = cols - <span class="number">1</span>,count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right ; ++i) &#123;</span><br><span class="line">            ans[count++] = matrix[top][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (++top &gt; down) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top ; i &lt;= down ; ++i)&#123;</span><br><span class="line">            ans[count++] = matrix[i][right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (--right &lt; left) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right ; i &gt;= left ; --i) &#123;</span><br><span class="line">            ans[count++] = matrix[down][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--down &lt; top) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> down;i &gt;= top ; --i) &#123;</span><br><span class="line">            ans[count++] = matrix[i][left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (++left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈的压入与弹出"><a href="#栈的压入与弹出" class="headerlink" title="栈的压入与弹出"></a>栈的压入与弹出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span> , len = pushed.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : pushed) &#123;</span><br><span class="line">        stack.push(num);</span><br><span class="line">        <span class="comment">//模拟出栈过程</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; stack.peek() == popped[index]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表中倒数第K个节点"><a href="#链表中倒数第K个节点" class="headerlink" title="链表中倒数第K个节点"></a>链表中倒数第K个节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head,slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head,next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并两个排序链表"><a href="#合并两个排序链表" class="headerlink" title="合并两个排序链表"></a>合并两个排序链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="type">int</span> v1,v2;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        v1 = l1.val;</span><br><span class="line">        v2 = l2.val;</span><br><span class="line">        <span class="keyword">if</span> (v1 &lt;= v2) &#123;</span><br><span class="line">            head.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        head.next = l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        head.next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树的子结构-1"><a href="#树的子结构-1" class="headerlink" title="树的子结构"></a>树的子结构</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(B == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(A == <span class="literal">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的镜像-1"><a href="#二叉树的镜像-1" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h3><p>注意是镜像复制，所以left复制的是right，right复制的是left</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">z</span> <span class="operator">=</span> root.left;</span><br><span class="line">    root.left = mirrorTree(root.right);</span><br><span class="line">    root.right = mirrorTree(z);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对称的二叉树-1"><a href="#对称的二叉树-1" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h3><p>按照层序遍历，最开始直接加入根节点的左右子树，之后判断左右子树的4个子节点是否对称，加入队列时要注意顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root.left);</span><br><span class="line">    queue.add(root.right);</span><br><span class="line">    TreeNode left,right;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        left = queue.poll();</span><br><span class="line">        right = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span> &amp;&amp; right.val == left.val) &#123;</span><br><span class="line">            queue.add(left.left);</span><br><span class="line">            queue.add(right.right);</span><br><span class="line">            queue.add(left.right);</span><br><span class="line">            queue.add(right.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺时针打印矩阵-1"><a href="#顺时针打印矩阵-1" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h3><h4 id="憨批写法"><a href="#憨批写法" class="headerlink" title="憨批写法"></a>憨批写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] dx = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] dy = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] spiralOrder(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">counts</span> <span class="operator">=</span> <span class="number">0</span> ,end = rows * cols,dir = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[end];</span><br><span class="line">    <span class="keyword">while</span> (counts &lt; end) &#123;</span><br><span class="line">        ans[counts] = matrix[x][y];</span><br><span class="line">        matrix[x][y] = Integer.MIN_VALUE;</span><br><span class="line">        counts++;</span><br><span class="line">        <span class="comment">//在范围内，且数字没有修改过</span></span><br><span class="line">        <span class="keyword">if</span> (!inRange(x,y,dir,rows,cols) &amp;&amp; matrix[x + dx[dir]][y + dy[dir]] != Integer.MIN_VALUE) &#123;</span><br><span class="line">            x += dx[dir];</span><br><span class="line">            y += dy[dir];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dir++;</span><br><span class="line">            dir %= <span class="number">4</span>;</span><br><span class="line">            x += dx[dir];</span><br><span class="line">            y += dy[dir];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">inRange</span><span class="params">(<span class="type">int</span> x , <span class="type">int</span> y,<span class="type">int</span> k,<span class="type">int</span> row,<span class="type">int</span> col)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ddx</span> <span class="operator">=</span> x + dx[k], ddy = y + dy[k];</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> ddx &gt;= row || ddx &lt; <span class="number">0</span> || ddy &gt;= col || ddy &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题解4轮遍历"><a href="#题解4轮遍历" class="headerlink" title="题解4轮遍历"></a>题解4轮遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] spiralOrder(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[rows * cols];</span><br><span class="line">    <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, down = rows - <span class="number">1</span> , left = <span class="number">0</span>,right = cols - <span class="number">1</span>,count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right ; ++i) &#123;</span><br><span class="line">            ans[count++] = matrix[top][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (++top &gt; down) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top ; i &lt;= down ; ++i)&#123;</span><br><span class="line">            ans[count++] = matrix[i][right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (--right &lt; left) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right ; i &gt;= left ; --i) &#123;</span><br><span class="line">            ans[count++] = matrix[down][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--down &lt; top) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> down;i &gt;= top ; --i) &#123;</span><br><span class="line">            ans[count++] = matrix[i][left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (++left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; min;</span><br><span class="line">        Stack&lt;Integer&gt; stack;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">            min = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">            stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            stack.push(x);</span><br><span class="line">            <span class="keyword">if</span> (min.empty() || min.peek() &gt;= x) &#123;</span><br><span class="line">                min.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.pop().equals(min.peek())) &#123;</span><br><span class="line">                min.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> stack.peek();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> min.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>栈的压入与弹出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span> , len = pushed.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : pushed) &#123;</span><br><span class="line">        stack.push(num);</span><br><span class="line">        <span class="comment">//模拟出栈过程</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; stack.peek() == popped[index]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树"></a>从上到下打印二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    TreeNode temp ;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        temp = queue.poll();</span><br><span class="line">        list.add(temp.val);</span><br><span class="line">        <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从上到下打印二叉树II"><a href="#从上到下打印二叉树II" class="headerlink" title="从上到下打印二叉树II"></a>从上到下打印二叉树II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    TreeNode temp;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; size; ++i) &#123;</span><br><span class="line">            temp = queue.poll();</span><br><span class="line">            list.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从上到下打印二叉树III"><a href="#从上到下打印二叉树III" class="headerlink" title="从上到下打印二叉树III"></a>从上到下打印二叉树III</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    TreeNode temp;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        size = queue.size();</span><br><span class="line">        List&lt;Integer&gt; z = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; size ; ++i) &#123;</span><br><span class="line">            temp = queue.poll();</span><br><span class="line">            z.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            ans.add(z);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Collections.reverse(z);</span><br><span class="line">            ans.add(z);</span><br><span class="line">        &#125;</span><br><span class="line">        flag = !flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树的后序遍历"><a href="#二叉搜索树的后序遍历" class="headerlink" title="二叉搜索树的后序遍历"></a>二叉搜索树的后序遍历</h3><p>参考题解<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/jian-dan-yi-dong-zhu-shi-cu-pin-zhi-xing-yong-shi-/">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/jian-dan-yi-dong-zhu-shi-cu-pin-zhi-xing-yong-shi-/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifyPostorder</span><span class="params">(<span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> postorder.length - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ;--i) &#123;</span><br><span class="line">        <span class="comment">// 左子树元素必须要小于递增栈被peek访问的元素，否则就不是二叉搜索树</span></span><br><span class="line">        <span class="keyword">if</span> (postorder[i] &gt; root ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; stack.peek() &gt; postorder[i]) &#123;</span><br><span class="line">            <span class="comment">// 数组元素小于单调栈的元素了，表示往左子树走了，记录下上个根节点</span></span><br><span class="line">            <span class="comment">// 找到这个左子树对应的根节点，之前右子树全部弹出，不再记录，因为不可能在往根节点的右子树走了</span></span><br><span class="line">            root = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(postorder[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] postorder;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifyPostorder</span><span class="params">(<span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.postorder = postorder;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>,postorder.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="comment">//划分左子树</span></span><br><span class="line">    <span class="keyword">while</span> (postorder[p] &lt; postorder[j]) &#123;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p;</span><br><span class="line">    <span class="comment">//划分友子树</span></span><br><span class="line">    <span class="keyword">while</span> (postorder[p] &gt; postorder[j]) &#123;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p == j &amp;&amp; helper(i,m - <span class="number">1</span>) &amp;&amp; helper(m,j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树中路径和为某一值的路径"><a href="#二叉树中路径和为某一值的路径" class="headerlink" title="二叉树中路径和为某一值的路径"></a>二叉树中路径和为某一值的路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    helper(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(),root,sum);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(List&lt;Integer&gt; l,TreeNode root,<span class="type">int</span> rest)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    l.add(root.val);</span><br><span class="line">    rest -= root.val;</span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="number">0</span> &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(l));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        helper(l, root.left, rest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        helper(l, root.right, rest);</span><br><span class="line">    &#125;</span><br><span class="line">    l.remove(l.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Node,Node&gt; copy = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        copy.put(p,<span class="keyword">new</span> <span class="title class_">Node</span>(p.val));</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        copy.get(p).next = copy.get(p.next);</span><br><span class="line">        copy.get(p).random = copy.get(p.random);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head,copy = <span class="literal">null</span>,temp = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        copy = <span class="keyword">new</span> <span class="title class_">Node</span>(p.val);</span><br><span class="line">        copy.next = p.next;</span><br><span class="line">        p.next = copy;</span><br><span class="line">        p = copy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.random != <span class="literal">null</span>) &#123;</span><br><span class="line">            p.next.random = p.random.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    copy = head.next;</span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        temp = p.next;</span><br><span class="line">        p.next = p.next.next;</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h3><p>重新排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">treeToDoublyList</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Node&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Node o1, Node o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.val - o2.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dfs(root,queue);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head , pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        cur = queue.poll();</span><br><span class="line">        cur.right = queue.peek();</span><br><span class="line">        cur.left = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    head.left = cur;</span><br><span class="line">    cur.right = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node root,PriorityQueue&lt;Node&gt; queue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    dfs(root.left,queue);</span><br><span class="line">    dfs(root.right,queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用二叉搜索树中序为递增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">preNode</span> <span class="operator">=</span> <span class="literal">null</span>,headNode = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">treeToDoublyList</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    headNode.left = preNode;</span><br><span class="line">    preNode.right = headNode;</span><br><span class="line">    <span class="keyword">return</span> headNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    <span class="keyword">if</span> (preNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        preNode.right = root;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        headNode = root;</span><br><span class="line">    &#125;</span><br><span class="line">    root.left = preNode;</span><br><span class="line">    preNode = root;</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">space</span> <span class="operator">=</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">TreeNode</span> <span class="variable">nn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.MIN_VALUE);</span><br><span class="line">            queue.offer(root);</span><br><span class="line">            TreeNode temp;</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (temp.val != Integer.MIN_VALUE) &#123;</span><br><span class="line">                    sb.append(temp.val).append(space);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sb.append(n).append(space);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span> &amp;&amp; temp.left.val != Integer.MIN_VALUE) &#123;</span><br><span class="line">                    queue.offer(temp.left);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//sb.append(n).append(space);</span></span><br><span class="line">                    queue.offer(nn);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span> &amp;&amp; temp.right.val != Integer.MIN_VALUE) &#123;</span><br><span class="line">                    queue.offer(temp.right);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//sb.append(n).append(space);</span></span><br><span class="line">                    queue.offer(nn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ystem.out.println(sb.toString());</span></span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">        <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data == <span class="literal">null</span> || data.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] s = data.substring(<span class="number">0</span>,data.length() - <span class="number">1</span>).split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">            Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(s[<span class="number">0</span>]));</span><br><span class="line">            queue.offer(root);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            TreeNode temp;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; s.length &amp;&amp; !queue.isEmpty()) &#123;</span><br><span class="line">                temp = queue.poll();</span><br><span class="line">               <span class="comment">// temp.val = Integer.parseInt(s[index]);</span></span><br><span class="line">                <span class="comment">//System.out.println(&quot;s[&quot; + index + &quot;]: &quot; + s[index]);</span></span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">if</span> (s[index].equals(n)) &#123;</span><br><span class="line">                    temp.left = <span class="literal">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(s[index]));</span><br><span class="line">                    queue.offer(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">if</span> (s[index].equals(n)) &#123;</span><br><span class="line">                    temp.right = <span class="literal">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(s[index]));</span><br><span class="line">                    queue.offer(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println(serialize(root));</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// String[] ans = new String[factorial(s.length())];</span></span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] c = s.toCharArray();</span><br><span class="line">    dfs(c,<span class="number">0</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[ans.size()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[] c,<span class="type">int</span> index,List&lt;String&gt; ans)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == c.length - <span class="number">1</span>) &#123;</span><br><span class="line">        ans.add(String.valueOf(c));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> tmp;</span><br><span class="line">    HashSet&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; c.length ; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(c[i])) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(c[i]);</span><br><span class="line">        tmp = c[i];</span><br><span class="line">        c[i] = c[index];</span><br><span class="line">        c[index] = tmp;</span><br><span class="line">        dfs(c,index + <span class="number">1</span>,ans);</span><br><span class="line">        tmp = c[i];</span><br><span class="line">        c[i] = c[index];</span><br><span class="line">        c[index] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组中出现次数超过一半"><a href="#数组中出现次数超过一半" class="headerlink" title="数组中出现次数超过一半"></a>数组中出现次数超过一半</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length ; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="number">0</span>) &#123;</span><br><span class="line">            current = nums[i];</span><br><span class="line">            val = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            val = nums[i] == current ? val + <span class="number">1</span> : val - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; k ; ++i) &#123;</span><br><span class="line">        ans[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>,k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] quickSort(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(arr,left,right);</span><br><span class="line">    <span class="keyword">if</span> (index == k) &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(arr,index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index &gt; k ? quickSort(arr,left,index-<span class="number">1</span>,k) : quickSort(arr,index + <span class="number">1</span>, right,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">//选取一个随机枢纽基准值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">    swap(nums,left,random);</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> nums[left];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span> , j = right;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= right &amp;&amp; nums[i] &lt; value) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; left &amp;&amp; nums[j] &gt; value)</span><br><span class="line">            --j;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,i,j);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums,left,j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">    nums[index1] = nums[index2];</span><br><span class="line">    nums[index2] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据中的中位数"><a href="#数据中的中位数" class="headerlink" title="数据中的中位数"></a>数据中的中位数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap,maxHeap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">            minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();  <span class="comment">//小顶堆，保留较大的一部分</span></span><br><span class="line">            maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Collections.reverseOrder());  <span class="comment">//大顶堆，保留较小的一部分</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (minHeap.size() != maxHeap.size()) &#123;</span><br><span class="line">                minHeap.add(num);</span><br><span class="line">                maxHeap.add(minHeap.poll());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxHeap.add(num);</span><br><span class="line">                minHeap.add(maxHeap.poll());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> minHeap.size() != maxHeap.size() ? minHeap.peek() : (minHeap.peek() + maxHeap.peek()) / <span class="number">2.0</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="连续数组的最大子序和"><a href="#连续数组的最大子序和" class="headerlink" title="连续数组的最大子序和"></a>连续数组的最大子序和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum = x;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1的次数"><a href="#1的次数" class="headerlink" title="1的次数"></a>1的次数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每一位出现1的最大数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] count = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">20</span>,<span class="number">300</span>,<span class="number">4000</span>,<span class="number">50000</span>,<span class="number">600000</span>, <span class="number">7000000</span>, <span class="number">80000000</span>, <span class="number">900000000</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>, pow = <span class="number">1</span>,pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//记录当前位数的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">1</span>) &#123;</span><br><span class="line">            ans += pre + <span class="number">1</span> + count[index];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rest &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ans += pow + rest * count[index];</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre + rest * pow;</span><br><span class="line">        pow *= <span class="number">10</span>;</span><br><span class="line">        index++;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//记录位数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//起始数字</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">9</span> ; <span class="comment">// 当前位总共有多少数字</span></span><br><span class="line">    <span class="comment">//先确定目标数字的最高位</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; count) &#123;</span><br><span class="line">        n -= count;</span><br><span class="line">        digit++;</span><br><span class="line">        start *= <span class="number">10</span>;</span><br><span class="line">        count = digit * start * <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确定目标数字</span></span><br><span class="line">    <span class="comment">//因为start为起始，所以要n-1</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> start + (n - <span class="number">1</span>) / digit;</span><br><span class="line">    <span class="comment">//确定是哪一位</span></span><br><span class="line">    <span class="keyword">return</span> Long.toString(num).charAt((n - <span class="number">1</span>) % digit) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="把数组排成最小值"><a href="#把数组排成最小值" class="headerlink" title="把数组排成最小值"></a>把数组排成最小值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; ++i) &#123;</span><br><span class="line">        s[i] = String.valueOf(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(s, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (o1 + o2).compareTo(o2 + o1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (String x : s) &#123;</span><br><span class="line">        sb.append(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt;= s.length(); ++i) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> s.substring(i - <span class="number">2</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(temp.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; temp.compareTo(<span class="string">&quot;26&quot;</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> grid.length, col = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[col];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; row ; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; col; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] += grid[i][j];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j] = Math.max(dp[j],dp[j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长不含重复字符串的子串"><a href="#最长不含重复字符串的子串" class="headerlink" title="最长不含重复字符串的子串"></a>最长不含重复字符串的子串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] set = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span>[] ss = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span> ,len = s.length(),left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; ++i) &#123;</span><br><span class="line">        tmp = ss[i];</span><br><span class="line">        set[tmp]++;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; len &amp;&amp; set[ss[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            tmp = ss[left];</span><br><span class="line">            set[tmp]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(i - left + <span class="number">1</span> , max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp_2</span> <span class="operator">=</span> <span class="number">0</span> , dp_3 = <span class="number">0</span> , dp_5 = <span class="number">0</span>,min = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; n ; ++i) &#123;</span><br><span class="line">        min = Math.min(Math.min(dp[dp_2] * <span class="number">2</span>,dp[dp_3] * <span class="number">3</span>),dp[dp_5] * <span class="number">5</span>);</span><br><span class="line">        dp[i] = min;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * dp[dp_2] == min) &#123;</span><br><span class="line">            dp_2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">3</span> * dp[dp_3] == min) &#123;</span><br><span class="line">            dp_3++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (<span class="number">5</span> * dp[dp_5] == min) &#123;</span><br><span class="line">            dp_5++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> <span class="variable">SPACE</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> SPACE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> x : c)&#123;</span><br><span class="line">        map[x - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> x : c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[x - <span class="string">&#x27;0&#x27;</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SPACE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        RecursiveTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">MergeAndCount</span>(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>);</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; res = pool.submit(task);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ans = res.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MergeAndCount</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] nums;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> left;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> right;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MergeAndCount</span> <span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.nums = nums;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">            temp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">            System.out.println(<span class="string">&quot;called by thread : &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">            <span class="keyword">if</span> (len &lt; <span class="number">2</span> || left == right) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">MergeAndCount</span> <span class="variable">leftPairs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MergeAndCount</span>(nums,left,mid);</span><br><span class="line">            <span class="type">MergeAndCount</span> <span class="variable">rightPairs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MergeAndCount</span>(nums,mid + <span class="number">1</span>,right);</span><br><span class="line">            invokeAll(leftPairs,rightPairs);</span><br><span class="line">            <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> leftPairs.join();</span><br><span class="line">            <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> rightPairs.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果整个数组已经有序，则无需合并，注意这里使用小于等于</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> r1 + r2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">crossPairs</span> <span class="operator">=</span> mergeAndCount(nums, left, mid, right, temp);</span><br><span class="line">            <span class="keyword">return</span> r1 + r2 + crossPairs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">mergeAndCount</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">                temp[i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left; k &lt;= right; k++) &#123;</span><br><span class="line">                <span class="comment">// 有下标访问，得先判断是否越界</span></span><br><span class="line">                <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                    nums[k] = temp[j];</span><br><span class="line">                    j++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == right + <span class="number">1</span>) &#123;</span><br><span class="line">                    nums[k] = temp[i];</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &lt;= temp[j]) &#123;</span><br><span class="line">                    <span class="comment">// 注意：这里是 &lt;= ，写成 &lt; 就不对，请思考原因</span></span><br><span class="line">                    nums[k] = temp[i];</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nums[k] = temp[j];</span><br><span class="line">                    j++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 在 j 指向的元素归并回去的时候，计算逆序对的个数，只多了这一行代码</span></span><br><span class="line">                    count += (mid - i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="链表相交节点"><a href="#链表相交节点" class="headerlink" title="链表相交节点"></a>链表相交节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    ListNode node1=headA;</span><br><span class="line">    ListNode node2=headB;</span><br><span class="line">    <span class="keyword">while</span> (node1!=node2)&#123;</span><br><span class="line">        node1=(node1==<span class="literal">null</span>)?headB:node1.next;</span><br><span class="line">        node2=(node2==<span class="literal">null</span>)?headA:node2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在排序数组中查找数字"><a href="#在排序数组中查找数字" class="headerlink" title="在排序数组中查找数字"></a>在排序数组中查找数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> , right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//右边界</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="keyword">if</span> (right &gt;= <span class="number">0</span> &amp;&amp; nums[right] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左边界</span></span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">    right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right;</span><br><span class="line">    <span class="keyword">return</span> j - i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>||binarySearch(nums,target)==-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> index=binarySearch(nums,target);</span><br><span class="line">    count++;</span><br><span class="line">    <span class="type">int</span> left=index-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;nums[left]==target)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        left--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> right=index+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(right&lt;nums.length&amp;&amp;nums[right]==target)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right=nums.length;</span><br><span class="line">    <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mid&gt;=<span class="number">0</span>&amp;&amp;mid&lt;nums.length&amp;&amp;nums[mid]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid&gt;=<span class="number">0</span>&amp;&amp;mid&lt;nums.length&amp;&amp;nums[mid]&gt;target)&#123;</span><br><span class="line">            right=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-n中缺失的数字"><a href="#0-n中缺失的数字" class="headerlink" title="0-n中缺失的数字"></a>0-n中缺失的数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == mid) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树中第k大节点"><a href="#二叉搜索树中第k大节点" class="headerlink" title="二叉搜索树中第k大节点"></a>二叉搜索树中第k大节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res, k;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.k = k;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.right);</span><br><span class="line">    <span class="keyword">if</span>(--k == <span class="number">0</span>) &#123;</span><br><span class="line">        res = root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxDepth(root.right),maxDepth(root.left));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    depth(root);</span><br><span class="line">    <span class="keyword">return</span> !flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        left = depth(root.left) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        right = depth(root.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(left - right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(left,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] singleNumbers(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">xor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums)<span class="comment">// 一样的抵消,不一样的两个数字异或运算结果必定有一位是1</span></span><br><span class="line">        xor ^= i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> xor &amp; (-xor);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; mask) == <span class="number">0</span>)<span class="comment">//== 0、 == mask 两种结果</span></span><br><span class="line">            ans[<span class="number">0</span>] ^= i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans[<span class="number">1</span>] ^= i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="和为s的连续正序列"><a href="#和为s的连续正序列" class="headerlink" title="和为s的连续正序列"></a>和为s的连续正序列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] findContinuousSequence(<span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> temp,a0;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt; target ; ++i) &#123;</span><br><span class="line">        temp = target - i * (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp % i == <span class="number">0</span>) &#123;</span><br><span class="line">            a0 = temp / i;</span><br><span class="line">            <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; i ; ++j) &#123;</span><br><span class="line">                ans[j] = a0 + j;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len][];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; ++i) &#123;</span><br><span class="line">        ans[i] = list.get(len - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转单词顺序"><a href="#反转单词顺序" class="headerlink" title="反转单词顺序"></a>反转单词顺序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] ss = s.trim().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> ss.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ss[i].equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(ss[i]).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.substring(n, s.length()) + s.substring(<span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (len * k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> <span class="number">0</span>, max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len - k + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; k ; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; max) &#123;</span><br><span class="line">            max = nums[i];</span><br><span class="line">            maxIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[index++] = max;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k ; i &lt; len ; ++i) &#123;</span><br><span class="line">        <span class="comment">//不在索引内</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex &lt; i - k + <span class="number">1</span>) &#123;</span><br><span class="line">            maxIndex = i - k + <span class="number">1</span>;</span><br><span class="line">            max = nums[i - k + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - k + <span class="number">1</span> ; j &lt; i ; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; max) &#123;</span><br><span class="line">                    max = nums[j];</span><br><span class="line">                    maxIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; max) &#123;</span><br><span class="line">            max = nums[i];</span><br><span class="line">            maxIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[index++] = max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a>队列的最大值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; max,nor;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        max = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        nor = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max_value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (max.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        nor.offer(value);</span><br><span class="line">        <span class="keyword">while</span> (!max.isEmpty() &amp;&amp; max.peekLast() &lt; value) &#123;</span><br><span class="line">            max.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        max.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop_front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nor.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nor.poll();</span><br><span class="line">        <span class="keyword">if</span> (!max.isEmpty() &amp;&amp; ans == max.peek()) &#123;</span><br><span class="line">            max.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a>n个骰子的点数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span>[] twoSum(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span>[] pre = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">6</span>];</span><br><span class="line">    Arrays.fill(pre,<span class="number">1</span> / <span class="number">6.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt;= n ; ++i) &#123;</span><br><span class="line">        <span class="type">double</span>[] tmp = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">5</span> * i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; pre.length ; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span> ; l &lt; <span class="number">6</span> ; ++l) &#123;</span><br><span class="line">                tmp[l + j] += pre[j] / <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">zero</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span> ; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            zero++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用大小王去填充中间的沟壑</span></span><br><span class="line">        zero -= nums[i + <span class="number">1</span>] - nums[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是00123那也能算是顺子，因为00能填充任意位置</span></span><br><span class="line">    <span class="keyword">return</span> zero &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="圆圈中的最后剩下的数字"><a href="#圆圈中的最后剩下的数字" class="headerlink" title="圆圈中的最后剩下的数字"></a>圆圈中的最后剩下的数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; ++i) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        idx = (idx + m - <span class="number">1</span>) % n;</span><br><span class="line">        list.remove(idx);</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 最后一轮剩下2个人，所以从2开始反推</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans = (ans + m) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="股票最大利润"><a href="#股票最大利润" class="headerlink" title="股票最大利润"></a>股票最大利润</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; prices.length ; ++i) &#123;</span><br><span class="line">        profit = Math.max(profit,prices[i] - min);</span><br><span class="line">        min = Math.min(min,prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(profit,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等差数列求和"><a href="#等差数列求和" class="headerlink" title="等差数列求和"></a>等差数列求和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> (<span class="type">int</span>) (Math.pow(n, <span class="number">2</span>) + n) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="不用加减乘除实现加法"><a href="#不用加减乘除实现加法" class="headerlink" title="不用加减乘除实现加法"></a>不用加减乘除实现加法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a &amp; b;</span><br><span class="line">    c = c &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> a ^ b;</span><br><span class="line">    <span class="keyword">return</span> add(d,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">plus</span> <span class="operator">=</span> (a ^ b); <span class="comment">// 求和（不计进位）. 相同位置0，相反位置1</span></span><br><span class="line">           b = ((a &amp; b) &lt;&lt; <span class="number">1</span>); <span class="comment">// 计算进位. 先保留同为1的位，都为1的位要向左进位，因此左移1位</span></span><br><span class="line">           a = plus;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> a;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符串转整数"><a href="#字符串转整数" class="headerlink" title="字符串转整数"></a>字符串转整数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strToInt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">neg</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">char</span>[] c = str.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; c.length &amp;&amp; c[index] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index == c.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> c[index];</span><br><span class="line">    <span class="keyword">if</span> ((temp &lt; <span class="string">&#x27;0&#x27;</span> || temp &gt; <span class="string">&#x27;9&#x27;</span>) &amp;&amp; temp != <span class="string">&#x27;+&#x27;</span> &amp;&amp; temp != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        index++;</span><br><span class="line">        neg = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = c[index];</span><br><span class="line">    <span class="keyword">while</span> (index &lt; c.length &amp;&amp; temp &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; temp &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        ans = ans * <span class="number">10</span> + temp - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!neg &amp;&amp; ans &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (neg &amp;&amp; -ans &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">        temp = c[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> neg ? (<span class="type">int</span>)-ans : (<span class="type">int</span>)ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树最近的公共祖先"><a href="#二叉搜索树最近的公共祖先" class="headerlink" title="二叉搜索树最近的公共祖先"></a>二叉搜索树最近的公共祖先</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判定字符串是否唯一"><a href="#判定字符串是否唯一" class="headerlink" title="判定字符串是否唯一"></a>判定字符串是否唯一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUnique</span><span class="params">(String astr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (astr == <span class="literal">null</span> || astr.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span>[] cc = astr.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : cc) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[ch] &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断是否互为字符重排"><a href="#判断是否互为字符重排" class="headerlink" title="判断是否互为字符重排"></a>判断是否互为字符重排</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">CheckPermutation</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> s1.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> s2.length();</span><br><span class="line">    <span class="keyword">if</span> (len1 != len2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span>[] chars = s1.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : chars) &#123;</span><br><span class="line">        map[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line">    chars = s2.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : chars) &#123;</span><br><span class="line">        map[ch]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : map) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;数组中重复的数字&quot;&gt;&lt;a href=&quot;#数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;数组中重复的数字&quot;&gt;&lt;/a&gt;数组中重复的数字&lt;/h3&gt;&lt;p&gt;最简单的用set判断&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JAVA" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JAVA/"/>
    
    
    <category term="Leetcode，算法" scheme="http://yorxika.github.io/tags/Leetcode%EF%BC%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>一些常见知识点</title>
    <link href="http://yorxika.github.io/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yorxika.github.io/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2020-08-29T08:03:01.000Z</published>
    <updated>2020-09-27T06:48:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="facedetecor-人脸识别"><a href="#facedetecor-人脸识别" class="headerlink" title="facedetecor 人脸识别"></a>facedetecor 人脸识别</h3><p><a href="https://github.com/RedApparat/FaceDetector">github仓库地址</a><br><span id="more"></span></p><p>//添加依赖<br>//<code>JAVA//    repositories &#123;//        maven &#123;//            url  &quot;http://dl.bintray.com/fotoapparat/fotoapparat&quot;//        &#125;//    &#125;////    compile &#39;io.fotoapparat:facedetector:1.0.0&#39;////// If you are using Fotoapparat add this one as well//    compile &#39;io.fotoapparat.fotoapparat:library:1.2.0&#39; // or later version//</code><br>//<br>//    流程：<br>//            1. 选择照片<br>//2. 将照片加载到 bitmap 中并缩放到设置的宽高<br>//3. 用 FaceDetector 来检测人脸，得到 Face 类数组（多人脸检测）<br>//            4. 在照片 bitmap 检测到的人脸上面画上方框和年龄<br>//<br>//#### 选择照片<br>//<br>//    将 Intent 设置 Type 和 Action，启动 activity 选择照片并得到照片的 uri。<br>//            <code>JAVA//    Intent intent = new Intent();//        intent.setType(&quot;image/*&quot;);//        intent.setAction(Intent.ACTION_GET_CONTENT);//    startActivityForResult(intent, OPEN_PHOTO_FOLDER_REQUEST_CODE);//</code><br>//<br>//        #### 加载照片到 bitmap 并缩放<br>//<br>//1. 通过uri用stream<br>//<code>JAVA//    public void initBitmap(Uri uri,int width,int height) &#123;//        try &#123;//            ContentResolver resolver = mContext.getContentResolver();//            BitmapFactory.Options options = new BitmapFactory.Options();//            options.inPreferredConfig = Bitmap.Config.RGB_565;//need this config//            Bitmap bitmap = BitmapFactory.decodeStream(resolver.openInputStream(uri), null, options);//            mBitmap = ThumbnailUtils.extractThumbnail(bitmap, width, height);//scale the bitmap//            detectFace();//        &#125; catch (Exception ex) &#123;//            Log.e(TAG,&quot;exception: &quot;+ex.getMessage());//        &#125;//    &#125;//</code><br>//<br>//        2. 通过真实路径的加载<br>//<code>JAVA//    private void initFRViewWithPath(Uri uri) &#123;//        String[] projection =   &#123;MediaStore.Images.Media.DATA&#125;;//        //        Cursor cursor = managedQuery(uri, projection, null, null, null);//deprecated//        CursorLoader cursorLoader = new CursorLoader(this,uri,projection,null,null,null);//        Cursor cursor = cursorLoader.loadInBackground();//        int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);//        cursor.moveToFirst();////        String path = cursor.getString(column_index);//        Log.e(TAG,&quot;real path: &quot;+path);//        mFRView.initBitmap(path,mFRView.getWidth (),mFRView.getHeight());//    &#125;//    public void initBitmap(String path,int width,int height) &#123;//        BitmapFactory.Options options = new BitmapFactory.Options();//        options.inPreferredConfig = Bitmap.Config.RGB_565;//        mBitmap = BitmapFactory.decodeFile(path, options);//        mBitmap = ThumbnailUtils.extractThumbnail(mBitmap,width,height);//scale the bitmap//        detectFace();//    &#125;//</code><br>//<br>//        ### 人脸检测<br>//<br>//<code>JAVA//    private void detectFace() &#123;//        if(mBitmap != null) &#123;//            mImageWidth = mBitmap.getWidth();//            mImageHeight = mBitmap.getHeight();//            mFaces = new FaceDetector.Face[NUMBER_OF_FACES];//            mFaceDetector = new FaceDetector(mImageWidth, mImageHeight, NUMBER_OF_FACES);//            mNumberOfFaceDetected = mFaceDetector.findFaces(mBitmap, mFaces);//            invalidate();//        &#125;//    &#125;//</code><br>//<br>//        #### 人脸画框<br>//<br>//    在 onDraw 中用 canvas 将检测到的人脸画上框并写上年龄。<br>//<br>//            <code>JAVA//    @Override//    protected void onDraw(Canvas canvas) &#123;//        super.onDraw(canvas);//        if(mBitmap != null) &#123;//            canvas.drawBitmap(mBitmap, 0, 0, null);//            Paint paint = new Paint();//            paint.setColor(Color.WHITE);//            paint.setStyle(Paint.Style.STROKE);//            paint.setStrokeWidth(2);//            paint.setTextSize(50);////            for(int i=0; i &lt; mNumberOfFaceDetected; i++)&#123;//                FaceDetector.Face face = mFaces[i];//                PointF pointF = new PointF();//                face.getMidPoint(pointF);//                mEyesDistance = face.eyesDistance();//                canvas.drawRect(//                        (int)(pointF.x - mEyesDistance),//                        (int)(pointF.y - mEyesDistance/2),//                        (int)(pointF.x + mEyesDistance),//                        (int)(pointF.y + mEyesDistance*3/2),//                        paint);//                canvas.drawText(&quot;28&quot;,pointF.x,pointF.y - mEyesDistance/2-5,paint);//            &#125;//        &#125;//    &#125;//</code></p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>也称为静态工厂方法模式，由一个工厂对象决定创建出哪一种产品类的实例。</p><p>简单工厂模式中有如下角色：</p><ul><li>工厂类：核心，负责创建所有实例的内部逻辑，由外界直接调用。</li><li>抽象产品类：要创建所有对象的抽象父类，负责描述所有实例所共有的公共接口。</li><li>具体产品类：要创建的产品。</li></ul><h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><p>1、抽象产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> abstarct <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、具体产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LenovaComputer</span> <span class="keyword">extends</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HpComputer</span> <span class="keyword">extends</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsusComputer</span> <span class="keyword">extends</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Computer <span class="title function_">createComputer</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">mComputer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;lenovo&quot;</span>:</span><br><span class="line">                mComputer = <span class="keyword">new</span> <span class="title class_">LenovoComputer</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;hp&quot;</span>:</span><br><span class="line">                mComputer = <span class="keyword">new</span> <span class="title class_">HpComputer</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;asus&quot;</span>:</span><br><span class="line">                mComputer = <span class="keyword">new</span> <span class="title class_">AsusComputer</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mComputer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>它需要知道所有工厂类型，因此只适合工厂类负责创建的对象比较少的情况。</li><li>避免直接实例化类，降低耦合性。</li><li>增加新产品需要修改工厂，违背开放封闭原则。</li></ul><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>定义一个用于创建对象的接口，使类的实例化延迟到子类。</p><p>工厂方法有以下角色：</p><ul><li>抽象产品类。</li><li>具体产品类。</li><li>抽象工厂类：返回一个泛型的产品对象。</li><li>具体工厂类：返回具体的产品对象。</li></ul><h4 id="简单示例-1"><a href="#简单示例-1" class="headerlink" title="简单示例"></a>简单示例</h4><p>抽象产品类和具体产品类同简单工厂一样。</p><p>3、抽象工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ComputerFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Computer</span>&gt; T <span class="title function_">createComputer</span><span class="params">(Class&lt;T&gt; clz)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、具体工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GDComputerFactory</span> <span class="keyword">extends</span> <span class="title class_">ComputerFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Computer</span>&gt; T <span class="title function_">createComputer</span><span class="params">(Class&lt;T&gt; clz)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">classname</span> <span class="operator">=</span> clz.getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            computer = (Computer) Class.forName(classname).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>相比简单工厂，如果我们需要新增产品类，无需修改工厂类，直接创建产品即可。</li></ul><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p>建造者有以下角色：</p><ul><li>导演类：负责安排已有模块的安装顺序，最后通知建造者开始建造。</li><li>建造者：抽象Builder类，用于规范产品的组建。</li><li>具体建造者：实现抽象Builder类的所有方法，并返回建造好的对象。</li><li>产品类。</li></ul><h4 id="简单示例-2"><a href="#简单示例-2" class="headerlink" title="简单示例"></a>简单示例</h4><p>1、产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String mCpu;</span><br><span class="line">    <span class="keyword">private</span> Stiring mMainboard;</span><br><span class="line">    <span class="keyword">private</span> String mRam;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setmCpu</span><span class="params">(String mCpu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mCpu = mCpu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setmMainboard</span><span class="params">(String mMainboard)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mMainboard = mMainboard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setmRam</span><span class="params">(String mRam)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mRam = mRam;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、抽象建造者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildCpu</span><span class="params">(String cpu)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildMainboard</span><span class="params">(String mainboard)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildRam</span><span class="params">(String ram)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title function_">create</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、具体建造者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoonComputerBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Computer</span> <span class="variable">mComputer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildCpu</span><span class="params">(String cpu)</span> &#123;</span><br><span class="line">        mComputer.setmCpu(cpu);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMainboard</span><span class="params">(String mainboard)</span> &#123;</span><br><span class="line">        mComputer.setmMainboard(mainboard);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildRam</span><span class="params">(String ram)</span> &#123;</span><br><span class="line">        mComputer.setmRam(ram);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mComputer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、导演类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="type">Builder</span> <span class="variable">mBuilder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span> <span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mBuilder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">createComputer</span><span class="params">(String cpu, String mainboard, String ram)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mBuilder.buildCpu(cpu);</span><br><span class="line">        <span class="built_in">this</span>.mBuilder.buildMainboard(mainboard);</span><br><span class="line">        <span class="built_in">this</span>.mBuilder.buildRam(ram);</span><br><span class="line">        <span class="keyword">return</span> mBuilder.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>屏蔽产品内部组成细节。</li><li>具体建造者类之间相互独立，容易扩展。</li><li>会产生多余的建造者对象和导演类。</li></ul><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>为其它对象提供一种代理以控制这个对象的访问。</p><p>代理模式中有以下角色：</p><p>抽象主题类：声明真实主题和代理的共同接口方法。<br>真实主题类。<br>代理类：持有对真实主题类的引用。<br>客户端类。<br>静态代理示例代码<br>1、抽象主题类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IShop</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、真实主题类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonChao</span> <span class="keyword">implements</span> <span class="title class_">IShop</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Purchasing</span> <span class="keyword">implements</span> <span class="title class_">IShop</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IShop mShop;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Purchasing</span><span class="params">(IShop shop)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mShop = shop;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span> &#123;</span><br><span class="line">        mShop.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、客户端类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Clent</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IShop</span> <span class="variable">jsonChao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonChao</span>();</span><br><span class="line">        <span class="type">IShop</span> <span class="variable">purchasing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Purchasing</span>(jsonChao);</span><br><span class="line">        purchasing.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理<br>在代码运行时通过反射来动态地生成代理类的对象，并确定到底来代理谁。</p><p>动态代理示例代码</p><p>在java的java.lang.reflect包下面提供了一个Proxy类和一个InvocationHandler接口，通过这个类和接口可以生成JDK动态代理类和动态代理对象。<br>InvocationHandler接口是给动态代理类实现的，负责处理被代理对象的操作的，而proxy是用来创建动态代理类实例对象的，因为只有得到了这个对象我们才能调用哪些需要代理的方法。</p><p>改写静态代理的代理类和客户端类，如下所示：</p><p>1、动态代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicPurchasing</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicPurchasing</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Overrdie</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、客户端类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Clent</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IShop</span> <span class="variable">jsonChao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonChao</span>();</span><br><span class="line">        <span class="type">DynamicPurchasing</span> <span class="variable">mDynamicPurchasing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicPurchasing</span>(jsonChao);</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> jsonChao.getClass.getClassLoader();</span><br><span class="line">        <span class="type">IShop</span> <span class="variable">purchasing</span> <span class="operator">=</span> Proxy.newProxyInstance(cl, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;IShop.class&#125;, mDynamicPurchasing);</span><br><span class="line">        purchasing.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>真实主题类发生变化时，由于它实现了公用的接口，因此代理类不需要修改。</p><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>动态地给一个对象添加一些额外的职责。</p><p>装饰模式有以下角色：</p><p>抽象组件：接口/抽象类，被装饰的最原始的对象。<br>具体组件：被装饰的具体对象。<br>抽象装饰者：扩展抽象组件的功能。<br>具体装饰者：装饰者具体实现类。<br>示例代码<br>1、抽象组件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Swordsman</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">attackMagic</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>2、具体组件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YangGuo</span> <span class="keyword">extends</span> <span class="title class_">Swordsman</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attackMagic</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3、抽象装饰者</p><p>抽象装饰者必须持有抽象组件的引用，以便扩展功能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Master</span> <span class="keyword">extends</span> <span class="title class_">Swordsman</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Swordsman swordsman;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Master</span><span class="params">(Swordsman swordsman)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.swordman = swordman;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attackMagic</span><span class="params">()</span> &#123;</span><br><span class="line">        swordsman.attackMagic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>4、具体装饰者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HongQiGong</span> <span class="keyword">extends</span> <span class="title class_">Master</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HongQiGong</span><span class="params">(Swordsman swordsman)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.swordsman = swordsman;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teachAttackMagic</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attackMagic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.attackMagic();</span><br><span class="line">        teackAttackMagic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>5、使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">YangGuo</span> <span class="variable">mYangGuo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YangGuo</span>();</span><br><span class="line"><span class="type">HongQiGong</span> <span class="variable">mHongQiGong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HongQiGong</span>(mYangGuo);</span><br><span class="line">mHongQiGong.attackMagic(); </span><br></pre></td></tr></table></figure><br>使用组合，动态地扩展对象的功能，在运行时能够使用不同的装饰器实现不同的行为。<br>比继承更易出错，旨在必要时使用。</p><h3 id="外观模式（门面模式）"><a href="#外观模式（门面模式）" class="headerlink" title="外观模式（门面模式）"></a>外观模式（门面模式）</h3><p>一个子系统的内部和外部通信必须通过一个统一的对象进行。即提供一个高层的接口，方便子系统更易于使用。</p><p>外观模式有以下角色：</p><ul><li>外观类：将客户端的请求代理给适当的子系统对象。</li><li>子系统类：可以有一个或多个子系统，用于处理外观类指派的任务。注意子系统不含外观类的引用。</li></ul><h4 id="简单示例-3"><a href="#简单示例-3" class="headerlink" title="简单示例"></a>简单示例</h4><p>1、子系统类（这个有三个子系统）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZhaoShi</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TaiJiQuan</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">QiShanQuan</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ShengHuo</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NeiGong</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">JiuYang</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">QianKun</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JingMai</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">JingMai</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、外观类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZhangWuJi</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ZhaoShi zhaoShi;</span><br><span class="line">    <span class="keyword">private</span> JingMai jingMai;</span><br><span class="line">    pirvate Neigong neiGong;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ZhangWuJi</span><span class="params">()</span> &#123;</span><br><span class="line">        zhaoShi = <span class="keyword">new</span> <span class="title class_">ZhaoShi</span>();</span><br><span class="line">        jingMai = <span class="keyword">new</span> <span class="title class_">JingMai</span>();</span><br><span class="line">        neiGong = <span class="keyword">new</span> <span class="title class_">NeiGong</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">qianKun</span><span class="params">()</span> &#123;</span><br><span class="line">        jingMai.JingMai();</span><br><span class="line">        neiGong.QianKun();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">qiShang</span><span class="params">()</span> &#123;</span><br><span class="line">        jingMai.JingMai();</span><br><span class="line">        neiGong.JiuYang();</span><br><span class="line">        zhaoShi.QiShangQuan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ZhangWuJi</span> <span class="variable">zhangWuJi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZhangWuJi</span>();</span><br><span class="line">zhangWuJi.QianKun();</span><br><span class="line">zhangWuJi.QiShang();</span><br></pre></td></tr></table></figure><ul><li>将对子系统的依赖转换为对外观类的依赖。</li><li>对外部隐藏子系统的具体实现。</li><li>这种外观特性增强了安全性。</li></ul><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p>使用共享对象有效支持大量细粒度（性质相似）的对象。</p><p>额外的两个概念：</p><ul><li>1、内部状态：共享信息，不可改变。</li><li>2、外部状态：依赖标记，可以改变。</li></ul><p>享元模式有以下角色：</p><ul><li>抽象享元角色：定义对象内部和外部状态的接口。</li><li>具体享元角色：实现抽象享元角色的任务。</li><li>享元工厂：管理对象池及创建享元对象。</li></ul><h3 id="简单示例-4"><a href="#简单示例-4" class="headerlink" title="简单示例"></a>简单示例</h3><p>1、抽象享元角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGoods</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGoodsPrice</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、具体享元角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span> <span class="title class_">IGoods</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String price;</span><br><span class="line">    </span><br><span class="line">    Goods (String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGoodsPrice</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、享元工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Goods&gt; pool = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Goods&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Goods <span class="title function_">getGoods</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool.containsKey(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> pool.get(name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Goods</span>(name);</span><br><span class="line">            pool.put(name, goods);</span><br><span class="line">            <span class="keyword">return</span> goods;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Goods</span> <span class="variable">goods1</span> <span class="operator">=</span> GoodsFactory.getGoods(<span class="string">&quot;Android进阶之光&quot;</span>);</span><br><span class="line">goods1.showGoodsPrice(<span class="string">&quot;普通版&quot;</span>);</span><br><span class="line"><span class="type">Goods</span> <span class="variable">goods2</span> <span class="operator">=</span> GoodsFactory.getGoods(<span class="string">&quot;Android进阶之光&quot;</span>);</span><br><span class="line">goods1.showGoodsPrice(<span class="string">&quot;普通版&quot;</span>);</span><br><span class="line"><span class="type">Goods</span> <span class="variable">goods3</span> <span class="operator">=</span> GoodsFactory.getGoods(<span class="string">&quot;Android进阶之光&quot;</span>);</span><br><span class="line">goods1.showGoodsPrice(<span class="string">&quot;签名版&quot;</span>);</span><br></pre></td></tr></table></figure><p>goods1为新创建的对象，后面的都是从对象池中取出的缓存对象。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个接口转换为另一个需要的接口。</p><p>适配器有以下角色：</p><ul><li>要转换的接口。</li><li>要转换的接口的实现类。</li><li>转换后的接口。</li><li>转换后的接口的实现类。</li><li>适配器类。</li></ul><h4 id="简单示例-5"><a href="#简单示例-5" class="headerlink" title="简单示例"></a>简单示例</h4><p>1、要转换的接口（火鸡）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Turkey</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、要转换的接口的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WildTurkey</span> <span class="keyword">implements</span> <span class="title class_">Turkey</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、转换后的接口（鸭子）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、转换后的接口的实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MallardDuck</span> <span class="keyword">implements</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Overrdie</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、适配器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    Turkey turkey;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        turkey.gobble();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 火鸡没有鸭子飞的远，因此多飞几次，达到适配鸭子fly的作用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i;i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">            turkey.fly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WildTurkey</span> <span class="variable">wildTurkey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WildTurkey</span>();</span><br><span class="line"><span class="type">TurkeyAdapter</span> <span class="variable">turkeyAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TurkeyAdapter</span>(wildTurkey);</span><br><span class="line">turkeyAdapter.quack();</span><br><span class="line">turkeyAdapter.fly();</span><br></pre></td></tr></table></figure><ul><li>注重适度使用即可。</li></ul><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>定义了一套算法框架，将某些步骤交给子类去实现。使得子类不需改变框架结构即可重写算法中的某些步骤。</p><p>模板方法模式有以下角色：</p><ul><li>抽象类：定义了一套算法框架。</li><li>具体实现类。</li></ul><h4 id="简单示例-6"><a href="#简单示例-6" class="headerlink" title="简单示例"></a>简单示例</h4><p>1、抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSwordsman</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">fighting</span><span class="params">()</span> &#123;</span><br><span class="line">        neigong();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这个是具体方法</span></span><br><span class="line">        jingmai();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (hasWeapons()) &#123;</span><br><span class="line">            weapons();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        moves();</span><br><span class="line">        </span><br><span class="line">        hook();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">hook</span><span class="params">()</span> &#123; &#125;;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="keyword">abstract</span> <span class="title function_">neigong</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="keyword">abstract</span> <span class="title function_">weapons</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="keyword">abstract</span> <span class="title function_">moves</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jingmai</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">hasWeapons</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、具体实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZhangWuJi</span> <span class="keyword">extends</span> <span class="title class_">AbstractSwordsman</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">neigong</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">weapons</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 没有武器，不做处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moves</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasWeapons</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">punlc <span class="keyword">class</span> <span class="title class_">ZhangSanFeng</span> <span class="keyword">extends</span> <span class="title class_">AbstractSwordsman</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">neigong</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">weapons</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moves</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hook</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 额外处理</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ZhangWuJi</span> <span class="variable">zhangWuJi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZhangWuJi</span>();</span><br><span class="line">zhangWuJi.fighting();</span><br><span class="line"><span class="type">ZhangSanFeng</span> <span class="variable">zhangSanFeng</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZhangSanFeng</span>();</span><br><span class="line">zhangSanFeng.fighting();</span><br></pre></td></tr></table></figure><ul><li>可以使用hook方法实现子类对父类的反向控制。</li><li>可以把核心或固定的逻辑搬移到基类，其它细节交给子类实现。</li><li>每个不同的实现都需要定义一个子类，复用性小。</li></ul><h3 id="观察者模式（发布-订阅模式）"><a href="#观察者模式（发布-订阅模式）" class="headerlink" title="观察者模式（发布 - 订阅模式）"></a>观察者模式（发布 - 订阅模式）</h3><p>定义对象间的一种1对多的依赖关系，每当这个对象的状态改变时，其它的对象都会接收到通知并被自动更新。</p><p>观察者模式有以下角色：</p><ul><li>抽象被观察者：将所有已注册的观察者对象保存在一个集合中。</li><li>具体被观察者：当内部状态发生变化时，将会通知所有已注册的观察者。</li><li>抽象观察者：定义了一个更新接口，当被观察者状态改变时更新自己。</li><li>具体被观察者：实现抽象观察者的更新接口。</li></ul><h4 id="简单示例-7"><a href="#简单示例-7" class="headerlink" title="简单示例"></a>简单示例</h4><p>1、抽象观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">observer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、具体观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeXinUser</span> <span class="keyword">implements</span> <span class="title class_">observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeXinUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、抽象被观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">observable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWeXinUser</span><span class="params">(WeXinUser weXinUser)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeWeXinUser</span><span class="params">(WeXinUser weXinUser)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、具体被观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subscription</span> <span class="keyword">implements</span> <span class="title class_">observable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;WeXinUser&gt; mUserList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWeXinUser</span><span class="params">(WeXinUser weXinUser)</span> &#123;</span><br><span class="line">        mUserList.add(weXinUser);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeWeXinUser</span><span class="params">(WeXinUser weXinUser)</span> &#123;</span><br><span class="line">        mUserList.remove(weXinUser);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(WeXinUser weXinUser : mUserList) &#123;</span><br><span class="line">            weXinUser.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Subscription</span> <span class="variable">subscription</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subscription</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">WeXinUser</span> <span class="variable">hongYang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeXinUser</span>(<span class="string">&quot;HongYang&quot;</span>);</span><br><span class="line"><span class="type">WeXinUser</span> <span class="variable">rengYuGang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeXinUser</span>(<span class="string">&quot;RengYuGang&quot;</span>);</span><br><span class="line"><span class="type">WeXinUser</span> <span class="variable">liuWangShu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeXinUser</span>(<span class="string">&quot;LiuWangShu&quot;</span>);</span><br><span class="line"></span><br><span class="line">subscription.addWeiXinUser(hongYang);</span><br><span class="line">subscription.addWeiXinUser(rengYuGang);</span><br><span class="line">subscription.addWeiXinUser(liuWangShu);</span><br><span class="line">subscription.notify(<span class="string">&quot;New article coming&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>实现了观察者和被观察者之间的抽象耦合，容易扩展。</li><li>有利于建立一套触发机制。</li><li>一个被观察者卡顿，会影响整体的执行效率。采用异步机制可解决此类问题。</li></ul><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>定义：将一组算法封装到鞠具有共同接口的独立的类中。<br>类图：<br><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/201901161634245.png" alt="在这里插入图片描述"></p><p>（1）实现Strategy接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）实现AddStrategy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;和: &quot;</span>+(num1+num2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（3）实现SubStrategy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;减: &quot;</span>+(num1 - num2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（4）新建测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Strategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddStrategy</span>();</span><br><span class="line">strategy.calc(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">Strategy</span> <span class="variable">strategy2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubStrategy</span>();</span><br><span class="line">strategy2.calc(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="委托模式"><a href="#委托模式" class="headerlink" title="委托模式"></a>委托模式</h3><p>两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。<br>简单委托模式实现：<br>（1）新建RealPrinter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealPrinter</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;RealPrinter is run&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>（2）新建Printer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="type">RealPrinter</span> <span class="variable">realPrinter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealPrinter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">realPrinter.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>（3）新建Test类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Printer</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Printer</span>();</span><br><span class="line">printer.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件化基础"><a href="#组件化基础" class="headerlink" title="组件化基础"></a>组件化基础</h3><h4 id="认识组件化"><a href="#认识组件化" class="headerlink" title="认识组件化"></a>认识组件化</h4><p><strong>多module划分为业务和基础功能</strong></p><ul><li><strong>组件</strong>：指的是单一的功能组件，如视频组件（VideoSDK）、支付组件（PaySDK）、路由组件（Router）等，每个组件都能单独抽出来制作成SDK。</li><li><strong>模块</strong>: 指的是独立的业务模块，如直播模块（LiveModule）、首页模块（HomeModule）、即时通信模块（IMModule）等。模块相对于组件来说粒度更大，模块可能包含多种不同的组件。</li></ul><p><strong>组件化开发的好处：</strong></p><ul><li>避免重复造轮子，可以节省开发和维护的成本。</li><li>可以通过组件和模块为业务基准合理地安排人力，提高开发效率。</li><li>不同的项目可以共用一个组件或模块，确保整体技术方案的统一性。</li><li>为未来插件化共用同一套底层模型做准备。</li></ul><p><strong>模块化开发的好处：</strong></p><ul><li>业务模块的解耦，业务移植更加简单。</li><li>多团队根据业务内容进行并行开发和测试。</li><li>单个业务可以单独编译打包，加快编译速度。</li><li>多个App共用模块，降低了研发和维护成本。</li></ul><p><strong>两者的缺点：</strong></p><ul><li>旧项目重新适配组件化的开发需要相应的人力及时间成本。</li></ul><p><strong>两者的本质思想：</strong></p><ul><li>代码重用和业务解耦。</li></ul><p><strong>区别：</strong></p><ul><li>模块化是业务导向，组件化是功能导向。</li></ul><p>引申：</p><p>项目方法数超过65535个时的解决方案：</p><ul><li>MultiDex分包。</li><li>插件化。</li></ul><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>AS独有的三种依赖方式：</p><ul><li><p><strong>Jar dependency：</strong> 通过Gradle配置引入lib文件夹中的所有.jar后缀的文件，还能引用.aar后缀的文件。</p></li><li><p><strong>Base module：</strong> 对应的是module dependency，实质上是将其打包成aar文件，方便其他库进行依赖。</p></li><li><p><strong>Library dependency：</strong> 第三方依赖通过其完成仓库索引依赖，仓库包含网络仓库和本地库。</p><p>dependencies { compile fileTree（include：[‘*.jar’], dir: ‘libs’) compile project(‘:base’) annotationProcessor ‘com.alibaba:arouter-compiler:1.1.1’ }</p></li></ul><p>一般情况下，AS定义使用dependencies包含全部资源引入。</p><p><strong>注意：</strong></p><ul><li>读入自身目录使用的是fileTree。</li><li>读入其他资源module使用的是”project“字段，而”：base“中冒号的意思是文件目录内与自己相同层级的其他module。</li></ul><h4 id="聚合和解耦"><a href="#聚合和解耦" class="headerlink" title="聚合和解耦"></a>聚合和解耦</h4><ul><li>AS正是以依赖的方式给每个module之间提供了沟通和交流的渠道，从而形成聚合。</li><li>聚合和解耦是项目架构的基础。</li><li>组件化架构就是在文件层级上有效地控制沟通和个体独立性的做法。</li></ul><h4 id="重新认识AndroidManifest"><a href="#重新认识AndroidManifest" class="headerlink" title="重新认识AndroidManifest"></a>重新认识AndroidManifest</h4><p>问题：每个module都有一份配合的AndroidManifest文件来记载其信息，最终生成一个App的时候，其只有一份AndroidManifest来指导App应该如何配置，那么如何记录这么多个module独立的配置信息呢？</p><p><strong>答案：将多个AndroidManifest合成一个</strong></p><p>合成的生成地址目录为app/build/intermediates/manifest/full/debug/AndroidManifest.xml, intermediates文件夹包含的是App生成过程中产生的“中间文件”。</p><p><strong>AndroidManifest属性变更</strong></p><p><strong>1.注册Activity</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">application</span></span><br><span class="line">    android:<span class="built_in">name</span>=<span class="string">&quot;material.com.top.app.GankApplication&quot;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>name需要具体包名+属性名，这是因为AndroidManifest会引用多个module中的文件，需要知道具体路径，不然在编译期打包时会找不到每个文件的具体位置。</p><p><strong>2.注册Application</strong></p><p>如果功能module中有两个自定义Application，在解决冲突后，Application最终会载入后编译的module的Application。</p><p><strong>3.权限声明</strong></p><ul><li>如果在一个功能module中声明所需要的权限，那么在主module中就会看到相应的权限。</li><li>如果在其他module中都声明相同的权限，最终的AndroidManifest会合并这个重复声明的权限，所以相同的权限只会声明一次。</li><li>如果考虑最终权限有可能被遗漏的问题，可以将全部的权限都在Base module中声明，这样全部权限都是有的。</li></ul><p><strong>4.shareUid</strong></p><p>通过声明Shared User id，拥有同一个User id的多个App可以配置成运行在同一个进程中，所以默认可以互相访问任意数据。</p><p>问题：如果只是在功能module中声明shareUid，那么最终的AndroidManifest会如何呢？</p><p><strong>答案：只有在主module（Application module）中声明sharedUserId，才会最终打包到full AndroidManifest中。</strong></p><p><strong>注意：</strong></p><ul><li>每个module打包aar时都会将versionCode和versionName补全。</li></ul><h4 id="你所不知道的Application"><a href="#你所不知道的Application" class="headerlink" title="你所不知道的Application"></a>你所不知道的Application</h4><p><strong>Applicaiton的基础和作用</strong></p><p>Application是整个App的一个单例对象，并且其生命周期是最长的，相当于整个App的生命周期。</p><p>Application中比较重要的方法：</p><ul><li>onTerminate——当终止应用程序对象时调用，不保证一定被调用，当程序被内核终止以便为其他应用程序释放资源时将不会提醒，并且不调用应用程序对象的onTerminate方法而直接终止进程。</li><li>onLowMemory——当后台程序已经终止且资源还匮乏时会调用这个方法。好的应用程序会在此释放资源。</li></ul><p>Applicaiton提供的最好用的方法：</p><ul><li>registerActivityLifecycleCallbacks()和unregisterActivityLifecycleCallbacks()。</li></ul><p>作用：用于注册或注销对<strong>App内所有Activity的生命周期监听。</strong></p><p><strong>组件化Application</strong></p><p>如果Library项目中也定义了与主项目相同的属性（例如默认生成的android:icon 和android:theme)，则此时会合并失败。</p><p>解决方式：使用tools：replace=“android:name”来声明Application是可被替换的。</p><p>在full文件夹中的AndroidManifest查看最终编入的是哪个Application。</p><h3 id="Jetpack"><a href="#Jetpack" class="headerlink" title="Jetpack"></a>Jetpack</h3><p><a href="https://juejin.im/post/6844903768614518798">Android Jetpack组件</a></p><ul><li><a href="https://juejin.im/post/6844903768614518798">带你领略Android Jetpack组件的魅力</a></li><li><a href="https://juejin.im/post/6844903768618696711">Android Jetpack 架构组件之 Lifecycle（使用篇）</a></li><li><a href="https://juejin.im/post/6844903768618696718">Android Jetpack 架构组件之 Lifecycle（源码篇）</a></li><li><a href="https://juejin.im/post/6844903768618696712">Android Jetpack 架构组件之 ViewModel （源码篇）</a></li><li><a href="https://juejin.im/post/6844903768622891021">Android Jetpack 架构组件之 LiveData（使用、源码篇）</a></li><li><a href="https://juejin.im/post/6844903768622891016">Android Jetpack架构组件之 Paging（使用、源码篇）</a></li><li><a href="https://juejin.im/post/6844903768622891015">Android Jetpack 架构组件之 Room（使用、源码篇）</a></li><li><a href="https://juejin.im/post/6844903768627085325">Android Jetpack 架构组件之Navigation</a></li><li><a href="https://juejin.im/post/6844903768627249159">Android Jetpack架构组件之WorkManger</a></li><li><a href="https://juejin.im/post/6844903768631279624">实战：从0搭建Jetpack版的WanAndroid客户端</a></li></ul><h3 id="大鱼吃小鱼"><a href="#大鱼吃小鱼" class="headerlink" title="大鱼吃小鱼"></a>大鱼吃小鱼</h3><p>给一个整型数组,从左到右大的数字会把它右边第一个小的数字吃掉,给出最后稳定下来的结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] a(<span class="type">int</span>[] fishes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fishes == <span class="literal">null</span> || fishes.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,len = fishes.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; len &amp;&amp; fishes[j] &lt; fishes[i]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == len) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fishes[cnt + <span class="number">1</span>] = fishes[j];</span><br><span class="line">        cnt++;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOfRange(fishes,<span class="number">0</span>,cnt + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个线程安全同步队列，模拟多线程环境下的生产者消费者机制</span></span><br><span class="line"><span class="comment"> * 一个生产者线程通过 produce 方法向队列里产生元素</span></span><br><span class="line"><span class="comment"> * 一个消费者线程通过 consume 方法从队列里消费元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 元素类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncQueue1</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存队列元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ArrayList&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] obj = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> elements 生产出的元素列表，需要将该列表元素放入队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(List&lt;T&gt; elements)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;producing&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(list.isEmpty())&#123;</span><br><span class="line">                    list.addAll(elements);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(list.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 从队列中取出的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="keyword">if</span>(!list.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;comsuming&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(!list.isEmpty())&#123;</span><br><span class="line">                    List&lt;T&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">                    list.clear();</span><br><span class="line">                    System.out.println(ans.toString());</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javacourse.ch30;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncQueue2</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存队列元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ArrayList&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] obj = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> elements 生产出的元素列表，需要将该列表元素放入队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(List&lt;T&gt; elements)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;producing&quot;</span>);</span><br><span class="line">                list.addAll(elements);</span><br><span class="line">                System.out.println(elements.toString());</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 从队列中取出的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="keyword">if</span>(!list.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;comsuming&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(!list.isEmpty())&#123;</span><br><span class="line">                    List&lt;T&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">                    list.clear();</span><br><span class="line">                    System.out.println(ans.toString());</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也可以用阻塞队列实现</p><p>阻塞队列的特点：</p><ul><li>当队列元素已满的时候，阻塞插入操作</li><li>当队列元素为空的时候，阻塞获取操作</li></ul><p>不同的阻塞队列：</p><p>ArrayBlockingQueue 与 LinkedBlockingQueue 都是支持 FIFO (先进先出)，但是 LinkedBlockingQueue 是无界的，而ArrayBlockingQueue 是有界的。</p><p>演示</p><p>还是设置生产者生产速度大于消费者消费速度（通过 <code>sleep()</code> 方法实现）</p><p>缓冲区 <code>BlockQueueBufferArea.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockQueueBufferArea</span> &#123;</span><br><span class="line"></span><br><span class="line">    BlockingQueue&lt;Integer&gt; mProductPoll = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">put</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;产品池被放入了一个资源&quot;</span>);</span><br><span class="line">            mProductPoll.put(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;产品池被取走了一个资源&quot;</span>);</span><br><span class="line">            mProductPoll.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者 <code>Producer.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockQueueBufferArea mBufferArea;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockQueueBufferArea bufferArea)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mBufferArea = bufferArea;</span><br><span class="line">        setName(<span class="string">&quot;Producer_&quot;</span> + getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不断的生产资源</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            sleepSomeTime();</span><br><span class="line">            mBufferArea.put();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sleepSomeTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者 <code>Consumer.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockQueueBufferArea mBufferArea;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockQueueBufferArea bufferArea)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mBufferArea = bufferArea;</span><br><span class="line">        setName(<span class="string">&quot;Consumer_&quot;</span> + getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不断的取出资源</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            sleepSomeTime();</span><br><span class="line">            mBufferArea.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sleepSomeTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试 <code>Test.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BlockQueueBufferArea</span> <span class="variable">bufferArea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockQueueBufferArea</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(bufferArea);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(bufferArea);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(bufferArea);</span><br><span class="line"></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(bufferArea);</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(bufferArea);</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(bufferArea);</span><br><span class="line"></span><br><span class="line">        consumer1.start();</span><br><span class="line">        consumer2.start();</span><br><span class="line">        consumer3.start();</span><br><span class="line"></span><br><span class="line">        producer1.start();</span><br><span class="line">        producer2.start();</span><br><span class="line">        producer3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Producer_Thread-5产品池被放入了一个资源</span><br><span class="line">Producer_Thread-4产品池被放入了一个资源</span><br><span class="line">Producer_Thread-3产品池被放入了一个资源</span><br><span class="line">Producer_Thread-3产品池被放入了一个资源</span><br><span class="line">Producer_Thread-4产品池被放入了一个资源</span><br><span class="line">Producer_Thread-5产品池被放入了一个资源</span><br><span class="line">Producer_Thread-3产品池被放入了一个资源</span><br><span class="line">Producer_Thread-4产品池被放入了一个资源</span><br><span class="line">Producer_Thread-5产品池被放入了一个资源</span><br><span class="line">Producer_Thread-3产品池被放入了一个资源</span><br><span class="line">Producer_Thread-4产品池被放入了一个资源</span><br><span class="line">Producer_Thread-5产品池被放入了一个资源</span><br><span class="line">Producer_Thread-3产品池被放入了一个资源</span><br><span class="line">Consumer_Thread-0产品池被取走了一个资源</span><br><span class="line">Consumer_Thread-1产品池被取走了一个资源</span><br><span class="line">Consumer_Thread-2产品池被取走了一个资源</span><br><span class="line">Producer_Thread-4产品池被放入了一个资源</span><br><span class="line">Producer_Thread-5产品池被放入了一个资源</span><br><span class="line">Producer_Thread-3产品池被放入了一个资源</span><br></pre></td></tr></table></figure><h3 id="简述GC过程-object类的finalize-方法是如何影响GC的"><a href="#简述GC过程-object类的finalize-方法是如何影响GC的" class="headerlink" title="简述GC过程,object类的finalize()方法是如何影响GC的"></a>简述GC过程,object类的finalize()方法是如何影响GC的</h3><p><strong>基本预备相关知识</strong></p><p>1 java的GC只负责内存相关的清理，所有其它资源的清理必须由程序员手工完成。要不然会引起资源泄露，有可能导致程序崩溃。</p><p>2 调用GC并不保证GC实际执行。</p><p>3 finalize抛出的未捕获异常只会导致该对象的finalize执行退出。</p><p><strong>4 用户可以自己调用对象的finalize方法，但是这种调用是正常的方法调用，和对象的销毁过程无关。</strong></p><p>5 JVM保证在一个对象所占用的内存被回收之前，如果它实现了finalize方法，则该方法一定会被调用。Object的默认finalize什么都不做，为了效率，GC可以认为一个什么都不做的finalize不存在。</p><p>6 对象的finalize调用链和clone调用链一样，必须手工构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;  </span><br><span class="line">    <span class="built_in">super</span>.finalize();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="finalize的作用"><a href="#finalize的作用" class="headerlink" title="finalize的作用"></a>finalize的作用</h4><ul><li>finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。</li><li>finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性</li><li>不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：① 清理本地对象(通过JNI创建的对象)；② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。其原因可见下文[finalize的问题]</li><li>当对象不再被任何对象引用时，GC会调用该对象的finalize()方法</li><li>可以在finalize()让这个对象再次被引用，避免被GC回收；但是最常用的目的还是做cleanup</li><li>Java不保证这个finalize()一定被执行；但是保证调用finalize的线程没有持有任何user-visible同步锁。</li><li>在finalize里面抛出的异常会被忽略，同时方法终止。</li><li>当finalize被调用之后，JVM会再一次检测这个对象是否能被存活的线程访问得到，如果不是，则清除该对象。也就是finalize只能被调用一次；也就是说，覆盖了finalize方法的对象需要经过两个GC周期才能被清除。</li></ul><h4 id="finalize的问题"><a href="#finalize的问题" class="headerlink" title="finalize的问题"></a>finalize的问题</h4><ul><li>一些与finalize相关的方法，由于一些致命的缺陷，已经被废弃了，如System.runFinalizersOnExit()方法、Runtime.runFinalizersOnExit()方法</li><li>System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们</li><li>Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行</li><li>finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行</li><li>对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的</li><li>finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为)</li></ul><p><strong>对象的销毁过程</strong></p><p>在对象的销毁过程中，按照对象的finalize的执行情况，可以分为以下几种，系统会记录对象的对应状态：<br>unfinalized 没有执行finalize，系统也不准备执行。<br>finalizable 可以执行finalize了，系统会在随后的某个时间执行finalize。<br>finalized 该对象的finalize已经被执行了。</p><p>GC怎么来保持对finalizable的对象的追踪呢。GC有一个Queue，叫做F-Queue，所有对象在变为finalizable的时候会加入到该Queue，然后等待GC执行它的finalize方法。</p><p>这时我们引入了对对象的另外一种记录分类，系统可以检查到一个对象属于哪一种。<br>reachable 从活动的对象引用链可以到达的对象。包括所有线程当前栈的局部变量，所有的静态变量等等。<br>finalizer-reachable 除了reachable外，从F-Queue可以通过引用到达的对象。<br>unreachable 其它的对象。</p><p>具体的finalize流程：</p><p>对象可由两种状态，涉及到两类状态空间，一是终结状态空间 F = {unfinalized, finalizable, finalized}；二是可达状态空间 R = {reachable, finalizer-reachable, unreachable}。各状态含义如下：</p><ul><li>unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的</li><li>finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行</li><li>finalized: 表示GC已经对该对象执行过finalize方法</li><li>reachable: 表示GC Roots引用可达</li><li>finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达</li><li>unreachable：对象不可通过上面两种途径可达</li></ul><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/20131006163937765" alt="img"></p><p>变迁说明：</p><ol><li>新建对象首先处于[reachable, unfinalized]状态(A)</li><li>随着程序的运行，一些引用关系会消失，导致状态变迁，从reachable状态变迁到f-reachable(B, C, D)或unreachable(E, F)状态</li><li>若JVM检测到处于unfinalized状态的对象变成f-reachable或unreachable，JVM会将其标记为finalizable状态(G,H)。若对象原处于[unreachable, unfinalized]状态，则同时将其标记为f-reachable(H)。</li><li>在某个时刻，JVM取出某个finalizable对象，将其标记为finalized并在某个线程中执行其finalize方法。由于是在活动线程中引用了该对象，该对象将变迁到(reachable, finalized)状态(K或J)。该动作将影响某些其他对象从f-reachable状态重新回到reachable状态(L, M, N)</li><li>处于finalizable状态的对象不能同时是unreahable的，由第4点可知，将对象finalizable对象标记为finalized时会由某个线程执行该对象的finalize方法，致使其变成reachable。这也是图中只有八个状态点的原因</li><li>程序员手动调用finalize方法并不会影响到上述内部标记的变化，因此JVM只会至多调用finalize一次，即使该对象“复活”也是如此。程序员手动调用多少次不影响JVM的行为</li><li>若JVM检测到finalized状态的对象变成unreachable，回收其内存(I)</li><li>若对象并未覆盖finalize方法，JVM会进行优化，直接回收对象（O）</li><li>注：System.runFinalizersOnExit()等方法可以使对象即使处于reachable状态，JVM仍对其执行finalize方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Leetcode.coding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">GC</span> <span class="variable">SAVE_HOOK</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 新建对象，因为SAVE_HOOK指向这个对象，对象此时的状态是(reachable,unfinalized)</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> <span class="title class_">GC</span>();</span><br><span class="line">        <span class="comment">//将SAVE_HOOK设置成null，此时刚才创建的对象就不可达了，因为没有句柄再指向它了，对象此时状态是(unreachable，unfinalized)</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//强制系统执行垃圾回收，系统发现刚才创建的对象处于unreachable状态，并检测到这个对象的类覆盖了finalize方法，因此把这个对象放入F-Queue队列，由低优先级线程执行它的finalize方法，此时对象的状态变成(unreachable, finalizable)或者是(finalizer-reachable,finalizable)</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// sleep，目的是给低优先级线程从F-Queue队列取出对象并执行其finalize方法提供机会。在执行完对象的finalize方法中的super.finalize()时，对象的状态变成(unreachable,finalized)状态，但接下来在finalize方法中又执行了SAVE_HOOK = this;这句话，又有句柄指向这个对象了，对象又可达了。因此对象的状态又变成了(reachable, finalized)状态。</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">// 这里楼主说对象处于(reachable,finalized)状态应该是合理的。对象的finalized方法被执行了，因此是finalized状态。又因为在finalize方法是执行了SAVE_HOOK=this这句话，本来是unreachable的对象，又变成reachable了。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != SAVE_HOOK) &#123; <span class="comment">//此时对象应该处于(reachable, finalized)状态</span></span><br><span class="line">            <span class="comment">// 这句话会输出，注意对象由unreachable，经过finalize复活了。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Yes , I am still alive&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No , I am dead&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再一次将SAVE_HOOK放空，此时刚才复活的对象，状态变成(unreachable,finalized)</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 再一次强制系统回收垃圾，此时系统发现对象不可达，虽然覆盖了finalize方法，但已经执行过了，因此直接回收。</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 为系统回收垃圾提供机会</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != SAVE_HOOK) &#123;</span><br><span class="line">            <span class="comment">// 这句话不会输出，因为对象已经彻底消失了。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Yes , I am still alive&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No , I am dead&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;execute method finalize()&quot;</span>);</span><br><span class="line">        <span class="comment">// 这句话让对象的状态由unreachable变成reachable，就是对象复活</span></span><br><span class="line">        SAVE_HOOK = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出如下：</span></span><br><span class="line"><span class="comment">//execute method finalize()</span></span><br><span class="line"><span class="comment">//Yes , I am still alive</span></span><br><span class="line"><span class="comment">//No , I am dead</span></span><br></pre></td></tr></table></figure><h3 id="给定一个有序的整型数组和一个数c-从里面选定两个数x、y-使得x-y-lt-c且x-y尽可能的大"><a href="#给定一个有序的整型数组和一个数c-从里面选定两个数x、y-使得x-y-lt-c且x-y尽可能的大" class="headerlink" title="给定一个有序的整型数组和一个数c,从里面选定两个数x、y,使得x+y&lt;=c且x+y尽可能的大"></a>给定一个有序的整型数组和一个数c,从里面选定两个数x、y,使得x+y&lt;=c且x+y尽可能的大</h3><p>先用二分法找到小于等于c的最大位置，接着按两数之和做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] b(<span class="type">int</span>[] nums, <span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> binarySearch(nums,y,nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt;= index ; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> nums[index] + nums[index - <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">minVal</span> <span class="operator">=</span> nums[i] + nums[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (maxVal &lt; y) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minVal &gt; y) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> y - nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> binarySearch(nums,rest,index);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[idx];</span><br><span class="line">            <span class="keyword">if</span> (sum == y) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,idx&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; max) &#123;</span><br><span class="line">                max = sum;</span><br><span class="line">                ans[<span class="number">0</span>] = i;</span><br><span class="line">                ans[<span class="number">1</span>] = idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> y,<span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> , right = end;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == y) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; y) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left] &lt; y ? left : findLast(nums,left,y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findLast</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; -<span class="number">1</span> &amp;&amp; nums[i] &gt; y) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="anr异常、oom异常、UI卡顿"><a href="#anr异常、oom异常、UI卡顿" class="headerlink" title="anr异常、oom异常、UI卡顿"></a>anr异常、oom异常、UI卡顿</h3><h4 id="ANR-Application-Not-Responding"><a href="#ANR-Application-Not-Responding" class="headerlink" title="ANR(Application Not Responding)"></a>ANR(Application Not Responding)</h4><p>ANR定义: 在Android上,如果你的应用程序有一段时间内响应不够灵敏,系统会向用户显示一个对话框,这个对话框称作为应用程序无响应(ANR: Application Not Responding)对话框.用户可以选择”等待”而让程序继续运行,也可以选择”强制关闭”.所以一个流畅的合理的应用程序中不能出现ANR,而让用户每次都要处理这个对话框.因此,在程序里对响应性能的设计很重要,这样系统不会显示ANR给用户.</p><p>默认情况下,在Android中Activity的最长执行时间是5秒,BroadcastReceiver的最长执行时间则是10秒.</p><p>在Android里，应用程序的响应性是由Activity Manager和WindowManager系统服务监视的 。当它监测到以下情况中的一个时，Android就会针对特定的应用程序显示ANR：</p><ol><li>在5秒内没有响应输入的事件（例如，按键按下，屏幕触摸）</li><li>BroadcastReceiver在10秒内没有执行完毕</li></ol><p>造成以上两点的原因有很多，比如在主线程中做了非常耗时的操作，比如说是下载，io异常等。</p><p>潜在的耗时操作，例如网络或数据库操作，或者高耗时的计算如改变位图尺寸，应该在子线程里（或者以数据库操作为例，通过异步请求的方式）来完成。而不是说你的主线程阻塞在那里等待子线程的完成——也不是调用 Thread.wait()或是Thread.sleep()。替代的方法是，主线程应该为子线程提供一个Handler，以便完成时能够提交给主线程。以这种方式设计你的应用程序，将能保证你的主线程保持对输入的响应性并能避免由于5秒输入事件的超时引发的ANR对话框。</p><p>造成原因</p><p>a)主线程被IO操作(从4.0之后网络IO不允许在主线程中)阻塞。</p><p>b)主线程中存在耗时的计算。</p><p>c)哪些操作是在主线程：</p><p>Activity的所有生命周期回调都是执行在主线程的；</p><p>Service默认是执行在主线程的；</p><p>BroadcastReceiver的onReceive回掉是执行在主线程的；</p><p>没有使用子线程的looper的Hander的handleMessage，post(Runnable)是执行在主线程的；</p><p>3 如何解决</p><ol><li>运行在主线程里的任何方法都尽可能少做事情。特别是，Activity应该在它的关键生命周期方法（如onCreate()和onResume()）里尽可能少的去做创建操作。（可以采用重新开启子线程的方式，然后使用Handler+Message的方式做一些操作，比如更新主线程中的ui等）</li><li>应用程序应该避免在BroadcastReceiver里做耗时的操作或计算。但不再是在子线程里做这些任务（因为 BroadcastReceiver的生命周期短），替代的是，如果响应Intent广播需要执行一个耗时的动作的话，应用程序应该启动一个 Service。（此处需要注意的是可以在BroadcastReceiver中启动Service，但是却不可以在Service中启动BroadcastReceiver）</li><li>避免在Intent Receiver里启动一个Activity，因为它会创建一个新的画面，并从当前用户正在运行的程序上抢夺焦点。如果你的应用程序在响应Intent广播时需要向用户展示什么，你应该使用Notification Manager来实现。</li><li>使用Thread或者HandlerThread提高优先级。</li></ol><h4 id="OOM-Out-Of-Memory"><a href="#OOM-Out-Of-Memory" class="headerlink" title="OOM(Out Of Memory)"></a>OOM(Out Of Memory)</h4><p>当前占用的内存加上我们申请的内存资源超过了Dalvik虚拟机的最大内存限制就会跑出的Out of memory异常。即：</p><p>一、加载对象过大</p><p>二、相应资源过多，没有来不及释放。</p><p>容易混淆的</p><p>a)内存溢出：oom。</p><p>b)内存抖动：短时间内大量的对象被创建，然后被马上释放。瞬间产生的对象会严重占用内存区。</p><p>c)内存泄露：进程中的某些内容没有被其他引用到了，但会直接或间接引用到（其他还没有被回收的对象），导致GC无法回收。</p><p>3 如何解决</p><ol><li><p>在内存引用上做些处理，常用的有软引用、强化引用、弱引用</p></li><li><p>在内存中加载图片时直接在内存中做处理，如：边界压缩.</p></li><li><p>优化Dalvik虚拟机的堆内存分配</p><p>对于Android平台来说，其托管层使用的Dalvik JavaVM从目前的表现来看还有很多地方可以优化处理，比如我们在开发一些大型游戏或耗资源的应用中可能考虑手动干涉GC处理，使用dalvik.system.VMRuntime类提供的setTargetHeapUtilization方法可以增强程序堆内存的处理效率。当然具体原理我们可以参考开源工程，这里我们仅说下使用方法: private final static floatTARGET_HEAP_UTILIZATION = 0.75f; 在程序onCreate时就可以调用VMRuntime.getRuntime().setTargetHeapUtilization(TARGET_HEAP_UTILIZATION);即可。　</p></li><li><p>自定义堆内存大小</p><p>对于一些Android项目，影响性能瓶颈的主要是Android自己内存管理机制问题，目前手机厂商对RAM都比较吝啬，对于软件的流畅性来说RAM对性能的影响十分敏感，除了 优化Dalvik虚拟机的堆内存分配外，我们还可以强制定义自己软件的对内存大小，我们使用Dalvik提供的dalvik.system.VMRuntime类来设置最小堆内存为例:</p><p>private final static int CWJ_HEAP_SIZE = 6<em> 1024</em> 1024 ;<br>　　VMRuntime.getRuntime().setMinimumHeapSize(CWJ_HEAP_SIZE); //设置最小heap内存为6MB大小。当然对于内存吃紧来说还可以通过手动干涉GC去处理</p><p>注意了，这个设置dalvik虚拟机的配置的方法对Android4.0 设置无效。</p></li><li><p>动态内存管理</p></li><li><p>bitmap显示缩略图，不要网络请求去加载大图;</p><p>ListView监听滑动事件，在滑动的时候不去调用网络请求;</p><p>及时释放内存;</p><p>图片压缩,<a href="http://blog.csdn.net/harryweasley/article/details/51955467">http://blog.csdn.net/harryweasley/article/details/51955467</a></p><p>inBitmap属性,提高安卓系统在Bitmap分配和释放的执行效率;</p><p><a href="http://www.cnblogs.com/punkisnotdead/p/4881771.html">http://www.cnblogs.com/punkisnotdead/p/4881771.html</a>.</p></li><li><p>避免在onDraw方法里执行对象的创建;</p></li><li><p>谨慎使用多进程;</p></li></ol><h4 id="UI卡顿"><a href="#UI卡顿" class="headerlink" title="UI卡顿"></a>UI卡顿</h4><p>1 原理</p><p>a)60fps ———&gt; 16ms</p><p>b)overdraw 过度绘制，一针绘制好多次。</p><p>* 手机GPU选项，减少红色，尽量出现蓝色;</p><p>* UI布局中有大量重叠的部分，还有一些非必要重叠部分，比如：布局文件layout有背景，里面的布局文件也有自己的背景，这时候，仅仅移除非必须的背景图片，就能减少红色焦区;</p><p>2 原因分析</p><p>a)人为在UI线程中做轻微耗时操作，导致UI线程卡顿；</p><p>b)布局Layout过于复杂，无法在16ms内完成渲染；</p><p>c)统一时间动画执行次数过多，导致CPU或GPU负载过重；</p><p>d)View过度绘制，导致某些像素在同一帧时间内被绘制多次，从而使CPU或GPU负载过重；</p><p>e)View频繁的触发measure、layout，导致measure、layout累计耗时过多，及整个View频繁的重新渲染；</p><p>f)内存频繁触发GC过多，导致暂时阻塞渲染操作；</p><p>g)沉余资源及逻辑等导致加载和执行缓慢；</p><p>h)ANR;</p><p>3 总结</p><p>a)布局优化.</p><p>b)列表及Adapter优化.</p><p>c)背景和图片等内存分配优化.</p><p>d)避免ANR.卡顿、死锁性能优化</p><h3 id="bitmap优化"><a href="#bitmap优化" class="headerlink" title="bitmap优化"></a>bitmap优化</h3><ol><li>recycle 回收；</li><li><p>LRU(Least Recently Used)缓存：当缓存满时，优先淘汰即删除近期最少使用的缓存对象。</p></li><li><p>计算inSampleSize：是调整Bitmap压缩比例的，该值必须&gt;=1，比如inSampleSize = 2，那么Bitmap的宽和高都变为原来的1/2。</p></li><li><p>缩略图。</p></li><li><p>三级缓存：网络、本地、内存。</p></li><li><p>Bitmap.compress方法压缩图片：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">quality</span> <span class="operator">=</span> Integer.valueOf(editText.getText().toString());</span><br><span class="line">bit.compress(CompressFormat.JPEG, quality, baos);</span><br><span class="line"><span class="type">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">bm = BitmapFactory.decodeByteArray(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">Log.i(<span class="string">&quot;wechat&quot;</span>, <span class="string">&quot;压缩后图片的大小&quot;</span> + (bm.getByteCount() / <span class="number">1024</span> / <span class="number">1024</span>)</span><br><span class="line">        + <span class="string">&quot;M宽度为&quot;</span> + bm.getWidth() + <span class="string">&quot;高度为&quot;</span> + bm.getHeight()</span><br><span class="line">        + <span class="string">&quot;bytes.length=  &quot;</span> + (bytes.length / <span class="number">1024</span>) + <span class="string">&quot;KB&quot;</span></span><br><span class="line">        + <span class="string">&quot;quality=&quot;</span> + quality);</span><br></pre></td></tr></table></figure><ol><li>采样率压缩</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.<span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapFactory</span>.Options();</span><br><span class="line">            options.inSampleSize = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            bm = BitmapFactory.decodeFile(Environment</span><br><span class="line">                    .getExternalStorageDirectory().getAbsolutePath()</span><br><span class="line">                    + <span class="string">&quot;/DCIM/Camera/test.jpg&quot;</span>, options);</span><br><span class="line">            Log.i(<span class="string">&quot;wechat&quot;</span>, <span class="string">&quot;压缩后图片的大小&quot;</span> + (bm.getByteCount() / <span class="number">1024</span> / <span class="number">1024</span>)</span><br><span class="line">                    + <span class="string">&quot;M宽度为&quot;</span> + bm.getWidth() + <span class="string">&quot;高度为&quot;</span> + bm.getHeight());</span><br></pre></td></tr></table></figure><p>设置inSampleSize的值(int类型)后，假如设为2，则宽和高都为原来的1/2，宽高都减少了，自然内存也降低了。</p><p>我上面的代码没用过options.inJustDecodeBounds = true; 因为我是固定来取样的数据，为什么这个压缩方法叫采样率压缩，是因为配合inJustDecodeBounds，先获取图片的宽、高【这个过程就是取样】，然后通过获取的宽高，动态的设置inSampleSize的值。</p><p>当inJustDecodeBounds设置为true的时候，BitmapFactory通过decodeResource或者decodeFile解码图片时，将会返回空(null)的Bitmap对象，这样可以避免Bitmap的内存分配，但是它可以返回Bitmap的宽度、高度以及MimeType。</p><ol><li><p>Matrix缩放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Matrix</span> <span class="variable">matrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line">            matrix.setScale(<span class="number">0.5f</span>, <span class="number">0.5f</span>);</span><br><span class="line">            bm = Bitmap.createBitmap(bit, <span class="number">0</span>, <span class="number">0</span>, bit.getWidth(),</span><br><span class="line">                    bit.getHeight(), matrix, <span class="literal">true</span>);</span><br><span class="line">            Log.i(<span class="string">&quot;wechat&quot;</span>, <span class="string">&quot;压缩后图片的大小&quot;</span> + (bm.getByteCount() / <span class="number">1024</span> / <span class="number">1024</span>)</span><br><span class="line">                    + <span class="string">&quot;M宽度为&quot;</span> + bm.getWidth() + <span class="string">&quot;高度为&quot;</span> + bm.getHeight());</span><br></pre></td></tr></table></figure></li><li><p>RGB565</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.<span class="type">Options</span> <span class="variable">options2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapFactory</span>.Options();</span><br><span class="line">            options2.inPreferredConfig = Bitmap.Config.RGB_565;</span><br><span class="line"></span><br><span class="line">            bm = BitmapFactory.decodeFile(Environment</span><br><span class="line">                    .getExternalStorageDirectory().getAbsolutePath()</span><br><span class="line">                    + <span class="string">&quot;/DCIM/Camera/test.jpg&quot;</span>, options2);</span><br><span class="line">            Log.i(<span class="string">&quot;wechat&quot;</span>, <span class="string">&quot;压缩后图片的大小&quot;</span> + (bm.getByteCount() / <span class="number">1024</span> / <span class="number">1024</span>)</span><br><span class="line">                    + <span class="string">&quot;M宽度为&quot;</span> + bm.getWidth() + <span class="string">&quot;高度为&quot;</span> + bm.getHeight());</span><br></pre></td></tr></table></figure></li><li><p>createScaledBitmap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bm = Bitmap.createScaledBitmap(bit, <span class="number">150</span>, <span class="number">150</span>, <span class="literal">true</span>);</span><br><span class="line">            Log.i(<span class="string">&quot;wechat&quot;</span>, <span class="string">&quot;压缩后图片的大小&quot;</span> + (bm.getByteCount() / <span class="number">1024</span>) + <span class="string">&quot;KB宽度为&quot;</span></span><br><span class="line">                    + bm.getWidth() + <span class="string">&quot;高度为&quot;</span> + bm.getHeight());</span><br></pre></td></tr></table></figure></li><li><p>options.inJustDecodeBounds = true 表示只读图片，不加载到内存中，设置这个参数为ture，就不会给图片分配内存空间，但是可以获取到图片的大小等属性; 设置为false, 就是要加载这个图片.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title function_">decodeSampledBitmapFromResource</span><span class="params">(Resources res, <span class="type">int</span> resId, <span class="type">int</span> reqWidth, <span class="type">int</span> reqHeight)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先把inJustDecodeBounds设置为true 取得原始图片的属性</span></span><br><span class="line">        <span class="keyword">final</span> BitmapFactory.<span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapFactory</span>.Options();</span><br><span class="line">        options.inJustDecodeBounds = <span class="literal">true</span>;</span><br><span class="line">        BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后算一下我们想要的最终的属性</span></span><br><span class="line">        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在decode的时候 别忘记直接 把这个属性改为false 否则decode出来的是null</span></span><br><span class="line">        options.inJustDecodeBounds = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>读bitmap<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title function_">readBitMap</span><span class="params">(Context context, <span class="type">int</span> resId)</span>&#123; </span><br><span class="line">    BitmapFactory.<span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapFactory</span>.Options(); </span><br><span class="line">    opt.inPreferredConfig = Bitmap.Config.RGB_565; </span><br><span class="line">    opt.inPurgeable = <span class="literal">true</span>; </span><br><span class="line">    opt.inInputShareable = <span class="literal">true</span>; </span><br><span class="line">    <span class="comment">//获取资源图片 </span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> context.getResources().openRawResource(resId); </span><br><span class="line">    <span class="keyword">return</span> BitmapFactory.decodeStream(is,<span class="literal">null</span>,opt); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a href="https://blog.csdn.net/zanelove/article/details/44278783">https://blog.csdn.net/zanelove/article/details/44278783</a></li></ol><h3 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h3><p>JNI是Java Native Interface的缩写，它提供了若干的<a href="https://baike.baidu.com/item/API/10154">API</a>实现了Java和其他语言的通信（主要是<a href="https://baike.baidu.com/item/C/7252092">C</a>&amp;<a href="https://baike.baidu.com/item/C%2B%2B">C++</a>）.这是百度百科上说的.通俗来说,就是JAVA调用C/C++函数的接口.如果你要想调用C系列的函数,你就必须遵守这样的约定.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">NativeDemo</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 系统加载其他的语言的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.load(<span class="string">&quot;C:\\Users\\Administrator\\Desktop\\com\\Hello.dll&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 就这个natice关键字.标记了这个接口,看起来像是abstract</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">NativeDemo</span>().sayHello();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wait方法和notify的区别"><a href="#wait方法和notify的区别" class="headerlink" title="wait方法和notify的区别"></a>wait方法和notify的区别</h3><p>调用sleep方法可以让当前正在运行的线程进入睡眠状态，即暂时停止运行指定的单位时间。并且该线程在睡眠期间不会释放对象锁。<br>sleep方法的目的是让当前线程暂停运行一段时间，而与对象锁相关的信息无影响，如果执行sleep方法时是处于持有对象锁的状态，那么睡眠时依然持有对象锁，如果执行sleep方法时不是处于持有对象锁的状态，睡眠期间也不会持有对象锁。</p><p>调用wait方法可以让当前线程（即调用object.wait方法的那个线程）进入等待唤醒状态，该线程会处于等待唤醒状态直到另一个线程调用了object对象的notify方法或者notifyAll方法。该方法没有形参，相当于调用了参数为0的wait（long timeout）方法。<br>同时，要调用wait方法，前提是获取了这个对象的锁。在调用wait方法时，线程会释放锁并进入等待状态。在被唤醒后，该线程会一直处于等待获取锁的状态直到它重新获取到锁，然后才可以重新恢复运行状态。<br>注释也强调了，该方法应该只在获取了对象的锁之后才去调用，即wait方法应该放在synchronized(obj){}块中，否则运行期间会抛出IllegalMonitorStateException异常。</p><p>举例来解释，比方说多线程下，object对象是共享对象，那么对object对象的操作可以放在synchronized(object)同步块中，当线程A在同步块中执行object.wait方法，线程A就进入了等待状态。这时在线程Q中的同步块中执行object.notify()，就能唤醒线程A。另一种情形，假如线程ABC都执行了object.wait方法，那么当线程Q中执行了object.notify()，则只能唤醒其中一个，至于具体是哪一个，是任意的。<br>调用notify唤醒的线程，处于等待获取锁状态，且这个被唤醒的线程，相对于其他在等待获取锁的线程，没有任何特权，也没有任何劣势，即公平竞争。<br>如注释中所描述，同步块，可以是对共享对象进行同步处理，也可以直接对实例方法进行同步处理，还可以对类进行同步处理。<br>如果，当前调用notify方法的线程没有获取对象锁，则将抛出IllegalMonitorStateException异常。</p><p>notifyAll方法与notify方法很类似，不同之处是notify方法唤醒任意一个线程而notifyAll方法唤醒的是所有线程。</p><p>wait方法和sleep方法的对比</p><ol><li>正如方法定义所描述，这两个方法都是native方法，且都会抛出InterruptedException，其中sleep方法是类方法，而wait方法是实例方法。</li><li>sleep方法是Thread类的方法，而wait方法是Object类的方法，由于一切类都是继承自Object类，因此Thread类中也有wait方法。</li><li>wait方法和sleep方法都可以通过interrupt方法打断线程的暂停状态，从而使得线程立刻抛出IntterruptedException。</li><li>sleep方法的作用是让当前线程暂停指定的时间，无关对象锁；而wait方法则是用于多个线程间的信息交互，与对象锁有关。</li><li>sleep方法是类方法，而锁是对象级别的。因此sleep方法并不影响锁的相关行为。因此如果在调用sleep方法时该线程是处理持有对象锁的状态，睡眠状态中仍然持有锁。而wait方法能安全使用的前提是获取了对象锁，wait方法之所以可以用于多个线程间的信息交流，正是它会释放对象锁。</li><li>这里引用知乎用户“孙立伟”的一段话：Thread.sleep和Object.wait都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。操作系统会将执行时间分配给其它线程。区别是，调用wait后，需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间。</li></ol><h4 id="为什么wait方法在Object对象中？"><a href="#为什么wait方法在Object对象中？" class="headerlink" title="为什么wait方法在Object对象中？"></a>为什么wait方法在Object对象中？</h4><p>简单说：因为synchronized中的这把锁可以是任意对象，所以任意对象都可以调用wait()和notify()；所以wait和notify属于Object。</p><p>专业说：因为这些方法在操作同步线程时，都必须要标识它们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的notify唤醒，不可以对不同锁中的线程进行唤醒。</p><p>也就是说，等待和唤醒必须是同一个锁。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在object类中。</p><h3 id="recyclerView的复用机制-和listView的区别"><a href="#recyclerView的复用机制-和listView的区别" class="headerlink" title="recyclerView的复用机制 和listView的区别"></a>recyclerView的复用机制 和listView的区别</h3><p>可直接参考<a href="https://juejin.im/post/6844903737522126862">掘金</a></p><p>ListView<br>        1.Adapter继承的是BaseAdapter。</p><pre><code>    2.可以直接在布局中设置分割线。    3.点击事件自带setOnItemClickListener方法    4.自带增加头部尾部方法   addHeaderView和addFooterView    5.ListView只有刷新所有数据的方法，局部刷新需自己定义    6.没有动画效果    7.缓存机制原理大致相同（缓存层级不同，获取缓存流程不同）</code></pre><p>RecyclerView<br>       1.Adapter继承的是RecyclerView.Adapter</p><pre><code>   2.不能在布局中直接设置分割线，可以自定义，在setAdapter之前添加分割线   3.RecyclerView提供addOnItemTouchListener监听item的触摸事件，通过addOnItemTouchListener加上Gesture Detector来实现item响应方法（也可以自定义方法进行处理）   4.RecyclerView需要借助Adapter实现头尾布局，通过设置ViewHolder不同的类型实现   5.RecyclerView可以调用notifyItemChanged实现局部刷新   6.RecyclerView自带动画效果，如果需要自定义动画可通过自定义RecyclerView.ItemAnimator类，然后调用setItemAnimator设置   7.缓存机制原理大致相同（缓存层级不同，获取缓存流程不同）</code></pre><p>RecyclerView 优化<br>   1.布局优化</p><pre><code>   减少层次结构、减少过渡绘制，可以提高item的解析测量与绘制的效率</code></pre><p>   2.关闭动画效果</p><pre><code>   如果不需要动画效果，可以取消RecyclerView的默认动画      mRecyclerView.setItemAnimator(null);</code></pre><p>   3.Item等高</p><pre><code> 把所有的 Item 的高度固定大小，这样可以减少测量次数，尤其是对于 GridLayoutManager。 mRecyclerView.setHasFixedSize(true);4.使用getExtraLayoutSpace为LayoutManager设置更多的预留空间 当item布局内容比较高，屏幕内只能展示一条item或者说一条显示都不全的时候，第一次滑动到第二个元素就会卡顿。 RecyclerView (以及其他基于adapter的view，比如ListView、GridView等)使用了缓存机制重用子 view（即系统只将屏幕可见范围之内的元素保存在内存中，在滚动的时候不断的重用这些内存中已经存在的view，而不是新建view）。 这个机制会导致一个问题，启动应用之后，在屏幕可见范围内，如果只有一张卡片可见，当滚动的时 候，RecyclerView找不到可以重用的view了，它将创建一个新的，因此在滑动到第二个feed的时候就会有一定的延时，但是第二个feed之 后的滚动是流畅的，因为这个时候RecyclerView已经有能重用的view了。</code></pre><p>   如何解决这个问题呢，其实只需重写getExtraLayoutSpace()方法。根据官方文档的描述 getExtraLayoutSpace将返回LayoutManager应该预留的额外空间（显示范围之外，应该额外缓存的空间）。</p><p>   5.RecycledViewPool</p><p>  当多个RecyclerView有相同的item布局结构时，多个RecyclerView共用一个RecycledViewPool可以避免创建ViewHolder的开销，避免GC。RecycledViewPool对象可通过RecyclerView对象获取，也可以自己实现。</p><p> 6.避免创建过多对象</p><p>   onCreateViewHolder 和 onBindViewHolder 对时间都比较敏感，尽量避免繁琐的操作和循环创建对象。例如创建 OnClickListener，可以全局创建一个，然后数据通过 itemView.setTag 携带。</p><p>  7.局部刷新</p><p>   可以用一下一些方法，替代notifyDataSetChanged，已达到局部刷新的目的。</p><p>notifyItemChanged(int position)</p><p>notifyItemInserted(int position)</p><p>notifyItemRemoved(int position)</p><p>notifyItemMoved(int fromPosition, int toPosition)</p><p>notifyItemRangeChanged(int positionStart, int itemCount)</p><p>notifyItemRangeInserted(int positionStart, int itemCount)</p><p>notifyItemRangeRemoved(int positionStart, int itemCount)</p><p>如果必须用 notifyDataSetChanged()，那么最好设置 mAdapter.setHasStableIds(true)</p><p>  8.重写onSroll事件</p><p>   对于大量图片的RecyclerView，滑动暂停后再加载；RecyclerView中存在几种绘制复杂，占用内存高的楼层类型，但是用户只是快速滑动到底部，并没有必要绘制计算这几种复杂类型，所以也可以考虑对滑动速度，滑动状态进行判断，满足条件后再加载这几种复杂的。</p><h3 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h3><p>RecyclerView 基础使用关键点同样有两点：</p><p>继承重写 RecyclerView.Adapter 和 RecyclerView.ViewHolder<br>设置布局管理器，控制布局效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步：继承重写 RecyclerView.Adapter 和 RecyclerView.ViewHolder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorRecyclerAdapter</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.Adapter&lt;AuthorRecyclerAdapter.AuthorViewHolder&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AuthorViewHolder <span class="title function_">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="type">int</span> viewType)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> viewHolder;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(AuthorViewHolder holder, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mData == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mData.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AuthorViewHolder</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.ViewHolder &#123;</span><br><span class="line"> </span><br><span class="line">        ...</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AuthorViewHolder</span><span class="params">(View itemView)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(itemView);</span><br><span class="line">            ...</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">mRecyclerView = (RecyclerView) findViewById(R.id.recycler_view);</span><br><span class="line">mRecyclerAdapter = <span class="keyword">new</span> <span class="title class_">AuthorRecyclerAdapter</span>(mData);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第二步：设置布局管理器，控制布局效果</span></span><br><span class="line"><span class="type">LinearLayoutManager</span> <span class="variable">linearLayoutManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinearLayoutManager</span>(RecyclerDemoActivity.<span class="built_in">this</span>);</span><br><span class="line">linearLayoutManager.setOrientation(LinearLayoutManager.VERTICAL);</span><br><span class="line">mRecyclerView.setLayoutManager(linearLayoutManager);</span><br><span class="line"> </span><br><span class="line">mRecyclerView.setAdapter(mRecyclerAdapter);</span><br></pre></td></tr></table></figure><p>在最开始就提到，RecyclerView 能够支持各种各样的布局效果，这是 ListView 所不具有的功能，那么这个功能如何实现的呢？其核心关键在于 RecyclerView.LayoutManager 类中。从前面的基础使用可以看到，RecyclerView 在使用过程中要比 ListView 多一个 setLayoutManager 步骤，这个 LayoutManager 就是用于控制我们 RecyclerView 最终的展示效果的。</p><p>而 LayoutManager 只是一个抽象类而已，系统已经为我们提供了三个相关的实现类LinearLayoutManager（线性布局效果）、GridLayoutManager（网格布局效果）、StaggeredGridLayoutManager（瀑布流布局效果）。如果你想用 RecyclerView 来实现自己 YY 出来的一种效果，则应该去继承实现自己的 LayoutManager，并重写相应的方法，而不应该想着去改写 RecyclerView。关于 LayoutManager 的使用有下面一些常见的 API（有些在 LayoutManager 实现的子类中）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">canScrollHorizontally();<span class="comment">//能否横向滚动</span></span><br><span class="line">canScrollVertically();<span class="comment">//能否纵向滚动</span></span><br><span class="line">scrollToPosition(<span class="type">int</span> position);<span class="comment">//滚动到指定位置</span></span><br><span class="line"> </span><br><span class="line">setOrientation(<span class="type">int</span> orientation);<span class="comment">//设置滚动的方向</span></span><br><span class="line">getOrientation();<span class="comment">//获取滚动方向</span></span><br><span class="line"> </span><br><span class="line">findViewByPosition(<span class="type">int</span> position);<span class="comment">//获取指定位置的Item View</span></span><br><span class="line">findFirstCompletelyVisibleItemPosition();<span class="comment">//获取第一个完全可见的Item位置</span></span><br><span class="line">findFirstVisibleItemPosition();<span class="comment">//获取第一个可见Item的位置</span></span><br><span class="line">findLastCompletelyVisibleItemPosition();<span class="comment">//获取最后一个完全可见的Item位置</span></span><br><span class="line">findLastVisibleItemPosition();<span class="comment">//获取最后一个可见Item的位置</span></span><br><span class="line"></span><br><span class="line">mListView = (ListView) findViewById(R.id.listview);</span><br><span class="line">mListView.setEmptyView(findViewById(R.id.empty_layout));<span class="comment">//设置内容为空时显示的视图</span></span><br></pre></td></tr></table></figure><h3 id="Runnable和Callable"><a href="#Runnable和Callable" class="headerlink" title="Runnable和Callable"></a>Runnable和Callable</h3><p>Java多线程有两个重要的接口，Runnable和Callable，分别提供一个run方法和call方法，二者是有较大差异的。</p><p>1）Runnable提供run方法，无法通过throws抛出异常，所有CheckedException必须在run方法内部处理。Callable提供call方法，直接抛出Exception异常。</p><p>2）Runnable的run方法无返回值，Callable的call方法提供返回值用来表示任务运行的结果</p><p>3）Runnable可以作为Thread构造器的参数，通过开启新的线程来执行，也可以通过线程池来执行。而Callable只能通过线程池执行。</p><p>Callable任务通过线程池的submit方法提交。且submit方法返回Future对象，通过Future的get方法可以获得具体的计算结果。而且get是个阻塞的方法，如果任务未执行完，则一直等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IntegerCallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">520</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程在进行计算&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">                sum += i;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//使用FutureTask</span></span><br><span class="line">        Callable&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(task);</span><br><span class="line">        executor.submit(futureTask);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//使用Future</span></span><br><span class="line"><span class="comment">//        Callable&lt;Integer&gt; call = new Task();</span></span><br><span class="line"><span class="comment">//        Future&lt;Integer&gt; future = executor.submit(call);</span></span><br><span class="line"> </span><br><span class="line">        executor.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程在执行任务&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task运行结果&quot;</span> + futureTask.get()); <span class="comment">//future.get()</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="execute和submit"><a href="#execute和submit" class="headerlink" title="execute和submit"></a>execute和submit</h3><p>execute和submit都属于线程池的方法，execute只能提交Runnable类型的任务，而submit既能提交Runnable类型任务也能提交Callable类型任务。</p><p>execute会直接抛出任务执行时的异常，submit会吃掉异常，可通过Future的get方法将任务执行时的异常重新抛出。</p><p>execute所属顶层接口是Executor,submit所属顶层接口是ExecutorService，实现类ThreadPoolExecutor重写了execute方法,抽象类AbstractExecutorService重写了submit方法。</p><p>怎么终止线程池？<br>shutdown()和shutdownNow()</p><p>shutdown与shutdownNow有什么区别？<br>shutdown会把线程池的状态改为SHUTDOWN，而shutdownNow把当前线程池状态改为STOP<br>shutdown只会中断所有空闲的线程，而shutdownNow会中断所有的线程。<br>shutdown返回方法为空，会将当前任务队列中的所有任务执行完毕；而<br>shutdownNow把任务队列中的所有任务都取出来返回。</p><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>JVM的类加载机制的五个阶段<br>加载：读取class文件，并根据class文件描述创建java.lang.Class对象的过程<br>验证：确保Class文件符合当前虚拟机的要求，保障虚拟机自身的安全<br>准备：在方法区中为类变量分配内存并设置类中变量的初始值<br>解析：将常量池中的符号引用替换为直接引用<br>初始化：执行类构造器的&lt; client&gt;方法为类进行初始化</p><p>类加载器有哪几种？<br>启动类加载器：负责加载Java_HOME/lib目录中的类库<br>扩展类加载器：负责加载Java_HOME/lib/ext目录中的类库<br>应用程序类加载器：负责加载用户路径（classpath）上的类库<br>此外，我们还可以通过继承java.lang.ClassLoader实现自定义加载器</p><h3 id="常见布局"><a href="#常见布局" class="headerlink" title="常见布局"></a>常见布局</h3><p>   LinearLayout：线性布局，在某一方向上一次排列内部视图<br>  RelativeLayout：相对布局，默认是FrameLayout，可以取一个控件作为参考控件，以此安排该控件的位置<br>  FrameLayout：帧布局，默认叠放在左上角<br>  ConstraintLayout：约束布局，利用可视化操作进行布局<br>  MaterialCardView：卡片式布局，在帧布局的基础上额外提供了圆角和阴影等效果<br>  DrawerLayout：抽屉式布局，即滑动菜单，内含两个控件，第一个为主界面，第二个为菜单界面<br>  CoordinatorLayout：协调器布局，加强版帧布局，普通情况下与帧布局效果相同，可以监听其索引子控件的各种事件，并自动帮助我们做出最为合理的相应。</p><p>什么情况下用线性布局，什么情况适合相对布局？</p><p>  线性布局的局限性在于只能针对一个方向上布局视图，所以适用于所有控件width或height属性为match_parent的情况，此时不需要考虑另一个方向上的布局情况。<br>  而相对布局就弥补了线性布局的这个短板，它通过相对定位可以让内部视图出现在任意位置，适用于比较复杂的布局情况。</p><p>简述布局中的merge标签</p><p>用来与include标签搭配进行布局嵌套。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">merge</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:ignore</span>=<span class="string">&quot;all&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/back&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentStart</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textAllCaps</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;返回&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/title&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerHorizontal</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@android:color/white&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textAllCaps</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;标题&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/share&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentEnd</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;分享&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textAllCaps</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;/<span class="name">merge</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">include</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">layout</span>=<span class="string">&quot;@layout/merge_item&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><br>merge标签中的子集是直接加到Activity的FrameLayout根节点下,(Activity视图的根节点都是frameLayout).如果你所创建的Layout并不是用FrameLayout作为根节点（而是应用LinearLayout等定义root标签),就不能通过merge来优化UI结构.<br>当应用Include或者ViewStub标签从外部导入xml结构时,可以将被导入的xml用merge作为根节点表示,这样当被嵌入父级结构中后可以很好的将它所包含的子集融合到父级结构中,而不会出现冗余的节点.<br>另外需要注意的是:</p><p>&lt; merge /&gt;只可以作为xml FrameLayout的根节点.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/main_frame&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">merge</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/btn1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;按钮1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/btn2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;按钮2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/btn3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;按钮3&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">merge</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>当需要扩充的xml layout本身是由merge作为根节点的话,需要将被导入的xml layout置于 viewGroup中,同时需要设置attachToRoot为True.</p><p>总之，标签在UI的结构优化中起着非常重要的作用，它可以删减多余的层级，优化UI。多用于替换FrameLayout或者当一个布局包含另一个时，标签消除视图层次结构中多余的视图组。例如你的主布局文件是垂直布局，引入了一个垂直布局的include，这是如果include布局使用的LinearLayout就没意义了，使用的话反而减慢你的UI表现。这时可以使用标签优化。</p><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ol><li>Frame Animation<br>帧动画，通过顺序播放一系列图像从而产生动画效果，图片过多时容易造成OOM（Out Of Memory内存用完）异常。</li><li>Tween Animation<br>补间动画（又叫view动画），是通过对场景里的对象不断做图像变换（透明度、缩放、平移、旋转）从而产生动画效果，是一种渐进式动画，并且View动画支持自定义。</li><li>Accribute Animation<br>属性动画，这也是在android3.0之后引进的动画，在手机的版本上是android４.0就可以使用这个动画，通过动态的改变对象的属性从而达到动画效果。</li></ol><p>同为动态改变对象，补间动画和属性动画有什么区别？<br>补间动画只是改变了View的显示效果而已，并不会真正的改变View的属性。而属性动画可以改变View的显示效果和属性。举个例子：例如屏幕左上角有一个Button按钮，使用补间动画将其移动到右下角，此刻你去点击右下角的Button，它是绝对不会响应点击事件的，因此其作用区域依然还在左上角。只不过是补间动画将其绘制在右下角而已，而属性动画则不会。</p><p><a href="https://blog.csdn.net/weixin_39001306/article/details/80614286?ops_request_misc=%7B%22request%5Fid%22%3A%22159765489019724848315097%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=159765489019724848315097&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-80614286.first_rank_ecpm_v3_pc_rank_v4&amp;utm_term=Android 动画&amp;spm=1018.2118.3001.4187">Android三种动画实现原理及使用</a></p><p><a href="https://blog.csdn.net/javaSXL/article/details/80950174?biz_id=102&amp;utm_term=Android 动画&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-80950174&amp;spm=1018.2118.3001.4187">Android动画总结</a></p><h3 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h3><p>安卓中如何进行进程间通信？<br>  Bundle、文件共享、Messenger、AIDL、ContentProvider、Socket</p><p>Binder机制是什么?<br>  Binder机制是​ Android系统中进程间通讯（IPC）的一种方式，Android中ContentProvider、Intent、aidl都是基于Binder。</p><p>如何使用Binder？<br>  （1）获得ServiceManager的对象引用<br>  （2）向duServiceManager注册新的Service<br>  （3）在Client中通过ServiceManager获得Service对象引用<br>  （3）在Client中发送请求，由Service返回结果。</p><p>Binder机制的好处：<br>  1、只需要进行一次数据拷贝，性能上仅次于共享内存<br>  2、基于C/S架构，职责明确，架构清晰，稳定性较好<br>  3、为每个App分配UID，UID可用来识别进程身份，安全性较好  </p><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>Android中权限分为哪两类 ？有什么区别？<br>  危险权限和普通权限，普通权限只需要在注册文件中声明即可，危险权限不仅需要在注册文件中声明，还需要向用户申请权限许可。  </p><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/20200728131511581.png" alt="在这里插入图片描述"></p><h3 id="http1-0-http1-1-http2-0-的区别"><a href="#http1-0-http1-1-http2-0-的区别" class="headerlink" title="http1.0 http1.1 http2.0 的区别"></a>http1.0 http1.1 http2.0 的区别</h3><p><strong>一、HTTP的历史</strong></p><p>早在 HTTP 建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的 web 服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了 WEB2.0 以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的 HTML 页面有了 CSS，Javascript，来丰富我们的页面展示，当 ajax 的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于 HTTP 协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和 PC 相比，手机端的网络情况更加复杂，这使得我们开始了不得不对 HTTP 进行深入理解并不断优化过程中。</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/0" alt="img"></p><p><strong>二、HTTP的基本优化</strong></p><p>影响一个 HTTP 网络请求的因素主要有两个：<strong>带宽和延迟。</strong></p><ul><li><p><strong>带宽：</strong>如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。</p></li><li><p><strong>延迟：</strong></p></li><li><ul><li><p>浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</p></li><li><p>DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</p></li><li><p>建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</p></li></ul></li></ul><p><strong>三、HTTP1.0和HTTP1.1的一些区别</strong></p><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><ol><li><p><strong>缓存处理</strong>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p></li><li><p><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p></li><li><p><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p></li><li><p><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p></li><li><p><strong>长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p></li></ol><p><strong>四、HTTPS与HTTP的一些区别</strong></p><ul><li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li></ul><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/0" alt="img"></p><p><strong>五、SPDY：HTTP1.x的优化</strong></p><p>2012年google如一声惊雷提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下：</p><ol><li><strong>降低延迟</strong>，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。</li><li><strong>请求优先级</strong>（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</li><li><strong>header压缩。</strong>前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</li><li><strong>基于HTTPS的加密协议传输</strong>，大大提高了传输数据的可靠性。</li><li><strong>服务端推送</strong>（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图：</li></ol><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/0" alt="img"></p><p>SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。</p><p><strong>六、HTTP2.0性能惊人</strong></p><p><strong>HTTP/2: the Future of the Internet</strong> <a href="https://link.zhihu.com/?target=https://http2.akamai.com/demo">https://link.zhihu.com/?target=https://http2.akamai.com/demo</a> 是 Akamai 公司建立的一个官方的演示，用以说明 HTTP/2 相比于之前的 HTTP/1.1 在性能上的大幅度提升。 同时请求 379 张图片，从Load time 的对比可以看出 HTTP/2 在速度上的优势。</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/0" alt="img"></p><p><strong>七、HTTP2.0：SPDY的升级版</strong></p><p>HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下：</p><p><strong>HTTP2.0和SPDY的区别：</strong></p><ol><li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li><li>HTTP2.0 消息头的压缩算法采用 <strong>HPACK</strong> <a href="http://http2.github.io/http2-spec/compression.html，而非">http://http2.github.io/http2-spec/compression.html，而非</a> SPDY 采用的 <strong>DEFLATE</strong> <a href="http://zh.wikipedia.org/wiki/DEFLATE">http://zh.wikipedia.org/wiki/DEFLATE</a></li></ol><p><strong>八、HTTP2.0和HTTP1.X相比的新特性</strong></p><ul><li><p><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p></li><li><p><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p></li><li><p><strong>header压缩</strong>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p></li><li><p><strong>服务端推送</strong>（server push），同SPDY一样，HTTP2.0也具有server push功能。</p></li></ul><p><strong>九、HTTP2.0的升级改造</strong></p><ul><li>前文说了HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。</li><li>当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考<strong>NGINX白皮书，NGINX配置HTTP2.0官方指南</strong> <a href="https://www.nginx.com/blog/nginx-1-9-5/。">https://www.nginx.com/blog/nginx-1-9-5/。</a></li><li>使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。</li></ul><p><strong>十、附注</strong></p><p><strong>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</strong></p><ul><li><p>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</p></li><li><p>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</p></li><li><p>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；<br>具体如图：</p></li></ul><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/0" alt="img"></p><p>服务器推送到底是什么？<br>服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下：</p><ul><li>普通的客户端请求过程：</li></ul><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/0" alt="img"></p><ul><li>服务端推送的过程：</li></ul><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/0" alt="img"></p><p><strong>为什么需要头部压缩？</strong><br>假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。具体参考：HTTP/2 头部压缩技术介绍</p><p><strong>HTTP2.0多路复用有多好？</strong><br>HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。<br>HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。</p><h3 id="http3-0"><a href="#http3-0" class="headerlink" title="http3.0"></a>http3.0</h3><p>HTTP1.1在应用层以纯文本的形式进行通信，每次通信都要带完整的HTTP的头，而且不考虑pipeli模式的化，每次的过程总是像上面描述的那样一去一回。那样在实时性、并发想上都存在问题</p><p>头部压缩：HTTP2.0会对HTTP的头进行一定的压缩，将原来每次都要携带的大量key value在两端建立一个索引表，对相同的头只发送索引表中的索引</p><p>HTTP2.0协议将一个TCP的连接中，切分成多个流。每个流都有自己的ID，而且流可以是客户端发服务端，也可以是服务端发客户端，它其实只是一个虚拟的通道。流是有优先级的</p><p>HTTP2.0还将所有的传输信息分割为更小的信息和帧，并对它们采用二进制格式编码。常见的帧有Header帧，用于传输Header内容，并且会开启一个新的流，再就是Data帧，用来传输正文实体。多个Data帧属于一个流</p><p>通过这两种机制，http2.0的客户端可以将对个请求不同的流中，然后将请求内容拆成帧，进行二进制传输。这些真可以打散乱序发送，然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定先处理那个流的数据</p><p>二进制传输就是以上</p><p>例子：</p><p>假设一个页面要发送三个独立的请求，一个获取css，一个获取js，一个获取图片jpg。如果使用HTTP1.1就是串行的，但是如果使用HTTP2.0，就可以在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一对一对应<br><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/aaatcp.jpg" alt="image"><br>http2.0成功解决了http1.1的队首阻塞问题，同时，也不需要通过http1.x的pipeline机制用多条tcp连接来实现并行请求和响应；减少了tcp连接数对服务器性能的影响，同时将页面的多个数据css，js，jpg等通过一个数据链接进行传输，能够加快页面组件的传输速度。</p><h4 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h4><p>HTTP2.0 也是基于TCP协议的，tcp协议在处理包时是有严格顺序的</p><p>当其中一个数据包遇到问题，TCP连接需要等待找个包完成重传之后才能继续进行，虽然HTTP2.0通过多个stream，使得逻辑上一个tcp连接上的并行内容，进行多路数据的传输，然而这中间没有关联的数据，一前一后，前面stream2的帧没有收到，后面stream1的帧也会因此堵塞</p><p>于是google的 QUIC协议从TCP切换到UDP</p><ul><li>机制一：自定义连接机制<br>一条tcp连接是由四元组标识的，分别是源ip、源端口、目的端口，一旦一个元素发生变化时，就会断开重连，重新连接。在次进行三次握手，导致一定的延时</li></ul><p>在TCP是没有办法的，但是基于UDP，就可以在QUIC自己的逻辑里面维护连接的机制，不再以四元组标识，而是以一个64<br>位的随机数作为ID来标识，而且UDP是无连接的，所以当ip或者端口变化的时候，只要ID不变，就不需要重新建立连接</p><ul><li>机制二：自定义重传机制<br>tcp为了保证可靠性，通过使用序号和应答机制，来解决顺序问题和丢包问题</li></ul><p>任何一个序号的包发过去，都要在一定的时间内得到应答，否则一旦超时，就会重发这个序号的包，通过自适应重传算法（通过采样往返时间RTT不断调整）</p><p>但是，在TCP里面超时的采样存在不准确的问题。例如发送一个包，序号100，发现没有返回，于是在发送一个100，过一阵返回ACK101.客户端收到了，但是往返的时间是多少，没法计算。是ACK到达的时候减去第一还是第二。</p><p>QUIC也有个序列号，是递增的，任何宇哥序列号的包只发送一次，下次就要加1，那样就计算可以准确了</p><p>但是有一个问题，就是怎么知道包100和包101发送的是同样的内容呢？quic定义了一个offset概念。QUIC既然是面向连接的，也就像TCP一样，是一个数据流，发送的数据在这个数据流里面有个偏移量offset，可以通过offset查看数据发送到了那里，这样只有这个offset的包没有来，就要重发。如果来了，按照offset拼接，还是能够拼成一个流。</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/offsetbbb.png" alt="image"></p><ul><li>机制三： 无阻塞的多路复用</li></ul><p>有了自定义的连接和重传机制，就可以解决上面HTTP2.0的多路复用问题</p><p>同HTTP2.0一样，同一条 QUIC连接上可以创建多个stream，来发送多个HTTP请求，但是，QUIC是基于UDP的，一个连接上的多个stream之间没有依赖。这样，假如stream2丢了一个UDP包，后面跟着stream3的一个UDP包，虽然stream2的那个包需要重新传，但是stream3的包无需等待，就可以发给用户。</p><ul><li>机制四：自定义流量控制</li></ul><p>TCP的流量控制是通过滑动窗口协议。QUIC的流量控制也是通过window_update，来告诉对端它可以接受的字节数。但是QUIC的窗口是适应自己的多路复用机制的，不但在一个连接上控制窗口，还在一个连接中的每个steam控制窗口。</p><p>在TCP协议中，接收端的窗口的起始点是下一个要接收并且ACK的包，即便后来的包都到了，放在缓存里面，窗口也不能右移，因为TCP的ACK机制是基于序列号的累计应答，一旦ACK了一个序列号，就说明前面的都到了，所以是要前面的没到，后面的到了也不能ACK,就会导致后面的到了，也有可能超时重传，浪费带宽</p><p>QUIC的ACK是基于offset的，每个offset的包来了，进了缓存，就可以应答，应答后就不会重发，中间的空档会等待到来或者重发，而窗口的起始位置为当前收到的最大offset，从这个offset到当前的stream所能容纳的最大缓存，是真正的窗口的大小，显然，那样更加准确。<br><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/offsetoss.jpg" alt="image"></p><h3 id="ping的过程"><a href="#ping的过程" class="headerlink" title="ping的过程"></a>ping的过程</h3><h4 id="同一网段内"><a href="#同一网段内" class="headerlink" title="同一网段内"></a>同一网段内</h4><p>首先，如果主机A，要去ping主机B，那么主机A，就要封装二层报文，他会先查自己的MAC地址表，如果没有B的MAC地址，就会向外发送一个ARP广播包，交换机会收到这个报文后，交换机有学习MAC地址的功能，所以他会检索自己有没有保存主机B的MAC地址，如果有，就返回给主机A，如果没有，就会向所有端口发送ARP广播，其它主机收到后，发现不是在找自己，就纷纷丢弃了该报文，不去理会。直到主机B收到了报文后，就立即响应，我的MAC地址是多少，同时学到主机A的MAC地址，并按同样的ARP报文格式返回给主机A。如图: </p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/20160311231718238" alt="img"></p><h4 id="不同网段内"><a href="#不同网段内" class="headerlink" title="不同网段内"></a>不同网段内</h4><p>如果主机A要ping主机C，那么主机A发现主机C的IP和自己不是同一网段，他就去找网关转发，但是他也不知道网关的MAC地址情况下呢？他就会向之前那个步骤一样先发送一个ARP广播，学到网关的MAC地址，再发封装ICMP报文给网关路由器.当路由器收到主机A发过来的ICMP报文，发现自己的目的地址是其本身MAC地址，根据目的的IP2.1.1.1，查路由表，发现2.1.1.1/24的路由表项，得到一个出口指针，去掉原来的MAC头部，加上自己的MAC地址向主机C转发。(如果网关也没有主机C的MAC地址，还是要向前面一个步骤一样，ARP广播一下即可相互学到。路由器2端口能学到主机D的MAC地址，主机D也能学到路由器2端口的MAC地址。)最后，在主机C已学到路由器2端口MAC地址，路由器2端口转发给路由器1端口，路由1端口学到主机A的MAC地址的情况下，他们就不需要再做ARP解析，就将ICMP的回显请求回复过来</p><h3 id="判断一点是否在三角形内"><a href="#判断一点是否在三角形内" class="headerlink" title="判断一点是否在三角形内"></a>判断一点是否在三角形内</h3><p>可通过面积，如果点p在三角形内则拆分的三个三角形面积相等<br><a href="https://www.cnblogs.com/graphics/archive/2010/08/05/1793393.html">https://www.cnblogs.com/graphics/archive/2010/08/05/1793393.html</a></p><h3 id="Java线程的6种状态及切换"><a href="#Java线程的6种状态及切换" class="headerlink" title="Java线程的6种状态及切换"></a>Java线程的6种状态及切换</h3><p>Java中线程的状态分为6种。</p><blockquote><ol><li><strong>初始(NEW)</strong>：新创建了一个线程对象，但还没有调用start()方法。</li><li><strong>运行(RUNNABLE)</strong>：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li><li><strong>阻塞(BLOCKED)</strong>：表示线程阻塞于锁。</li><li><strong>等待(WAITING)</strong>：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li><strong>超时等待(TIMED_WAITING)</strong>：该状态不同于WAITING，它可以在指定的时间后自行返回。</li><li><strong>终止(TERMINATED)</strong>：表示该线程已经执行完毕。</li></ol></blockquote><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/20181120173640764.jpeg" alt="线程状态图"></p><h4 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a><strong>初始状态</strong></h4><p>实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</p><h4 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a><strong>就绪状态</strong></h4><ol><li>就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。</li><li>调用线程的start()方法，此线程进入就绪状态。</li><li>当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。</li><li>当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。</li><li>锁池里的线程拿到对象锁后，进入就绪状态。</li></ol><h4 id="运行中状态"><a href="#运行中状态" class="headerlink" title="运行中状态"></a><strong>运行中状态</strong></h4><p>线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。</p><h4 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a><strong>阻塞状态</strong></h4><p>阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。</p><h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><p>处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</p><h4 id="超时等待"><a href="#超时等待" class="headerlink" title="超时等待"></a>超时等待</h4><p>处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</p><h4 id="终止状态"><a href="#终止状态" class="headerlink" title="终止状态"></a><strong>终止状态</strong></h4><ol><li>当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。</li><li>在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</li></ol><h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a><strong>等待队列</strong></h4><ul><li>调用obj的wait(), notify()方法前，必须获得obj锁，也就是必须写在synchronized(obj) 代码段内。</li><li>与等待队列相关的步骤和图</li></ul><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/20180701221233161" alt="img"></p><ol><li>线程1获取对象A的锁，正在使用对象A。</li><li>线程1调用对象A的wait()方法。</li><li>线程1释放对象A的锁，并马上进入等待队列。</li><li>锁池里面的对象争抢对象A的锁。</li><li>线程5获得对象A的锁，进入synchronized块，使用对象A。</li><li>线程5调用对象A的notifyAll()方法，唤醒所有线程，所有线程进入同步队列。若线程5调用对象A的notify()方法，则唤醒一个线程，不知道会唤醒谁，被唤醒的那个线程进入同步队列。</li><li>notifyAll()方法所在synchronized结束，线程5释放对象A的锁。</li><li>同步队列的线程争抢对象锁，但线程1什么时候能抢到就不知道了。 </li></ol><h4 id="同步队列状态"><a href="#同步队列状态" class="headerlink" title="同步队列状态"></a><strong>同步队列状态</strong></h4><ul><li>当前线程想调用对象A的同步方法时，发现对象A的锁被别的线程占有，此时当前线程进入同步队列。简言之，同步队列里面放的都是想争夺对象锁的线程。</li><li>当一个线程1被另外一个线程2唤醒时，1线程进入同步队列，去争夺对象锁。</li><li>同步队列是在同步的环境下才有的概念，一个对象对应一个同步队列。</li><li>线程等待时间到了或被notify/notifyAll唤醒后，会进入同步队列竞争锁，如果获得锁，进入RUNNABLE状态，否则进入BLOCKED状态等待获取锁。</li></ul><h4 id="几个方法的比较"><a href="#几个方法的比较" class="headerlink" title="几个方法的比较"></a><strong>几个方法的比较</strong></h4><ol><li>Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态，但不释放对象锁，millis后线程自动苏醒进入就绪状态。作用：给其它线程执行机会的最佳方式。</li><li>Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。该方法与sleep()类似，只是不能由用户指定暂停多长时间。</li><li>thread.join()/thread.join(long millis)，当前线程里调用其它线程t的join方法，当前线程进入WAITING/TIMED_WAITING状态，当前线程不会释放已经持有的对象锁。线程t执行完毕或者millis时间到，当前线程一般情况下进入RUNNABLE状态，也有可能进入BLOCKED状态（因为join是基于wait实现的）。</li><li>obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout) timeout时间到自动唤醒。</li><li>obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。</li><li>LockSupport.park()/LockSupport.parkNanos(long nanos),LockSupport.parkUntil(long deadlines), 当前线程进入WAITING/TIMED_WAITING状态。对比wait方法,不需要获得锁就可以让线程进入WAITING/TIMED_WAITING状态，需要通过LockSupport.unpark(Thread thread)唤醒。</li></ol><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>可参考<a href="https://juejin.im/post/6844903702260629512">掘金</a></p><p><strong>责任链模式(Chain of Responsibility Pattern)</strong>：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。</p><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p><strong>Handler（抽象处理者）</strong>：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用。通过该引用，处理者可以连成一条链。</p><p><strong>ConcreteHandler（具体处理者）</strong>：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。</p><p>类图如下所示：</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/166c90b265849954" alt="责任链模式.类图"></p><h4 id="纯与不纯的责任链模式"><a href="#纯与不纯的责任链模式" class="headerlink" title="纯与不纯的责任链模式"></a>纯与不纯的责任链模式</h4><p><strong>纯的责任链模式</strong>：</p><ul><li>一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后 又将责任向下传递的情况</li><li>一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况</li></ul><p><strong>不纯的责任链模式</strong>：</p><ul><li>允许某个请求被一个具体处理者部分处理后再向下传递</li><li>或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求</li><li>而且一个请求可以最终不被任何处理者对象所接收</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="职责链模式的主要优点"><a href="#职责链模式的主要优点" class="headerlink" title="职责链模式的主要优点"></a>职责链模式的主要优点</h5><ul><li>对象仅需知道该请求会被处理即可，且链中的对象不需要知道链的结构，由客户端负责链的创建，<strong>降低了系统的耦合度</strong></li><li>请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，<strong>可简化对象的相互连接</strong></li><li>在给对象分派职责时，职责链可以给我们更多的<strong>灵活性</strong>，可以在运行时对该链进行动态的增删改，改变处理一个请求的职责</li><li>新增一个新的具体请求处理者时无须修改原有代码，只需要在客户端重新建链即可，<strong>符合 “开闭原则”</strong></li></ul><h5 id="职责链模式的主要缺点"><a href="#职责链模式的主要缺点" class="headerlink" title="职责链模式的主要缺点"></a>职责链模式的主要缺点</h5><ul><li>一个请求可能因职责链没有被正确配置而<strong>得不到处理</strong></li><li>对于比较长的职责链，请求的处理可能涉及到多个处理对象，<strong>系统性能将受到一定影响</strong>，且不方便调试</li><li>可能因为职责链创建不当，造成循环调用，导致系统陷入<strong>死循环</strong></li></ul><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的</li><li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li><li>可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序</li></ul><h3 id="SharePreference"><a href="#SharePreference" class="headerlink" title="SharePreference"></a>SharePreference</h3><p>SharePreference</p><p>一般用于保存偏好设置，比如说我们设置里的条目</p><p>sharepreference使用步骤</p><p>1、拿到sharepreference</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拿到share preference</span></span><br><span class="line">        setting_info = <span class="keyword">this</span>.getSharedPreferences(<span class="string">&quot;setting_info&quot;</span>, MODE_PRIVATE);</span><br></pre></td></tr></table></figure><p>这里的this是指上下文Context，在Activity中，因为Activity直接或间接继承了Context，所以直接使用this。</p><p>其中<strong>Context.MODE_PRIVATE</strong>是我们最常用的，只允许自己的程序访问</p><p>写入的数据保存在：</p><p>   /data/data/<package name>/shared_prefs/setting_info.xml (手机中有root权限才可以看见)</package></p><p>2、进入编辑模式</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拿到编辑器</span></span><br><span class="line">        SharedPreferences.Editor <span class="keyword">edit</span> = setting_info.<span class="keyword">edit</span>();</span><br></pre></td></tr></table></figure><p>3、保存数据</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存数据</span></span><br><span class="line">        edit.put<span class="constructor">Boolean(<span class="string">&quot;state&quot;</span>,<span class="params">isChecked</span>)</span>;</span><br></pre></td></tr></table></figure><p>保存数据时，根据数据的类型boolean，String，float，等等</p><p>4、提交数据编辑器</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>提交编辑器</span><br><span class="line">        edit.commit();</span><br></pre></td></tr></table></figure><p> sharepreference同样属于内部存储，与files/cache相同，在data/data包名下shared_prefs以xml文件形式保存。</p><p>它的内容保存都是以键值对的方式保存。</p><p>sharepreference数据回显</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//数据回显</span><br><span class="line">        boolean <span class="keyword">state</span> = setting_info.getBoolean(<span class="string">&quot;state&quot;</span>, false);</span><br><span class="line">        mAllowUnknownSourceSwitch.<span class="built_in">set</span>Checked(<span class="keyword">state</span>);</span><br></pre></td></tr></table></figure><p>删除数据:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences.<span class="type">Editor</span> <span class="variable">relieveEditor</span> <span class="operator">=</span> getSharedPreferences(<span class="string">&quot;AllTopic&quot;</span>, MODE_PRIVATE).edit();</span><br><span class="line"> relieveEditor.remove(<span class="string">&quot;topic&quot;</span>);</span><br><span class="line">relieveEditor.apply();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>清除sharepreference中的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SharedPreferences</span> <span class="variable">sp</span> <span class="operator">=</span> getSharedPreferences(<span class="string">&quot;setting_info&quot;</span>, Context.MODE_PRIVATE);</span><br><span class="line"><span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> sp.edit();</span><br><span class="line">editor.clear();</span><br><span class="line">editor.commit();</span><br></pre></td></tr></table></figure><p>commit()操作 会先写数据到内存缓存，然后创建一个Runnable,通过调用下面的语句将Runnable加入到写文件的队列中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueuedWork.queue(writeToDiskRunnable, false);// 执行writeToDiskRunnable时不能延迟</span><br></pre></td></tr></table></figure><p>apply()操作 会先写数据到内存缓存，然后创建一个Runnable,通过调用下面的语句将Runnable加入到写文件的队列中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueuedWork.queue(writeToDiskRunnable, true);// 延迟执行Runnable</span><br></pre></td></tr></table></figure><p>SharePreference中所有的内存级别缓存都是线程安全的,内部通过使用Synchronized 维护</p><p>备注： SharePreference 是线程安全的，内部的commit,apply都实现了线程同步，但是不支持多进程访问，除了初始化时从xml文件读取数据，其他时候都是内存级别的，所以数据不能共享</p><p>xml 时可以实现数据共享的，但是多个进程同时访问同一个xml文件，是无法保证数据的同步，正确性</p><p>SharePreference写数据到缓存时，只会将有变化的数据重新写入文件， 另外，则使用backup文件(初始化时使用，如果写文件的过程中出错，则使用backup恢复数据)</p><p>针对多进程共享SharePreference，可以通过ContentProvider包括一层，能不用SharePreference实现</p><p>commit 是在当前线程中写数据到文件 </p><p>apply在异步线程中写数据到文件</p><p>commit:</p><ul><li>commit方法是有一个boolean的返回值</li><li>当数据变化进行存储时是一个原子性的操作</li><li>当两个editor对象同时对一个共享的preferences参数进行操作时，永远都是最后一个调用commit方法的editor变更了最后的数据值</li></ul><p>apply:</p><ul><li>apply方法是没有返回值的</li><li>当两个editor同时对preferences对象编辑时，也是最后一个调用apply方法的对象编辑数据</li><li>apply的提交操作也是原子性的，但是只提交到内存，速度更快</li></ul><h3 id="怎么判断是反射调用的方法"><a href="#怎么判断是反射调用的方法" class="headerlink" title="怎么判断是反射调用的方法"></a>怎么判断是反射调用的方法</h3><p>检查调用堆栈，可以看到调用的来源是否来自 MethodAccesor.invoke, Method.invoke 等关键方法，从而可以判断出是否是被反射调用</p><p>至于堆栈，new 一个异常就可以拿到了</p><h3 id="安卓framework层架构"><a href="#安卓framework层架构" class="headerlink" title="安卓framework层架构"></a>安卓framework层架构</h3><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/image-20200901101222393.png" alt="image-20200901101222393"></p><p>关于Framework层：</p><p>Android的Framework是直接应用之下的一层，叫做应用程序框架层。这一层是核心应用程序所使用的API框架，为应用层提供各种API，提供各种组件和服务来支持我们的Android开发，包括ActivityManager,WindowManager,ViewSystem等。 </p><p>从图中可以看到</p><ol><li>ActivityManagerService(Ams):负责管理所有应用程序中的Activity,它掌握所有Activity的情况，具有所有调度Activity生命周期的能力，简单来说，ActivityManagerService是管理和掌控所有的Activity.</li><li>WindowManagerService(Wms):控制窗口的显示、隐藏以及窗口的层序，简单来说，它就是管理窗口的，大多数和View有关系的都要和它打交道。</li><li>内容提供器(Content Providers)：可以让一个应用访问”另一个应用”的数据(比如联系人数据库),或者共享他们的数据</li><li>视图系统(View System):丰富且可拓展,包括:列表(lists),网络(grids),文本框(text boxes),按钮(buttons)等等.</li><li>通知管理器(Notification Manager):可以在”状态栏中”显示自定义的提示信息</li><li>包管理器(Package Manger):对Android系统内的程序管理</li><li>Telephony Manager主要提供了一系列用于访问与手机通讯相关的状态和信息的方法，查询电信网络状态信息，sim卡的信息等。</li><li>Resource Manager提供非代码资源的访问，如本地字符串，图形，和布局文件（Layout files )。</li><li>Location Manager提供设备的地址位置的获取方式。很显然，GPS导航肯定能用到位置服务。</li><li>XMPP可扩展通讯和表示协议。前身为Jabber，提供即时通信服务。例如推送功能,Google Talk。</li></ol><blockquote><p>Android Framework的三大核心功能：</p><p>1、View.java:View工作原理，实现包括绘制view、处理触摸、按键事件等。</p><p>2、ActivityManagerService.java:Ams 管理所有应用程序的Activity等。</p><p>3、WindowManagerService.java:Wms 为所有应用程序分配窗口，并管理这些窗口。</p><p>Framework其实可以简单的理解为一些API的库房，android开发人员将一些基本功能实现，通过接口提供给上层调用，可以重复的调用</p><p>​     我们可以称Framework层才真正是Java语言实现的层，在这层里定义的API都是用Java语言编写。但是又因为它包含了JNI的方法，JNI用C/C++编写接口，根据函数表查询调用核心库层里的底层方法，最终访问到Linux内核。那么Framework层的作用就有2个。</p><p>1.用Java语言编写一些规范化的模块封装成框架，供APP层开发者调用开发出具有特殊业务的手机应用。</p><p>2.用Java Native Interface调用core lib层的本地方法，JNI的库是在Dalvik虚拟机启动时加载进去的，Dalvik会直接去寻址这个JNI方法，然后去调用。</p><p>​    2种方式的结合达到了Java方法和操作系统的相互通信。Android为什么要用Java编写Framework层呢？直接用C或C++不是更好？有关专家给出了如下解释：</p><p>   C/C++过于底层，开发者要花很多的经历对C/C++的语言研究清楚，例如C/C++的内存机制，如果稍不注意，就会忘了开启或者释放。而Java的GC会自动处理这些，省去了很多的时间让开发者专注于自己的业务。所以才会从C/C++的底层慢慢向上变成了JAVA的开发语言，该层通过JNI和核心运行库层进行交互。 </p></blockquote><h3 id="Activity启动流程分析"><a href="#Activity启动流程分析" class="headerlink" title="Activity启动流程分析"></a>Activity启动流程分析</h3><p>参考<a href="https://blog.csdn.net/u012267215/article/details/91406211">CSDN</a></p><h3 id="Activity怎么绕过manifest-xml文件注册"><a href="#Activity怎么绕过manifest-xml文件注册" class="headerlink" title="Activity怎么绕过manifest.xml文件注册"></a>Activity怎么绕过manifest.xml文件注册</h3><p>参考<a href="https://blog.csdn.net/lc_miao/article/details/88095698?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">CSDN</a></p><h3 id="客户端认证服务端证书的过程"><a href="#客户端认证服务端证书的过程" class="headerlink" title="客户端认证服务端证书的过程"></a>客户端认证服务端证书的过程</h3><p><a href="https://www.cnblogs.com/zfxJava/p/5295957.html">数字签名、数字证书、对称加密算法、非对称加密算法、单向加密（散列算法）</a></p><p>消息—&gt;[公钥]—&gt;加密后的信息—&gt;[私钥]—&gt;消息</p><p>加密：防窃听（私钥）（对签名加密，形成数字签名）（古典加密主要以保护算法为主，现代加密主要以保护密钥为主）</p><p>签名：防篡改（hash签名，并附加上原文一起发送）（权威机构给证书卡的一个章，即<strong>签名算法</strong>）</p><p>我们怎么确认CA的公钥就是对的呢，层层授信背书（CA的公钥也需要更牛的CA给它签名，只要上级证书的公钥，可以解开CA的签名，就可以。层层上去，直到全球皆知的几个著名的大CA）</p><p>在web数据传输过程中，由于客户端和服务器端是多对一的关系，因此可以让所有的客户端持有相同的公钥，服务器持有私钥，这样一来就能方便地实现数据的加密传输</p><p>浏览器与Web Server之间要经过一个握手的过程来完成身份鉴定与密钥交换，从而建立安全连接。具体过程如下：<br>用户浏览器将其SSL版本号、加密套件候选列表、压缩算法候选列表等有关的数据以及一个随机数发送到服务器。  </p><p>服务器将其选择使用的协议版本、加密套件、压缩算法等有关的数据以及一个随机数发送给浏览器，同时发给浏览器的还有服务器的证书。如果配置服务器的SSL需要验证用户身份，还要发出请求要求浏览器提供用户证书。 </p><p>客户端检查服务器证书，如果检查失败，提示不能建立SSL连接。如果成功，那么继续。客户端浏览器为本次会话生成Pre-Master secret，发送Client Key Exchange，并将其用服务器公钥加密后发送给服务器。如果服务器要求鉴别客户身份，客户端还要再对另外一些数据签名后并将其与客户端证书一起发送给服务器。 </p><p>到目前为止，无论客户端还是服务器都有了三个随机数，自己的，对端的以及刚生成的Pre-Mastert随机数。通过这三个随机数，可以在客户端和服务器产生相同的对称密钥。这样做的主要原因是对称加密比非对称加密的运算量低一个数量级以上，能够显著提高双方会话时的运算速度。</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/20191204221729188.png" alt="img"></p><p>整个过程涉及2对公私密钥对，一对由服务器产生，用于加密，一对由CA产生，用于签名。<br>整个过程还涉及2个信任：客户端信任CA，CA发布的证书中的公钥就是合法服务器的公钥。客户端信任浏览器内置的CA公钥就是与CA私钥对应的公钥。最后要说明的是，非对称加密在https中只是用来对对称加密密钥进行协商的过程才使用，在两端协商完对称加密的密钥之后，数据的加密传输均采用对称加密的方式。</p><p>因为黑客也有服务器的公钥，所以在截取后可以打开服务器的密文，也可以模拟客户端获取一些信息。所以最好是两对公私钥，客户端用服务器的公钥加密传输，服务器用客户端的公钥加密传输</p><p>对于重放和篡改，通过timestamp和nonce随机数联合起来，保证唯一，对于同样的请求，只接受一次</p><h3 id="android-资源ID生成规则"><a href="#android-资源ID生成规则" class="headerlink" title="android 资源ID生成规则"></a>android 资源ID生成规则</h3><p>在Android中资源的使用几乎无处不在，layout、string、drawable、raw、style、theme 等等都是。<br>这些资源会在编译过程中被打包进 APK 中（res文件夹）或者被打包成独立的资源 APK 包（比如 framework-res.apk ）。<br>但是这些资源都会被赋予独一无二的 ID 即资源索引来方便系统访问。<br>这些资源索引由 Android 的工具 AAPT（Android Asset Packing Tool）生成的八位十六进制整数型。</p><p>在编译的时候，AAPT会扫描你所定义的所有资源（在不同文件中定义的以及单独的资源文件），然后给它们指定不同的资源ID。<br>资源ID 是一个32bit的数字，格式是PPTTNNNN ， PP代表资源所属的包(package) ,TT代表资源的类型(type)，NNNN代表这个类型下面的资源的名称。 对于应用程序的资源来说，PP的取值是0×77。<br>TT 和NNNN 的取值是由AAPT工具随意指定的–基本上每一种新的资源类型的数字都是从上一个数字累加的（从1开始）；而每一个新的资源条目也是从数字1开始向上累加的。</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/4302219-791ec956783d296e.png" alt="img"></p><p>中间 02 所在位置值代表资源ID对应的资源的类型，分别是：<br>02：drawable<br>03：layout<br>04：values<br>05：xml<br>06：raw<br>07：color<br>08：menu</p><p>PS:分配resource id的主要逻辑实现是在framework/base/tools/aapt/Resource.cpp 和 ResourceTable.cpp</p><h3 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h3><p><a href="https://www.runoob.com/w3cnote/java-annotation.html">https://www.runoob.com/w3cnote/java-annotation.html</a></p><p>关于注解首先引入官方文档的一句话：Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。看完这句话也许你还是一脸懵逼，接下我将从注解的定义、元注解、注解属性、自定义注解、注解解析JDK 提供的注解这几个方面再次了解注解（Annotation）</p><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><ul><li>元注解顾名思义我们可以理解为注解的注解，它是作用在注解中，方便我们使用注解实现想要的功能。元注解分别有@Retention、 @Target、 @Document、 @Inherited和@Repeatable（JDK1.8加入）五种。</li></ul><h5 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h5><ul><li>Retention英文意思有保留、保持的意思，它表示注解存在阶段是保留在源码（编译期），字节码（类加载）或者运行期（JVM中运行）。在@Retention注解中使用枚举RetentionPolicy来表示注解保留时期</li><li>@Retention(RetentionPolicy.SOURCE)，注解仅存在于源码中，在class字节码文件中不包含</li><li>@Retention(RetentionPolicy.CLASS)， 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得</li><li>@Retention(RetentionPolicy.RUNTIME)， 注解会在class字节码文件中存在，在运行时可以通过反射获取到</li><li>如果我们是自定义注解，则通过前面分析，我们自定义注解如果只存着源码中或者字节码文件中就无法发挥作用，而在运行期间能获取到注解才能实现我们目的，所以自定义注解中肯定是使用 <strong>@Retention(RetentionPolicy.RUNTIME)</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyTestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h5><ul><li>Target的英文意思是目标，这也很容易理解，使用@Target元注解表示我们的注解作用的范围就比较具体了，可以是类，方法，方法参数变量等，同样也是通过枚举类ElementType表达作用类型</li><li>@Target(ElementType.TYPE) 作用接口、类、枚举、注解</li><li>@Target(ElementType.FIELD) 作用属性字段、枚举的常量</li><li>@Target(ElementType.METHOD) 作用方法</li><li>@Target(ElementType.PARAMETER) 作用方法参数</li><li>@Target(ElementType.CONSTRUCTOR) 作用构造函数</li><li>@Target(ElementType.LOCAL_VARIABLE)作用局部变量</li><li>@Target(ElementType.ANNOTATION_TYPE)作用于注解（@Retention注解中就使用该属性）</li><li>@Target(ElementType.PACKAGE) 作用于包</li><li>@Target(ElementType.TYPE_PARAMETER) 作用于类型泛型，即泛型方法、泛型类、泛型接口 （jdk1.8加入）</li><li>@Target(ElementType.TYPE_USE) 类型使用.可以用于标注任意类型除了 class （jdk1.8加入）</li><li>一般比较常用的是ElementType.TYPE类型</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h5><ul><li>Document的英文意思是文档。它的作用是能够将注解中的元素包含到 Javadoc 中去。</li></ul><h5 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h5><ul><li>Inherited的英文意思是继承，但是这个继承和我们平时理解的继承大同小异，一个被@Inherited注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解。</li><li>下面我们来看个@Inherited注解例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**自定义注解*/</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTestAnnotation &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**父类标注自定义注解*/</span></span><br><span class="line"><span class="meta">@MyTestAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**子类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**测试子类获取父类自定义注解*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取Son的class对象</span></span><br><span class="line">       Class&lt;Son&gt; sonClass = Son.class;</span><br><span class="line">      <span class="comment">// 获取Son类上的注解MyTestAnnotation可以执行成功</span></span><br><span class="line">      <span class="type">MyTestAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> sonClass.getAnnotation(MyTestAnnotation.class);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h5><ul><li>Repeatable的英文意思是可重复的。顾名思义说明被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。</li><li>下面我们看一个人玩游戏的例子</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**一个人喜欢玩游戏，他喜欢玩英雄联盟，绝地求生，极品飞车，尘埃4等，则我们需要定义一个人的注解，他属性代表喜欢玩游戏集合，一个游戏注解，游戏属性代表游戏名称*/</span></span><br><span class="line"><span class="comment">/**玩家注解*/</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> People &#123;</span><br><span class="line">    Game[] value() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**游戏注解*/</span></span><br><span class="line"><span class="meta">@Repeatable(People.class)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Game &#123;</span><br><span class="line">    String value() default <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**玩游戏类*/</span></span><br><span class="line"><span class="meta">@Game(value = <span class="string">&quot;LOL&quot;</span>)</span></span><br><span class="line"><span class="meta">@Game(value = <span class="string">&quot;PUBG&quot;</span>)</span></span><br><span class="line"><span class="meta">@Game(value = <span class="string">&quot;NFS&quot;</span>)</span></span><br><span class="line"><span class="meta">@Game(value = <span class="string">&quot;Dirt4&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlayGame</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过上面的例子，你可能会有一个疑问，游戏注解中括号的变量是啥，其实这和游戏注解中定义的属性对应。接下来我们继续学习注解的属性。</li></ul><h4 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h4><ul><li>通过上一小节@Repeatable注解的例子，我们说到注解的属性。注解的属性其实和类中定义的变量有异曲同工之处，只是注解中的变量都是成员变量（属性），并且注解中是没有方法的，只有成员变量，变量名就是使用注解括号中对应的参数名，变量返回值注解括号中对应参数类型。相信这会你应该会对上面的例子有一个更深的认识。而@Repeatable注解中的变量则类型则是对应Annotation（接口）的泛型Class。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**注解Repeatable源码*/</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repeatable &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the</span></span><br><span class="line"><span class="comment">     * repeatable annotation type.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the containing annotation type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注解的本质"><a href="#注解的本质" class="headerlink" title="注解的本质"></a>注解的本质</h4><ul><li>注解的本质就是一个Annotation接口</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**Annotation接口源码*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Annotation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">boolean <span class="title">equals</span>(<span class="params">Object obj</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">hashCode</span>()</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过以上源码，我们知道注解本身就是Annotation接口的子接口，<strong>也就是说注解中其实是可以有属性和方法，但是接口中的属性都是static final的，对于注解来说没什么意义，而我们定义接口的方法就相当于注解的属性，也就对应了前面说的为什么注解只有属性成员变量，其实他就是接口的方法，这就是为什么成员变量会有括号</strong>，不同于接口我们可以在注解的括号中给成员变量赋值。</li></ul><h4 id="注解属性类型"><a href="#注解属性类型" class="headerlink" title="注解属性类型"></a>注解属性类型</h4><ul><li>注解属性类型可以有以下列出的类型</li><li>1.基本数据类型</li><li>2.String</li><li>3.枚举类型</li><li>4.注解类型</li><li>5.Class类型</li><li>6.以上类型的一维数组类型</li></ul><h4 id="注解成员变量赋值"><a href="#注解成员变量赋值" class="headerlink" title="注解成员变量赋值"></a>注解成员变量赋值</h4><ul><li>如果注解又多个属性，则可以在注解括号中用“，”号隔开分别给对应的属性赋值，如下例子，注解在父类中赋值属性</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTestAnnotation &#123;</span><br><span class="line">    String name() default <span class="string">&quot;mao&quot;</span>;</span><br><span class="line">    int age() default <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyTestAnnotation(name = <span class="string">&quot;father&quot;</span>,age = 50)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JVM和DVM的区别，ART与DVM的区别"><a href="#JVM和DVM的区别，ART与DVM的区别" class="headerlink" title="JVM和DVM的区别，ART与DVM的区别"></a>JVM和DVM的区别，ART与DVM的区别</h3><p>1、什么是JVM？</p><p>JVM本质上就是一个软件，是计算机硬件的一层软件抽象，在这之上才能够运行Java程序，JAVA在编译后会生成类似于汇编语言的JVM字节码，与C语言编译后产生的汇编语言不同的是，C编译成的汇编语言会直接在硬件上跑，但JAVA编译后生成的字节码是在JVM上跑，需要由JVM把字节码翻译成机器指令，才能使JAVA程序跑起来。</p><p>JVM运行在操作系统上，屏蔽了底层实现的差异，从而有了JAVA吹嘘的平台独立性和Write Once Run Anywhere。根据JVM规范实现的具体虚拟机有几十种，主流的JVM包括Hotspot、Jikes RVM等，都是用C/C++和汇编编写的，每个JRE编译的时候针对每个平台编译，因此下载JRE（JVM、Java核心类库和支持文件）的时候是分平台的，JVM的作用是把平台无关的.class里面的字节码翻译成平台相关的机器码，来实现跨平台。</p><p>2、什么是DVM，和JVM有什么不同？</p><p>JVM是Java Virtual Machine，而DVM就是Dalvik Virtual Machine，是安卓中使用的虚拟机，所有安卓程序都运行在安卓系统进程里，每个进程对应着一个Dalvik虚拟机实例。他们都提供了对象生命周期管理、堆栈管理、线程管理、安全和异常管理以及垃圾回收等重要功能，各自拥有一套完整的指令系统，以下简要对比两种虚拟机的不同。</p><p><strong>①JAVA虚拟机运行的是JAVA字节码，Dalvik虚拟机运行的是Dalvik字节码</strong></p><p>JAVA程序经过编译，生成JAVA字节码保存在class文件中，JVM通过解码class文件中的内容来运行程序。而DVM运行的是Dalvik字节码，所有的Dalvik字节码由JAVA字节码转换而来，并被打包到一个DEX（Dalvik Executable）可执行文件中，DVM通过解释DEX文件来执行这些字节码。</p><p><strong>②Dalvik可执行文件体积更小</strong></p><p>class文件中包含多个不同的方法签名，如果A类文件引用B类文件中的方法，方法签名也会被复制到A类文件中（在虚拟机加载类的连接阶段将会使用该签名链接到B类的对应方法），也就是说，多个不同的类会同时包含相同的方法签名，同样地，大量的字符串常量在多个类文件中也被重复使用，这些冗余信息会直接增加文件的体积，而JVM在把描述类的数据从class文件加载到内存时，需要对数据进行校验、转换解析和初始化，最终才形成可以被虚拟机直接使用的JAVA类型，因为大量的冗余信息，会严重影响虚拟机解析文件的效率。</p><p>为了减小执行文件的体积，安卓使用Dalvik虚拟机，SDK中有个dx工具负责将JAVA字节码转换为Dalvik字节码，dx工具对JAVA类文件重新排列，将所有JAVA类文件中的常量池分解，消除其中的冗余信息，重新组合形成一个常量池，所有的类文件共享同一个常量池，使得相同的字符串、常量在DEX文件中只出现一次，从而减小了文件的体积。</p><p><strong>③JVM基于栈，DVM基于寄存器</strong></p><p>JAVA虚拟机基于栈结构，程序在运行时虚拟机需要频繁的从栈上读取写入数据，这个过程需要更多的指令分派与内存访问次数，会耗费很多CPU时间。</p><p>Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式要快很多。</p><p>3、什么是ART虚拟机，和JVM/DVM有什么不同？</p><p>首先了解JIT（Just In Time，即时编译技术）和AOT(Ahead Of Time，预编译技术)两种编译模式。</p><p>JIT以JVM为例，javac把程序源码编译成JAVA字节码，JVM通过逐条解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译，执行速度必然比C/C++编译后的可执行二进制字节码程序慢，为了提高执行速度，就引入了JIT技术，JIT会在运行时分析应用程序的代码，识别哪些方法可以归类为热方法，这些方法会被JIT编译器编译成对应的汇编代码，然后存储到代码缓存中，以后调用这些方法时就不用解释执行了，可以直接使用代码缓存中已编译好的汇编代码。这能显著提升应用程序的执行效率。（安卓Dalvik虚拟机在2.2中增加了JIT）</p><p>相对的AOT就是指C/C++这类语言，编译器在编译时直接将程序源码编译成目标机器码，运行时直接运行机器码。</p><p><strong>Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码</strong></p><p>Dalvik执行的是dex字节码，依靠JIT编译器去解释执行，运行时动态地将执行频率很高的dex字节码翻译成本地机器码，然后在执行，但是将dex字节码翻译成本地机器码是发生在应用程序的运行过程中，并且应用程序每一次重新运行的时候，都要重新做这个翻译工作，因此，即使采用了JIT，Dalvik虚拟机的总体性能还是不能与直接执行本地机器码的ART虚拟机相比。</p><p>安卓运行时从Dalvik虚拟机替换成ART虚拟机，并不要求开发者重新将自己的应用直接编译成目标机器码，也就是说，应用程序仍然是一个包含dex字节码的apk文件。所以在安装应用的时候，dex中的字节码将被编译成本地机器码，之后每次打开应用，执行的都是本地机器码。移除了运行时的解释执行，效率更高，启动更快。（安卓在4.4中发布了ART运行时）</p><p>ART优点：</p><p>①系统性能显著提升</p><p>②应用启动更快、运行更快、体验更流畅、触感反馈更及时</p><p>③续航能力提升</p><p>④支持更低的硬件</p><p>ART缺点</p><p>①更大的存储空间占用，可能增加10%-20%</p><p>②更长的应用安装时间</p><h3 id="ANR-DEBUG"><a href="#ANR-DEBUG" class="headerlink" title="ANR DEBUG"></a>ANR DEBUG</h3><p>1，AndroidStudio Logcat查看</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/20190820150513658.png" alt="img"></p><p>通过查看Logcat的方法只能看一个大概，告诉你主线程等待异常；</p><p>2，traces.txt</p><p>app每次出现anr异常，系统都会记录到手机的traces.txt文件中，所以，出现anr可通过查看traces.txt追踪异常；</p><p>对adb不了解的可先看下Android adb shell 常用命令<a href="https://www.cnblogs.com/abeam/p/8908225.html">https://www.cnblogs.com/abeam/p/8908225.html</a></p><p>配置好adb以后查找traces.txt文件（声明：不需要root）</p><p>window + R ，输入cmd 打开命令窗口：</p><p>①adb shell （链接设备）</p><p>②cd /data/anr （进入/data/anr目录下）</p><p>③ls （查看当前目录下文件）</p><p>④ctrl + d 退出</p><p>⑤adb pull data/anr/traces.txt c:\anr （可将文件导入到c盘anr文件中，如果出现以下异常，需按照另外一种办法解决）</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/20190820160911602.png" alt="img"></p><p>出现这种异常需使用另外一个命令导出</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span><span class="number">6.0</span>及以下设备</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">adb bugreport &gt; bugreport.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span><span class="number">7.0</span>及以上设备</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">adb bugreport bugreport.zip</span><br></pre></td></tr></table></figure><p>压缩成功，可以先查看以下，然后导出：</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/20190820161702382.png" alt="img"></p><p>然后到电脑C盘anr文件夹中解压压缩包，找到 FS文件夹 ——&gt;  data文件夹  ——&gt;  anr文件夹</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/20190820161925932.png" alt="img"></p><p>打开查找anr异常</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/2019082016205650.png" alt="img"></p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/20190820162146480.png" alt="img"></p><p>可精准定位到异常；</p><p>其实造成ANR异常的原因很多，主线程阻塞，CPU满负荷，内存不足，还有各大组件ANR。</p><p>ANR的避免和检测</p><p>为了避免在开发中引入可能导致应用发生ANR的问题，除了切记不要在主线程中作耗时操作，我们也可以借助于一些工具来进行检测，从而更有效的避免ANR的引入。</p><p><strong>StrictMode</strong></p><p>严格模式StrictMode是Android SDK提供的一个用来检测代码中是否存在违规操作的工具类，StrictMode主要检测两大类问题。</p><ul><li>线程策略 ThreadPolicy<ul><li>detectCustomSlowCalls：检测自定义耗时操作</li><li>detectDiskReads：检测是否存在磁盘读取操作</li><li>detectDiskWrites：检测是否存在磁盘写入操作</li><li>detectNetWork：检测是否存在网络操作</li></ul></li><li>虚拟机策略VmPolicy<ul><li>detectActivityLeaks：检测是否存在Activity泄露</li><li>detectLeakedClosableObjects：检测是否存在未关闭的Closeable对象泄露</li><li>detectLeakedSqlLiteObjects：检测是否存在Sqlite对象泄露</li><li>setClassInstanceLimit：检测类实例个数是否超过限制</li></ul></li></ul><p>可以看到，ThreadPolicy可以用来检测可能催在的主线程耗时操作，需要注意的是我们只能在Debug版本中使用它，发布到市场上的版本要关闭掉。StrictMode的使用很简单，我们只需要在应用初始化的地方例如Application或者MainActivity类的onCreate方法中执行如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_login);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启线程模式</span></span><br><span class="line">        StrictMode.setThreadPolicy(<span class="keyword">new</span> <span class="title class_">StrictMode</span>.ThreadPolicy.Builder()</span><br><span class="line">                .detectAll()</span><br><span class="line">                .penaltyLog()</span><br><span class="line">                .penaltyDialog() <span class="comment">////打印logcat，当然也可以定位到dropbox，通过文件保存相应的log</span></span><br><span class="line">                .build());</span><br><span class="line">        <span class="comment">// 开启虚拟机模式</span></span><br><span class="line">        StrictMode.setVmPolicy(<span class="keyword">new</span> <span class="title class_">StrictMode</span>.VmPolicy.Builder()</span><br><span class="line">                .detectAll()</span><br><span class="line">                .penaltyLog()</span><br><span class="line">                .build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的初始化代码调用penaltyLog表示在Logcat中打印日志，调用detectAll方法表示启动所有的检测策略，我们也可以根据应用的具体要求只开启某些策略，语句如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StrictMode.setThreadPolicy(<span class="keyword">new</span> <span class="title class_">StrictMode</span>.ThreadPolicy.Builder()</span><br><span class="line">        .detectDiskReads()</span><br><span class="line">        .detectDiskWrites()</span><br><span class="line">        .detectNetwork()  </span><br><span class="line">        .penaltyLog()</span><br><span class="line">        .build());</span><br><span class="line"></span><br><span class="line">StrictMode.setVmPolicy(<span class="keyword">new</span> <span class="title class_">StrictMode</span>.VmPolicy.Builder()</span><br><span class="line">        .detectLeakedSqlLiteObjects()</span><br><span class="line">        .detectLeakedClosableObjects()</span><br><span class="line">        .detectActivityLeaks()</span><br><span class="line">        .penaltyLog()</span><br><span class="line">        .build());</span><br></pre></td></tr></table></figure><p><strong>BlockCanary</strong></p><p>BlockCanary是一个非侵入式式的性能监控函数库，它的用法和leakCanary类似，只不过后者监控应用的内存泄露，而BlockCanary主要用来监控应用主线程的卡顿。它的基本原理是利用主线程的消息队列处理机制，通过对比消息分发开始和结束的时间点来判断是否超过设定的时间，如果是，则判断为主线程卡顿。它的集成很简单，首先在build.gradle中添加依赖</p><p>一般选取以下其中一个 case 引入即可</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">&#x27;com.github.markzhai:blockcanary-android:1.5.0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅在debug包启用BlockCanary进行卡顿监控和提示的话，可以这么用</span></span><br><span class="line">    debugCompile <span class="string">&#x27;com.github.markzhai:blockcanary-android:1.5.0&#x27;</span></span><br><span class="line">    releaseCompile <span class="string">&#x27;com.github.markzhai:blockcanary-no-op:1.5.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在Application类中进行配置和初始化即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnrDemoApplication</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        <span class="comment">// 在主进程初始化调用哈</span></span><br><span class="line">        BlockCanary.install(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">AppBlockCanaryContext</span>()).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现自己监控的上下文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppBlockCanaryContext</span> <span class="keyword">extends</span> <span class="title class_">BlockCanaryContext</span> &#123;</span><br><span class="line">    <span class="comment">// 实现各种上下文，包括应用标示符，用户uid，网络类型，卡慢判断阙值，Log保存位置等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implement in your project.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Qualifier which can specify this installation, like version + flavor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">provideQualifier</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implement in your project.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">provideUid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;uid&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Network type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125; like 2G, 3G, 4G, wifi, etc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">provideNetworkType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Config monitor duration, after this time BlockCanary will stop, use</span></span><br><span class="line"><span class="comment">     * with &#123;<span class="doctag">@code</span> BlockCanary&#125;&#x27;s isMonitorDurationEnd</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> monitor last duration (in hour)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">provideMonitorDuration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Config block threshold (in millis), dispatch over this duration is regarded as a BLOCK. You may set it</span></span><br><span class="line"><span class="comment">     * from performance of device.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> threshold in mills</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">provideBlockThreshold</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread stack dump interval, use when block happens, BlockCanary will dump on main thread</span></span><br><span class="line"><span class="comment">     * stack according to current sample cycle.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Because the implementation mechanism of Looper, real dump interval would be longer than</span></span><br><span class="line"><span class="comment">     * the period specified here (especially when cpu is busier).</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> dump interval (in millis)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">provideDumpInterval</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> provideBlockThreshold();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Path to save log, like &quot;/blockcanary/&quot;, will save to sdcard if can.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> path of log files</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">providePath</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/blockcanary/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If need notification to notice block.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if need, else if not need.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">displayNotification</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implement in your project, bundle files into a zip file.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src  files before compress</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dest files compressed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if compression is successful</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">zip</span><span class="params">(File[] src, File dest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implement in your project, bundled log files.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zippedFile zipped file</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">upload</span><span class="params">(File zippedFile)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Packages that developer concern, by default it uses process name,</span></span><br><span class="line"><span class="comment">     * put high priority one in pre-order.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null if simply concern only package with process name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">concernPackages</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Filter stack without any in concern package, used with @&#123;code concernPackages&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if filter, false it not.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filterNonConcernStack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Provide white list, entry in white list will not be shown in ui list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> return null if you don&#x27;t need white-list filter.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">provideWhiteList</span><span class="params">()</span> &#123;</span><br><span class="line">        LinkedList&lt;String&gt; whiteList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        whiteList.add(<span class="string">&quot;org.chromium&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> whiteList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Whether to delete files whose stack is in white list, used with white-list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if delete, false it not.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteFilesInWhiteList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Block interceptor, developer may provide their own actions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBlock</span><span class="params">(Context context, BlockInfo blockInfo)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在AndroidManifest.xml文件中声明Application，一定不要忘记</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/f14a0afe75eb5367a96f369f4ced1609" alt="这里写图片描述"></p><p>现在就已经将BlockCanary集成到应用里面了，接下来，编译安装到手机上，点击<a href="http://lib.csdn.net/base/softwaretest">测试</a>按钮，将产生一个ANR,效果如图：</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/7165ec7fa1d2f7cccbab22ad839312b6" alt="这里写图片描述"></p><h3 id="APK减包"><a href="#APK减包" class="headerlink" title="APK减包"></a>APK减包</h3><p><a href="https://blog.csdn.net/whb20081815/article/details/70140063">https://blog.csdn.net/whb20081815/article/details/70140063</a></p><h3 id="Android控件为什么不能加锁？"><a href="#Android控件为什么不能加锁？" class="headerlink" title="Android控件为什么不能加锁？"></a>Android控件为什么不能加锁？</h3><p>这是因为Android的UI线程是不安全的,如果在多线程中并发访问可能会导致UI控件处于不可预期的状态.</p><p>那么为什么不对UI控件的访问加上锁机制呢?缺点有两个:首先加上锁机制会让UI访问逻辑变的复杂,其次锁机制会降低UI的访问效率,因为锁机制会阻塞某些线程的执行(?).</p><p><strong>检测机制：ViewRootImpl的checkThread()检测当前线程是否是UI线程，否则抛异常</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">checkThread</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CalledFromWrongThreadException</span>(</span><br><span class="line"><span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子线程更新UI"><a href="#子线程更新UI" class="headerlink" title="子线程更新UI"></a>子线程更新UI</h3><p><a href="https://juejin.im/post/6844903968435503112">https://juejin.im/post/6844903968435503112</a></p><p>一般的View有一个Surface，并且对应SurfaceFlinger的一块内存区域。这个本地Surface和View是绑定的，他的绘制操作，最终都会调用到ViewRootImpl，那么这个就会被检查是否主线程了，所以只要在ViewRootImpl启动后，访问UI的所有操作都不可以在子线程中进行。</p><p>那SurfaceView为什么可以子线程访问他的画布呢？如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title class_">SurfaceHolder</span>.Callback &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="type">SurfaceView</span> <span class="variable">surfaceView</span> <span class="operator">=</span> findViewById(R.id.sv);</span><br><span class="line">        surfaceView.getHolder().addCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceCreated</span><span class="params">(<span class="keyword">final</span> SurfaceHolder holder)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                   <span class="type">Canvas</span> <span class="variable">canvas</span> <span class="operator">=</span> holder.lockCanvas();</span><br><span class="line">                   canvas.drawColor(Color.RED);</span><br><span class="line">                   holder.unlockCanvasAndPost(canvas);</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="type">int</span> format, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实查看SurfaceView的代码，可以发现他自带一个Surface</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SurfaceView</span> <span class="keyword">extends</span> <span class="title class_">View</span> <span class="keyword">implements</span> <span class="title class_">ViewRootImpl</span>.WindowStoppedCallback &#123;</span><br><span class="line">    ...</span><br><span class="line">   <span class="keyword">final</span> <span class="type">Surface</span> <span class="variable">mSurface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Surface</span>();   </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在SurfaceView的updateSurface()中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">updateSurface</span><span class="params">()</span> &#123;</span><br><span class="line">....</span><br><span class="line">  <span class="keyword">if</span> (creating) &#123;</span><br><span class="line">    <span class="comment">//View自带Surface的创建</span></span><br><span class="line">       mSurfaceSession = <span class="keyword">new</span> <span class="title class_">SurfaceSession</span>(viewRoot.mSurface);</span><br><span class="line">      mDeferredDestroySurfaceControl = mSurfaceControl;</span><br><span class="line">      updateOpaqueFlag();</span><br><span class="line">      <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;SurfaceView - &quot;</span> + viewRoot.getTitle().toString();</span><br><span class="line">      mSurfaceControl = <span class="keyword">new</span> <span class="title class_">SurfaceControlWithBackground</span>(</span><br><span class="line">          name,</span><br><span class="line">          (mSurfaceFlags &amp; SurfaceControl.OPAQUE) != <span class="number">0</span>,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">SurfaceControl</span>.Builder(mSurfaceSession)</span><br><span class="line">               .setSize(mSurfaceWidth, mSurfaceHeight)</span><br><span class="line">              .setFormat(mFormat)</span><br><span class="line">              .setFlags(mSurfaceFlags));</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//SurfaceView 中自带的Surface</span></span><br><span class="line">   <span class="keyword">if</span> (creating) &#123;</span><br><span class="line">      mSurface.copyFrom(mSurfaceControl);</span><br><span class="line">  &#125;            </span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SurfaceView中的mSurface也有在SurfaceFlinger对应的内存区域，这样就很容易实现子线程访问画布了。</p><p>这样设计有什么不好的地方吗？</p><p>因为这个 mSurface 不在 View 体系中，它的显示也不受 View 的属性控制，所以不能进行平移，缩放等变换，也不能放在其它 ViewGroup 中，一些 View 中的特性也无法使用。</p><h3 id="AsyncTask使用和缺陷"><a href="#AsyncTask使用和缺陷" class="headerlink" title="AsyncTask使用和缺陷"></a>AsyncTask使用和缺陷</h3><p>一、AsyncTask的基本用法</p><p>由于AsyncTask是一个抽象类，所以如果我们想使用它，就必须要创建一个子类去继承它。在继承时我们可以为AsyncTask类指定三个泛型参数，这三个参数的用途如下：</p><ol><li><p>Params<br>在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。</p></li><li><p>Progress<br>后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。</p></li><li><p>Result<br>当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。</p></li></ol><p>因此，一个最简单的自定义AsyncTask就可以写成如下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DownloadTask</span> <span class="keyword">extends</span> <span class="title class_">AsyncTask</span>&lt;Void, Integer, Boolean&gt; &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们把AsyncTask的第一个泛型参数指定为Void，表示在执行AsyncTask的时候不需要传入参数给后台任务。第二个泛型参数指定为Integer，表示使用整型数据来作为进度显示单位。第三个泛型参数指定为Boolean，则表示使用布尔型数据来反馈执行结果。</p><p>当然，目前我们自定义的DownloadTask还是一个空任务，并不能进行任何实际的操作，我们还需要去重写AsyncTask中的几个方法才能完成对任务的定制。经常需要去重写的方法有以下四个：</p><ol><li><p>onPreExecute()<br>这个方法会在后台任务开始执行之间调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。</p></li><li><p>doInBackground(Params…)<br>这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过return语句来将任务的执行结果进行返回，如果AsyncTask的第三个泛型参数指定的是Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用publishProgress(Progress…)方法来完成。</p></li><li><p>onProgressUpdate(Progress…)<br>当在后台任务中调用了publishProgress(Progress…)方法后，这个方法就很快会被调用，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。</p></li><li><p>onPostExecute(Result)<br>当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。因此，一个比较完整的自定义AsyncTask就可以写成如下方式：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DownloadTask</span> <span class="keyword">extends</span> <span class="title class_">AsyncTask</span>&lt;Void, Integer, Boolean&gt; &#123;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPreExecute</span><span class="params">()</span> &#123;</span><br><span class="line">progressDialog.show();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Boolean <span class="title function_">doInBackground</span><span class="params">(Void... params)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">downloadPercent</span> <span class="operator">=</span> doDownload();</span><br><span class="line">publishProgress(downloadPercent);</span><br><span class="line"><span class="keyword">if</span> (downloadPercent &gt;= <span class="number">100</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onProgressUpdate</span><span class="params">(Integer... values)</span> &#123;</span><br><span class="line">progressDialog.setMessage(<span class="string">&quot;当前下载进度：&quot;</span> + values[<span class="number">0</span>] + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPostExecute</span><span class="params">(Boolean result)</span> &#123;</span><br><span class="line">progressDialog.dismiss();</span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line">Toast.makeText(context, <span class="string">&quot;下载成功&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Toast.makeText(context, <span class="string">&quot;下载失败&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们模拟了一个下载任务，在doInBackground()方法中去执行具体的下载逻辑，在onProgressUpdate()方法中显示当前的下载进度，在onPostExecute()方法中来提示任务的执行结果。如果想要启动这个任务，只需要简单地调用以下代码即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">DownloadTask</span>().execute();</span><br></pre></td></tr></table></figure><p>以上就是AsyncTask的基本用法，我们并不需求去考虑什么异步消息处理机制，也不需要专门使用一个Handler来发送和接收消息，只需要调用一下<strong>publishProgress()</strong>方法就可以轻松地从子线程切换到UI线程了。</p><p>二、AsyncTask内部线程池</p><p>AnsycTask执行任务时，内部会创建一个进程作用域的线程池来管理要运行的任务，也就就是说当你调用了AsyncTask.execute()后，AsyncTask会把任务交给线程池，由线程池来管理创建Thread和运行Therad。对于内部的线程池不同版本的Android的实现方式是不一样的：</p><p>3.0之前规定同一时刻能够运行的线程数为5个，线程池总大小为128。也就是说当我们启动了10个任务时，只有5个任务能够立刻执行，另外的5个任务则需要等待，当有一个任务执行完毕后，第6个任务才会启动，以此类推。而线程池中最大能存放的线程数是128个，当我们尝试去添加第129个任务时，程序就会崩溃。</p><p>因此在3.0版本中AsyncTask的改动还是挺大的，在3.0之前的AsyncTask可以同时有5个任务在执行，而3.0之后的AsyncTask同时只能有1个任务在执行。为什么升级之后可以同时执行的任务数反而变少了呢？这是因为更新后的AsyncTask已变得更加灵活，如果不想使用默认的线程池，还可以自由地进行配置。比如使用如下的代码来启动任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Executor</span> <span class="variable">exec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">15</span>, <span class="number">200</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">DownloadTask</span>().executeOnExecutor(exec);</span><br></pre></td></tr></table></figure><p>这样就可以使用我们自定义的一个Executor来执行任务，而不是使用SerialExecutor。上述代码的效果允许在同一时刻有15个任务正在执行，并且最多能够存储200个任务。</p><p>三、AsyncTask缺陷</p><p> 1.生命周期</p><p>关于AsyncTask存在一个这样广泛的误解，很多人认为一个在Activity中的AsyncTask会随着Activity的销毁而销毁。然后事实并非如此。AsyncTask会一直执行doInBackground()方法直到方法执行结束。一旦上述方法结束，会依据情况进行不同的操作。<br> •如果cancel(boolean)调用了，则执行onCancelled(Result)方法<br> •如果cancel(boolean)没有调用，则执行onPostExecute(Result)方法</p><p>AsyncTask的cancel方法需要一个布尔值的参数，参数名为mayInterruptIfRunning,意思是如果正在执行是否可以打断,如果这个值设置为true，表示这个任务可以被打断，否则，正在执行的程序会继续执行直到完成。如果在doInBackground()方法中有一个循环操作，我们应该在循环中使用isCancelled()来判断，如果返回为true，我们应该避免执行后续无用的循环操作。</p><p>总之，我们使用AsyncTask需要确保AsyncTask正确地取消。</p><p>2.不好好工作的cancel()</p><p>简而言之的答案，<strong>有时候起作用</strong>。</p><p>如果你调用了AsyncTask的cancel(false)，doInBackground()仍然会执行到方法结束，只是不会去调用onPostExecute()方法。但是实际上这是让应用程序执行了没有意义的操作。那么是不是我们调用cancel(true)前面的问题就能解决呢？并非如此。如果mayInterruptIfRunning设置为true，会使任务尽早结束，但是如果的doInBackground()有不可打断的方法会失效，比如这个BitmapFactory.decodeStream() IO操作。但是你可以提前关闭IO流并捕获这样操作抛出的异常。但是这样会使得cancel()方法没有任何意义。</p><p>3.内存泄露</p><p>还有一种常见的情况就是，在Activity中使用非静态匿名内部AsyncTask类，由于Java内部类的特点，AsyncTask内部类会持有外部类的隐式引用。由于AsyncTask的生命周期可能比Activity的长，当Activity进行销毁AsyncTask还在执行时，由于AsyncTask持有Activity的引用，导致Activity对象无法回收，进而产生内存泄露。</p><p>4.结果丢失</p><p>另一个问题就是在屏幕旋转等造成Activity重新创建时AsyncTask数据丢失的问题。当Activity销毁并重新创建后，还在运行的AsyncTask会持有一个Activity的非法引用即之前的Activity实例。导致onPostExecute()没有任何作用。</p><p>5.串行还是并行</p><p>下面的两个任务时同时执行呢，还是AsyncTask1执行结束之后，AsyncTask2才能执行呢？实际上是结果依据API不同而不同。<br>关于AsyncTask时串行还是并行有很多疑问，这很正常，因为它经过多次的修改。如果你并不明白什么时串行还是并行，可以通过接下来的例子了解，假设我们在一个方法体里面有如下两行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">AsyncTask1</span>.execute();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">AsyncTask2</span>.execute();</span><br></pre></td></tr></table></figure><p>在1.6(Donut)之前:<br>在第一版的AsyncTask，任务是串行调度。一个任务执行完成另一个才能执行。由于串行执行任务，使用多个AsyncTask可能会带来有些问题。所以这并不是一个很好的处理异步（尤其是需要将结果作用于UI试图）操作的方法。</p><p>从1.6到2.3(Gingerbread)<br>后来Android团队决定让AsyncTask并行来解决1.6之前引起的问题，这个问题是解决了，新的问题又出现了。很多开发者实际上依赖于顺序执行的行为。于是很多并发的问题蜂拥而至。</p><p>3.0（Honeycomb）到现在<br>好吧，开发者可能并不喜欢让AsyncTask并行，于是Android团队又把AsyncTask改成了串行。当然这一次的修改并没有完全禁止AsyncTask并行。你可以通过设置executeOnExecutor(Executor)来实现多个AsyncTask并行。关于API文档的描述如下<br>If we want to make sure we have control over the execution, whether it will run serially or parallel, we can check at runtime with this code to make sure it runs parallel</p><p>6.真的需要AsyncTask么</p><p>并非如此，使用AsyncTask虽然可以以简短的代码实现异步操作，但是正如本文提到的，你需要让AsyncTask正常工作的话，需要注意很多条条框框。推荐的一种进行异步操作的技术就是使用Loaders。这个方法从Android 3.0 (Honeycomb)开始引入，在android支持包中也有包含。可以通过查看官方的文档来详细了解Loaders。</p><h3 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h3><p>HandlerThread是Thread的一个子类，HandlerThread自带Looper使他可以通过消息队列来重复使用当前线程，节省系统资源开销。这是它的优点也是缺点，每一个任务都将以队列的方式逐个被执行到，一旦队列中有某个任务执行时间过长，那么就会导致后续的任务都会被延迟处理。它的使用也比较简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HandlerThread thread = <span class="keyword">new</span> <span class="built_in">HandlerThread</span>(<span class="string">&quot;MyHandlerThread&quot;</span>);</span><br><span class="line">thread.<span class="built_in">start</span>();</span><br><span class="line">mHandler = <span class="keyword">new</span> <span class="built_in">Handler</span>(thread.<span class="built_in">getLooper</span>());</span><br><span class="line">mHandler.<span class="built_in">post</span>(<span class="keyword">new</span> <span class="built_in">Runnable</span>()&#123;...&#125;);</span><br></pre></td></tr></table></figure><p>HandlerThread的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="type">int</span> mPriority;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mTid</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    Looper mLooper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HandlerThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Call back method that can be explicitly overridden if needed to execute some</span></span><br><span class="line"><span class="comment">     * setup before Looper loops.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLooperPrepared</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的代码比较短，我们主要来看一下它的run()方法，我们发现它和普通Thread不同之处在于它在run()方法内创建了一个消息队列（如果不太了解消息机制的同学可以看一下<a href="https://www.jianshu.com/p/1f1163f54aa7">Android中的消息机制</a>来了解一下），然后来通过Handler的消息的方式来通知HandlerThread执行下一个具体的任务。由于HandlerThread的run()方法内Looper是个无限循环，所以当我们不需要使用HandlerThread的时候可以通过qiut()的方法来终止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Looper</span> <span class="variable">looper</span> <span class="operator">=</span> getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="literal">null</span>) &#123;</span><br><span class="line">            looper.quit();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>quit()实际上就是让run()内的Looper停止循环。</p><p>当我们使用HandlerThread创建一个线程，它statr()之后会在它的线程创建一个Looper对象且初始化了一个MessageQueue(<a href="https://www.jianshu.com/p/1f1163f54aa7">消息队列</a>），通过Looper对象在他的线程构建一个Handler对象，然后我们通过Handler发送消息的形式将任务发送到MessageQueue中，因为Looper是顺序处理消息的，所以当有多个任务存在时就会顺序的排队执行。当我们不使用的时候我们应该调用它的quit()或者quitSafely()来终止它的循环。</p><p><a href="https://blog.csdn.net/carson_ho/article/details/79285760">https://blog.csdn.net/carson_ho/article/details/79285760</a></p><h3 id="插件化和组件化"><a href="#插件化和组件化" class="headerlink" title="插件化和组件化"></a>插件化和组件化</h3><p><a href="https://juejin.im/post/6844903649102004231">https://juejin.im/post/6844903649102004231</a></p><p><a href="https://www.jianshu.com/p/79e4df63f31f">https://www.jianshu.com/p/79e4df63f31f</a></p><p><a href="https://www.jianshu.com/p/b42b5ce09e2c">https://www.jianshu.com/p/b42b5ce09e2c</a></p><h3 id="64匹马-8个赛道-找出前4名最少比赛多少场"><a href="#64匹马-8个赛道-找出前4名最少比赛多少场" class="headerlink" title="64匹马,8个赛道,找出前4名最少比赛多少场?"></a>64匹马,8个赛道,找出前4名最少比赛多少场?</h3><p><strong>第一步</strong>：全部马分8组，各跑一次，然后淘汰掉每组的后四名（8次）；</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/110817-20160127233530379-1057511397.png" alt="img"></p><p>第二步：取每组第一名进行一次比赛，然后淘汰最后四名所在组的所有马（1次）：</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/110817-20160127233850067-1986622269.png" alt="img"></p><p>分析：其实这时候红色区域的马也可以淘汰了，A1可以直接晋级；</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/110817-20160127234620488-978837349.png" alt="img"></p><p>第三步：A2、A3、A4、B2、B3、C1、C2、D1八匹马跑一次，即：在剩下需要排名的马中，除了B1外，其它8匹马跑一次（1次）</p><p>分类讨论：</p><p>1、如果这次排名，B2或C1能进前三名，则加上B1后，B1一定能进前三名，因为B1 排名比B2和C1都要靠前；</p><p>   到此比赛可以结束了；<strong>这种情况8+1+1＝10次出结果；</strong></p><p>2、如果这次排名，B2或C1不能进入前三名，则需要<strong>再进行一次</strong>比赛，B1、A2、A3、A4进行，取前三名：</p><p>   <strong>这种情况8+1+1+1=11次出结果。</strong></p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/110817-20160128000700692-1341932831.png" alt="img"></p><h3 id="application-context不能干嘛"><a href="#application-context不能干嘛" class="headerlink" title="application context不能干嘛"></a>application context不能干嘛</h3><p><strong> Context到底是什么</strong></p><p>Context的中文翻译为：语境; 上下文; 背景; 环境，在开发中我们经常说称之为“上下文”，那么这个“上下文”到底是指什么意思呢？在语文中，我们可以理解为语境，在程序中，我们可以理解为当前对象在程序中所处的一个环境，一个与系统交互的过程。比如微信聊天，此时的“环境”是指聊天的界面以及相关的数据请求与传输，Context在加载资源、启动Activity、获取系统服务、创建View等操作都要参与。</p><p>那Context到底是什么呢？一个Activity就是一个Context，一个Service也是一个Context。Android程序员把“场景”抽象为Context类，他们认为用户和操作系统的每一次交互都是一个场景，比如打电话、发短信，这些都是一个有界面的场景，还有一些没有界面的场景，比如后台运行的服务（Service）。一个应用程序可以认为是一个工作环境，用户在这个环境中会切换到不同的场景，这就像一个前台秘书，她可能需要接待客人，可能要打印文件，还可能要接听客户电话，而这些就称之为不同的场景，前台秘书可以称之为一个应用程序。</p><p><strong>如何生动形象的理解Context</strong></p><p>上面的概念中采用了通俗的理解方式，将Context理解为“上下文”或者“场景”，如果你仍然觉得很抽象，不好理解。在这里我给出一个可能不是很恰当的比喻，希望有助于大家的理解：一个Android应用程序，可以理解为一部电影或者一部电视剧，Activity，Service，Broadcast Receiver，Content Provider这四大组件就好比是这部戏里的四个主角：胡歌，霍建华，诗诗，Baby。他们是由剧组（系统）一开始就定好了的，整部戏就是由这四位主演领衔担纲的，所以这四位主角并不是大街上随随便便拉个人（new 一个对象）都能演的。有了演员当然也得有摄像机拍摄啊，他们必须通过镜头（Context）才能将戏传递给观众，这也就正对应说四大组件（四位主角）必须工作在Context环境下（摄像机镜头）。那Button，TextView，LinearLayout这些控件呢，就好比是这部戏里的配角或者说群众演员，他们显然没有这么重用，随便一个路人甲路人乙都能演（可以new一个对象），但是他们也必须要面对镜头（工作在Context环境下），所以<code>Button mButton=new Button（Context）</code>是可以的。虽然不很恰当，但还是很容易理解的，希望有帮助。</p><p><strong>源码中的Context</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface to global information about an application environment.  This is</span></span><br><span class="line"><span class="comment"> * an abstract class whose implementation is provided by</span></span><br><span class="line"><span class="comment"> * the Android system.  It</span></span><br><span class="line"><span class="comment"> * allows access to application-specific resources and classes, as well as</span></span><br><span class="line"><span class="comment"> * up-calls for application-level operations such as launching activities,</span></span><br><span class="line"><span class="comment"> * broadcasting and receiving intents, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * File creation mode: the default mode, where the created file can only</span></span><br><span class="line"><span class="comment">     * be accessed by the calling application (or all applications sharing the</span></span><br><span class="line"><span class="comment">     * same user ID).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #MODE_WORLD_READABLE</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #MODE_WORLD_WRITEABLE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MODE_PRIVATE</span> <span class="operator">=</span> <span class="number">0x0000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MODE_WORLD_WRITEABLE</span> <span class="operator">=</span> <span class="number">0x0002</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MODE_APPEND</span> <span class="operator">=</span> <span class="number">0x8000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MODE_MULTI_PROCESS</span> <span class="operator">=</span> <span class="number">0x0004</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>源码中的注释是这么来解释Context的：Context提供了关于应用环境全局信息的接口。它是一个抽象类，它的执行被Android系统所提供。它允许获取以应用为特征的资源和类型，是一个统领一些资源（应用程序环境变量等）的上下文。就是说，它描述一个应用程序环境的信息（即上下文）；是一个抽象类，Android提供了该抽象类的具体实现类；通过它我们可以获取应用程序的资源和类（包括应用级别操作，如启动Activity，发广播，接受Intent等）。既然上面Context是一个抽象类，那么肯定有他的实现类咯，我们在Context的源码中通过IDE可以查看到他的子类最终可以得到如下关系图：</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/1187237-1b4c0cd31fd0193f.png" alt="img"></p><p>Context类本身是一个纯abstract类，它有两个具体的实现子类：ContextImpl和ContextWrapper。其中ContextWrapper类，如其名所言，这只是一个包装而已，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper中提供了attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象，调用ContextWrapper的方法都会被转向其所包含的真正的Context对象。ContextThemeWrapper类，如其名所言，其内部包含了与主题（Theme）相关的接口，这里所说的主题就是指在AndroidManifest.xml中通过android：theme为Application元素或者Activity元素指定的主题。当然，只有Activity才需要主题，Service是不需要主题的，因为Service是没有界面的后台场景，所以Service直接继承于ContextWrapper，Application同理。而ContextImpl类则真正实现了Context中的所以函数，应用程序中所调用的各种Context类的方法，其实现均来自于该类。一句话总结：Context的两个子类分工明确，其中ContextImpl是Context的具体实现类，ContextWrapper是Context的包装类。Activity，Application，Service虽都继承自ContextWrapper（Activity继承自ContextWrapper的子类ContextThemeWrapper），但它们初始化的过程中都会创建ContextImpl对象，由ContextImpl实现Context中的方法。</p><p><strong>一个应用程序有几个Context</strong></p><p>其实这个问题本身并没有什么意义，关键还是在于对Context的理解，从上面的关系图我们已经可以得出答案了，在应用程序中Context的具体实现子类就是：Activity，Service，Application。那么<code>Context数量=Activity数量+Service数量+1</code>。当然如果你足够细心，可能会有疑问：我们常说四大组件，这里怎么只有Activity，Service持有Context，那Broadcast Receiver，Content Provider呢？Broadcast Receiver，Content Provider并不是Context的子类，他们所持有的Context都是其他地方传过去的，所以并不计入Context总数。上面的关系图也从另外一个侧面告诉我们Context类在整个Android系统中的地位是多么的崇高，因为很显然Activity，Service，Application都是其子类，其地位和作用不言而喻。</p><p><strong>Context作用域</strong></p><p>虽然Context神通广大，但并不是随便拿到一个Context实例就可以为所欲为，它的使用还是有一些规则限制的。由于Context的具体实例是由ContextImpl类去实现的，因此在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity，还有弹出Dialog。出于安全原因的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/1187237-fb32b0f992da4781.png" alt="img"></p><p>从上图我们可以发现Activity所持有的Context的作用域最广，无所不能。因为Activity继承自ContextThemeWrapper，而Application和Service继承自ContextWrapper，很显然ContextThemeWrapper在ContextWrapper的基础上又做了一些操作使得Activity变得更强大，这里我就不再贴源码给大家分析了，有兴趣的童鞋可以自己查查源码。上图中的YES和NO我也不再做过多的解释了，这里我说一下上图中Application和Service所不推荐的两种使用情况。<br>1：如果我们用ApplicationContext去启动一个LaunchMode为standard的Activity的时候会报错<code>android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</code>这是因为非Activity类型的Context并没有所谓的任务栈，所以待启动的Activity就找不到栈了。解决这个问题的方法就是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就为它创建一个新的任务栈，而此时Activity是以singleTask模式启动的。所有这种用Application启动Activity的方式不推荐使用，Service同Application。<br>2：在Application和Service中去layout inflate也是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。所以这种方式也不推荐使用。<br>一句话总结：凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。</p><p><strong>如何获取Context</strong></p><p>通常我们想要获取Context对象，主要有以下四种方法<br>1：View.getContext,返回当前View对象的Context对象，通常是当前正在展示的Activity对象。<br>2：Activity.getApplicationContext,获取当前Activity所在的(应用)进程的Context对象，通常我们使用Context对象时，要优先考虑这个全局的进程Context。<br>3：ContextWrapper.getBaseContext():用来获取一个ContextWrapper进行装饰之前的Context，可以使用这个方法，这个方法在实际开发中使用并不多，也不建议使用。<br>4：Activity.this 返回当前的Activity实例，如果是UI控件需要使用Activity作为Context对象，但是默认的Toast实际上使用ApplicationContext也可以。</p><p><strong>Application中的Context和Activity中的Context的区别 </strong></p><p>在需要传递Context参数的时候，如果是在Activity中，我们可以传递this（这里的this指的是Activity.this，是当前Activity的上下文）或者Activity.this。这个时候如果我们传入getApplicationContext()，我们会发现这样也是可以用的。可是大家有没有想过传入Activity.this和传入getApplicationContext()的区别呢？首先Activity.this和getApplicationContext()返回的不是同一个对象，一个是当前Activity的实例，一个是项目的Application的实例，这两者的生命周期是不同的，它们各自的使用场景不同，this.getApplicationContext()取的是这个应用程序的Context，它的生命周期伴随应用程序的存在而存在；而Activity.this取的是当前Activity的Context，它的生命周期则只能存活于当前Activity，这两者的生命周期是不同的。getApplicationContext() 生命周期是整个应用，当应用程序摧毁的时候，它才会摧毁；Activity.this的context是属于当前Activity的，当前Activity摧毁的时候，它就摧毁。</p><p><strong>getApplication()和getApplicationContext()</strong></p><p>上面说到获取当前Application对象用getApplicationContext，不知道你有没有联想到getApplication()，这两个方法有什么区别？相信这个问题会难倒不少开发者。</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/1187237-593b912ecd199046.png" alt="img"></p><p>getApplication()&amp;getApplicationContext().png</p><p>程序是不会骗人的，我们通过上面的代码，打印得出两者的内存地址都是相同的，看来它们是同一个对象。其实这个结果也很好理解，因为前面已经说过了，Application本身就是一个Context，所以这里获取getApplicationContext()得到的结果就是Application本身的实例。那么问题来了，既然这两个方法得到的结果都是相同的，那么Android为什么要提供两个功能重复的方法呢？实际上这两个方法在作用域上有比较大的区别。getApplication()方法的语义性非常强，一看就知道是用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法了。</p><p><strong>正确使用Context</strong></p><p>一般Context造成的内存泄漏，几乎都是当Context销毁的时候，却因为被引用导致销毁失败，而Application的Context对象可以理解为随着进程存在的，所以我们总结出使用Context的正确姿势：<br>1：当Application的Context能搞定的情况下，并且生命周期长的对象，优先使用Application的Context。<br>2：不要让生命周期长于Activity的对象持有到Activity的引用。<br>3：尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐式持有外部类实例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有。</p><h3 id="为什么-Dialog不能使用Application的Context"><a href="#为什么-Dialog不能使用Application的Context" class="headerlink" title="为什么 Dialog不能使用Application的Context"></a>为什么 Dialog不能使用Application的Context</h3><p>参考<a href="https://www.jianshu.com/p/92392088a7a8">简书</a></p><h3 id="图片三级缓存加载"><a href="#图片三级缓存加载" class="headerlink" title="图片三级缓存加载"></a>图片三级缓存加载</h3><p>参考<a href="https://www.jianshu.com/p/05715546ac23">简书</a></p><h3 id="AtomicInteger如何保证线程安全"><a href="#AtomicInteger如何保证线程安全" class="headerlink" title="AtomicInteger如何保证线程安全"></a>AtomicInteger如何保证线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This class intended to be implemented using VarHandles, but there</span></span><br><span class="line"><span class="comment">     * are unresolved cyclic startup dependencies.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.<span class="type">Unsafe</span> <span class="variable">U</span> <span class="operator">=</span> jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">VALUE</span> <span class="operator">=</span> U.objectFieldOffset(AtomicInteger.class, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicInteger with the given initial value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">(<span class="type">int</span> initialValue)</span> &#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicInteger with initial value &#123;<span class="doctag">@code</span> 0&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> U.getAndAddInt(<span class="built_in">this</span>, VALUE, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>用volatile关键字修饰value字段<br>AtomicInteger用value字段来存储数据值，volatile关键字保证了value字段对各个线程的可见性。各线程读取value字段时，会先从主内存把数据同步到工作内存，这样保证可见性。</li><li>Unsafe实现操作原子性，用户在使用时无需额外的同步操作。<br>如AtomicInteger提供了自增方法getAndIncrement，其内部实现是由Unsafe类的compareAndSetInt方法来保证的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk.internal.misc.Unsafe</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically updates Java variable to &#123;<span class="doctag">@code</span> x&#125; if it is currently</span></span><br><span class="line"><span class="comment"> * holding &#123;<span class="doctag">@code</span> expected&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><br><span class="line"><span class="comment"> * and write.  Corresponds to C11 atomic_compare_exchange_strong.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSetInt</span><span class="params">(Object o, <span class="type">long</span> offset,<span class="type">int</span> expected, <span class="type">int</span> x)</span>;</span><br></pre></td></tr></table></figure><p>compareAndSetInt方法是一个CAS操作，用native关键字修饰。<br>原理：先比较内存中的值与expected是否一致，一致的前提下才赋予新的值x，此时返回true，否则返回false。</p><h3 id="锁升级机制"><a href="#锁升级机制" class="headerlink" title="锁升级机制"></a>锁升级机制</h3><p>参考<a href="https://blog.csdn.net/zwx900102/article/details/106305107?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">CSDN</a></p><h3 id="为什么内部类会默认持有外部类的引用？"><a href="#为什么内部类会默认持有外部类的引用？" class="headerlink" title="为什么内部类会默认持有外部类的引用？"></a>为什么内部类会默认持有外部类的引用？</h3><p>Java中，非静态的内部类和匿名内部类都会隐式地持有其外部类的引用。静态的内部类不会持有外部类的引用。</p><p>关于内部类如何访问外部类的成员， 分析之后其实也很简单， 主要是通过以下几步做到的：</p><p>1 编译器自动为内部类添加一个成员变量， 这个成员变量的类型和外部类的类型相同， 这个成员变量就是指向外部类对象的引用；</p><p>2 编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型， 在构造方法内部使用这个参数为1中添加的成员变量赋值；</p><p>3 在调用内部类的构造函数初始化内部类对象时， 会默认传入外部类的引用。</p><h3 id="View中的post和handler的post有什么区别？"><a href="#View中的post和handler的post有什么区别？" class="headerlink" title="View中的post和handler的post有什么区别？"></a>View中的post和handler的post有什么区别？</h3><p>参考<a href="https://juejin.im/entry/6844903473306157063">掘金</a></p><p>Handler的工作机制，网上介绍的文章太多了，这里我就不赘述了，想继续了解的同学可以参考下这篇文章：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fxiaoweiz%2Fp%2F3660585.html">Handler源码分析</a>。一句话总结就是通过Handler对象，不论是post Msg还是Runnable，最终都是构造了一个Msg对象，插入到与之对应的Looper的MessageQueue中，不同的是Running时msg对象的callback字段设成了Runnable的值。稍后这条msg会从队列中取出来并且得到执行，UI线程就是这么一个基于事件的循环。所以可以看出Handler.post相关的代码在onCreate里那一刻时就已经开始了执行（加入到了队列，下次循环到来时就会被真正执行了）。</p><p>View.post</p><p>要解释它的行为，我们就必须深入代码中去找答案了，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">post</span><span class="params">(Runnable action)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AttachInfo</span> <span class="variable">attachInfo</span> <span class="operator">=</span> mAttachInfo;</span><br><span class="line">        <span class="keyword">if</span> (attachInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 注意这个判断，这个变量时机太早的话是没值的，</span></span><br><span class="line">           <span class="comment">// 比如在act#onCreate阶段 </span></span><br><span class="line">            <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 仔细阅读下面这段注释！！！</span></span><br><span class="line">        <span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></span><br><span class="line">        <span class="comment">// Assume that the runnable will be successfully placed after attach.</span></span><br><span class="line">        getRunQueue().post(action);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面的源码，我们大概可以看出<code>mAttachInfo</code>字段在这里比较关键，当其有值时，其实和普通的<code>Handler.post</code>就没区别了，但有时它是没值的，比如我们上面示例代码里的onCreate阶段，那么这时执行到了<code>getRunQueue().post(action);</code>这行代码，从这段注释也大概可以看出来真正的执行会被延迟（这里的<code>Postpone</code>注释）；我们接着往下看看getRunQueue相关的代码，如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  其实这段注释已经说的很清楚明了了！！！</span></span><br><span class="line"><span class="comment">     * Queue of pending runnables. Used to postpone calls to post() until this</span></span><br><span class="line"><span class="comment">     * view is attached and has a handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> HandlerActionQueue mRunQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> HandlerActionQueue <span class="title">getRunQueue</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRunQueue == <span class="literal">null</span>) &#123;</span><br><span class="line">            mRunQueue = <span class="keyword">new</span> HandlerActionQueue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mRunQueue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面我们可以看出，mRunQueue就是View用来处理它还没attach到window（还没对应的handler）时，客户代码发起的post调用的，起了一个<code>临时缓存</code>的作用。不然总不能丢弃吧，这样开发体验就太差了！！！<br>紧接着，我们继续看下<code>HandlerActionQueue</code>类型的定义，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerActionQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HandlerAction[] mActions; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(Runnable action)</span> &#123;</span><br><span class="line">        postDelayed(action, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postDelayed</span><span class="params">(Runnable action, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">HandlerAction</span> <span class="variable">handlerAction</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerAction</span>(action, delayMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mActions == <span class="literal">null</span>) &#123;</span><br><span class="line">                mActions = <span class="keyword">new</span> <span class="title class_">HandlerAction</span>[<span class="number">4</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            mActions = GrowingArrayUtils.append(mActions, mCount, handlerAction);</span><br><span class="line">            mCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeActions</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> HandlerAction[] actions = mActions;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, count = mCount; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">HandlerAction</span> <span class="variable">handlerAction</span> <span class="operator">=</span> actions[i];</span><br><span class="line">                handler.postDelayed(handlerAction.action, handlerAction.delay);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mActions = <span class="literal">null</span>;</span><br><span class="line">            mCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HandlerAction</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Runnable action;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> delay;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">HandlerAction</span><span class="params">(Runnable action, <span class="type">long</span> delay)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.action = action;</span><br><span class="line">            <span class="built_in">this</span>.delay = delay;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Runnable otherAction)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> otherAction == <span class="literal">null</span> &amp;&amp; action == <span class="literal">null</span></span><br><span class="line">                    || action != <span class="literal">null</span> &amp;&amp; action.equals(otherAction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里的源码部分，我们只摘录了部分关键代码，其余不太相关的直接略去了。<br>从这里可以看出，我们前面的View.post调用里的Runnable最终会被存储在这里的<code>mActions</code>数组里，这里最关键的一点就是其<code>executeActions</code>方法，因为这个方法里我们之前post的Runnable才真正通过<code>handler.postDelayed</code>方式使其进入handler对应的消息队列里等待执行；</p><p>到此为止，我们还差知道View里的<code>mAttachInfo</code>字段何时被赋值以及这里的<code>executeActions</code>方法是什么时候被触发的，答案就是在View的<code>dispatchAttachedToWindow</code>方法，其关键源码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchAttachedToWindow</span>(<span class="params">AttachInfo info, <span class="built_in">int</span> visibility</span>)</span> &#123;</span><br><span class="line">        mAttachInfo = info;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Transfer all pending runnables.</span></span><br><span class="line">        <span class="keyword">if</span> (mRunQueue != <span class="literal">null</span>) &#123;</span><br><span class="line">            mRunQueue.executeActions(info.mHandler);</span><br><span class="line">            mRunQueue = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        performCollectViewAttributes(mAttachInfo, visibility);</span><br><span class="line">        onAttachedToWindow();</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而通过之前的文章，我们已经知道了此方法是当<code>Act Resume</code>之后，在<code>ViewRootImpl.performTraversals()</code>中触发的，参考<a href="https://www.jianshu.com/p/e7b6fa788ae6">View.onAttachedToWindow调用时机分析</a>。</p><p>总结</p><ol><li>Handler.post，它的执行时间基本是等同于onCreate里那行代码触达的时间；</li><li>View.post，则不同，它说白了执行时间一定是在<code>Act#onResume</code>发生后才开始算的；或者换句话说它的效果相当于你上面的View.post方法是写在<code>Act#onResume</code>里面的（但只执行一次，因为onCreate不像onResume会被多次触发）；</li><li>当然，虽然这里说的是<code>post</code>方法，但对应的<code>postDelayed</code>方法区别也是类似的。</li></ol><p>平时当你项目很小，MainActivity的逻辑也很简单时是看不出啥区别的，但当act的<code>onCreate</code>到<code>onResume</code>之间耗时比较久时（比如2s以上），就能明显感受到这2者的区别了，而且本身它们的实际含义也是很不同的，前者的Runnable真正执行时，可能act的整个view层次都还没完整的measure、layout完成，但后者的Runnable执行时，则一定能保证act的view层次结构已经measure、layout并且至少绘制完成了一次。</p><h3 id="margin-padding-align"><a href="#margin-padding-align" class="headerlink" title="margin,padding,align"></a>margin,padding,align</h3><p>android : layout_marginxxx的用法是指当前组件距离其父组件在xxx方向上的边距</p><p> android : padding(xxx)    —-  padding是相对于当前组件而言的，就是指组件内的文本距离当前组件xxx位置的边距</p><p> align就是各种对齐的意思</p><ol><li><p>与指定的组件某位置的边缘进行对其</p><p>比如说 ： android： layout_alignxxx = “yyy”   —- 其中xxx代表方位，yyy代表想要和哪个组件对齐，相应组件的id</p></li><li><p>与父组件的某位置的边缘（上下左右）对其. </p></li></ol><p>android : layout_alignParentXxx      —-    当前组件和其父组件的Xxx位置对齐</p><h3 id="Android-自定义属性"><a href="#Android-自定义属性" class="headerlink" title="Android 自定义属性"></a>Android 自定义属性</h3><p><a href="https://blog.csdn.net/lmj623565791/article/details/45022631">https://blog.csdn.net/lmj623565791/article/details/45022631</a></p><p><a href="https://blog.csdn.net/wzy_1988/article/details/49619773">https://blog.csdn.net/wzy_1988/article/details/49619773</a></p><h3 id="Android-app的打包流程，各种文件分别如何处理"><a href="#Android-app的打包流程，各种文件分别如何处理" class="headerlink" title="Android app的打包流程，各种文件分别如何处理"></a>Android app的打包流程，各种文件分别如何处理</h3><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/217990-20170219155424582-264022190.png" alt="img"></p><p><strong>aapt-&gt;</strong></p><p><strong>aidl -&gt; javac-&gt; dx(dex)-&gt; apkbuilder-&gt; jarsigner-&gt; zipalign</strong> </p><p><strong>步骤中提到的工具如下表：</strong></p><div class="table-container"><table><thead><tr><th>名称</th><th>功能介绍</th><th>在操作系统中的路径</th></tr></thead><tbody><tr><td>aapt</td><td>Android资源打包工具</td><td>${ANDROID_SDK_HOME}/platform-tools/appt</td></tr><tr><td>aidl</td><td>Android接口描述语言转化为.java文件的工具</td><td>${ANDROID_SDK_HOME}/platform-tools/aidl</td></tr><tr><td>javac</td><td>Java Compiler</td><td>${JDK_HOME}/javac或/usr/bin/javac</td></tr><tr><td>dex</td><td>转化.class文件为Davik VM能识别的.dex文件</td><td>${ANDROID_SDK_HOME}/platform-tools/dx</td></tr><tr><td>apkbuilder</td><td>生成apk包</td><td>${ANDROID_SDK_HOME}/tools/opkbuilder</td></tr><tr><td>jarsigner</td><td>.jar文件的签名工具</td><td>${JDK_HOME}/jarsigner或/usr/bin/jarsigner</td></tr><tr><td>zipalign</td><td>字节码对齐工具</td><td>${ANDROID_SDK_HOME}/tools/zipalign</td></tr></tbody></table></div><p><strong>第一步：打包资源文件，生成R.java文件</strong></p><p>编译R.java类需要用到AndroidSDK提供的aapt工具,aapt参数众多,以下是主要参数:</p><ol><li>-d one or more device assets to include, separated by commas </li><li>-f force overwrite of existing files </li><li>-g specify a pixel tolerance to force images to grayscale, default 0 </li><li>-j specify a jar or zip file containing classes to include </li><li>-k junk path of file(s) added </li><li>-m make package directories under location specified by -J </li><li>-u update existing packages (add new, replace older, remove deleted files) </li><li>-v verbose output </li><li>-x create extending (non-application) resource IDs </li><li>-z require localization of resource attributes marked with </li><li>localization=”suggested” </li><li>-A additional directory in which to find raw asset files </li><li>-G A file to output proguard options into. </li><li>-F specify the apk file to output </li><li>-I add an existing package to base include set </li><li>-J specify where to output R.java resource constant definitions </li><li>-M specify full path to AndroidManifest.xml to include in zip </li><li>-P specify where to output public resource definitions </li><li>-S directory in which to find resources. Multiple directories will be scann </li></ol><p>aapt编译R.java文件具体如下:</p><p>需要进入应用程序目录,新建一个gen目录,没有gen目录,命令将会出现找不到文件的错误!</p><p>命令成功执行后将会在gen目录下生成成包结构的目录树,及R.java文件!</p><p> <img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/217990-20170219155616613-1242069411.png" alt="img"></p><p><strong>第二步：处理AIDL文件，生成对应的.java文件（当然，有很多工程没有用到AIDL，那这个过程就可以省了）</strong></p><p>将.aidl文件生成.java文件需要用到AndroidSDK自带的aidl工具,此工具具体参数如下:</p><ol><li>-I<DIR>  search path for import statements. </DIR></li><li>-d<FILE>  generate dependency file. </FILE></li><li>-p<FILE>  file created by —preprocess to import. </FILE></li><li>-o<FOLDER> base output folder for generated files. </FOLDER></li><li>-b     fail when trying to compile a parcelable. </li><li>值得注意的是：这个工具的参数与参数值之间不能有空格,Google也有对工资不满意的工程师! </li></ol><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/217990-20170219155626660-2143563246.png" alt="img"></p><p><strong>第三步：编译Java文件，生成对应的.class文件</strong></p><p>javac命令用法如下:</p><ol><li>其中，可能的选项包括： </li><li>-g             生成所有调试信息 </li><li>-g:none          不生成任何调试信息 </li><li>-g:{lines,vars,source}   只生成某些调试信息 </li><li>-nowarn          不生成任何警告 </li><li>-verbose          输出有关编译器正在执行的操作的消息 </li><li>-deprecation        输出使用已过时的 API 的源位置 </li><li>-classpath &lt;路径&gt;      指定查找用户类文件和注释处理程序的位置 </li><li>-cp &lt;路径&gt;          指定查找用户类文件和注释处理程序的位置 </li><li>-sourcepath &lt;路径&gt;      指定查找输入源文件的位置 </li><li>-bootclasspath &lt;路径&gt;    覆盖引导类文件的位置 </li><li>-extdirs &lt;目录&gt;       覆盖安装的扩展目录的位置 </li><li>-endorseddirs &lt;目录&gt;     覆盖签名的标准路径的位置 </li><li>-proc:{none,only}     控制是否执行注释处理和/或编译。 </li><li>-processor <class1>[,<class2>,<class3>…]要运行的注释处理程序的名称；绕过默认的搜索进程 </class3></class2></class1></li><li>-processorpath &lt;路径&gt;    指定查找注释处理程序的位置 </li><li>-d &lt;目录&gt;          指定存放生成的类文件的位置 </li><li>-s &lt;目录&gt;          指定存放生成的源文件的位置 </li><li>-implicit:{none,class}   指定是否为隐式引用文件生成类文件 </li><li>-encoding &lt;编码&gt;       指定源文件使用的字符编码 </li><li>-source &lt;版本&gt;        提供与指定版本的源兼容性 </li><li>-target &lt;版本&gt;        生成特定 VM 版本的类文件 </li><li>-version          版本信息 </li><li>-help           输出标准选项的提要 </li><li>-Akey[=value]       传递给注释处理程序的选项 </li><li>-X             输出非标准选项的提要 </li><li><p>-J&lt;标志&gt;           直接将 &lt;标志&gt; 传递给运行时系统 </p><p>javac -encoding utf-8 -target 1.5 -bootclasspath E:\Androiddev\android-sdk-windows2.2\platforms\android-3\android.jar -d bin src\com\byread\reader*.java gen\com\byread\reader\R.java </p></li></ol><p><strong>第四步：把.class文件转化成Davik VM支持的.dex文件</strong></p><p>将工程bin目录下的class文件编译成classes.dex，Android虚拟机只能执行dex文件!</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/217990-20170219155642238-1124177882.png" alt="img"></p><p><strong>第五步：打包生成未签名的.apk文件</strong></p><p>【输入】打包后的资源文件、打包后类文件（.dex文件）、libs文件（包括.so文件，当然很多工程都没有这样的文件，如果你不使用C/C++开发的话）</p><p>【输出】未签名的.apk文件</p><p>【工具】apkbuilder工具</p><p>apkbuilder工具用法如下：</p><ol><li>-v   Verbose. </li><li>-d   Debug Mode: Includes debug files in the APK file. </li><li>-u   Creates an unsigned package. </li><li>-storetype Forces the KeyStore type. If ommited the default is used. </li><li></li><li>-z   Followed by the path to a zip archive. </li><li>​    Adds the content of the application package. </li><li></li><li>-f   Followed by the path to a file. </li><li>​    Adds the file to the application package. </li><li></li><li>-rf   Followed by the path to a source folder. </li><li>​    Adds the java resources found in that folder to the application </li><li>​    package, while keeping their path relative to the source folder. </li><li></li><li>-rj   Followed by the path to a jar file or a folder containing </li><li>​    jar files. </li><li>​    Adds the java resources found in the jar file(s) to the application </li><li>​    package. </li><li></li><li>-nf   Followed by the root folder containing native libraries to </li><li><p>​    include in the application package.<span style="color: rgb(0, 0, 255); font-family: 楷体; line-height: 20px;font-size:18px; ">I:最后一步,通过jarsigner命令用证书文件对未签名的APK文件进行签名</span> </p><p>apkbuilder ${output.apk.file} -u -z ${packagedresource.file} -f ${dex.file} -rf ${source.dir} -rj ${libraries.dir} </p></li></ol><p><strong>第六步：对未签名.apk文件进行签名</strong></p><p>【输入】未签名的.apk文件</p><p>【输出】签名的.apk文件</p><p>【工具】jarsigner</p><p> <strong>第七步：对签名后的.apk文件进行对齐处理（不进行对齐处理是不能发布到Google Market的）</strong></p><p>【输入】签名后的.apk文件</p><p>【输出】对齐后的.apk文件</p><p>【工具】zipalign工具</p><h3 id="数据库sqlite-索引"><a href="#数据库sqlite-索引" class="headerlink" title="数据库sqlite 索引"></a>数据库sqlite 索引</h3><p>索引（Index）是一种特殊的查找表，数据库搜索引擎用来加快数据检索。简单地说，索引是一个指向表中数据的指针。一个数据库中的索引与一本书的索引目录是非常相似的。</p><p>拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。</p><p>索引有助于加快 SELECT 查询和 WHERE 子句，但它会减慢使用 UPDATE 和 INSERT 语句时的数据输入。索引可以创建或删除，但不会影响数据。</p><h4 id="B-树与索引"><a href="#B-树与索引" class="headerlink" title="B-树与索引"></a>B-树与索引</h4><p>大多数的数据库都是以B-树或者B+树作为存储结构的，B树索引也是最常见的索引。先简单介绍下B-树，可以增强对索引的理解。</p><p>B-树是为磁盘设计的一种多叉平衡树，B树的真正最准确的定义为：一棵含有t（t&gt;=2）个关键字的平衡多路查找树。一棵M阶的B树满足以下条件：</p><ol><li>每个结点至多有M个孩子</li><li>除根结点和叶结点外，其它每个结点至少有M/2个孩子</li><li>根结点至少有两个孩子（除非该树仅包含一个结点）</li><li>所有叶结点在同一层，叶结点不包含任何关键字信息，可以看作一种外部节点</li><li>有K个关键字的非叶结点恰好包含K+1个孩子</li></ol><p>B树中的每个结点根据实际情况可以包含大量的关键字信息和分支(当然是不能超过磁盘块的大小，根据磁盘驱动(disk drives)的不同，一般块的大小在1k~4k左右)；这样树的深度降低了，这就意味着查找一个元素只要很少结点从外存磁盘中读入内存，很快访问到要查找的数据。B-树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成。而相对于磁盘的io速度，cpu的计算时间可以忽略不计，所以B树的意义就显现出来了，树的深度降低，而深度决定了io的读写次数。</p><p>B树索引是一个典型的树结构，其包含的组件主要是：</p><ol><li>叶子节点（Leaf node）：包含条目直接指向表里的数据行。</li><li>分支节点（Branch node）：包含的条目指向索引里其他的分支节点或者是叶子节点。</li><li>根节点（Root node）：一个B树索引只有一个根节点，它实际就是位于树的最顶端的分支节点。</li></ol><p>如下图所示：</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/2012092914383471643.jpg" alt="这里写图片描述"></p><p>每个索引都包含两部分内容，一部分是索引本身的值，第二部分即指向数据页或者另一个索引也的指针。每个节点即为一个索引页，包含了多个索引。</p><p>当你为一个空表建立一个索引，数据库会分配一个空的索引页，这个索引页即代表根节点，在你插入数据之前，这个索引页都是空的。每当你插入数据，数据库就会在根节点创建索引条目。当根节点插满的时候，再插入数据时，根节点就会分裂。举个例子，根节点插入了如图所示的数据。（超过4个就分裂），这时候插入H，就会分裂成2个节点，移动G到新的根节点，把H和N放在新的右孩子节点中。如图所示：</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/2012092914383427039.png" alt="这里写图片描述"><br>根节点插满4个节点</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/2012092914383471907.png" alt="这里写图片描述"><br>插入H，进行分裂。</p><p>大致的分裂步骤如下： </p><ol><li>创建两个子节点 <ol><li>将原节点中的数据近似分为两半，写入两个新的孩子节点中。 <ol><li>在根节点中放置指向页节点的指针</li></ol></li></ol></li></ol><p>当你不断向表中插入数据，根节点中指向叶节点的指针也被插满，当叶子还需要分裂的时候，根节点没有空间再创建指向新的叶节点的指针。那么数据库就会创建分支节点。随着叶子节点的分裂，根节点中的指针都指向了这些分支节点。随着数据的不断插入，索引会增加更多的分支节点，使树结构变成这样的一个多级结构。</p><h4 id="索引的种类"><a href="#索引的种类" class="headerlink" title="索引的种类"></a>索引的种类</h4><ol><li>聚集索引<br>表中行的物理顺序与键值的逻辑（索引）顺序相同。因为数据的物理顺序只能有一种，所以一张表只能有一个聚集索引。如果一张表没有聚集索引，那么这张表就没有顺序的概念，所有的新行都会插入到表的末尾。对于聚集索引，叶节点即存储了数据行，不再有单独的数据页。就比如说我小时候查字典从来不看目录，我觉得字典本身就是一个目录，比如查裴字，只需要翻到p字母开头的，再按顺序找到e。通过这个方法我每次都能最快的查到老师说的那个字，得到老师的表扬。</li><li>非聚集索引<br>表中行的物理顺序与索引顺序无关。对于非聚集索引，叶节点存储了索引字段值以及指向相应数据页的指针。叶节点紧邻在数据之上，对数据页的每一行都有相应的索引行与之对应。有时候查字典，我并不知道这个字读什么，那我就不得不通过字典目录的“部首”来查找了。这时候我会发现，目录中的排序和实际正文的排序是不一样的，这对我来说很苦恼，因为我不能比别人快了，我需要先再目录中找到这个字，再根据页数去找到正文中的字。</li></ol><h4 id="索引与数据的查询，插入与删除"><a href="#索引与数据的查询，插入与删除" class="headerlink" title="索引与数据的查询，插入与删除"></a>索引与数据的查询，插入与删除</h4><ol><li>查询<br>查询操作就和查字典是一样的。当我们去查找指定记录时，数据库会先查找根节点，将待查数据与根节点的数据进行比较，再通过根节点的指针查询下一个记录，直到找到这个记录。这是一个简单的平衡树的二分搜索的过程，我就不赘述了。在聚集索引中，找到页节点即找到了数据行，而在非聚集索引中，我们还需要再去读取数据页。</li><li>插入<br>聚集索引的插入操作比较复杂，最简单的情况，插入操作会找到对于的数据页，然后为新数据腾出空间，执行插入操作。如果该数据页已经没有空间，那就需要拆分数据页，这是一个非常耗费资源的操作。对于仅有非聚集索引的表，插入只需在表的末尾插入即可。如果也包含了聚集索引，那么也会执行聚集索引需要的插入操作。</li><li>删除<br>删除行后下方的数据会向上移动以填补空缺。如果删除的数据是该数据页的最后一行，那么这个数据页会被回收，它的前后一页的指针会被改变，被回收的数据页也会在特定的情况被重新使用。与此同时，对于聚集索引，如果索引页只剩一条记录，那么该记录可能会移动到邻近的索引表中，原来的索引页也会被回收。而非聚集索引没办法做到这一点，这就会导致出现多个数据页都只有少量数据的情况。</li></ol><h4 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h4><p>其实通过前面的介绍，索引的优缺点已经一目了然。</p><p>先说优点： </p><ol><li>大大加快数据的检索速度，这也是创建索引的最主要的原因 </li><li>加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义 </li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li></ol><p>再说缺点： </p><ol><li>创建索引需要耗费一定的时间，但是问题不大，一般索引只要build一次 </li><li>索引需要占用物理空间，特别是聚集索引，需要较大的空间 </li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度，这个是比较大的问题。</li></ol><h4 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h4><p>根据上文的分析，我们大致对什么时候使用索引有了自己的想法。一般我们需要在这些列上建立索引：</p><ol><li>在经常需要搜索的列上，这是毋庸置疑的</li><li>经常同时对多列进行查询，且每列都含有重复值可以建立组合索引，组合索引尽量要使常用查询形成索引覆盖（查询中包含的所需字段皆包含于一个索引中，我们只需要搜索索引页即可完成查询）。同时，该组合索引的前导列一定要是使用最频繁的列。对于前导列的问题，在后面SQLite的索引使用介绍中还会做讨论。</li><li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度，连接条件要充分考虑带有索引的表。</li><li>在经常需要对范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的，同样，在经常需要排序的列上最好也创建索引。</li><li>在经常放到where子句中的列上面创建索引，加快条件的判断速度。要注意的是where字句中对列的任何操作（如计算表达式，函数）都需要对表进行整表搜索，而没有使用该列的索引。所以查询时尽量把操作移到等号右边。</li></ol><p>使用 CREATE INDEX 语句创建索引，它允许命名索引，指定表及要索引的一列或多列，并指示索引是升序排列还是降序排列。</p><p>索引也可以是唯一的，与 UNIQUE 约束类似，在列上或列组合上防止重复条目。</p><p><strong>CREATE INDEX</strong> 的基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure><p>单列索引是一个只基于表的一个列上创建的索引。基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name);</span><br></pre></td></tr></table></figure><p>使用唯一索引不仅是为了性能，同时也为了数据的完整性。唯一索引不允许任何重复的值插入到表中。基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name</span><br><span class="line"><span class="keyword">on</span> table_name (column_name);</span><br></pre></td></tr></table></figure><p>组合索引是基于一个表的两个或多个列上创建的索引。基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">on</span> table_name (column1, column2);</span><br></pre></td></tr></table></figure><p>是否要创建一个单列索引还是组合索引，要考虑到您在作为查询过滤条件的 WHERE 子句中使用非常频繁的列。</p><p>如果值使用到一个列，则选择使用单列索引。如果在作为过滤的 WHERE 子句中有两个或多个列经常使用，则选择使用组合索引。</p><h4 id="什么情况下要避免使用索引？"><a href="#什么情况下要避免使用索引？" class="headerlink" title="什么情况下要避免使用索引？"></a><strong>什么情况下要避免使用索引？</strong></h4><p>虽然索引的目的在于提高数据库的性能，但这里有几个情况需要避免使用索引。使用索引时，应重新考虑下列准则：</p><ul><li>索引不应该使用在较小的表上。</li><li>索引不应该使用在有频繁的大批量的更新或插入操作的表上。</li><li>索引不应该使用在含有大量的 NULL 值的列上。</li><li>索引不应该使用在频繁操作的列上。</li><li>含有很少非重复数据值的列，比如只有0，1，这时候扫描整表通常会更有效</li><li>对于定义为<code>TEXT</code>，<code>IMAGE</code>的数据不应该创建索引。这些字段长度不固定，或许很长，或许为空。 </li></ul><h3 id="abc三个线程循环顺序打印26个字母"><a href="#abc三个线程循环顺序打印26个字母" class="headerlink" title="abc三个线程循环顺序打印26个字母"></a>abc三个线程循环顺序打印26个字母</h3><h4 id="使用Semaphore"><a href="#使用Semaphore" class="headerlink" title="使用Semaphore"></a>使用Semaphore</h4><p>Semaphore又称信号量，是操作系统中的一个概念，在Java并发编程中，信号量控制的是线程并发的数量。</p><p>public Semaphore(int permits)<br>其中参数permits就是允许同时运行的线程数目;<br>Semaphore是用来保护一个或者多个共享资源的访问，Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。一个线程要访问共享资源，先获得信号量，如果信号量的计数器值大于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。如果计数器值为0,线程进入休眠。当某个线程使用完共享资源后，释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。</p><p>Semaphore使用时需要先构建一个参数来指定共享资源的数量，Semaphore构造完成后即是获取Semaphore、共享资源使用完毕后释放Semaphore。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (a &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    A.acquire();</span><br><span class="line">                    <span class="keyword">if</span> (a &gt; <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                        B.release();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + a);</span><br><span class="line">                    a++;</span><br><span class="line">                    B.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (a &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    B.acquire();</span><br><span class="line">                    <span class="keyword">if</span> (a &gt; <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                        C.release();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + a);</span><br><span class="line">                    a++;</span><br><span class="line">                    C.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (a &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    C.acquire();</span><br><span class="line">                    <span class="keyword">if</span> (a &gt; <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                        A.release();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + a);</span><br><span class="line">                    a++;</span><br><span class="line">                    A.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">C</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="使用lock"><a href="#使用lock" class="headerlink" title="使用lock"></a>使用lock</h4><p>通过ReentrantLock我们可以很方便的进行显式的锁操作，即获取锁和释放锁，对于同一个对象锁而言，统一时刻只可能有一个线程拿到了这个锁，此时其他线程通过lock.lock()来获取对象锁时都会被阻塞，直到这个线程通过lock.unlock()操作释放这个锁后，其他线程才能拿到这个锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (a &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">if</span> ((a - <span class="string">&#x27;0&#x27;</span>) % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; a &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + a);</span><br><span class="line">                        a++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (a &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">if</span> ((a - <span class="string">&#x27;0&#x27;</span>) % <span class="number">3</span> == <span class="number">1</span> &amp;&amp; a &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + a);</span><br><span class="line">                        a++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (a &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">if</span> ((a - <span class="string">&#x27;0&#x27;</span>) % <span class="number">3</span> == <span class="number">2</span> &amp;&amp; a &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + a);</span><br><span class="line">                        a++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReentrantLock结合Condition"><a href="#ReentrantLock结合Condition" class="headerlink" title="ReentrantLock结合Condition"></a>ReentrantLock结合Condition</h4><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/648116-20180515071111037-181504931.png" alt="image"></p><p> 首先我们需要明白condition对象是依赖于lock对象的，意思就是说condition对象需要通过lock对象进行创建出来(调用Lock对象的newCondition()方法)。consition的使用方式非常的简单。但是需要注意在调用方法前获取锁。</p><p>condition可以通俗的理解为条件队列。当一个线程在调用了await方法以后，直到线程等待的某个条件为真的时候才会被唤醒。这种方式为线程提供了更加简单的等待/通知模式。Condition必须要配合锁一起使用，因为对共享状态变量的访问发生在多线程环境下。一个Condition的实例必须与一个Lock绑定，因此Condition一般都是作为Lock的内部实现。</p><ol><li><strong>await()</strong> ：造成当前线程在接到信号或被中断之前一直处于等待状态。</li><li><strong>await(long time, TimeUnit unit)</strong> ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。</li><li><strong>awaitNanos(long nanosTimeout)</strong> ：造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。返回值表示剩余时间，如果在nanosTimesout之前唤醒，那么返回值 = nanosTimeout - 消耗时间，如果返回值 &lt;= 0 ,则可以认定它已经超时了。</li><li><strong>awaitUninterruptibly()</strong> ：造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。</li><li><strong>awaitUntil(Date deadline)</strong> ：造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。如果没有到指定时间就被通知，则返回true，否则表示到了指定时间，返回返回false。</li><li><strong>signal()</strong> ：唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。</li><li><p><strong>signal()All</strong> ：唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的锁。</p><p>Condition是AQS的内部类。每个Condition对象都包含一个队列(等待队列)。等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。等待队列的基本结构如下所示。</p></li></ol><p><a href="https://images2018.cnblogs.com/blog/648116/201805/648116-20180515071112580-1447258155.png"><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/648116-20180515071113479-1426477894.png" alt="image"></a></p><p>等待分为首节点和尾节点。当一个线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。新增节点就是将尾部节点指向新增的节点。节点引用更新本来就是在获取锁以后的操作，所以不需要CAS保证。同时也是线程安全的操作。</p><p>当线程调用了await方法以后。线程就作为队列中的一个节点被加入到等待队列中去了。同时会释放锁的拥有。当从await方法返回的时候。一定会获取condition相关联的锁。当等待队列中的节点被唤醒的时候，则唤醒节点的线程开始尝试获取同步状态。如果不是通过 其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException异常信息。</p><p>调用Condition的signal()方法，将会唤醒在等待队列中等待最长时间的节点（条件队列里的首节点），在唤醒节点前，会将节点移到同步队列中。当前线程加入到等待队列中如图所示：</p><p><a href="https://images2018.cnblogs.com/blog/648116/201805/648116-20180515071116951-1461321313.png"><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/648116-20180515071118116-198589862.png" alt="image"></a></p><p>在调用signal()方法之前必须先判断是否获取到了锁。接着获取等待队列的首节点，将其移动到同步队列并且利用LockSupport唤醒节点中的线程。节点从等待队列移动到同步队列如下图所示：</p><p><a href="https://images2018.cnblogs.com/blog/648116/201805/648116-20180515071121537-1055324971.png"><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/648116-20180515071122335-2001301461.png" alt="image"></a></p><p>被唤醒的线程将从await方法中的while循环中退出。随后加入到同步状态的竞争当中去。成功获取到竞争的线程则会返回到await方法之前的状态。</p><p>调用await方法后，将当前线程加入Condition等待队列中。当前线程释放锁。否则别的线程就无法拿到锁而发生死锁。自旋(while)挂起，不断检测节点是否在同步队列中了，如果是则尝试获取锁，否则挂起。当线程被signal方法唤醒，被唤醒的线程将从await()方法中的while循环中退出来，然后调用acquireQueued()方法竞争同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">A</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">B</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">C</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (a &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                   lock.lock();</span><br><span class="line">                    <span class="keyword">while</span> ((a - <span class="string">&#x27;0&#x27;</span>) % <span class="number">3</span> != <span class="number">0</span> &amp;&amp; a &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                        A.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (a &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + a);</span><br><span class="line">                        a++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    B.signal();</span><br><span class="line">                  lock.unlock();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (a &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">while</span> ((a - <span class="string">&#x27;0&#x27;</span>) % <span class="number">3</span> != <span class="number">1</span>  &amp;&amp; a &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                        B.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (a &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + a);</span><br><span class="line">                        a++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    C.signal();</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (a &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">while</span> ((a - <span class="string">&#x27;0&#x27;</span>) % <span class="number">3</span> != <span class="number">2</span>  &amp;&amp; a &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                        C.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (a &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + a);</span><br><span class="line">                        a++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    A.signal();</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p>判断是否有环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寻找环的起点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这时候已经相遇</span></span><br><span class="line">fast = head;</span><br><span class="line"><span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fast;</span><br></pre></td></tr></table></figure><p>具体可参考[环形链表II]</p><p>求环上的结点数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">slow = fast.next;</span><br><span class="line"><span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure><p>求链表长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p != fast) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    p = p.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count + count;</span><br></pre></td></tr></table></figure><p>求出环上距离任意一个节点最远的点（对面节点）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到count / 2的点即可</span></span><br></pre></td></tr></table></figure><h3 id="WebSocket心跳及重连机制"><a href="#WebSocket心跳及重连机制" class="headerlink" title="WebSocket心跳及重连机制"></a><strong>WebSocket心跳及重连机制</strong></h3><p>在使用websocket的过程中，有时候会遇到网络断开的情况，但是在网络断开的时候服务器端并没有触发onclose的事件。这样会有：服务器会继续向客户端发送多余的链接，并且这些数据还会丢失。所以就需要一种机制来检测客户端和服务端是否处于正常的链接状态。因此就有了websocket的心跳了。还有心跳，说明还活着，没有心跳说明已经挂掉了。</p><p><strong>1. 为什么叫心跳包呢？</strong><br>它就像心跳一样每隔固定的时间发一次，来告诉服务器，我还活着。</p><p><strong>2. 心跳机制是？</strong><br>心跳机制是每隔一段时间会向服务器发送一个数据包，告诉服务器自己还活着，同时客户端会确认服务器端是否还活着，如果还活着的话，就会回传一个数据包给客户端来确定服务器端也还活着，否则的话，有可能是网络断开连接了。需要重连~</p><h3 id="内存隔离"><a href="#内存隔离" class="headerlink" title="内存隔离"></a>内存隔离</h3><p><strong>进程隔离</strong>是为保护<a href="https://zh.wikipedia.org/wiki/操作系统">操作系统</a>中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了<a href="https://zh.wikipedia.org/w/index.php?title=虚拟地址空间&amp;action=edit&amp;redlink=1">虚拟地址空间</a>。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。</p><p>进程隔离的安全性通过禁止进程间内存的访问可以方便实现。相比之下，一些不安全的操作系统（例如<a href="https://zh.wikipedia.org/wiki/DOS">DOS</a><a href="https://zh.wikipedia.org/wiki/进程隔离#cite_note-2">[2]</a>）能够允许任何进程对其他进程的内存进行写操作。</p><ol><li>进程隔离的硬件要求</li></ol><p>进程隔离对硬件有一些基本的要求，其中最主要的硬件是MMU （Memory Management Unit 内存管理单元），有时候ARM Cortex M之上的MPU也能达到类似的功能，但是其功能很弱，无法做到地之间的翻译，而只能在物理内存地址之上划定线性的范围。</p><p>下面重点介绍一下MMU的功能， 对于X86处理器来说其32位兼容模式运行还会有分段式内存访问的模式（其也可以达到隔离内存和翻译的作用），本文不会介绍，本文主要介绍内存分页访问的相关内容。</p><p>MMU的作用简单用一句话概括就是将线性地址翻译为物理地址， 对于理解操作系统内核来说我们并不需要了解太多MMU的细节，但是如果我们要实现一个内核，这部分知识是根据处理器体系结构的不同而不同的。</p><ol><li>为什么需要线性地址（虚拟地址） 到 物理地址的翻译</li></ol><p>我们先看如果没有线性地址的概念只有物理地址会出现的问题：</p><p>a.  整个操作系统能够访问的地址空间和实际插入的物理内存大小相关。</p><p>b. 每个进程能够访问的地址空间是从物理内存空间上的一部分。</p><p>c. 编译生成的程序需要事先知道运行在物理地址空间的范围，才能够生成相应的执行代码。</p><p>而对于上面的三个问题是一般的操作系统都无法忍受的，对于通用的操作系统来说，其能访问的内存空间是根据地址线的范围来决定的，例如32位系统就是2^32， 而对于64位操作系统是2^48 不会因为实际插入的物理内存大小的变化而变化， 而同样的为操作系统编译生成的可执行程序需要具有通用性，而不能针对不同的硬件都重新生成可执行程序来适配不同的物理内存大小和范围。</p><p>引入了线性地址到物理地址的翻译就能够解决以上的问题， 例如对于32位处理器上运行的Linux操作系统，其每个进程的内存空间都如下图所示</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/20170702190629154" alt="img"></p><p>从上图我们可以看到对于其上运行的每一个进程，它的内存线性地址空间地址都是从0 — &gt; 4GB的范围，其中Linux内核的地址空间为 3—&gt;4GB的线性地址高位空间（同一个内核的地址空间映射在每个进程的3—&gt;4GB的内存范围内）， 而对于0 — &gt; 3GB来说为每个进程自己的用户态地址空间范围。  所以每个不同的应用程序在运行时其进程的0 — &gt; 3GB为它们的可访问地址范围，虽然它们的代码逻辑完全不同，但是内存的可访问范围却完全相同。</p><ol><li>分页内存访问的操作系统如何做到进程的线性地址空间隔离</li></ol><p>操作系统内核上电之后会初始化MMU并将自己映射到3— &gt; 4GB的线性地址空间， 而当我们通过系统调用如fork创建进程时，其会在进程描述结构体内集成内存虚拟地址空间的结构体，其内容包含的是当前进程的地址空间页表，当操作系统进行任务切换时会改写CPU的页表基地址寄存器为当前被运行进程的页表基地址，从而达成切换地址空间范围到相应的进程内存范围的目的。</p><ol><li>地址翻译的过程</li></ol><p>MMU将一个线性地址翻译为一个物理地址的过程如下图所示</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/20170702200349024" alt="img"></p><p>对于32位处理器，其按照10， 10， 12的规则，头10位线性地址对应页目录的index， 通过此10位的值在页目录中查询到一个页表项的地址，然后再根据中间10位定位实际对应的页的物理地址， 最后根据最后12位4KB的偏移范围在一个物理页中寻址出实际需要访问的内存位置。</p><p>所以一个线性地址分为3部分，头10位是页目录中的索引值，中间10位是页表中的索引值，最后12位是页内便宜地址。</p><p>而不同的线性地址可以映射到相同的物理地址，此处可以极大的节省实际的内存开销，例如同一个共享库如glibc.so其实例在物理内存中只存在一份，而被不同的进程映射到了自己的线性地址空间中，它们共享的访问glibc的代码段，而其数据段则每个进程有不同的glibc数据段副本。</p><h3 id="线程启动的方式"><a href="#线程启动的方式" class="headerlink" title="线程启动的方式"></a>线程启动的方式</h3><p>一、继承Thread类创建线程类</p><p>（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</p><p>（2）创建Thread子类的实例，即创建了线程对象。</p><p>（3）调用线程对象的start()方法来启动该线程。</p><p>二、通过Runnable接口创建线程类</p><p>（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</p><p>（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</p><p>（3）调用线程对象的start()方法来启动该线程。</p><p>三、通过Callable和Future创建线程</p><p>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</p><p>（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</p><p>（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。</p><p>（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableThreadTest</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">CallableThreadTest</span> <span class="variable">ctt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableThreadTest</span>();</span><br><span class="line">FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(ctt);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 的循环变量i的值&quot;</span>+i);</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(ft,<span class="string">&quot;有返回值的线程&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span>+ft.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建线程的三种方式的对比</strong></p><p>采用实现Runnable、Callable接口的方式创见多线程时，优势是：</p><p>线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。</p><p>在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</p><p>劣势是：</p><p>编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。</p><p>使用继承Thread类的方式创建多线程时优势是：</p><p>编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。</p><p>劣势是：</p><p>线程类已经继承了Thread类，所以不能再继承其他父类。</p><h3 id="线程中start和run的区别"><a href="#线程中start和run的区别" class="headerlink" title="线程中start和run的区别"></a>线程中start和run的区别</h3><p>start() :</p><p>它的作用是启动一个新线程。<br>通过start()方法来启动的新线程，处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行相应线程的run()方法，这里方法run()称为线程体，它包含了要执行的这个线程的内容，run方法运行结束，此线程随即终止。start()不能被重复调用。用start方法来启动线程，真正实现了多线程运行，即无需等待某个线程的run方法体代码执行完毕就直接继续执行下面的代码。这里无需等待run方法执行完毕，即可继续执行下面的代码，即进行了线程切换。</p><p>run() :</p><p>run()就和普通的成员方法一样，可以被重复调用。<br>如果直接调用run方法，并不会启动新线程！程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到多线程的目的。<br>总结：调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pong</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;pong&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                pong();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.run();</span><br><span class="line">        System.out.print(<span class="string">&quot;ping&quot;</span>);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">pongping</span><br></pre></td></tr></table></figure><p>总结一下：</p><ol><li>start() 可以启动一个新线程，run()不能</li><li>start()不能被重复调用，run()可以</li><li>start()中的run代码可以不执行完就继续执行下面的代码，即进行了线程切换。直接调用run方法必须等待其代码全部执行完才能继续执行下面的代码。</li><li>start() 实现了多线程，run()没有实现多线程。</li></ol><h3 id="SpannableStringBuilder"><a href="#SpannableStringBuilder" class="headerlink" title="SpannableStringBuilder"></a>SpannableStringBuilder</h3><blockquote><p>This is the class for text whose content and markup can both be changed.<br>（这是一个内容和标记都可以更改的文本类）</p></blockquote><p>不同于我们平时赋值使用的<code>String</code>、<code>StringBuffer</code>等，只能给<code>TextView</code>设置文本内容，而文本的样式只能用<code>TextView</code>来控制，而且该样式的可定制性还不大好。</p><p><code>SpannableStringBuilder</code>有个亲兄弟——<code>SpannableString</code>。是不是觉得有点熟悉？似乎看到了<code>StringBuilder</code>、<code>String</code>的影子…<br>是的，<code>SpannableStringBuilder</code>和<code>SpannableString</code>的区别类似与<code>StringBuilder</code>、<code>String</code>，就是<code>SpannableStringBuilder</code>可以拼接，而<code>SpannableString</code>不可拼接。</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/1638147-e632df95127dbbde.png" alt="img"></p><h4 id="主要的方法"><a href="#主要的方法" class="headerlink" title="主要的方法"></a>主要的方法</h4><p><code>SpannableStringBuilder</code>和<code>SpannableString</code>主要通过使用<code>setSpan(Object what, int start, int end, int flags)</code>改变文本样式。<br>对应的参数：</p><ul><li>start： 指定Span的开始位置</li><li>end： 指定Span的结束位置，并不包括这个位置。</li><li>flags：取值有如下四个</li><li><code>Spannable. SPAN_INCLUSIVE_EXCLUSIVE</code>：前面包括，后面不包括，即在文本前插入新的文本会应用该样式，而在文本后插入新文本不会应用该样式</li><li><code>Spannable. SPAN_INCLUSIVE_INCLUSIVE</code>：前面包括，后面包括，即在文本前插入新的文本会应用该样式，而在文本后插入新文本也会应用该样式</li><li><code>Spannable. SPAN_EXCLUSIVE_EXCLUSIVE</code>：前面不包括，后面不包括</li><li><code>Spannable. SPAN_EXCLUSIVE_INCLUSIVE</code>：前面不包括，后面包括</li><li>what： 对应的各种Span，不同的Span对应不同的样式。已知的可用类有：</li><li><code>BackgroundColorSpan</code> : 文本背景色</li><li><code>ForegroundColorSpan</code> : 文本颜色</li><li><code>MaskFilterSpan</code> : 修饰效果，如模糊(BlurMaskFilter)浮雕</li><li><code>RasterizerSpan</code> : 光栅效果</li><li><code>StrikethroughSpan</code> : 删除线</li><li><code>SuggestionSpan</code> : 相当于占位符</li><li><code>UnderlineSpan</code> : 下划线</li><li><code>AbsoluteSizeSpan</code> : 文本字体（绝对大小）</li><li><code>DynamicDrawableSpan</code> : 设置图片，基于文本基线或底部对齐。</li><li><code>ImageSpan</code> : 图片</li><li><code>RelativeSizeSpan</code> : 相对大小（文本字体）</li><li><code>ScaleXSpan</code> : 基于x轴缩放</li><li><code>StyleSpan</code> : 字体样式：粗体、斜体等</li><li><code>SubscriptSpan</code> : 下标（数学公式会用到）</li><li><code>SuperscriptSpan</code> : 上标（数学公式会用到）</li><li><code>TextAppearanceSpan</code> : 文本外貌（包括字体、大小、样式和颜色）</li><li><code>TypefaceSpan</code> : 文本字体</li><li><code>URLSpan</code> : 文本超链接</li><li><code>ClickableSpan</code> : 点击事件</li></ul><p>参考<a href="https://www.jianshu.com/p/f004300c6920">简书</a></p><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(Main::fetchPrice);</span><br><span class="line">        <span class="comment">// 如果执行成功:</span></span><br><span class="line">        cf.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 如果执行异常:</span></span><br><span class="line">        cf.exceptionally((e) -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Double <span class="title function_">fetchPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;fetch price failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>Java 7开始引入了一种新的Fork/Join线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。</p><p>我们举个例子：如果要计算一个超大数组的和，最简单的做法是用一个循环在一个线程内完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br></pre></td></tr></table></figure><p>还有一种方法，可以把数组拆成两部分，分别计算，最后加起来就是最终结果，这样可以用两个线程并行执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br></pre></td></tr></table></figure><p>如果拆成两部分还是很大，我们还可以继续拆，用4个线程并行执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┐</span><br><span class="line">└─┴─┴─┴─┴─┴─┘</span><br></pre></td></tr></table></figure><p>这就是Fork/Join任务的原理：判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建2000个随机数组成的数组:</span></span><br><span class="line">        <span class="type">long</span>[] array = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">2000</span>];</span><br><span class="line">        <span class="type">long</span> <span class="variable">expectedSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = random();</span><br><span class="line">            expectedSum += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Expected sum: &quot;</span> + expectedSum);</span><br><span class="line">        <span class="comment">// fork/join:</span></span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> ForkJoinPool.commonPool().invoke(task);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Fork/join sum: &quot;</span> + result + <span class="string">&quot; in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">random</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="type">long</span>[] array;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    SumTask(<span class="type">long</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end) &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 如果任务足够小,直接计算:</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += <span class="built_in">this</span>.array[i];</span><br><span class="line">                <span class="comment">// 故意放慢计算速度:</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务太大,一分为二:</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (end + start) / <span class="number">2</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;split %d~%d ==&gt; %d~%d, %d~%d&quot;</span>, start, end, start, middle, middle, end));</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">subtask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(<span class="built_in">this</span>.array, start, middle);</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">subtask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(<span class="built_in">this</span>.array, middle, end);</span><br><span class="line">        invokeAll(subtask1, subtask2);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">subresult1</span> <span class="operator">=</span> subtask1.join();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">subresult2</span> <span class="operator">=</span> subtask2.join();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> subresult1 + subresult2;</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + subresult1 + <span class="string">&quot; + &quot;</span> + subresult2 + <span class="string">&quot; ==&gt; &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示了以上代码的工作过程概要，但实际上Fork/Join框架的内部工作过程要比这张图复杂得多，例如如何决定某一个recursive task是使用哪条线程进行运行；再例如如何决定当一个任务/子任务提交到Fork/Join框架内部后，是创建一个新的线程去运行还是让它进行队列等待。</p><p>所以如果不深入理解Fork/Join框架的运行原理，只是根据之上最简单的使用例子观察运行效果，那么我们只能知道子任务在Fork/Join框架中被拆分得足够小后，并且其内部使用多线程并行完成这些小任务的计算后再进行结果向上的合并动作，最终形成顶层结果。不急，一步一步来，我们先从这张概要的过程图开始讨论。</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/20170511170511140" alt="这里写图片描述"></p><p>图中最顶层的任务使用submit方式被提交到Fork/Join框架中，后者将前者放入到某个线程中运行，工作任务中的compute方法的代码开始对这个任务T1进行分析。如果当前任务需要累加的数字范围过大（代码中设定的是大于200），则将这个计算任务拆分成两个子任务（T1.1和T1.2），每个子任务各自负责计算一半的数据累加，请参见代码中的fork方法。如果当前子任务中需要累加的数字范围足够小（小于等于200），就进行累加然后返回到上层任务中。</p><p>ForkJoinPool有四个构造函数，其中参数最全的那个构造函数如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ForkJoinPool</span><span class="params">(<span class="type">int</span> parallelism,</span></span><br><span class="line"><span class="params">                        ForkJoinWorkerThreadFactory factory,</span></span><br><span class="line"><span class="params">                        UncaughtExceptionHandler handler,</span></span><br><span class="line"><span class="params">                        <span class="type">boolean</span> asyncMode)</span></span><br></pre></td></tr></table></figure><ul><li>parallelism：可并行级别，Fork/Join框架将依据这个并行级别的设定，决定框架内并行执行的线程数量。并行的每一个任务都会有一个线程进行处理，但是千万不要将这个属性理解成Fork/Join框架中最多存在的线程数量，也不要将这个属性和ThreadPoolExecutor线程池中的corePoolSize、maximumPoolSize属性进行比较，因为ForkJoinPool的组织结构和工作方式与后者完全不一样。而后续的讨论中，读者还可以发现Fork/Join框架中可存在的线程数量和这个参数值的关系并不是绝对的关联（有依据但并不全由它决定）。</li><li>factory：当Fork/Join框架创建一个新的线程时，同样会用到线程创建工厂。只不过这个线程工厂不再需要实现ThreadFactory接口，而是需要实现ForkJoinWorkerThreadFactory接口。后者是一个函数式接口，只需要实现一个名叫newThread的方法。在Fork/Join框架中有一个默认的ForkJoinWorkerThreadFactory接口实现：DefaultForkJoinWorkerThreadFactory。</li><li>handler：异常捕获处理器。当执行的任务中出现异常，并从任务中被抛出时，就会被handler捕获。</li><li>asyncMode：这个参数也非常重要，从字面意思来看是指的异步模式，它并不是说Fork/Join框架是采用同步模式还是采用异步模式工作。Fork/Join框架中为每一个独立工作的线程准备了对应的待执行任务队列，这个任务队列是使用数组进行组合的双向队列。即是说存在于队列中的待执行任务，即可以使用先进先出的工作模式，也可以使用后进先出的工作模式。</li></ul><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/20170512085043577" alt="这里写图片描述"></p><p>当asyncMode设置为ture的时候，队列采用先进先出方式工作；反之则是采用后进先出的方式工作，该值默认为false</p><p>ForkJoinPool还有另外两个构造函数，一个构造函数只带有parallelism参数，既是可以设定Fork/Join框架的最大并行任务数量；另一个构造函数则不带有任何参数，对于最大并行任务数量也只是一个默认值——当前操作系统可以使用的CPU内核数量（Runtime.getRuntime().availableProcessors()）。实际上ForkJoinPool还有一个私有的、原生构造函数，之上提到的三个构造函数都是对这个私有的、原生构造函数的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ForkJoinPool</span><span class="params">(<span class="type">int</span> parallelism,</span></span><br><span class="line"><span class="params">                         ForkJoinWorkerThreadFactory factory,</span></span><br><span class="line"><span class="params">                         UncaughtExceptionHandler handler,</span></span><br><span class="line"><span class="params">                         <span class="type">int</span> mode,</span></span><br><span class="line"><span class="params">                         String workerNamePrefix)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">        <span class="built_in">this</span>.ueh = handler;</span><br><span class="line">        <span class="built_in">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">        <span class="type">long</span> <span class="variable">np</span> <span class="operator">=</span> (<span class="type">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">        <span class="built_in">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>如果你对Fork/Join框架没有特定的执行要求，可以直接使用不带有任何参数的构造函数。也就是说推荐基于当前操作系统可以使用的CPU内核数作为Fork/Join框架内最大并行任务数量，这样可以保证CPU在处理并行任务时，尽量少发生任务线程间的运行状态切换（实际上单个CPU内核上的线程间状态切换基本上无法避免，因为操作系统同时运行多个线程和多个进程）。</p><p>Fork/Join框架中提供的fork方法和join方法，可以说是该框架中提供的最重要的两个方法，它们和parallelism“可并行任务数量”配合工作，可以导致拆分的子任务T1.1、T1.2甚至TX在Fork/Join框架中不同的运行效果。例如TX子任务或等待其它已存在的线程运行关联的子任务，或在运行TX的线程中“递归”执行其它任务，又或者启动一个新的线程运行子任务……</p><p>fork方法用于将新创建的子任务放入当前线程的work queue队列中，Fork/Join框架将根据当前正在并发执行ForkJoinTask任务的ForkJoinWorkerThread线程状态，决定是让这个任务在队列中等待，还是创建一个新的ForkJoinWorkerThread线程运行它，又或者是唤起其它正在等待任务的ForkJoinWorkerThread线程运行它。</p><p>这里面有几个元素概念需要注意，ForkJoinTask任务是一种能在Fork/Join框架中运行的特定任务，也只有这种类型的任务可以在Fork/Join框架中被拆分运行和合并运行。ForkJoinWorkerThread线程是一种在Fork/Join框架中运行的特性线程，它除了具有普通线程的特性外，最主要的特点是<strong>每一个ForkJoinWorkerThread线程都具有一个独立的任务等待队列（work queue）</strong>，这个任务队列用于存储在本线程中被拆分的若干子任务。</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/20170514084721521" alt="这里写图片描述"></p><p>join方法用于让当前线程阻塞，直到对应的子任务完成运行并返回执行结果。或者，如果这个子任务存在于当前线程的任务等待队列（work queue）中，则取出这个子任务进行“递归”执行。其目的是尽快得到当前子任务的运行结果，然后继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Leetcode.coding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">10000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[MAX];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; MAX; i++) &#123;</span><br><span class="line">            nums[i] = random.nextInt(MAX);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="type">ForkMergeSort</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkMergeSort</span>(nums);</span><br><span class="line">        ForkJoinTask&lt;<span class="type">int</span>[]&gt; taskResult = pool.submit(task);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span>[] ans;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ans = taskResult.get();</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            writer.write(<span class="string">&quot;cost time = &quot;</span> + (end - current));</span><br><span class="line"><span class="comment">//            for(int i = 0 ; i &lt; MAX / 2 ; ++i) &#123;</span></span><br><span class="line"><span class="comment">//                writer.write(&quot;nums[&quot; + i + &quot;] = &quot; + ans[i] + &quot;\n&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ForkMergeSort</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;<span class="type">int</span>[]&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ForkMergeSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.nums = nums;</span><br><span class="line">            <span class="comment">//System.out.println(&quot;called by thread : &quot; + Thread.currentThread().getName());</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span>[] compute() &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> len / <span class="number">2</span>;</span><br><span class="line">                <span class="type">ForkMergeSort</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkMergeSort</span>(Arrays.copyOf(nums,mid));</span><br><span class="line">                <span class="type">ForkMergeSort</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkMergeSort</span>(Arrays.copyOfRange(nums,mid,len));</span><br><span class="line">                invokeAll(task1,task2);</span><br><span class="line">                <span class="type">int</span>[] r1 = task1.join();</span><br><span class="line">                <span class="type">int</span>[] r2 = task2.join();</span><br><span class="line">                <span class="type">int</span>[] merge = joinInts(r1,r2);</span><br><span class="line">                <span class="keyword">return</span> merge;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果条件成立，说明数组中只有一个元素，或者是数组中的元素都已经排列好位置了</span></span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">1</span> || nums[<span class="number">0</span>] &lt;= nums[<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nums;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> targetp[] = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">                    targetp[<span class="number">0</span>] = nums[<span class="number">1</span>];</span><br><span class="line">                    targetp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">return</span> targetp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法用于合并两个有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] joinInts(<span class="type">int</span> array1[] , <span class="type">int</span> array2[]) &#123;</span><br><span class="line">        <span class="type">int</span> destInts[] = <span class="keyword">new</span> <span class="title class_">int</span>[array1.length + array2.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">array1Len</span> <span class="operator">=</span> array1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">array2Len</span> <span class="operator">=</span> array2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">destLen</span> <span class="operator">=</span> destInts.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只需要以新的集合destInts的长度为标准，遍历一次即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span> , array1Index = <span class="number">0</span> , array2Index = <span class="number">0</span> ; index &lt; destLen ; index++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value1</span> <span class="operator">=</span> array1Index &gt;= array1Len?Integer.MAX_VALUE:array1[array1Index];</span><br><span class="line">            <span class="type">int</span> <span class="variable">value2</span> <span class="operator">=</span> array2Index &gt;= array2Len?Integer.MAX_VALUE:array2[array2Index];</span><br><span class="line">            <span class="comment">// 如果条件成立，说明应该取数组array1中的值</span></span><br><span class="line">            <span class="keyword">if</span>(value1 &lt; value2) &#123;</span><br><span class="line">                array1Index++;</span><br><span class="line">                destInts[index] = value1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则取数组array2中的值</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                array2Index++;</span><br><span class="line">                destInts[index] = value2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> destInts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ArrayMap和SparseArray"><a href="#ArrayMap和SparseArray" class="headerlink" title="ArrayMap和SparseArray"></a>ArrayMap和SparseArray</h3><p><a href="https://blog.csdn.net/qq_37704124/article/details/89715604">https://blog.csdn.net/qq_37704124/article/details/89715604</a></p><ul><li>ArrayMap</li><li>ArraySet</li><li>SparseArray</li><li>SparseIntArray</li><li>SparseBooleanArray</li><li>SparseLongArray</li></ul><h4 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a><strong>SparseArray</strong></h4><p>SparseArray比HashMap更省内存，在某些条件下性能更好，主要是因为它避免了对key的自动装箱（int转为Integer类型），它内部则是通过两个数组来进行数据存储的，一个存储key，另外一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间，我们从源码中可以看到key和value分别是用数组表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] mKeys;</span><br><span class="line"><span class="keyword">private</span> Object[] mValues;<span class="number">12</span></span><br></pre></td></tr></table></figure><p>我们可以看到，SparseArray只能存储key为int类型的数据，同时，SparseArray在存储和读取数据时候，使用的是二分查找法，我们可以看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, E value)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">       ...</span><br><span class="line">       &#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> key, E valueIfKeyNotFound)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">       ...</span><br><span class="line">       &#125;<span class="number">12345678</span></span><br></pre></td></tr></table></figure><p>也就是在put添加数据的时候，会使用二分查找法和之前的key比较当前我们添加的元素的key的大小，然后按照从小到大的顺序排列好，所以，SparseArray存储的元素都是按元素的key值从小到大排列好的。<br>而在获取数据的时候，也是使用二分查找法判断元素的位置，所以，在获取数据的时候非常快，比HashMap快的多，因为HashMap获取数据是通过遍历Entry[]数组来得到对应的元素。</p><p>在此之外，SparseArray还提供了两个特有方法，更方便数据的查询：<br>获取对应的key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">keyAt</span><span class="params">(<span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure><p>获取对应的value：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">valueAt</span><span class="params">(<span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure><p>虽说SparseArray性能比较好，但是由于其添加、查找、删除数据都需要先进行一次二分查找，所以在数据量大的情况下性能并不明显，将降低至少50%。</p><p>满足下面两个条件我们可以使用SparseArray代替HashMap：</p><ul><li>数据量不大，最好在千级以内</li><li>key必须为int类型，这中情况下的HashMap可以用SparseArray代替：</li></ul><h4 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a><strong>ArrayMap</strong></h4><p>ArrayMap是一个&lt;<strong>key,value</strong>&gt;映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用两个数组进行数据存储，一个数组记录key的hash值，另外一个数组记录Value值，它和SparseArray一样，也会对key使用二分法进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作，所以，应用场景和SparseArray的一样，如果在数据量比较大的情况下，那么它的性能将退化至少50%。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ArrayMap</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">CONCURRENT_MODIFICATION_EXCEPTIONS</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BASE_SIZE</span> <span class="operator">=</span> <span class="number">4</span>;  <span class="comment">// 容量增量的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CACHE_SIZE</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 缓存数组的上限</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object[] mBaseCache; <span class="comment">//用于缓存大小为4的ArrayMap</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> mBaseCacheSize;</span><br><span class="line">    <span class="keyword">static</span> Object[] mTwiceBaseCache; <span class="comment">//用于缓存大小为8的ArrayMap</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> mTwiceBaseCacheSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> mIdentityHashCode;</span><br><span class="line">    <span class="type">int</span>[] mHashes;         <span class="comment">//由key的hashcode所组成的数组</span></span><br><span class="line">    Object[] mArray;       <span class="comment">//由key-value对所组成的数组，是mHashes大小的2倍</span></span><br><span class="line">    <span class="type">int</span> mSize;             <span class="comment">//成员变量的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayMap对象的数据储存格式如图所示：</p><ul><li>mHashes是一个记录所有key的hashcode值组成的数组，是从小到大的排序方式；</li><li>mArray是一个记录着key-value键值对所组成的数组，是mHashes大小的2倍；</li></ul><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/arrayMap.jpg" alt="arrayMap"></p><p>其中mSize记录着该ArrayMap对象中有多少对数据，执行put()或者append()操作，则mSize会加1，执行remove()，则mSize会减1。mSize往往小于mHashes.length，如果mSize大于或等于mHashes.length，则说明mHashes和mArray需要扩容。</p><p>ArrayMap类有两个非常重要的静态成员变量mBaseCache和mTwiceBaseCacheSize，用于ArrayMap所在进程的全局缓存功能：</p><ul><li>mBaseCache：用于缓存大小为4的ArrayMap，mBaseCacheSize记录着当前已缓存的数量，超过10个则不再缓存；</li><li>mTwiceBaseCacheSize：用于缓存大小为8的ArrayMap，mTwiceBaseCacheSize记录着当前已缓存的数量，超过10个则不再缓存。</li></ul><p>为了减少频繁地创建和回收Map对象，ArrayMap采用了两个大小为10的缓存队列来分别保存大小为4和8的Map对象。为了节省内存有更加保守的内存扩张以及内存收缩策略。 接下来分别说说缓存机制和扩容机制。</p><p>参考<a href="http://gityuan.com/2019/01/13/arraymap/">Gityuan</a></p><h3 id="api与implementation的区别"><a href="#api与implementation的区别" class="headerlink" title="api与implementation的区别"></a>api与implementation的区别</h3><p>implementation可以让module在编译时隐藏自己使用的依赖，但是在运行时这个依赖对所有模块是可见的。而api与compile一样，无法隐藏自己使用的依赖。</p><p>在多module中，implementation确实可以起到隐藏依赖的作用，网上很多的文章都只讲到了这点，那么这样做的目的是什么呢？其实这并不是Google设计implemention与api的目的，因为官方文档中说这样计的目的在于减少build的时间，那么implemention是如何减少build time的呢？</p><p>如果app本地implementation mylibrary1，mylibrary1远程implemention mylibrary2，这时候app则不能获取到mylibrary2中的myClass2类，依然起到了依赖隔离的作用。</p><p>由以上可以看到在全部远程依赖模式下，无论是api还是implemention都起不到依赖隔离的作用。不过，在远程依赖模式下，依赖的一个模块如果版本发生变化，implemention与api的构建速度谁快谁慢还需要进一步研究。</p><p>综上，在多层次模块化（大于等于三层module）开发时，如果都是本地依赖，implementation相比api，主要优势在于减少build time。如果只有两层module，api与implemention在build time上并无太大的差别。</p><h3 id="怎么保证service不被杀死／进程保活？"><a href="#怎么保证service不被杀死／进程保活？" class="headerlink" title="怎么保证service不被杀死／进程保活？"></a>怎么保证service不被杀死／进程保活？</h3><p>（1）Service设置成START_STICKY（onStartCommand方法中），kill 后会被重启（等待5秒左右），重传Intent，保持与重启前一样 </p><p> （2）通过 startForeground将进程设置为前台进程，做前台服务，优先级和前台应用一个级别，除非在系统内存非常缺，否则此进程不会被 kill.具体实现方式为在service中创建一个notification，再调用void android.app.Service.startForeground(int id,Notificationnotification)方法运行在前台即可。 </p><p> （3）双进程Service：让2个进程互相保护，其中一个Service被清理后，另外没被清理的进程可以立即重启进程。 </p><p> （4）AlarmManager不断启动service。该方式原理是通过定时警报来不断启动service，这样就算service被杀死，也能再启动。同时也可以监听网络切换、开锁屏等广播来启动service。 </p><h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p><a href="https://blog.csdn.net/carson_ho/article/details/73560642">https://blog.csdn.net/carson_ho/article/details/73560642</a></p><h3 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h3><p><a href="https://juejin.im/post/6844903958113157128">https://juejin.im/post/6844903958113157128</a></p><p><a href="https://juejin.im/post/6867744083809419277#heading-7">https://juejin.im/post/6867744083809419277#heading-7</a></p><h3 id="GIT底层数据结构"><a href="#GIT底层数据结构" class="headerlink" title="GIT底层数据结构"></a>GIT底层数据结构</h3><p><a href="https://www.cnblogs.com/cczlovexw/p/12964086.html">https://www.cnblogs.com/cczlovexw/p/12964086.html</a></p><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>断点续传其实正如字面意思，就是在下载的断开点继续开始传输，不用再从头开始。所以理解断点续传的核心后，发现其实和很简单，关键就在于对传输中断点的把握，我就自己的理解画了一个简单的示意图：</p><p><img src="/2020/08/29/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/20141206215834127" alt="img"></p><h3 id="JAVA异常"><a href="#JAVA异常" class="headerlink" title="JAVA异常"></a>JAVA异常</h3><p>Java 在代码中通过使用 <code>try&#123;&#125;catch()&#123;&#125;finally&#123;&#125;</code> 块来对异常进行捕获或者处理。但是对于 JVM 来说，是如何处理 try/catch 代码块与异常的呢。</p><p>实际上 Java 编译后，会在代码后附加异常表的形式来实现 Java 的异常处理及 finally 机制（在 JDK1.4.2之前，javac 编译器使用 jsr 和 ret 指令来实现 finally 语句，但是1.4.2之后自动在每段可能的分支路径后将 finally 语句块内容冗余生成一遍来实现。JDK1.7及之后版本，则完全禁止在 Class 文件中使用 jsr 和 ret 指令）。</p><h4 id="异常表"><a href="#异常表" class="headerlink" title="异常表"></a>异常表</h4><p>属性表（attribute_info）可以存在于 Class 文件、字段表、方法表中，用于描述某些场景的专有信息。属性表中有个 Code 属性，该属性在方法表中使用，Java 程序方法体中的代码被编译成的字节码指令存储在 Code 属性中。而异常表（exception_table）则是存储在 Code 属性表中的一个结构，这个结构是可选的。</p><h4 id="异常表结构"><a href="#异常表结构" class="headerlink" title="异常表结构"></a>异常表结构</h4><p>异常表结构如下表所示。它包含四个字段：如果当字节码在第 start_pc 行到 end_pc 行之间（即[start_pc, end_pc)）出现了类型为 catch_type 或者其子类的异常（catch_type 为指向一个 CONSTANT_Class_info 型常量的索引），则跳转到第 handler_pc 行执行。如果 catch_type 为0，表示任意异常情况都需要转到 handler_pc 处进行处理。</p><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th><th style="text-align:left">数量</th></tr></thead><tbody><tr><td style="text-align:left">u2</td><td style="text-align:left">start_pc</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">end_pc</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">handler_pc</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">catch_type</td><td style="text-align:left">1</td></tr></tbody></table></div><h4 id="处理异常机制"><a href="#处理异常机制" class="headerlink" title="处理异常机制"></a>处理异常机制</h4><p>如上面所说，每个类编译后，都会跟随一个异常表，如果发生异常，首先在异常表中查找对应的行（即代码中相应的 <code>try&#123;&#125;catch()&#123;&#125;</code> 代码块），如果找到，则跳转到异常处理代码执行，如果没有找到，则返回（执行 finally 之后），并 copy 异常的应用给父调用者，接着查询父调用的异常表，以此类推。</p><h4 id="异常处理实例"><a href="#异常处理实例" class="headerlink" title="异常处理实例"></a>异常处理实例</h4><p>对于 Java 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        x = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        x = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将其编译为 ByteCode 字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span>;</span><br><span class="line">  Code:</span><br><span class="line">    Stack=<span class="number">1</span>, Locals=<span class="number">5</span>, Args_size=<span class="number">1</span></span><br><span class="line">    <span class="number">0</span>:iconst_1<span class="comment">//try 中的x=1</span></span><br><span class="line">    <span class="number">1</span>:istore_1</span><br><span class="line">    <span class="number">2</span>:iload_1<span class="comment">//保存 x 到 returnValue 中</span></span><br><span class="line">    <span class="number">3</span>:istore<span class="number">4</span></span><br><span class="line">    <span class="number">5</span>:iconst_3<span class="comment">//finally 中的 x=3</span></span><br><span class="line">    <span class="number">6</span>:istore_1</span><br><span class="line">    <span class="number">7</span>: iload<span class="number">4</span><span class="comment">//将 returnValue 中的值放到栈顶，准备给 ireturn 返回</span></span><br><span class="line">    <span class="number">9</span>:ireturn</span><br><span class="line">    <span class="number">10</span>:astore_2<span class="comment">//给 catch 中的 Exception e 赋值，存储在 Slot 2 中</span></span><br><span class="line">    <span class="number">11</span>:iconst_2<span class="comment">//catch 中的 x=2</span></span><br><span class="line">    <span class="number">12</span>:istore_1</span><br><span class="line">    <span class="number">13</span>:iload_1<span class="comment">//保存 x 到 returnValue 中，此时 x=2</span></span><br><span class="line">    <span class="number">14</span>:istore<span class="number">4</span></span><br><span class="line">    <span class="number">16</span>:iconst_3<span class="comment">//finally 中的 x=3</span></span><br><span class="line">    <span class="number">17</span>:istore_1</span><br><span class="line">    <span class="number">18</span>:iload<span class="number">4</span><span class="comment">//将 returnValue 中的值放到栈顶，准备给 ireturn 返回</span></span><br><span class="line">    <span class="number">20</span>:ireturn</span><br><span class="line">    <span class="number">21</span>:astore_3<span class="comment">//如果出现了不属于 java.lang.Exception 及其子类中的异常则到这里</span></span><br><span class="line">    <span class="number">22</span>:iconst_3<span class="comment">//finally 中的 x=3</span></span><br><span class="line">    <span class="number">23</span>:istore_1</span><br><span class="line">    <span class="number">24</span>:aload_3<span class="comment">//将异常放置到栈顶，并抛出</span></span><br><span class="line">    <span class="number">25</span>:athrow</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  Exception table:</span><br><span class="line">    fromtotargettype</span><br><span class="line">    <span class="number">0</span><span class="number">5</span><span class="number">10</span>Class java/lang/Exception</span><br><span class="line">    <span class="number">0</span><span class="number">5</span><span class="number">21</span>any</span><br><span class="line">    <span class="number">10</span><span class="number">16</span><span class="number">21</span>any</span><br></pre></td></tr></table></figure><p>首先可以看到，对于 finally，编译器将每个可能出现的分支后都放置了冗余。并且编译器生成了三个异常表记录，从 Java 代码的语义上讲，执行路径分别为：</p><blockquote><ol><li>如果 try 语句块中出现了属于 Exception 及其子类的异常，则跳转到 catch 处理；</li><li>如果 try 语句块中出现了不属于 Exception 及其子类的异常，则跳转到 finally 处理；</li><li>如果 catch 语句块中出现了任何异常，则跳转到 finally 处理。</li></ol></blockquote><p>由此可以分析此段代码可能的返回结果：</p><blockquote><ol><li>如果没有出现异常，返回1；</li><li>如果出现 Exception 异常，返回2；</li><li>如果出现了 Exception 意外的异常，非正常退出，没有返回；</li></ol></blockquote><p>我们来分析字节码：</p><p>首先，0-4行，就是把整数1赋值给 x，并且将此时 x 的值复制一个副本到本地变量表的 Slot 中（即 returnValue），这个 Slot 里面的值在 ireturn 指令执行前会被重新读到栈顶，作为返回值。这是如果没有异常，则执行5-9行，把 x 赋值为3，然后返回 returnValue 中保存的1，方法结束。如果出现异常，读取异常表发现应该执行第10行，pc 寄存器指针转向10行，10-20行就是把2赋值给 x，然后把 x 赋值给 returnValue，再将 x 赋值为3，然后将 returnValue 中的2读到操作栈顶返回。第21行开始是把 x 赋值为3并且将栈顶的异常抛出，方法结束。</p><h3 id="单测"><a href="#单测" class="headerlink" title="单测"></a>单测</h3><p><a href="https://jsonchao.github.io/2018/07/09/一文全面了解Android单元测试/">https://jsonchao.github.io/2018/07/09/%E4%B8%80%E6%96%87%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Android%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</a></p><h3 id="相册图片加载"><a href="#相册图片加载" class="headerlink" title="相册图片加载"></a>相册图片加载</h3><p><a href="https://blog.csdn.net/hanhailong726188/article/details/51923265">https://blog.csdn.net/hanhailong726188/article/details/51923265</a></p><p><a href="http://blog.imallen.wang/2016/06/04/2016-06-04-gao-xiao-jia-zai-shou-ji-zhong-suo-you-tu-pian-wen-jian-jia-de-fang-fa/">http://blog.imallen.wang/2016/06/04/2016-06-04-gao-xiao-jia-zai-shou-ji-zhong-suo-you-tu-pian-wen-jian-jia-de-fang-fa/</a></p><h3 id="安卓的activity和application有什么区别"><a href="#安卓的activity和application有什么区别" class="headerlink" title="安卓的activity和application有什么区别"></a>安卓的activity和application有什么区别</h3><p>生命周期跟UI相关的，使用Activity的Context处理，如：对话框，各种View，需要startActivity的等。<br>生命周期跟UI无关的，使用Application的Context，如：AsyncTask，Thread，第三方库初始化等等。</p><p><strong>在Activity中，Activity.this和getApplicationContext()返回的不是同一个对象，一个是当前Activity的实例，一个是项目的Application的实例，这两者的生命周期是不同的，它们各自的使用场景不同</strong>，getApplicationContext() 生命周期是整个应用，当应用程序摧毁的时候，它才会摧毁；Activity.this的context是属于当前Activity的，当前Activity摧毁的时候，它就摧毁。</p><p>相同:</p><p>Activity 和 Application 都是 Context 的子类</p><p>Context 从字面上理解就是上下文的意思, 在实际应用中它也确实是起到了管理上下文环境中各个参数和变量的作用, 方便我们可以简单的访问到各种资源.</p><p>不同:</p><p>维护的生命周期不同.</p><ul><li>Activity 维护的是当前的 Activity 的生命周期. <strong>所以其对应的Context也只能访问该 Activity 内的各种资源</strong></li><li>Application 维护的是整个项目的生命周期.</li></ul><p>使用 context 的时候, 小心内存泄露, 防止内存泄露, 注意一下几个方面:</p><ol><li>不要让生命周期长的对象引用 activity context, 即保证引用 activity 的对象要与 activity 本身生命周期是一样的.</li><li>对于生命周期长的对象,可以使用 application context。</li><li>避免非静态的内部类, 尽量使用静态类, 避免生命周期问题, 注意内部类对外部对象引用导致的生命周期变化.</li></ol><p><a href="https://blog.csdn.net/LVXIANGAN/article/details/83345061">https://blog.csdn.net/LVXIANGAN/article/details/83345061</a></p><h3 id="android-fragment和activity的区别"><a href="#android-fragment和activity的区别" class="headerlink" title="android fragment和activity的区别"></a>android fragment和activity的区别</h3><p><a href="https://blog.csdn.net/u012974916/article/details/24563371">https://blog.csdn.net/u012974916/article/details/24563371</a></p><h3 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h3><p><a href="https://juejin.im/post/6844903657310257159">https://juejin.im/post/6844903657310257159</a></p><h3 id="Android-SharedPreferences-实现原理分析"><a href="#Android-SharedPreferences-实现原理分析" class="headerlink" title="Android SharedPreferences 实现原理分析"></a>Android SharedPreferences 实现原理分析</h3><p><a href="https://www.jianshu.com/p/f7289e801a7f">https://www.jianshu.com/p/f7289e801a7f</a></p><p><a href="https://www.jianshu.com/p/ff8c256df6d2">https://www.jianshu.com/p/ff8c256df6d2</a></p><h3 id="为什么-Android-要采用-Binder-作为-IPC-机制？"><a href="#为什么-Android-要采用-Binder-作为-IPC-机制？" class="headerlink" title="为什么 Android 要采用 Binder 作为 IPC 机制？"></a>为什么 Android 要采用 Binder 作为 IPC 机制？</h3><p><strong>在开始回答 前，先简单概括性地说说Linux现有的所有进程间IPC方式：</strong></p><p>\1. <strong>管道：</strong>在创建时分配一个page大小的内存，缓存区大小比较有限；<br> \2. <strong>消息队列</strong>：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；<br> \3. <strong>共享内存</strong>：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；<br> \4. <strong>套接字</strong>：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；<br> \5. <strong>信号量</strong>：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。<br> \6. <strong>信号</strong>: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；</p><p><strong>Android的内核也是基于Linux内核，为何不直接采用Linux现有的进程IPC方案呢，难道Linux社区那么多优秀人员都没有考虑到有Binder这样一个更优秀的方案，是google太过于牛B吗？事实是真相并非如此，请细细往下看，您就明白了。</strong></p><blockquote><p>原文作者：Gityuan<br> 链接：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F39440766%2Fanswer%2F89210950">https://www.zhihu.com/question/39440766/answer/89210950</a></p></blockquote><hr><p><strong>接下来正面回答这个问题，从5个角度来展开对Binder的分析：</strong></p><p><strong>（1）从性能的角度</strong> <strong>数据拷贝次数：</strong>Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。</p><p><strong>（2）从稳定性的角度</strong><br> Binder是基于C/S架构的，简单解释下C/S架构，是指客户端(Client)和服务端(Server)组成的架构，Client端有什么需求，直接发送给Server端去完成，架构清晰明朗，Server端与Client端相对独立，稳定性较好；而共享内存实现方式复杂，没有客户与服务端之别， 需要充分考虑到访问临界资源的并发同步问题，否则可能会出现死锁等问题；从这稳定性角度看，Binder架构优越于共享内存。</p><p>仅仅从以上两点，各有优劣，还不足以支撑google去采用binder的IPC机制，那么更重要的原因是：</p><p><strong>（3）从安全的角度</strong><br> 传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份；而Android作为一个开放的开源体系，拥有非常多的开发平台，App来源甚广，因此手机的安全显得额外重要；对于普通用户，绝不希望从App商店下载偷窥隐射数据、后台造成手机耗电等等问题，传统Linux IPC无任何保护措施，完全由上层协议来确保。</p><p>Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志，前面提到C/S架构，<strong>Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限，目前权限控制很多时候是通过弹出权限询问对话框，让用户选择是否运行</strong>。Android 6.0，也称为Android M，在6.0之前的系统是在App第一次安装时，会将整个App所涉及的所有权限一次询问，只要留意看会发现很多App根本用不上通信录和短信，但在这一次性权限权限时会包含进去，让用户拒绝不得，因为拒绝后App无法正常使用，而一旦授权后，应用便可以胡作非为。</p><p>针对这个问题，google在Android M做了调整，不再是安装时一并询问所有权限，而是在App运行过程中，需要哪个权限再弹框询问用户是否给相应的权限，对权限做了更细地控制，让用户有了更多的可控性，但<strong>同时也带来了另一个用户诟病的地方，那也就是权限询问的弹框的次数大幅度增多。</strong>对于Android M平台上，有些App开发者可能会写出让手机异常频繁弹框的App，企图直到用户授权为止，这对用户来说是不能忍的，用户最后吐槽的可不光是App，还有Android系统以及手机厂商，有些用户可能就跳果粉了，这还需要广大Android开发者以及手机厂商共同努力，共同打造安全与体验俱佳的Android手机。</p><p>Android中权限控制策略有SELinux等多方面手段，下面列举从Binder的一个角度的权限控制：<br> <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F41003297%2Fanswer%2F89328987%3Ffrom%3Dprofile_answer_card">Android源码的Binder权限是如何控制？ -Gityuan的回答</a></p><p><strong>传统IPC</strong>只能由用户在数据包里填入UID/PID；另外，可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。从安全角度，Binder的安全性更高。</p><p><strong>说到这，可能有人要反驳</strong>，Android就算用了Binder架构，而现如今Android手机的各种流氓软件，不就是干着这种偷窥隐射，后台偷偷跑流量的事吗？没错，确实存在，但这不能说Binder的安全性不好，因为Android系统仍然是掌握主控权，可以控制这类App的流氓行为，只是对于该采用何种策略来控制，在这方面android的确存在很多有待进步的空间，这也是google以及各大手机厂商一直努力改善的地方之一。在Android 6.0，google对于app的权限问题作为较多的努力，大大收紧的应用权限；另外，在<strong>Google举办的Android Bootcamp 2016</strong>大会中，google也表示在Android 7.0 （也叫Android N）的权限隐私方面会进一步加强加固，比如SELinux，Memory safe language(还在research中)等等，在今年的5月18日至5月20日，google将推出Android N。</p><p>话题扯远了，继续说Binder。</p><p><strong>（4）从语言层面的角度</strong><br> 大家多知道Linux是基于C语言(面向过程的语言)，而Android是基于Java语言(面向对象的语句)，而对于Binder恰恰也符合面向对象的思想，将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。可以从一个进程传给其它进程，让大家都能访问同一Server，就像将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。从语言层面，Binder更适合基于面向对象语言的Android系统，对于Linux系统可能会有点“水土不服”。</p><p><strong>另外，Binder是为Android这类系统而生，而并非Linux社区没有想到Binder IPC机制的存在，对于Linux社区的广大开发人员，我还是表示深深佩服，让世界有了如此精湛而美妙的开源系统。</strong>也并非Linux现有的IPC机制不够好，相反地，经过这么多优秀工程师的不断打磨，依然非常优秀，每种Linux的IPC机制都有存在的价值，同时在Android系统中也依然采用了大量Linux现有的IPC机制，根据每类IPC的原理特性，因时制宜，不同场景特性往往会采用其下最适宜的。比如在<strong>Android OS中的Zygote进程的IPC采用的是Socket（套接字）机制</strong>，Android中的<strong>Kill Process采用的signal（信号）机制</strong>等等。而<strong>Binder更多则用在system_server进程与上层App层的IPC交互</strong>。</p><p><strong>(5) 从公司战略的角度</strong></p><p>总所周知，Linux内核是开源的系统，所开放源代码许可协议GPL保护，该协议具有“病毒式感染”的能力，怎么理解这句话呢？受GPL保护的Linux Kernel是运行在内核空间，对于上层的任何类库、服务、应用等运行在用户空间，一旦进行SysCall（系统调用），调用到底层Kernel，那么也必须遵循GPL协议。</p><p>而Android 之父 Andy Rubin对于GPL显然是不能接受的，为此，Google巧妙地将GPL协议控制在内核空间，将用户空间的协议采用Apache-2.0协议（允许基于Android的开发商不向社区反馈源码），同时在GPL协议与Apache-2.0之间的Lib库中采用BSD证授权方法，有效隔断了GPL的传染性，仍有较大争议，但至少目前缓解Android，让GPL止步于内核空间，这是Google在GPL Linux下 开源与商业化共存的一个成功典范。</p><p><strong>有了这些铺垫，我们再说说Binder的今世前缘</strong></p><p>Binder是基于开源的 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Fwww.angryredplanet.com%2F~hackbod%2Fopenbinder%2Fdocs%2Fhtml%2FBinderIPCMechanism.html">OpenBinder</a>实现的，OpenBinder是一个开源的系统IPC机制,最初是由 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fen.wikipedia.org%2Fwiki%2FBe_Inc.">Be Inc.</a> 开发，接着由<a href="https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPalm%2C_Inc.">Palm, Inc.</a>公司负责开发，现在OpenBinder的作者在Google工作，既然作者在Google公司，在用户空间采用Binder 作为核心的IPC机制，再用Apache-2.0协议保护，自然而然是没什么问题，减少法律风险，以及对开发成本也大有裨益的，那么从公司战略角度，Binder也是不错的选择。</p><p>另外，再说一点关于OpenBinder，在2015年OpenBinder以及合入到Linux Kernel主线 3.19版本，这也算是Google对Linux的一点回馈吧。</p><p><strong>综合上述5点，可知Binder是Android系统上层进程间通信的不二选择。</strong></p><hr><p><strong>接着，回答楼主提到的</strong>D-Bus</p><p>也采用C/S架构的IPC机制，<strong><a href="https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fwww.freedesktop.org%2Fwiki%2FSoftware%2Fdbus%2F">D-Bus</a></strong>是在用户空间实现的方法，效率低，消息拷贝次数和上下文切换次数都明显多过于Binder。针对D-Bus这些缺陷，于是就产生了<strong>kdbus</strong>，这是D-Bus在内核实现版，效率得到提升，与Binder一样在内核作为字符设计，通过open()打开设备，mmap()映射内存。</p><p>（1）kdbus在进程间通信过程，Client端将消息在内存的消息队列，可以存储大量的消息，Server端不断从消息队里中取消息，大小只受限内存；<br> （2）Binder的机制是每次通信，会通信的进程或线程中的todo队里中增加binder事务，并且每个进程所允许Binder线程数，google提供的默认最大线程数为16个，受限于CPU，由于线程数太多，增加系统负载，并且每个进程默认分配的（1M-8K）大小的内存。</p><p>而kdbus对于内存消耗较大，同时也适合传输大量数据和大量消息的系统。Binder对CPU和内存的需求比较低，效率比较高，从而进一步说明Binder适合于移动系统Android，但是，也有一定缺点，就是不同利用Binder输出大数据，比如利用Binder传输几M大小的图片，便会出现异常，虽然有厂商会增加Binder内存，但是也不可能比系统默认内存大很多，否则整个系统的可用内存大幅度降低。</p><p><strong>最后，简单讲讲Android Binder架构</strong></p><p>Binder在Android系统中江湖地位非常之高。在Zygote孵化出system_server进程后，在system_server进程中出初始化支持整个Android framework的各种各样的Service，而这些Service从大的方向来划分，分为Java层Framework和Native Framework层(C++)的Service，几乎都是基于BInder IPC机制。</p><ol><li><strong>Java framework：作为Server端继承(或间接继承)于Binder类，Client端继承(或间接继承)于BinderProxy类。</strong>例如 ActivityManagerService(用于控制Activity、Service、进程等) 这个服务作为Server端，间接继承Binder类，而相应的ActivityManager作为Client端，间接继承于BinderProxy类。 当然还有PackageManagerService、WindowManagerService等等很多系统服务都是采用C/S架构；</li><li><strong>Native Framework层：这是C++层，作为Server端继承(或间接继承)于BBinder类，Client端继承(或间接继承)于BpBinder。</strong>例如MediaPlayService(用于多媒体相关)作为Server端，继承于BBinder类，而相应的MediaPlay作为Client端，间接继承于BpBinder类。</li></ol><p><strong>总之，一句话”无Binder不Android”。</strong></p><h3 id="滑动冲突"><a href="#滑动冲突" class="headerlink" title="滑动冲突"></a>滑动冲突</h3><p><a href="https://www.jianshu.com/p/982a83271327">https://www.jianshu.com/p/982a83271327</a></p><p>Okhttp原理</p><p><a href="https://juejin.im/post/6844903903033557005">https://juejin.im/post/6844903903033557005</a></p><h3 id="冷启动，热启动"><a href="#冷启动，热启动" class="headerlink" title="冷启动，热启动"></a>冷启动，热启动</h3><p><a href="https://www.jianshu.com/p/eb3b410cce49">https://www.jianshu.com/p/eb3b410cce49</a></p><p><a href="https://blog.csdn.net/fafaws3000/article/details/103928571">https://blog.csdn.net/fafaws3000/article/details/103928571</a></p><h3 id="ART虚拟机"><a href="#ART虚拟机" class="headerlink" title="ART虚拟机"></a>ART虚拟机</h3><p><a href="https://source.android.com/devices/tech/dalvik">https://source.android.com/devices/tech/dalvik</a></p><p>Android Runtime (ART) 是 Android 上的应用和部分系统服务使用的托管式运行时。ART 及其前身 Dalvik 最初是专为 Android 项目打造的。作为运行时的 ART 可执行 Dalvik 可执行文件并遵循 Dex 字节码规范。</p><p>ART 和 Dalvik 是运行 Dex 字节码的兼容运行时，因此针对 Dalvik 开发的应用也能在 ART 环境中运作。不过，Dalvik 采用的一些技术并不适用于 ART。有关最重要问题的信息，请参阅<a href="http://developer.android.com/guide/practices/verifying-apps-art.html">在 Android Runtime (ART) 上验证应用行为</a>。</p><h2 id="ART-功能"><a href="#ART-功能" class="headerlink" title="ART 功能"></a>ART 功能</h2><p>以下是 ART 实现的一些主要功能。</p><h3 id="预先-AOT-编译"><a href="#预先-AOT-编译" class="headerlink" title="预先 (AOT) 编译"></a>预先 (AOT) 编译</h3><p>ART 引入了预先编译机制，可提高应用的性能。ART 还具有比 Dalvik 更严格的安装时验证。</p><p>在安装时，ART 使用设备自带的 <strong>dex2oat</strong> 工具来编译应用。此实用工具接受 <a href="https://source.android.com/devices/tech/dalvik/dex-format">DEX</a> 文件作为输入，并为目标设备生成经过编译的应用可执行文件。该工具应能够顺利编译所有有效的 DEX 文件。但是，一些后处理工具会生成无效文件，Dalvik 可以接受这些文件，但 ART 无法编译这些文件。如需了解详情，请参阅<a href="http://developer.android.com/guide/practices/verifying-apps-art.html#GC_Migration">处理垃圾回收问题</a>。</p><h3 id="垃圾回收方面的优化"><a href="#垃圾回收方面的优化" class="headerlink" title="垃圾回收方面的优化"></a>垃圾回收方面的优化</h3><p>垃圾回收 (GC) 可能有损于应用性能，从而导致显示不稳定、界面响应速度缓慢以及其他问题。ART 通过以下几种方式对垃圾回收做了优化：</p><ul><li>只有一次（而非两次）GC 暂停</li><li>在 GC 保持暂停状态期间并行处理</li><li>在清理最近分配的短时对象这种特殊情况中，回收器的总 GC 时间更短</li><li>优化了垃圾回收的工效，能够更加及时地进行并行垃圾回收，这使得 <a href="http://developer.android.com/tools/debugging/debugging-memory.html#LogMessages"><code>GC_FOR_ALLOC</code></a> 事件在典型用例中极为罕见</li><li>压缩 GC 以减少后台内存使用和碎片</li></ul><h3 id="开发和调试方面的优化"><a href="#开发和调试方面的优化" class="headerlink" title="开发和调试方面的优化"></a>开发和调试方面的优化</h3><p>ART 提供了大量功能来优化应用开发和调试。</p><h4 id="支持采样分析器"><a href="#支持采样分析器" class="headerlink" title="支持采样分析器"></a>支持采样分析器</h4><p>一直以来，开发者都使用 <a href="http://developer.android.com/tools/help/traceview.html">Traceview</a> 工具（用于跟踪应用执行情况）作为分析器。虽然 Traceview 可提供有用的信息，但每次方法调用产生的开销会导致 Dalvik 分析结果出现偏差，而且使用该工具明显会影响运行时性能。</p><p>ART 添加了对没有这些限制的专用采样分析器的支持，因而可更准确地了解应用执行情况，而不会明显减慢速度。KitKat 版本为 Dalvik 的 Traceview 添加了采样支持。</p><h4 id="支持更多调试功能"><a href="#支持更多调试功能" class="headerlink" title="支持更多调试功能"></a>支持更多调试功能</h4><p>ART 支持许多新的调试选项，特别是与监控和垃圾回收相关的功能。例如，您可以：</p><ul><li>查看堆栈跟踪中保留了哪些锁，然后跳转到持有锁的线程。</li><li>询问指定类的当前活动的实例数、请求查看实例，以及查看使对象保持有效状态的参考。</li><li>过滤特定实例的事件（如断点）。</li><li>查看方法退出（使用“method-exit”事件）时返回的值。</li><li>设置字段观察点，以在访问和/或修改特定字段时暂停程序执行。</li></ul><h4 id="优化了异常和崩溃报告中的诊断详细信息"><a href="#优化了异常和崩溃报告中的诊断详细信息" class="headerlink" title="优化了异常和崩溃报告中的诊断详细信息"></a>优化了异常和崩溃报告中的诊断详细信息</h4><p>当发生运行时异常时，ART 会为您提供尽可能多的上下文和详细信息。ART 会提供 <code>java.lang.ClassCastException</code>、<code>java.lang.ClassNotFoundException</code> 和 <code>java.lang.NullPointerException</code> 的更多异常详细信息。（较高版本的 Dalvik 会提供 <code>java.lang.ArrayIndexOutOfBoundsException</code> 和 <code>java.lang.ArrayStoreException</code> 的更多异常详细信息，这些信息现在包括数组大小和越界偏移量；ART 也提供这类信息。）</p><p>例如，<code>java.lang.NullPointerException</code> 现在会显示有关应用尝试处理 null 指针时所执行操作的信息，例如应用尝试写入的字段或尝试调用的方法。一些典型示例如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException: Attempt <span class="keyword">to</span> <span class="keyword">write</span> <span class="keyword">to</span> field <span class="string">&#x27;int</span></span><br><span class="line"><span class="string">android.accessibilityservice.AccessibilityServiceInfo.flags&#x27;</span> <span class="keyword">on</span> a null object</span><br><span class="line"><span class="keyword">reference</span></span><br><span class="line">java.lang.NullPointerException: Attempt <span class="keyword">to</span> invoke <span class="keyword">virtual</span> <span class="keyword">method</span></span><br><span class="line">&#x27;<span class="title function_">java</span>.<span class="title function_">lang</span>.<span class="title function_">String</span> <span class="title function_">java</span>.<span class="title function_">lang</span>.<span class="title function_">Object</span>.<span class="title function_">toString</span><span class="params">()</span>&#x27; <span class="title function_">on</span> <span class="title function_">a</span> <span class="title function_">null</span> <span class="title function_">object</span> <span class="title function_">reference</span></span><br></pre></td></tr></table></figure><p>ART 还通过纳入 Java 和原生堆栈信息，在应用原生代码崩溃报告中提供更实用的上下文信息。</p><h3 id="JAVA阻塞队列"><a href="#JAVA阻塞队列" class="headerlink" title="JAVA阻塞队列"></a>JAVA阻塞队列</h3><p><a href="https://juejin.im/post/6844903640709201934">https://juejin.im/post/6844903640709201934</a></p><p><a href="https://www.infoq.cn/article/java-blocking-queue">https://www.infoq.cn/article/java-blocking-queue</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;facedetecor-人脸识别&quot;&gt;&lt;a href=&quot;#facedetecor-人脸识别&quot; class=&quot;headerlink&quot; title=&quot;facedetecor 人脸识别&quot;&gt;&lt;/a&gt;facedetecor 人脸识别&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/RedApparat/FaceDetector&quot;&gt;github仓库地址&lt;/a&gt;&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JAVA" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JAVA/"/>
    
    
    <category term="Android" scheme="http://yorxika.github.io/tags/Android/"/>
    
    <category term="JAVA" scheme="http://yorxika.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>分割数组的最大值</title>
    <link href="http://yorxika.github.io/2020/08/02/%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://yorxika.github.io/2020/08/02/%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2020-08-01T17:04:58.000Z</published>
    <updated>2020-08-01T17:12:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第410题分割数组的最大值</p><p>给定一个非负整数数组和一个整数 <em>m</em>，你需要将这个数组分成 <em>m</em> 个非空的连续子数组。设计一个算法使得这 <em>m</em> 个子数组各自和的最大值最小。<br><span id="more"></span><br><strong>示例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line">nums = [7,2,5,10,8]</span><br><span class="line">m = 2</span><br><span class="line"></span><br><span class="line"><span class="section">输出:</span></span><br><span class="line">18</span><br><span class="line"></span><br><span class="line"><span class="section">解释:</span></span><br><span class="line">一共有四种方法将nums分割为2个子数组。</span><br><span class="line">其中最好的方式是将其分为[7,2,5] 和 [10,8]，</span><br><span class="line">因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</span><br></pre></td></tr></table></figure><hr><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>来自官方题解</p><p>「使……最大值尽可能小」是二分搜索题目常见的问法。</p><p>本题中，我们注意到：当我们选定一个值 x<em>x</em>，我们可以线性地验证是否存在一种分割方案，满足其最大分割子数组和不超过 x<em>x</em>。策略如下：</p><blockquote><p>贪心地模拟分割的过程，从前到后遍历数组，用 \textit{sum}<em>sum</em> 表示当前分割子数组的和，\textit{cnt}<em>cnt</em> 表示已经分割出的子数组的数量（包括当前子数组），那么每当 \textit{sum}<em>sum</em> 加上当前值超过了 x<em>x</em>，我们就把当前取的值作为新的一段分割子数组的开头，并将 \textit{cnt}<em>cnt</em> 加 11。遍历结束后验证是否 \textit{cnt}<em>cnt</em> 不超过 m<em>m</em>。</p></blockquote><p>这样我们可以用二分查找来解决。二分的上界为数组 <em>nums</em> 中所有元素的和，下界为数组 <em>nums</em> 中所有元素的最大值。通过二分查找，我们可以得到最小的最大分割子数组和，这样就可以得到最终的答案了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">splitArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> nums[<span class="number">0</span>] , right = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">        right += nums[i];  <span class="comment">//right表示解范围的最大值</span></span><br><span class="line">        left = Math.max(left,nums[i]);  <span class="comment">//left为数组最大值，解范围的最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(nums,mid,m))  <span class="comment">//如果这个最大和满足，就把这个最大和变小</span></span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断给定的x，求数组的最大和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> x,<span class="type">int</span> m)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum + nums[i] &gt; x)&#123; <span class="comment">//如果子数组和比给定的最大值还大</span></span><br><span class="line">            count ++;  <span class="comment">//重新开始计算子数组的和，并且计数+1</span></span><br><span class="line">            sum = nums[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>  <span class="comment">//不超过子数组的和，就继续累加</span></span><br><span class="line">            sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &lt;= m;  <span class="comment">//如果不超过给定划分个数，就是符合的 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第410题分割数组的最大值&lt;/p&gt;
&lt;p&gt;给定一个非负整数数组和一个整数 &lt;em&gt;m&lt;/em&gt;，你需要将这个数组分成 &lt;em&gt;m&lt;/em&gt; 个非空的连续子数组。设计一个算法使得这 &lt;em&gt;m&lt;/em&gt; 个子数组各自和的最大值最小。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="二分查找" scheme="http://yorxika.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>恢复空格</title>
    <link href="http://yorxika.github.io/2020/08/02/%E6%81%A2%E5%A4%8D%E7%A9%BA%E6%A0%BC/"/>
    <id>http://yorxika.github.io/2020/08/02/%E6%81%A2%E5%A4%8D%E7%A9%BA%E6%A0%BC/</id>
    <published>2020-08-01T16:44:30.000Z</published>
    <updated>2020-08-01T16:56:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode面试题17.13 恢复空格</p><p>哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子<code>&quot;I reset the computer. It still didn’t boot!&quot;</code>已经变成了<code>&quot;iresetthecomputeritstilldidntboot&quot;</code>。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典<code>dictionary</code>，不过，有些词没在词典里。假设文章用<code>sentence</code>表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。</p><p><strong>注意：</strong>本题相对原题稍作改动，只需返回未识别的字符数<br><span id="more"></span><br><strong>示例：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">dictionary = [<span class="string">&quot;looked&quot;</span>,<span class="string">&quot;just&quot;</span>,<span class="string">&quot;like&quot;</span>,<span class="string">&quot;her&quot;</span>,<span class="string">&quot;brother&quot;</span>]</span><br><span class="line">sentence = <span class="string">&quot;jesslookedjustliketimherbrother&quot;</span></span><br><span class="line">输出： 7</span><br><span class="line">解释： 断句后为<span class="string">&quot;jess looked just like tim her brother&quot;</span>，共7个未识别字符。</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><code>dp[i]</code> 表示字符串的前 <code>i</code> 个字符的最少未匹配数。</p><p>假设当前我们已经考虑完了前 <code>i</code> 个字符了，对于前 <code>i + 1</code> 个字符对应的最少未匹配数：</p><ol><li>第 <code>i + 1</code> 个字符未匹配，则 <code>dp[i + 1] = dp[i] + 1</code>，即不匹配数加 1;</li><li>遍历前 <code>i</code> 个字符，若以其中某一个下标 <code>idx</code> 为开头、以第 <code>i + 1</code> 个字符为结尾的字符串正好在词典里，则 <code>dp[i] = min(dp[i], dp[idx])</code> 更新 <code>dp[i]</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">respace</span><span class="params">(String[] dictionary, String sentence)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; dict = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(dictionary));</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sentence.length();</span><br><span class="line">    <span class="comment">//dp[i]表示字符串前i个字符的最少未匹配数</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= len ; ++i)&#123;</span><br><span class="line">        <span class="comment">//多了一个未识别数</span></span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span> ; index &lt; i ; index++)&#123;</span><br><span class="line">            <span class="comment">//i从1开始，index从0开始，很巧妙</span></span><br><span class="line">            <span class="comment">//相当于是倒着遍历</span></span><br><span class="line">            <span class="keyword">if</span>(dict.contains(sentence.substring(index,i)))</span><br><span class="line">                dp[i] = Math.min(dp[i],dp[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>//todo</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode面试题17.13 恢复空格&lt;/p&gt;
&lt;p&gt;哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子&lt;code&gt;&amp;quot;I reset the computer. It still didn’t boot!&amp;quot;&lt;/code&gt;已经变成了&lt;code&gt;&amp;quot;iresetthecomputeritstilldidntboot&amp;quot;&lt;/code&gt;。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典&lt;code&gt;dictionary&lt;/code&gt;，不过，有些词没在词典里。假设文章用&lt;code&gt;sentence&lt;/code&gt;表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;本题相对原题稍作改动，只需返回未识别的字符数&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="Trie树" scheme="http://yorxika.github.io/tags/Trie%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>最小区间</title>
    <link href="http://yorxika.github.io/2020/08/02/%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/"/>
    <id>http://yorxika.github.io/2020/08/02/%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/</id>
    <published>2020-08-01T16:06:31.000Z</published>
    <updated>2020-08-01T16:26:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode632题最小区间</p><p>你有 <code>k</code> 个升序排列的整数数组。找到一个<strong>最小</strong>区间，使得 <code>k</code> 个列表中的每个列表至少有一个数包含在其中。</p><p>我们定义如果 <code>b-a &lt; d-c</code> 或者在 <code>b-a == d-c</code> 时 <code>a &lt; c</code>，则区间 [a,b] 比 [c,d] 小。<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:<span class="comment">[<span class="comment">[4,10,15,24,26]</span>, <span class="comment">[0,9,12,20]</span>, <span class="comment">[5,18,22,30]</span>]</span></span><br><span class="line">输出: <span class="comment">[20,24]</span></span><br><span class="line">解释: </span><br><span class="line">列表 1：<span class="comment">[4, 10, 15, 24, 26]</span>，24 在区间 <span class="comment">[20,24]</span> 中。</span><br><span class="line">列表 2：<span class="comment">[0, 9, 12, 20]</span>，20 在区间 <span class="comment">[20,24]</span> 中。</span><br><span class="line">列表 3：<span class="comment">[5, 18, 22, 30]</span>，22 在区间 <span class="comment">[20,24]</span> 中。</span><br></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>维护1个大根堆以及一个小根堆，注意到这k个数组是<strong>升序</strong>排列的有序数组，因而初始化时将这k个数组的首元素放进堆里；之后遍历小根堆，退出条件是小根堆的大小小于k，当小根堆的大小小于k时就不满足k个列表中的每个列表至少有一个数包含在其中。在遍历小根堆时，取出大根堆以及小根堆的元素，这样就满足了k个列表中的每个列表至少有一个数包含在这个区间中，接下来判断长度，如果长度小于已知长度，就修改答案，同时移除大小根堆的元素，加入移除元素在数组里的下一位置元素，重构堆。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</span><br><span class="line">    <span class="comment">//小根堆，记录元素的二维坐标</span></span><br><span class="line">    Queue&lt;<span class="type">int</span> []&gt; minQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt</span><br><span class="line">            (arr -&gt; nums.get(arr[<span class="number">0</span>]).get(arr[<span class="number">1</span>])));</span><br><span class="line">    <span class="comment">//大根堆，记录元素的二维坐标</span></span><br><span class="line">    Queue&lt;<span class="type">int</span> []&gt; maxQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((arr1,arr2) -&gt;</span><br><span class="line">            nums.get(arr2[<span class="number">0</span>]).get(arr2[<span class="number">1</span>]) - nums.get(arr1[<span class="number">0</span>]).get(arr1[<span class="number">1</span>]));</span><br><span class="line">    <span class="type">int</span>[] ans = &#123;Integer.MIN_VALUE,Integer.MAX_VALUE&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.size() ; ++i)&#123;</span><br><span class="line">        <span class="comment">//将每列的第一个元素都加进去</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,<span class="number">0</span>&#125;;</span><br><span class="line">        minQueue.offer(temp);</span><br><span class="line">        maxQueue.offer(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (minQueue.size() == nums.size())&#123;</span><br><span class="line">        <span class="comment">//取出小根堆堆顶元素</span></span><br><span class="line">        <span class="type">int</span>[] minArr = minQueue.poll();</span><br><span class="line">        <span class="comment">//取出大根堆堆顶元素</span></span><br><span class="line">        <span class="type">int</span>[] maxArr = maxQueue.peek();</span><br><span class="line">        <span class="comment">//此时在这两个元素至少包含所有数组的一个元素</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="type">long</span>)nums.get(maxArr[<span class="number">0</span>]).get(maxArr[<span class="number">1</span>]) - (<span class="type">long</span>)nums.get(minArr[<span class="number">0</span>]).get(minArr[<span class="number">1</span>])</span><br><span class="line">        &lt; (<span class="type">long</span>)ans[<span class="number">1</span>] - ans[<span class="number">0</span>])&#123;</span><br><span class="line">            ans[<span class="number">0</span>] = nums.get(minArr[<span class="number">0</span>]).get(minArr[<span class="number">1</span>]);</span><br><span class="line">            ans[<span class="number">1</span>] = nums.get(maxArr[<span class="number">0</span>]).get(maxArr[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//比较过后可以丢弃掉小根堆的元素，同时添加下一元素到堆里</span></span><br><span class="line">        <span class="keyword">if</span>(minArr[<span class="number">1</span>] &lt; nums.get(minArr[<span class="number">0</span>]).size() - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span>[] newArr = &#123;minArr[<span class="number">0</span>],minArr[<span class="number">1</span>] + <span class="number">1</span>&#125;;</span><br><span class="line">            minQueue.offer(newArr);</span><br><span class="line">            maxQueue.remove(minArr);</span><br><span class="line">            maxQueue.offer(newArr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过堆的实现还是可以看看官方题解，只用维护一下小根堆，以及一个全局最大值，对应的next数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rangeLeft</span> <span class="operator">=</span> <span class="number">0</span>, rangeRight = Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minRange</span> <span class="operator">=</span> rangeRight - rangeLeft;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.size();</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="comment">//小根堆里维护的是k个列表的指针</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer index1, Integer index2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums.get(index1).get(next[index1]) - nums.get(index2).get(next[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            priorityQueue.offer(i);</span><br><span class="line">            max = Math.max(max, nums.get(i).get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> priorityQueue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">curRange</span> <span class="operator">=</span> max - nums.get(minIndex).get(next[minIndex]);</span><br><span class="line">            <span class="keyword">if</span> (curRange &lt; minRange) &#123;</span><br><span class="line">                minRange = curRange;</span><br><span class="line">                rangeLeft = nums.get(minIndex).get(next[minIndex]);</span><br><span class="line">                rangeRight = max;</span><br><span class="line">            &#125;</span><br><span class="line">            next[minIndex]++;</span><br><span class="line">            <span class="comment">//这里的break也是和上面是一样的意思，为了维护k个列表的堆</span></span><br><span class="line">            <span class="keyword">if</span> (next[minIndex] == nums.get(minIndex).size()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里设置comparator，比较的其实是next[minIndex]里对应的数值</span></span><br><span class="line">            priorityQueue.offer(minIndex);</span><br><span class="line">            max = Math.max(max, nums.get(minIndex).get(next[minIndex]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;rangeLeft, rangeRight&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode632题最小区间&lt;/p&gt;
&lt;p&gt;你有 &lt;code&gt;k&lt;/code&gt; 个升序排列的整数数组。找到一个&lt;strong&gt;最小&lt;/strong&gt;区间，使得 &lt;code&gt;k&lt;/code&gt; 个列表中的每个列表至少有一个数包含在其中。&lt;/p&gt;
&lt;p&gt;我们定义如果 &lt;code&gt;b-a &amp;lt; d-c&lt;/code&gt; 或者在 &lt;code&gt;b-a == d-c&lt;/code&gt; 时 &lt;code&gt;a &amp;lt; c&lt;/code&gt;，则区间 [a,b] 比 [c,d] 小。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="堆" scheme="http://yorxika.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>地下城游戏</title>
    <link href="http://yorxika.github.io/2020/07/17/%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/"/>
    <id>http://yorxika.github.io/2020/07/17/%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/</id>
    <published>2020-07-16T16:23:59.000Z</published>
    <updated>2020-07-16T16:41:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第174题地下城游戏</p><p>一些恶魔抓住了公主（<strong>P</strong>）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（<strong>K</strong>）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p><p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。<br><span id="more"></span><br>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p><p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p><p><strong>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</strong></p><p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 <code>右 -&gt; 右 -&gt; 下 -&gt; 下</code>，则骑士的初始健康点数至少为 <strong>7</strong>。</p><div class="table-container"><table><thead><tr><th>-2 (K)</th><th>-3</th><th>3</th></tr></thead><tbody><tr><td>-5</td><td>-10</td><td>1</td></tr><tr><td>10</td><td>30</td><td>-5 (P)</td></tr></tbody></table></div><p><strong>说明:</strong></p><ul><li>骑士的健康点数没有上限。</li><li>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>要找到确保能找到公主的最低体力值，那么就要求走过的路径尽可能短。采用自顶向下的动态规划，从终点开始，由于要求最低体力值，所以不妨假设在终点时最终体力值为1，那么到达改该点需要的最大体力值则为$Max(1,1-dp[row][col])$,接下来从该点倒序遍历求到达该点最短路径需要的最大体力值，因而为$Max(1,Min(dp[i+1][j],dp[i][j+1])-dp[i][j])$，即保证到达下一个格子的体力值始终为正，要注意处理边界情况，即最后一行和最后一列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateMinimumHP</span><span class="params">(<span class="type">int</span>[][] dungeon)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(dungeon == <span class="literal">null</span> || dungeon[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> row=dungeon.length;</span><br><span class="line">        <span class="type">int</span> col=dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//这个数组表示在i,j位置骑士需要的最小生命值</span></span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=row-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=col-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==row-<span class="number">1</span>&amp;&amp;j==col-<span class="number">1</span>)&#123; <span class="comment">//终点的情况</span></span><br><span class="line">                    dp[i][j]=Math.max(<span class="number">1</span>, <span class="number">1</span>-dungeon[i][j]);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==row-<span class="number">1</span>)&#123; <span class="comment">//最后一行的情况</span></span><br><span class="line">                    dp[i][j]=Math.max(<span class="number">1</span>, dp[i][j+<span class="number">1</span>]-dungeon[i][j]);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==col-<span class="number">1</span>)&#123; <span class="comment">//最后一列的情况</span></span><br><span class="line">                    dp[i][j]=Math.max(<span class="number">1</span>, dp[i+<span class="number">1</span>][j]-dungeon[i][j]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=Math.max(<span class="number">1</span>, Math.min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>])-dungeon[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方题解通过拓展了数组，进而减少了无关的边界判断：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateMinimumHP</span><span class="params">(<span class="type">int</span>[][] dungeon)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> dungeon.length, m = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[n][m - <span class="number">1</span>] = dp[n - <span class="number">1</span>][m] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">minn</span> <span class="operator">=</span> Math.min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]);</span><br><span class="line">                dp[i][j] = Math.max(minn - dungeon[i][j], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第174题地下城游戏&lt;/p&gt;
&lt;p&gt;一些恶魔抓住了公主（&lt;strong&gt;P&lt;/strong&gt;）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（&lt;strong&gt;K&lt;/strong&gt;）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。&lt;/p&gt;
&lt;p&gt;骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>两个数组的交集II</title>
    <link href="http://yorxika.github.io/2020/07/14/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/"/>
    <id>http://yorxika.github.io/2020/07/14/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/</id>
    <published>2020-07-13T17:01:31.000Z</published>
    <updated>2020-07-13T17:08:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自力扣第350题两个数组的交集II</p><p>给定两个数组，编写一个函数来计算它们的交集。<br><span id="more"></span><br><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1,2,2,1]</span>, nums2 = <span class="comment">[2,2]</span></span><br><span class="line">输出：<span class="comment">[2,2]</span></span><br></pre></td></tr></table></figure><h3 id="哈希map"><a href="#哈希map" class="headerlink" title="哈希map"></a>哈希map</h3><p>常规写法，用一个map存储两个数组中较短数组的元素，以及次数，接着遍历第二个数组，判断第二个数组里的元素是否存在于map里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums1.length &gt; nums2.length)</span><br><span class="line">        <span class="keyword">return</span> intersect(nums2,nums1);</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : nums1) &#123;</span><br><span class="line">        map.put(value, map.getOrDefault(value, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> value : nums2)&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> map.getOrDefault(value,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(value);</span><br><span class="line">            map.put(value,a-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[ans.size()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; ans.size() ; i++)</span><br><span class="line">        res[i] = ans.get(i);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>太久没写题了，都忘记还有排序后双指针的做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="comment">// 排好序的写法</span></span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line">    Arrays.sort(nums2);</span><br><span class="line">    <span class="comment">// 定义i，j两个指针，k用于记录交集的索引值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            <span class="comment">// 说明num1[i]较小，i右移</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            <span class="comment">// 说明nums2[j]较小，j右移</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 两个元素相同，记录在k</span></span><br><span class="line">            nums1[k++] = nums1[i];</span><br><span class="line">            <span class="comment">// 两个指针向前走一步</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOfRange(nums1, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="另类哈希"><a href="#另类哈希" class="headerlink" title="另类哈希"></a>另类哈希</h3><p>找执行用时范例里看到的，本质上也是一种hash，只不过事先预设或找出测试用例里最大的元素值，那么这样对其求余即可，用数组作为哈希表，提升了运行时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAGIC</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> freq[] = <span class="keyword">new</span> <span class="title class_">int</span>[MAGIC];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">        freq[Math.abs(nums1[i] % MAGIC)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (freq[Math.abs(nums2[i] % MAGIC)]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           res[j++] = nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(res, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自力扣第350题两个数组的交集II&lt;/p&gt;
&lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="双指针" scheme="http://yorxika.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>和为K的子数组</title>
    <link href="http://yorxika.github.io/2020/05/18/%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yorxika.github.io/2020/05/18/%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2020-05-18T14:44:53.000Z</published>
    <updated>2020-05-18T15:34:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第560题和为K的子数组</p><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。<br><span id="more"></span><br><strong>示例 1 :</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:nums = <span class="comment">[1,1,1]</span>, k = 2</span><br><span class="line">输出: 2 , <span class="comment">[1,1]</span> 与 <span class="comment">[1,1]</span> 为两种不同的情况。</span><br></pre></td></tr></table></figure><h3 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h3><p>$O(n^2)$，但是要考虑负数的情况，因而不能当$result &gt; k$时就跳出循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j &lt; nums.length;j++)&#123;</span><br><span class="line">                result += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(result == k)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">/* if(result &gt; k)</span></span><br><span class="line"><span class="comment">                break;*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>定义$pre[i]$为数组$[0..i]$里所有数的和，则有$pre[i] = pre[i-1] + nums[i]$<br>进而$[j…i]这个子数组的和为k$可以转化为$pre[i] - pre[j-1] == k $<br>进而有$pre[j-1] == pre[i]-k$<br>所以考虑以$i$结尾的和为$k$的连续子数组需要统计前缀和为$pre[i]-k 的 pre[j]$的出现次数。可以考虑用一个HashMap存储前缀和以及对应的出现次数，从左往右遍历一遍即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums ,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span> ,preSum = <span class="number">0</span>;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>,<span class="number">1</span>);  <span class="comment">//特例</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length ; ++i)&#123;</span><br><span class="line">        preSum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(preSum -k))&#123;</span><br><span class="line">            cnt += map.get(preSum - k);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(preSum,map.getOrDefault(preSum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀和优化"><a href="#前缀和优化" class="headerlink" title="前缀和优化"></a>前缀和优化</h3><p>将$nums[i]$当作从$[0…i]$里所有数的前缀和，记录前缀和里的最大值最小值max,min,这样开始数组做HashMap时只需要$max - min + 1$大小的空间。<br>接下来就是对前缀和遍历，如果前缀和$nums[i]==k$，对应的计数就加一，如果$nums[i]-k&gt;=min \&amp;\&amp; nums[i]-k&lt;=max$说明$map[nums[i] - k - min]$也是满足上文中提到的$pre[j-1] == pre[i]-k$的例子，之所以要满足$nums[i]-k&gt;=min \&amp;\&amp; nums[i]-k&lt;=max$是为了避免越界。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> min=nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">nums[i]+=nums[i-<span class="number">1</span>];</span><br><span class="line">max=max&gt;nums[i]?max:nums[i];</span><br><span class="line">min=min&lt;nums[i]?min:nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> map[]=<span class="keyword">new</span> <span class="title class_">int</span>[max-min+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i]==k)&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums[i]-k&gt;=min&amp;&amp;nums[i]-k&lt;=max)&#123;</span><br><span class="line">    count+=map[nums[i]-k-min];</span><br><span class="line">&#125;</span><br><span class="line">map[nums[i]-min]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第560题和为K的子数组&lt;/p&gt;
&lt;p&gt;给定一个整数数组和一个整数 &lt;strong&gt;k，&lt;/strong&gt;你需要找到该数组中和为 &lt;strong&gt;k&lt;/strong&gt; 的连续的子数组的个数。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="数组" scheme="http://yorxika.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://yorxika.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>统计优美子数组</title>
    <link href="http://yorxika.github.io/2020/05/10/%E7%BB%9F%E8%AE%A1%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yorxika.github.io/2020/05/10/%E7%BB%9F%E8%AE%A1%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2020-05-10T06:09:35.000Z</published>
    <updated>2020-05-18T13:17:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode1248题统计优美子数组</p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。</p><p>如果某个 <strong>连续</strong> 子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「<strong>优美子数组</strong>」。</p><p>请返回这个数组中「优美子数组」的数目。<br><span id="more"></span><br><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1,1,2,1</span>,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：包含 <span class="number">3</span> 个奇数的子数组是 [<span class="number">1,1,2,1</span>] 和 [<span class="number">1,2,1,1</span>] 。</span><br></pre></td></tr></table></figure><hr><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>用一个辅助数组odd存放原数组nums里奇数位的下标，接着对odd数组遍历，取当前数值j(即原本nums数组里某奇数的下标为j)到其前一个奇数的距离（即odd[i] - odd[i-1]）乘上后k个奇数的下标以及他能拓展的长度。</p><p>总的来说就是用数组存了2个指针，这2个指针刚好指向第一个奇数和第k个奇数，接下来再分别往前往后拓展，拓展相乘的结果就是当前k个连续奇数的可能情况，最后对所有结果再累加即可。<img src="/2020/05/10/%E7%BB%9F%E8%AE%A1%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84/05/10/%E7%BB%9F%E8%AE%A1%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84/c07fdee6a57f189e1ccd7aa1487f2ff76f2f392bfdbece516d4cc9e29df6a0b4-image.png" alt="image.png"></p><p>图来自力扣<a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/solution/java-hua-dong-chuang-kou-xiang-jie-zhi-xing-yong-s/">题解</a></p><p>将奇数的下标用数组储存，其中<strong>橘色部分为奇数出现的位置，蓝色部分标定数组的边界</strong>。对于每种子情形，其可能数为：(arr[i] - arr[i - 1]) * (arr[i + k] - arr[i + k - 1]),其中，左边界为−1，右边界为arr.length。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] odd = <span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span> , cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[i] &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                odd[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        odd[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        odd[++cnt] = len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i + k &lt;= cnt ; ++i)</span><br><span class="line">            ans += (odd[i] - odd[i-<span class="number">1</span>]) * (odd[i+k] - odd[i+k-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>来自<a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/solution/hua-dong-chuang-kou-qian-zhui-he-bi-xu-miao-dong-b/">sweetiee</a></p><ol><li>计算前缀和数组 <code>arr</code>：遍历原数组，每遍历一个元素，计算当前的前缀和（即到当前元素为止，数组中有多少个奇数）；</li><li>对上述前缀和数组，双重循环统计 <code>arr[j] - arr[i] == k</code> 的个数，这样做是 O(N^2)<em>O</em>(<em>N</em>2) 的（这里会超时哦）。</li><li><strong>优化</strong>：因此，我们可以像「<a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a>」那样使用 <code>HashMap</code> 优化到 <em>O</em>(<em>N</em>)，键是「前缀和」，值是「前缀和的个数」（下面代码中具体使用的是 <code>int[] prefixCnt</code> 数组，下标是「前缀和」，值是「前缀和的个数」），因此我们可以遍历原数组，每遍历到一个元素，计算当前的前缀和 <code>sum</code>，就在 <code>res</code> 中累加上前缀和为 <code>sum - k</code> 的个数。</li><li>这里的前缀和指的是从0开始到当前元素这个区间的奇数的个数，所以两个前缀和的差就是两个元素之间的奇数的个数，我们要找的就是奇数个数为k的区间哈。prefixCnt数组是用来统计的是前缀和的个数，数组下标是前缀和，值是个数。如果当前的前缀数组的奇数个数为s2，那我们需要看有多少个前缀数组的奇数个数为 s1 = s2 - k 的，那么这些区间的奇数个数都是k，就累加到res中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 数组 prefixCnt 的下标是前缀和（即当前奇数的个数），值是前缀和的个数。</span></span><br><span class="line">        <span class="type">int</span>[] prefixCnt = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        prefixCnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 遍历原数组，计算当前的前缀和，统计到 prefixCnt 数组中，</span></span><br><span class="line">        <span class="comment">// 并且在 res 中累加上与当前前缀和差值为 k 的前缀和的个数。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            sum += num &amp; <span class="number">1</span>;</span><br><span class="line">            prefixCnt[sum]++;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= k) &#123;  <span class="comment">//说明已经有k个奇数</span></span><br><span class="line">                res += prefixCnt[sum - k];</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode1248题统计优美子数组&lt;/p&gt;
&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果某个 &lt;strong&gt;连续&lt;/strong&gt; 子数组中恰好有 &lt;code&gt;k&lt;/code&gt; 个奇数数字，我们就认为这个子数组是「&lt;strong&gt;优美子数组&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;请返回这个数组中「优美子数组」的数目。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="双指针" scheme="http://yorxika.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="滑动窗口" scheme="http://yorxika.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>数组中的逆序对</title>
    <link href="http://yorxika.github.io/2020/05/08/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>http://yorxika.github.io/2020/05/08/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</id>
    <published>2020-05-08T13:26:14.000Z</published>
    <updated>2020-05-08T13:43:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode面试题51.数组中的逆序对</p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [7,5,6,4]</span></span><br><span class="line"><span class="section">输出: 5</span></span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>这题其实在算法导论里就有提到。</p><p>以下内容来自<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/bao-li-jie-fa-fen-zhi-si-xiang-shu-zhuang-shu-zu-b/">liweiwei</a></p><ul><li>利用「归并排序」计算逆序对，是非常经典的做法；</li><li><strong>关键在于「合并两个有序数组」的步骤，利用数组的部分有序性</strong>，一下子计算出一个数之前或者之后元素的逆序的个数；</li><li><strong>前面「分」的时候什么都不做，「合」的过程中计算「逆序对」的个数</strong>；</li><li>「排序」的工作是必要的，正是因为「排序」才能在下一轮利用顺序关系加快逆序数的计算，也能避免重复计算；</li><li>在代码实现上，只需要在「归并排序」代码的基础上，加上「逆序对」个数的计算，计算公式需要自己在草稿纸上推导。</li></ul><p>所有的「逆序对」来源于 3 个部分：</p><ul><li>左边区间的逆序对；</li><li>右边区间的逆序对；</li><li>横跨两个区间的逆序对。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            copy[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">return</span> reversePairs(copy, <span class="number">0</span>, len - <span class="number">1</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * nums[left..right] 计算逆序对个数并且排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftPairs</span> <span class="operator">=</span> reversePairs(nums, left, mid, temp);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightPairs</span> <span class="operator">=</span> reversePairs(nums, mid + <span class="number">1</span>, right, temp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果整个数组已经有序，则无需合并，注意这里使用小于等于</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftPairs + rightPairs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">crossPairs</span> <span class="operator">=</span> mergeAndCount(nums, left, mid, right, temp);</span><br><span class="line">        <span class="keyword">return</span> leftPairs + rightPairs + crossPairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * nums[left..mid] 有序，nums[mid + 1..right] 有序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">mergeAndCount</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left; k &lt;= right; k++) &#123;</span><br><span class="line">            <span class="comment">// 有下标访问，得先判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                nums[k] = temp[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == right + <span class="number">1</span>) &#123;</span><br><span class="line">                nums[k] = temp[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &lt;= temp[j]) &#123;</span><br><span class="line">                <span class="comment">// 注意：这里是 &lt;= ，写成 &lt; 就不对，请思考原因</span></span><br><span class="line">                nums[k] = temp[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = temp[j];</span><br><span class="line">                j++;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 在 j 指向的元素归并回去的时候，计算逆序对的个数，只多了这一行代码</span></span><br><span class="line">                count += (mid - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode面试题51.数组中的逆序对&lt;/p&gt;
&lt;p&gt;在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="归并排序" scheme="http://yorxika.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>最低票价</title>
    <link href="http://yorxika.github.io/2020/05/08/%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B7/"/>
    <id>http://yorxika.github.io/2020/05/08/%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B7/</id>
    <published>2020-05-08T12:59:14.000Z</published>
    <updated>2020-05-08T13:13:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第983题最低票价</p><p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 <code>days</code> 的数组给出。每一项是一个从 <code>1</code> 到 <code>365</code> 的整数。</p><p>火车票有三种不同的销售方式：</p><ul><li>一张为期一天的通行证售价为 <code>costs[0]</code> 美元；</li><li>一张为期七天的通行证售价为 <code>costs[1]</code> 美元；</li><li>一张为期三十天的通行证售价为 <code>costs[2]</code> 美元。</li></ul><p>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p><p>返回你想要完成在给定的列表 <code>days</code> 中列出的每一天的旅行所需要的最低消费。<br><span id="more"></span></p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：days = [1,4,6,7,8,20], costs = [2,7,15]</span><br><span class="line">输出：11</span><br><span class="line">解释： </span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：</span><br><span class="line">在第<span class="number"> 1 </span>天，你花了 costs[0] = $2 买了一张为期<span class="number"> 1 </span>天的通行证，它将在第<span class="number"> 1 </span>天生效。</span><br><span class="line">在第<span class="number"> 3 </span>天，你花了 costs[1] = $7 买了一张为期<span class="number"> 7 </span>天的通行证，它将在第 3, 4, ...,<span class="number"> 9 </span>天生效。</span><br><span class="line">在第<span class="number"> 20 </span>天，你花了 costs[0] = $2 买了一张为期<span class="number"> 1 </span>天的通行证，它将在第<span class="number"> 20 </span>天生效。</span><br><span class="line">你总共花了 $11，并完成了你计划的每一天旅行。</span><br></pre></td></tr></table></figure><hr><h3 id="动态规划-从后往前"><a href="#动态规划-从后往前" class="headerlink" title="动态规划(从后往前)"></a>动态规划(从后往前)</h3><p>记dp[i]为第i天所花费的最小金额，那么dpn[i]的取值有3种情况：</p><ul><li>买一天期，后面的不包n</li><li>买七天期，包到第 <code>n + 7 - 1</code> 天，第 <code>n + 7</code> 天往后的不包</li><li>买三十天期，包到第 <code>n + 30 - 1</code> 天，第 <code>n + 30</code> 天往后的不包</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = <span class="built_in">min</span>(决策<span class="number">1</span>, 决策<span class="number">2</span>, 决策<span class="number">3</span>);</span><br><span class="line">      = <span class="built_in">min</span>(c[<span class="number">0</span>] + <span class="number">1</span>天后不包, c[<span class="number">1</span>] + <span class="number">7</span>天后不包, c[<span class="number">2</span>] + <span class="number">30</span>天不包);</span><br><span class="line">      = <span class="built_in">min</span>(c[<span class="number">0</span>] + dp[i + <span class="number">1</span>], c[<span class="number">1</span>] + dp[i + <span class="number">7</span>], c[<span class="number">2</span>] + dp[i + <span class="number">30</span>]);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mincostTickets</span><span class="params">(<span class="type">int</span>[] days, <span class="type">int</span>[] costs)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> days.length, maxDay = days[len - <span class="number">1</span>], minDay = days[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[maxDay + <span class="number">31</span>]; <span class="comment">// 多扩几天，省得判断 365 的限制</span></span><br><span class="line">        <span class="comment">// 只需看 maxDay -&gt; minDay，此区间外都不需要出门，不会增加费用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> maxDay, i = len - <span class="number">1</span>; d &gt;= minDay; d--) &#123;</span><br><span class="line">            <span class="comment">// i 表示 days 的索引</span></span><br><span class="line">            <span class="comment">// 也可提前将所有 days 放入 Set，再通过 set.contains() 判断</span></span><br><span class="line">            <span class="keyword">if</span> (d == days[i]) &#123;</span><br><span class="line">                dp[d] = Math.min(dp[d + <span class="number">1</span>] + costs[<span class="number">0</span>], dp[d + <span class="number">7</span>] + costs[<span class="number">1</span>]);</span><br><span class="line">                dp[d] = Math.min(dp[d], dp[d + <span class="number">30</span>] + costs[<span class="number">2</span>]);</span><br><span class="line">                i--; <span class="comment">// 别忘了递减一天</span></span><br><span class="line">            &#125; <span class="keyword">else</span> dp[d] = dp[d + <span class="number">1</span>]; <span class="comment">// 不需要出门</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[minDay]; <span class="comment">// 从后向前遍历，返回最前的 minDay</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划-从前往后"><a href="#动态规划-从前往后" class="headerlink" title="动态规划(从前往后)"></a>动态规划(从前往后)</h3><p>思路同上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mincostTickets</span><span class="params">(<span class="type">int</span>[] days, <span class="type">int</span>[] costs)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> days.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastDay</span> <span class="operator">=</span> days[len-<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[lastDay+<span class="number">1</span>];  <span class="comment">//dp[i]表示第i天的花费</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp1,temp2,temp3;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= lastDay ; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == days[cursor])&#123;</span><br><span class="line">            temp1 = i - <span class="number">1</span>;</span><br><span class="line">            temp2 = Math.max(i - <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">            temp3 = Math.max(i - <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//枚举当前花费的情况</span></span><br><span class="line">            dp[i] = Math.min(Math.min(dp[temp1]+costs[<span class="number">0</span>],dp[temp2]+costs[<span class="number">1</span>]),dp[temp3]+costs[<span class="number">2</span>]);</span><br><span class="line">            ++cursor;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>];  <span class="comment">//第0天花费肯定为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[lastDay];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第983题最低票价&lt;/p&gt;
&lt;p&gt;在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 &lt;code&gt;days&lt;/code&gt; 的数组给出。每一项是一个从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;365&lt;/code&gt; 的整数。&lt;/p&gt;
&lt;p&gt;火车票有三种不同的销售方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一张为期一天的通行证售价为 &lt;code&gt;costs[0]&lt;/code&gt; 美元；&lt;/li&gt;
&lt;li&gt;一张为期七天的通行证售价为 &lt;code&gt;costs[1]&lt;/code&gt; 美元；&lt;/li&gt;
&lt;li&gt;一张为期三十天的通行证售价为 &lt;code&gt;costs[2]&lt;/code&gt; 美元。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。&lt;/p&gt;
&lt;p&gt;返回你想要完成在给定的列表 &lt;code&gt;days&lt;/code&gt; 中列出的每一天的旅行所需要的最低消费。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>01矩阵</title>
    <link href="http://yorxika.github.io/2020/04/19/01%E7%9F%A9%E9%98%B5/"/>
    <id>http://yorxika.github.io/2020/04/19/01%E7%9F%A9%E9%98%B5/</id>
    <published>2020-04-19T15:31:00.000Z</published>
    <updated>2020-04-19T15:53:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第542题01矩阵</p><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。<br><span id="more"></span><br><strong>示例 2:</strong><br>输入:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>首先把每个源点 0 入队，然后从各个 0 <strong>同时开始</strong>一圈一圈的向 1 扩散（每个 1 都是被离它最近的 0 扩散到的 ），扩散的时候可以设置 <code>boolean[][] visited</code> 标志是否访问过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] updateMatrix(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length,col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[][] seen = <span class="keyword">new</span> <span class="title class_">boolean</span>[row][col];</span><br><span class="line">    <span class="type">int</span>[][] d = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; row ; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; col ; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                seen[i][j] = <span class="literal">true</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] tmp;</span><br><span class="line">    <span class="type">int</span> dx,dy;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        tmp = queue.poll();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span> ; k &lt; <span class="number">4</span> ; ++k)&#123;</span><br><span class="line">            dx = tmp[<span class="number">0</span>]+d[k][<span class="number">0</span>];</span><br><span class="line">            dy = tmp[<span class="number">1</span>]+d[k][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(dx &gt;= <span class="number">0</span> &amp;&amp; dx &lt; row &amp;&amp; dy &gt;= <span class="number">0</span> &amp;&amp; dy &lt; col &amp;&amp; !seen[dx][dy])&#123;</span><br><span class="line">                matrix[dx][dy] = matrix[tmp[<span class="number">0</span>]][tmp[<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;dx,dy&#125;);</span><br><span class="line">                seen[dx][dy] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>用dp[i][j]表示该位置距离最近的0的距离，则<code>dp[i][j] = 1+min(dp[i-1][j],dp[i][j-1],dp[i+1][j],dp[i][j+1]) if matrix[i][j] == 1</code></p><p>尝试将问题分解：</p><ol><li>距离 (i, j) 最近的 0 的位置，是在其 「左上，右上，左下，右下」4个方向之一；</li><li>因此我们分别从四个角开始递推，就分别得到了位于「左上方、右上方、左下方、右下方」距离 (i, j)的最近的 0 的距离，取 min即可；</li><li>通过上两步思路，我们可以很容易的写出 4 个双重 for循环，动态规划的解法写到这一步其实已经完全 OK 了；</li><li>如果第三步还不满足的话，从四个角开始的4次递推，其实还可以优化成从任一组对角开始的2次递推，比如只写从左上角、右下角开始递推就行了。</li></ol><p>对dp数组初始化时不能将其设置为0X7FFFFFFF，不然+1就会溢出，变成-2147483647.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] updateMatrix(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length,col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; row ; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; col ; ++j)</span><br><span class="line">            dp[i][j] = matrix[i][j] == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从左上角开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; row ; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; col ; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j],dp[i-<span class="number">1</span>][j]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j],dp[i][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从右下角开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> col - <span class="number">1</span> ; j &gt;= <span class="number">0</span> ; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; row - <span class="number">1</span>)</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j],dp[i+<span class="number">1</span>][j]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(j &lt; col - <span class="number">1</span>)</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j],dp[i][j+<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第542题01矩阵&lt;/p&gt;
&lt;p&gt;给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。&lt;/p&gt;
&lt;p&gt;两个相邻元素间的距离为 1 。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="宽度优先搜索" scheme="http://yorxika.github.io/tags/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>外观数列</title>
    <link href="http://yorxika.github.io/2020/04/13/%E5%A4%96%E8%A7%82%E9%98%9F%E5%88%97/"/>
    <id>http://yorxika.github.io/2020/04/13/%E5%A4%96%E8%A7%82%E9%98%9F%E5%88%97/</id>
    <published>2020-04-13T08:27:50.000Z</published>
    <updated>2020-04-13T08:33:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第38题外观数列</p><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1</span>.     <span class="number">1</span></span><br><span class="line"><span class="attribute">2</span>.     <span class="number">11</span></span><br><span class="line"><span class="attribute">3</span>.     <span class="number">21</span></span><br><span class="line"><span class="attribute">4</span>.     <span class="number">1211</span></span><br><span class="line"><span class="attribute">5</span>.     <span class="number">111221</span></span><br></pre></td></tr></table></figure><p><code>1</code> 被读作 <code>&quot;one 1&quot;</code> (<code>&quot;一个一&quot;</code>) , 即 <code>11</code>。<br><code>11</code> 被读作 <code>&quot;two 1s&quot;</code> (<code>&quot;两个一&quot;</code>）, 即 <code>21</code>。<br><code>21</code> 被读作 <code>&quot;one 2&quot;</code>,  “<code>one 1&quot;</code> （<code>&quot;一个二&quot;</code> , <code>&quot;一个一&quot;</code>) , 即 <code>1211</code>。<br><span id="more"></span><br>给定一个正整数 <em>n</em>（1 ≤ <em>n</em> ≤ 30），输出外观数列的第 <em>n</em> 项。</p><hr><h3 id="递归-双指针"><a href="#递归-双指针" class="headerlink" title="递归+双指针"></a>递归+双指针</h3><p>第n层依赖n-1层求出的结果,设置两个指针,pre指向字符串初始位置0,cur指向字符串1的位置,如果说<code>str[pre] != str[cur]</code>,说明当前字符与前面紧邻的字符不等则更新此次结果,则是<code>sb.append(count).append(str[pre]);</code>,结束循环时,如果<code>pre!=cur</code>,说明两者之间的数据是相等的,仍需要append数据.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] str = countAndSay(n-<span class="number">1</span>).toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(cur = <span class="number">1</span> ; cur &lt; str.length;++cur)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[pre] != str[cur])&#123;  <span class="comment">//当前字符与前面紧邻的字符不等则更新此次结果</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> cur - pre;</span><br><span class="line">                sb.append(count).append(str[pre]);</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre != cur)&#123;  <span class="comment">//防止最后一段数相等，如果不等说明p1到cur-1这段字符串是相等的</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> cur - pre;</span><br><span class="line">            sb.append(count).append(str[pre]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第38题外观数列&lt;/p&gt;
&lt;p&gt;「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：&lt;/p&gt;
&lt;figure class=&quot;highlight apache&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;1&lt;/span&gt;.     &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;2&lt;/span&gt;.     &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;3&lt;/span&gt;.     &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;4&lt;/span&gt;.     &lt;span class=&quot;number&quot;&gt;1211&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;5&lt;/span&gt;.     &lt;span class=&quot;number&quot;&gt;111221&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;1&lt;/code&gt; 被读作 &lt;code&gt;&amp;quot;one 1&amp;quot;&lt;/code&gt; (&lt;code&gt;&amp;quot;一个一&amp;quot;&lt;/code&gt;) , 即 &lt;code&gt;11&lt;/code&gt;。&lt;br&gt;&lt;code&gt;11&lt;/code&gt; 被读作 &lt;code&gt;&amp;quot;two 1s&amp;quot;&lt;/code&gt; (&lt;code&gt;&amp;quot;两个一&amp;quot;&lt;/code&gt;）, 即 &lt;code&gt;21&lt;/code&gt;。&lt;br&gt;&lt;code&gt;21&lt;/code&gt; 被读作 &lt;code&gt;&amp;quot;one 2&amp;quot;&lt;/code&gt;,  “&lt;code&gt;one 1&amp;quot;&lt;/code&gt; （&lt;code&gt;&amp;quot;一个二&amp;quot;&lt;/code&gt; , &lt;code&gt;&amp;quot;一个一&amp;quot;&lt;/code&gt;) , 即 &lt;code&gt;1211&lt;/code&gt;。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="双指针" scheme="http://yorxika.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>串联所有单词的子串</title>
    <link href="http://yorxika.github.io/2020/04/13/%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
    <id>http://yorxika.github.io/2020/04/13/%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</id>
    <published>2020-04-13T07:45:13.000Z</published>
    <updated>2020-04-13T07:54:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第30题串联所有单词的子串</p><p>给定一个字符串 <strong>s</strong> 和一些长度相同的单词 <strong>words。</strong>找出 <strong>s</strong> 中恰好可以由 <strong>words</strong> 中所有单词串联形成的子串的起始位置。</p><p>注意子串要与 <strong>words</strong> 中的单词完全匹配，中间不能有其他字符，但不需要考虑 <strong>words</strong> 中单词串联的顺序。<br><span id="more"></span><br><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">  s = <span class="string">&quot;barfoothefoobarman&quot;</span>,</span><br><span class="line">  words = [<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;bar&quot;</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">9</span>]</span><br><span class="line">解释：</span><br><span class="line">从索引 <span class="number">0</span> 和 <span class="number">9</span> 开始的子串分别是 <span class="string">&quot;barfoo&quot;</span> 和 <span class="string">&quot;foobar&quot;</span> 。</span><br><span class="line">输出的顺序不重要, [<span class="number">9</span>,<span class="number">0</span>] 也是有效答案。</span><br></pre></td></tr></table></figure><hr><p>首先用一个HashMap存储words里的所有单词以及对应的频次，接着从字符串s的第一个字符开始遍历，按每次增加一个单词的长度（因为题目给定所有单词的长度是固定的），在外层循环里维护一个遍历count用来记录前进了多少个单词，以及一个子串map，用来记录子串里的单词。<br>当counts小于总的字符串数组长度时,依次读取单个单词长度len的字符串,如果全局map有这个单词,说明是子串之一,将其放入子串map,并比较子串map和全局map里的出现频率,如果超过了还要调整初始指针j的位置,并删除对应的子串map里的单词;如果遇到不存在的单词,就清空当前滑动窗口,指针前进.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findSubstring</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span> || words.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">unit</span> <span class="operator">=</span> words[<span class="number">0</span>].length();  <span class="comment">//每个单词的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">allNums</span> <span class="operator">=</span> words.length;  <span class="comment">//所有单词的总共长度</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; allwords = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            allwords.put(word,<span class="number">1</span>+allwords.getOrDefault(word,<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; unit ; ++i)&#123;</span><br><span class="line">            <span class="comment">//按单单词遍历</span></span><br><span class="line">            HashMap&lt;String ,Integer&gt; subMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  <span class="comment">//子串字典</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">counts</span> <span class="operator">=</span> <span class="number">0</span> ;  <span class="comment">//计数一共前进了多少个单词</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i ; j &lt; s.length() - unit*allNums + <span class="number">1</span> ; j += unit)&#123;</span><br><span class="line">                <span class="comment">//boolean hasRemoved = false;</span></span><br><span class="line">                <span class="keyword">while</span> (counts &lt; allNums)&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">curWord</span> <span class="operator">=</span> s.substring(j + counts*unit, j + (counts+<span class="number">1</span>)*unit);</span><br><span class="line">                    <span class="keyword">if</span>(allwords.containsKey(curWord))&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> subMap.getOrDefault(curWord,<span class="number">0</span>);</span><br><span class="line">                        subMap.put(curWord,freq+<span class="number">1</span>);</span><br><span class="line">                        <span class="comment">//如果出现的次数超过了，需要前进滑动窗口</span></span><br><span class="line">                        <span class="keyword">if</span>(subMap.get(curWord) &gt; allwords.get(curWord))&#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">cntRemoved</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">while</span> (subMap.get(curWord) &gt; allwords.get(curWord))&#123;</span><br><span class="line">                                <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(j+cntRemoved*unit,j+(cntRemoved+<span class="number">1</span>)*unit);</span><br><span class="line">                                <span class="type">int</span> fre= subMap.get(sub);</span><br><span class="line">                                <span class="keyword">if</span>(fre &gt; <span class="number">1</span>)</span><br><span class="line">                                    subMap.put(sub,fre-<span class="number">1</span>);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    subMap.remove(sub);</span><br><span class="line">                                cntRemoved++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            counts = counts - cntRemoved + <span class="number">1</span>;  <span class="comment">//计数减掉移动的窗口，然后还要算上当前单词</span></span><br><span class="line">                            j = j + (cntRemoved - <span class="number">1</span>)*unit;  <span class="comment">//减一是因为后面还要加1</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//此时单词不匹配</span></span><br><span class="line">                        subMap.clear();  <span class="comment">//直接清空滑动窗口</span></span><br><span class="line">                        j = j + counts * unit;</span><br><span class="line">                        counts = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    counts++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(counts == allNums) &#123;</span><br><span class="line">                    res.add(j);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> s.substring(j,j+unit);  <span class="comment">//移除子串最前面那个元素</span></span><br><span class="line">                    <span class="type">int</span> freq= subMap.get(first);</span><br><span class="line">                    <span class="keyword">if</span>(freq &gt; <span class="number">1</span>)</span><br><span class="line">                        subMap.put(first,freq-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        subMap.remove(first);</span><br><span class="line">                    counts--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第30题串联所有单词的子串&lt;/p&gt;
&lt;p&gt;给定一个字符串 &lt;strong&gt;s&lt;/strong&gt; 和一些长度相同的单词 &lt;strong&gt;words。&lt;/strong&gt;找出 &lt;strong&gt;s&lt;/strong&gt; 中恰好可以由 &lt;strong&gt;words&lt;/strong&gt; 中所有单词串联形成的子串的起始位置。&lt;/p&gt;
&lt;p&gt;注意子串要与 &lt;strong&gt;words&lt;/strong&gt; 中的单词完全匹配，中间不能有其他字符，但不需要考虑 &lt;strong&gt;words&lt;/strong&gt; 中单词串联的顺序。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="字符串" scheme="http://yorxika.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LFU缓存</title>
    <link href="http://yorxika.github.io/2020/04/06/LFU/"/>
    <id>http://yorxika.github.io/2020/04/06/LFU/</id>
    <published>2020-04-05T16:34:03.000Z</published>
    <updated>2020-04-05T17:11:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源力扣第460题LFU缓存</p><p>请你为 <a href="https://baike.baidu.com/item/缓存算法">最不经常使用（LFU）</a>缓存算法设计并实现数据结构。它应该支持以下操作：<code>get</code> 和 <code>put</code>。</p><ul><li><code>get(key)</code> - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。</li><li><code>put(key, value)</code> - 如果键不存在，请设置或插入值。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近</strong> 最少使用的键。<span id="more"></span>「项的使用次数」就是自插入该项以来对其调用 <code>get</code> 和 <code>put</code> 函数的次数之和。使用次数会在对应项被移除后置为 0 。</li></ul><h3 id="两个Map实现"><a href="#两个Map实现" class="headerlink" title="两个Map实现"></a>两个Map实现</h3><p>利用一个Map存放key到value值的映射，一个Map存放key到freq的映射，由于题目要求<code>当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近 最少使用的键</code>，因而采用linkedHashMap实现平局，默认是插入顺序，true为访问顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,Integer&gt; map1;  <span class="comment">//key -&gt; value</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,Integer&gt; map2;  <span class="comment">//key -&gt; freq</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LFUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(capacity);</span><br><span class="line">        <span class="comment">//用linkedHashMap实现平局，默认是插入顺序，true为访问顺序</span></span><br><span class="line">        map2 = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(capacity,<span class="number">0.75F</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(map1.containsKey(key))&#123;</span><br><span class="line">            map2.put(key,map2.get(key)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> map1.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(capacity == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(map1.containsKey(key))&#123;</span><br><span class="line">            map1.put(key,value);</span><br><span class="line">            map2.put(key,map2.get(key)+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(map1.size() == capacity)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> key;</span><br><span class="line">                <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map2.entrySet())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(min &gt; entry.getValue())&#123;</span><br><span class="line">                        temp = entry.getKey();</span><br><span class="line">                        min = entry.getValue();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                map1.remove(temp);</span><br><span class="line">                map2.remove(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            map1.put(key,value);</span><br><span class="line">            map2.put(key,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>来自<a href="https://leetcode-cn.com/problems/lfu-cache/solution/java-13ms-shuang-100-shuang-xiang-lian-biao-duo-ji/">sweetiee</a></p><p><code>HashMap cache</code> 存缓存的内容; 将写法 1 写法 2 中的 <code>freqMap</code> 不再用 <code>HashMap</code> 来表示，而是直接用双向链表 <code>DoubleLinkedList firstLinkedList; DoubleLinkedList lastLinkedList</code>，省去了一些哈希相关的耗时，也不需要用 min 来存储最小频次了，<code>lastLinkedList.pre</code> 这条 <code>DoubleLinkedList</code> 即为最小频次对应的 Node 双向链表，<code>lastLinkedList.pre.tail.pre</code> 这个 Node 即为最小频次的双向链表中的所有 Node 中最先访问的 Node，即容量满了后要删除的 Node。</p><p><img src="/2020/04/06/LFU/04/06/LFU/909ea661e76e600e49763d06d2fa72b7897e36ebf47d966292636bce1b241734-image.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Node&gt; cache;  <span class="comment">// 存储缓存的内容，Node中除了value值外，还有key、freq、所在DoubleLinkedList、</span></span><br><span class="line">    <span class="comment">// 所在DoubleLinkedList中的postNode、所在DoubleLinkedList中的preNode，具体定义在下方。</span></span><br><span class="line"></span><br><span class="line">    DoubleLinkedList firstLinkedList; <span class="comment">// firstLinkedList.post 是频次最大的双向链表</span></span><br><span class="line">    DoubleLinkedList lastLinkedList;  <span class="comment">// lastLinkedList.pre 是频次最小的双向链表，满了之后</span></span><br><span class="line">    <span class="comment">// 删除 lastLinkedList.pre.tail.pre 这个Node即为频次最小且访问最早的Node</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LFUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt; (capacity);</span><br><span class="line">        firstLinkedList = <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>();</span><br><span class="line">        lastLinkedList = <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>();</span><br><span class="line">        firstLinkedList.post = lastLinkedList;</span><br><span class="line">        lastLinkedList.pre = firstLinkedList;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该key访问频次+1</span></span><br><span class="line">        freqInc(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="comment">// 若key存在，则更新value，访问频次+1</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            freqInc(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若key不存在</span></span><br><span class="line">            <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果缓存满了，删除lastLinkedList.pre这个链表（即表示最小频次的链表）中的tail.pre这个Node</span></span><br><span class="line">                <span class="comment">// （即最小频次链表中最先访问的Node），如果该链表中的元素删空了，则删掉该链表。</span></span><br><span class="line">                cache.remove(lastLinkedList.pre.tail.pre.key);</span><br><span class="line">                lastLinkedList.removeNode(lastLinkedList.pre.tail.pre);</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (lastLinkedList.pre.head.post == lastLinkedList.pre.tail) &#123;</span><br><span class="line">                    removeDoubleLinkedList(lastLinkedList.pre);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cache中put新Key-Node对儿，并将新node加入表示freq为1的DoubleLinkedList中，</span></span><br><span class="line">            <span class="comment">// 若不存在freq为1的DoubleLinkedList则新建。</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="keyword">if</span> (lastLinkedList.pre.freq != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">DoubleLinkedList</span> <span class="variable">newDoublyLinedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>(<span class="number">1</span>);</span><br><span class="line">                addDoubleLinkedList(newDoublyLinedList, lastLinkedList.pre);</span><br><span class="line">                newDoublyLinedList.addNode(newNode);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lastLinkedList.pre.addNode(newNode);</span><br><span class="line">            &#125;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * node的访问频次 + 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">freqInc</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 将node从原freq对应的双向链表里移除, 如果链表空了则删除链表。</span></span><br><span class="line">        <span class="type">DoubleLinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> node.DoubleLinkedList;</span><br><span class="line">        <span class="type">DoubleLinkedList</span> <span class="variable">preLinkedList</span> <span class="operator">=</span> linkedList.pre;</span><br><span class="line">        linkedList.removeNode(node);</span><br><span class="line">        <span class="keyword">if</span> (linkedList.head.post == linkedList.tail) &#123;</span><br><span class="line">            removeDoubleLinkedList(linkedList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将node加入新freq对应的双向链表，若该链表不存在，则先创建该链表。</span></span><br><span class="line">        node.freq++;</span><br><span class="line">        <span class="keyword">if</span> (preLinkedList.freq != node.freq) &#123;</span><br><span class="line">            <span class="type">DoubleLinkedList</span> <span class="variable">newDoublyLinedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>(node.freq);</span><br><span class="line">            addDoubleLinkedList(newDoublyLinedList, preLinkedList);</span><br><span class="line">            newDoublyLinedList.addNode(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            preLinkedList.addNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加代表某1频次的双向链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addDoubleLinkedList</span><span class="params">(DoubleLinkedList newDoublyLinedList, DoubleLinkedList preLinkedList)</span> &#123;</span><br><span class="line">        newDoublyLinedList.post = preLinkedList.post;</span><br><span class="line">        newDoublyLinedList.post.pre = newDoublyLinedList;</span><br><span class="line">        newDoublyLinedList.pre = preLinkedList;</span><br><span class="line">        preLinkedList.post = newDoublyLinedList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除代表某1频次的双向链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeDoubleLinkedList</span><span class="params">(DoubleLinkedList DoubleLinkedList)</span> &#123;</span><br><span class="line">        DoubleLinkedList.pre.post = DoubleLinkedList.post;</span><br><span class="line">        DoubleLinkedList.post.pre = DoubleLinkedList.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    Node pre; <span class="comment">// Node所在频次的双向链表的前继Node</span></span><br><span class="line">    Node post; <span class="comment">// Node所在频次的双向链表的后继Node</span></span><br><span class="line">    DoubleLinkedList DoubleLinkedList;  <span class="comment">// Node所在频次的双向链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> freq; <span class="comment">// 该双向链表表示的频次</span></span><br><span class="line"></span><br><span class="line">    DoubleLinkedList pre;  <span class="comment">// 该双向链表的前继链表（pre.freq &lt; this.freq）</span></span><br><span class="line">    DoubleLinkedList post; <span class="comment">// 该双向链表的后继链表 (post.freq &gt; this.freq)</span></span><br><span class="line"></span><br><span class="line">    Node head; <span class="comment">// 该双向链表的头节点，新节点从头部加入，表示最近访问</span></span><br><span class="line">    Node tail; <span class="comment">// 该双向链表的尾节点，删除节点从尾部删除，表示最久访问</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoubleLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        head.post = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoubleLinkedList</span><span class="params">(<span class="type">int</span> freq)</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        head.post = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">        <span class="built_in">this</span>.freq = freq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.pre.post = node.post;</span><br><span class="line">        node.post.pre = node.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.post = head.post;</span><br><span class="line">        head.post.pre = node;</span><br><span class="line">        head.post = node;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        node.DoubleLinkedList = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/lfu-cache/solution/ha-xi-biao-shuang-xiang-lian-biao-java-by-liweiwei/">weiwei</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key 就是题目中的 key</span></span><br><span class="line"><span class="comment">     * value 是结点类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, ListNode&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问次数哈希表，使用 ListNode[] 也可以，不过要占用很多空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DoubleLinkedList&gt; frequentMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 外部传入的容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局最高访问次数，删除最少使用访问次数的结点时会用到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">minFrequent</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LFUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(capacity);</span><br><span class="line">        frequentMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get 一次操作，访问次数就增加 1；</span></span><br><span class="line"><span class="comment">     * 从原来的链表调整到访问次数更高的链表的表头</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试测出来的，capacity 可能传 0</span></span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 获得结点类</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">listNode</span> <span class="operator">=</span> removeListNode(key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 挂接到新的访问次数的双向链表的头部</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">frequent</span> <span class="operator">=</span> listNode.frequent;</span><br><span class="line">            addListNode2Head(frequent, listNode);</span><br><span class="line">            <span class="keyword">return</span> listNode.value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 key 存在，就更新访问次数 + 1，更新值</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">listNode</span> <span class="operator">=</span> removeListNode(key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 value</span></span><br><span class="line">            listNode.value = value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">frequent</span> <span class="operator">=</span> listNode.frequent;</span><br><span class="line">            addListNode2Head(frequent, listNode);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 key 不存在</span></span><br><span class="line">        <span class="comment">// 1、如果满了，先删除访问次数最小的的末尾结点，再删除 map 里对应的 key</span></span><br><span class="line">        <span class="keyword">if</span> (map.size() == capacity) &#123;</span><br><span class="line">            <span class="comment">// 1、从双链表里删除结点</span></span><br><span class="line">            <span class="type">DoubleLinkedList</span> <span class="variable">doubleLinkedList</span> <span class="operator">=</span> frequentMap.get(minFrequent);</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">removeNode</span> <span class="operator">=</span> doubleLinkedList.removeTail();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、删除 map 里对应的 key</span></span><br><span class="line">            map.remove(removeNode.key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、再创建新结点放在访问次数为 1 的双向链表的前面</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newListNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(key, value);</span><br><span class="line">        addListNode2Head(<span class="number">1</span>, newListNode);</span><br><span class="line">        map.put(key, newListNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【注意】因为这个结点是刚刚创建的，最少访问次数一定为 1</span></span><br><span class="line">        <span class="built_in">this</span>.minFrequent = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下部分主要是结点类和双向链表的操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结点类，是双向链表的组成部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> key;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">frequent</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">private</span> ListNode pre;</span><br><span class="line">        <span class="keyword">private</span> ListNode next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双向链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 虚拟头结点，它无前驱结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> ListNode dummyHead;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 虚拟尾结点，它无后继结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> ListNode dummyTail;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当前双向链表的有效结点数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DoubleLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 虚拟头尾结点赋值多少无所谓</span></span><br><span class="line">            <span class="built_in">this</span>.dummyHead = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.dummyTail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">2</span>, -<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            dummyHead.next = dummyTail;</span><br><span class="line">            dummyTail.pre = dummyHead;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 把一个结点类添加到双向链表的开头（头部是最新使用数据）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> addNode</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode2Head</span><span class="params">(ListNode addNode)</span> &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">oldHead</span> <span class="operator">=</span> dummyHead.next;</span><br><span class="line">            <span class="comment">// 两侧结点指向它</span></span><br><span class="line">            dummyHead.next = addNode;</span><br><span class="line">            oldHead.pre = addNode;</span><br><span class="line">            <span class="comment">// 它的前驱和后继指向两侧结点</span></span><br><span class="line">            addNode.pre = dummyHead;</span><br><span class="line">            addNode.next = oldHead;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 把双向链表的末尾结点删除（尾部是最旧的数据，在缓存满的时候淘汰）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> ListNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">oldTail</span> <span class="operator">=</span> dummyTail.pre;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newTail</span> <span class="operator">=</span> oldTail.pre;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 两侧结点建立连接</span></span><br><span class="line">            newTail.next = dummyTail;</span><br><span class="line">            dummyTail.pre = newTail;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 它的两个属性切断连接</span></span><br><span class="line">            oldTail.pre = <span class="literal">null</span>;</span><br><span class="line">            oldTail.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重要：删除一个结点，当前双向链表的结点个数少 1</span></span><br><span class="line">            count--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 维护</span></span><br><span class="line">            <span class="keyword">return</span> oldTail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将原来访问次数的结点，从双向链表里脱离出来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">removeListNode</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">// 获得结点类</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">deleteNode</span> <span class="operator">=</span> map.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">preNode</span> <span class="operator">=</span> deleteNode.pre;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nextNode</span> <span class="operator">=</span> deleteNode.next;</span><br><span class="line">        <span class="comment">// 两侧结点建立连接</span></span><br><span class="line">        preNode.next = nextNode;</span><br><span class="line">        nextNode.pre = preNode;</span><br><span class="line">        <span class="comment">// 删除去原来两侧结点的连接</span></span><br><span class="line">        deleteNode.pre = <span class="literal">null</span>;</span><br><span class="line">        deleteNode.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 维护双链表结点数</span></span><br><span class="line">        frequentMap.get(deleteNode.frequent).count--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【注意】维护 minFrequent</span></span><br><span class="line">        <span class="comment">// 如果当前结点正好在最小访问次数的链表上，并且移除以后结点数为 0，最小访问次数需要加 1</span></span><br><span class="line">        <span class="keyword">if</span> (deleteNode.frequent == minFrequent &amp;&amp; frequentMap.get(deleteNode.frequent).count == <span class="number">0</span>) &#123;</span><br><span class="line">            minFrequent++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问次数加 1</span></span><br><span class="line">        deleteNode.frequent++;</span><br><span class="line">        <span class="keyword">return</span> deleteNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把结点放在对应访问次数的双向链表的头部</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> frequent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> addNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addListNode2Head</span><span class="params">(<span class="type">int</span> frequent, ListNode addNode)</span> &#123;</span><br><span class="line">        DoubleLinkedList doubleLinkedList;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不存在，就初始化</span></span><br><span class="line">        <span class="keyword">if</span> (frequentMap.containsKey(frequent)) &#123;</span><br><span class="line">            doubleLinkedList = frequentMap.get(frequent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doubleLinkedList = <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加到 DoubleLinkedList 的表头</span></span><br><span class="line">        doubleLinkedList.addNode2Head(addNode);</span><br><span class="line">        frequentMap.put(frequent, doubleLinkedList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源力扣第460题LFU缓存&lt;/p&gt;
&lt;p&gt;请你为 &lt;a href=&quot;https://baike.baidu.com/item/缓存算法&quot;&gt;最不经常使用（LFU）&lt;/a&gt;缓存算法设计并实现数据结构。它应该支持以下操作：&lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;put&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;get(key)&lt;/code&gt; - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;put(key, value)&lt;/code&gt; - 如果键不存在，请设置或插入值。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 &lt;strong&gt;最近&lt;/strong&gt; 最少使用的键。&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数据结构设计" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="设计" scheme="http://yorxika.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组</title>
    <link href="http://yorxika.github.io/2020/04/06/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://yorxika.github.io/2020/04/06/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</id>
    <published>2020-04-05T16:09:26.000Z</published>
    <updated>2020-04-05T16:15:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源力扣189题旋转数组</p><p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">输入</span><span class="punctuation">:</span> <span class="string">[1,2,3,4,5,6,7] 和 k = 3</span></span><br><span class="line"><span class="attribute">输出</span><span class="punctuation">:</span> <span class="string">[5,6,7,1,2,3,4]</span></span><br><span class="line"><span class="attribute">解释</span><span class="punctuation">:</span></span><br><span class="line"><span class="attribute">向右旋转 1 步</span><span class="punctuation">:</span> <span class="string">[7,1,2,3,4,5,6]</span></span><br><span class="line"><span class="attribute">向右旋转 2 步</span><span class="punctuation">:</span> <span class="string">[6,7,1,2,3,4,5]</span></span><br><span class="line"><span class="attribute">向右旋转 3 步</span><span class="punctuation">:</span> <span class="string">[5,6,7,1,2,3,4]</span></span><br></pre></td></tr></table></figure><h3 id="循环旋转"><a href="#循环旋转" class="headerlink" title="循环旋转"></a>循环旋转</h3><p>来自官方题解<br>直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量 temp里面。然后，我们将被替换数字（temp）放到它正确的位置，并继续这个过程 <em>n</em> 次， <em>n</em> 是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果 n%k==0，其中 k=k%n （因为如果 k 大于 n ，移动 k 次实际上相当于移动 k%n次）。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。</p><p>把元素看做同学，把下标看做座位，大家换座位。第一个同学离开座位去第k+1个座位，第k+1个座位的同学被挤出去了，他就去坐他后k个座位，如此反复。但是会出现一种情况，就是其中一个同学被挤开之后，坐到了第一个同学的位置（空位置，没人被挤出来），但是此时还有人没有调换位置，这样就顺着让第二个同学换位置。 那么什么时候就可以保证每个同学都换完了呢？n个同学，换n次，所以用一个count来计数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    k = k % nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">counts</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; counts &lt; nums.length ; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> (cur + k) % nums.length;</span><br><span class="line">          <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[next];</span><br><span class="line">          nums[next] = pre;</span><br><span class="line">          pre = temp;</span><br><span class="line">          cur = next;</span><br><span class="line">          counts++;</span><br><span class="line">        &#125;<span class="keyword">while</span> (i != cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三次翻转"><a href="#三次翻转" class="headerlink" title="三次翻转"></a>三次翻转</h3><p>这个方法基于这个事实：当我们旋转数组 k 次， k<em>%</em>n 个尾部元素会被移动到头部，剩下的元素会被向后移动。</p><p>在这个方法中，我们首先将所有元素反转。然后反转前 k 个元素，再反转后面 n-k 个元素，就能得到想要的结果。</p><p>假设 n=7 且 k=3 。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始数组                  :<span class="number"> 1 </span>2<span class="number"> 3 </span>4<span class="number"> 5 </span>6 7</span><br><span class="line">反转所有数字后             :<span class="number"> 7 </span>6<span class="number"> 5 </span>4<span class="number"> 3 </span>2 1</span><br><span class="line">反转前 k 个数字后          :<span class="number"> 5 </span>6<span class="number"> 7 </span>4<span class="number"> 3 </span>2 1</span><br><span class="line">反转后 n-k 个数字后        :<span class="number"> 5 </span>6<span class="number"> 7 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>--&gt; 结果</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源力扣189题旋转数组&lt;/p&gt;
&lt;p&gt;给定一个数组，将数组中的元素向右移动 &lt;em&gt;k&lt;/em&gt; 个位置，其中 &lt;em&gt;k&lt;/em&gt; 是非负数。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="数组" scheme="http://yorxika.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://yorxika.github.io/2020/04/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yorxika.github.io/2020/04/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-05T15:58:22.000Z</published>
    <updated>2020-04-05T17:07:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>复习一下快速排序</p><h3 id="双指针快排"><a href="#双指针快排" class="headerlink" title="双指针快排"></a>双指针快排</h3><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    quickSort(nums,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(nums,start,end);</span><br><span class="line">    quickSort(nums,start,index-<span class="number">1</span>);</span><br><span class="line">    quickSort(nums,index+<span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">//随机选取一个数作为划分点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(end - start + <span class="number">1</span>) + start;</span><br><span class="line">    swap(nums,start,random);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[start];  <span class="comment">//基准值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start+<span class="number">1</span>,right = end;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= end &amp;&amp; nums[left] &lt;= pivot)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= right &amp;&amp; nums[right] &gt; pivot)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(nums,left,right);  <span class="comment">//交换左右两个指针</span></span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[start] = nums[right];</span><br><span class="line">    nums[right] = pivot;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">    nums[index1] = nums[index2];</span><br><span class="line">    nums[index2] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三指针"><a href="#三指针" class="headerlink" title="三指针"></a>三指针</h3><p>来源<a href="https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/">weiwei</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">RANDOM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> left + RANDOM.nextInt(right - left + <span class="number">1</span>);</span><br><span class="line">    swap(nums, randomIndex, left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环不变量：</span></span><br><span class="line">    <span class="comment">// all in [left + 1, lt] &lt; pivot</span></span><br><span class="line">    <span class="comment">// all in [lt + 1, i) = pivot</span></span><br><span class="line">    <span class="comment">// all in [gt, right] &gt; pivot</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">    <span class="type">int</span> <span class="variable">lt</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="type">int</span> <span class="variable">gt</span> <span class="operator">=</span> right + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; gt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">            lt++;</span><br><span class="line">            swap(nums, i, lt);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            gt--;</span><br><span class="line">            swap(nums, i, gt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, left, lt);</span><br><span class="line">    <span class="comment">// 注意这里，大大减少了两侧分治的区间</span></span><br><span class="line">    quickSort(nums, left, lt - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, gt, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">    nums[index1] = nums[index2];</span><br><span class="line">    nums[index2] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;复习一下快速排序&lt;/p&gt;
&lt;h3 id=&quot;双指针快排&quot;&gt;&lt;a href=&quot;#双指针快排&quot; class=&quot;headerlink&quot; title=&quot;双指针快排&quot;&gt;&lt;/a&gt;双指针快排&lt;/h3&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法导论" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
    <category term="排序" scheme="http://yorxika.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>有效括号的嵌套深度</title>
    <link href="http://yorxika.github.io/2020/04/05/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6/"/>
    <id>http://yorxika.github.io/2020/04/05/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6/</id>
    <published>2020-04-05T14:52:49.000Z</published>
    <updated>2020-04-05T15:23:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第1111题有效括号的嵌套深度</p><p><strong>有效括号字符串</strong> 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「<strong>有效括号字符串</strong>」部分。</p><p><strong>嵌套深度</strong> <code>depth</code> 定义：即有效括号字符串嵌套的层数，<code>depth(A)</code> 表示有效括号字符串 <code>A</code> 的嵌套深度。详情参见题末「<strong>嵌套深度</strong>」部分。<br><span id="more"></span><br>有效括号字符串类型与对应的嵌套深度计算方法如下图所示：</p><p><img src="/2020/04/05/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6/04/05/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6/1111.png" alt="img"></p><p>给你一个「有效括号字符串」 <code>seq</code>，请你将其分成两个不相交的有效括号字符串，<code>A</code> 和 <code>B</code>，并使这两个字符串的深度最小。</p><ul><li>不相交：每个 <code>seq[i]</code> 只能分给 <code>A</code> 和 <code>B</code> 二者中的一个，不能既属于 <code>A</code> 也属于 <code>B</code> 。</li><li><code>A</code> 或 <code>B</code> 中的元素在原字符串中可以不连续。</li><li><code>A.length + B.length = seq.length</code></li><li>深度最小：<code>max(depth(A), depth(B))</code> 的可能取值最小。 </li></ul><p>划分方案用一个长度为 <code>seq.length</code> 的答案数组 <code>answer</code> 表示，编码规则如下：</p><ul><li><code>answer[i] = 0</code>，<code>seq[i]</code> 分给 <code>A</code> 。</li><li><code>answer[i] = 1</code>，<code>seq[i]</code> 分给 <code>B</code> 。</li></ul><p>如果存在多个满足要求的答案，只需返回其中任意 <strong>一个</strong> 即可。</p><p><strong>示例 1：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">seq</span> = <span class="string">&quot;(()())&quot;</span></span><br><span class="line">输出：[0,1,1,1,1,0]</span><br></pre></td></tr></table></figure><hr><p>题目没读懂，看<a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solution/qian-tao-shen-du-wan-cheng-gua-hao-pi-pei-wen-ti-s/">weiwei</a>的题解大概懂了一点，目要求我们把输入的整体有效字符串做一个重组，要求是只拆成两个部分 <code>A</code> 和 <code>B</code> ，每个字符要么分到 <code>A</code> 要么分到 <code>B</code>，分到 <code>A</code> 标记为 <code>0</code>，分到 <code>B</code> 标记为 <code>1</code>。而<strong>每个部分的字符又要保持在输入字符串中的顺序不变</strong>。因此输出是一个与原始字符串等长的整数数组，这个整数数组里只有 <code>0</code> 和 <code>1</code>。</p><blockquote><p>核心思想就是：连续的 <code>(</code>会造成嵌套深度的增加，因此对于这种要把他们分到不同的组中。而连续的标准不仅仅是原始字符串中的左右相邻，应该还包括中间成对的 <code>（）</code>消除后的连续。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxDepthAfterSplit(String seq) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> seq.length();</span><br><span class="line">    <span class="keyword">if</span> (seq == <span class="literal">null</span> || seq.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="type">char</span>[] arr = seq.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span> ;  <span class="comment">//模拟栈的深度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            depth++;  <span class="comment">//左括号压栈</span></span><br><span class="line">            ans[i] = depth % <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//右括号出栈</span></span><br><span class="line">            ans[i] = depth % <span class="number">2</span>;</span><br><span class="line">            depth--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第1111题有效括号的嵌套深度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有效括号字符串&lt;/strong&gt; 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「&lt;strong&gt;有效括号字符串&lt;/strong&gt;」部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;嵌套深度&lt;/strong&gt; &lt;code&gt;depth&lt;/code&gt; 定义：即有效括号字符串嵌套的层数，&lt;code&gt;depth(A)&lt;/code&gt; 表示有效括号字符串 &lt;code&gt;A&lt;/code&gt; 的嵌套深度。详情参见题末「&lt;strong&gt;嵌套深度&lt;/strong&gt;」部分。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="栈" scheme="http://yorxika.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Z字型变换</title>
    <link href="http://yorxika.github.io/2020/04/03/Z%E5%AD%97%E5%9E%8B%E5%8F%98%E6%8D%A2/"/>
    <id>http://yorxika.github.io/2020/04/03/Z%E5%AD%97%E5%9E%8B%E5%8F%98%E6%8D%A2/</id>
    <published>2020-04-03T15:31:22.000Z</published>
    <updated>2020-04-03T15:44:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第6题Z字型变换</p><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 <code>&quot;LEETCODEISHIRING&quot;</code> 行数为 3 时，排列如下：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">L</span>   <span class="built_in">C</span>   <span class="built_in">I</span>   <span class="variable">R</span></span><br><span class="line"><span class="built_in">E</span> <span class="variable">T</span> <span class="built_in">O</span> <span class="built_in">E</span> <span class="variable">S</span> <span class="built_in">I</span> <span class="built_in">I</span> <span class="variable">G</span></span><br><span class="line"><span class="built_in">E</span>   <span class="built_in">D</span>   <span class="variable">H</span>   <span class="built_in">N</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span>(<span class="params"><span class="built_in">string</span> s, <span class="built_in">int</span> numRows</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;LEETCODEISHIRING&quot;</span>, <span class="attr">numRows</span> = <span class="number">3</span></span><br><span class="line">输出: <span class="string">&quot;LCIRETOESIIGEDHN&quot;</span></span><br></pre></td></tr></table></figure><hr><p>模拟从上到下的打印过程。</p><pre><code class="lang-JAVA">    public String convert(String s, int numRows) &#123;        if(numRows &lt; 2 || s == null)            return s;        List&lt;StringBuilder&gt; list = new ArrayList&lt;&gt;();        for(int i = 0 ; i &lt; numRows ; i++)            list.add(new StringBuilder());        char[] arr = s.toCharArray();        int index = 0 , flag = -1;        for(int i = 0 ; i &lt; arr.length ; ++i)&#123;            list.get(index).append(arr[i]);            if(index == numRows - 1 || index == 0)                flag = -flag;            index += flag;        &#125;        StringBuilder stringBuilder = new StringBuilder();        for(StringBuilder sb : list)            stringBuilder.append(sb);        return stringBuilder.toString();    &#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第6题Z字型变换&lt;/p&gt;
&lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。&lt;/p&gt;
&lt;p&gt;比如输入字符串为 &lt;code&gt;&amp;quot;LEETCODEISHIRING&amp;quot;&lt;/code&gt; 行数为 3 时，排列如下：&lt;/p&gt;
&lt;figure class=&quot;highlight mathematica&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;L&lt;/span&gt;   &lt;span class=&quot;built_in&quot;&gt;C&lt;/span&gt;   &lt;span class=&quot;built_in&quot;&gt;I&lt;/span&gt;   &lt;span class=&quot;variable&quot;&gt;R&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;O&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;G&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;E&lt;/span&gt;   &lt;span class=&quot;built_in&quot;&gt;D&lt;/span&gt;   &lt;span class=&quot;variable&quot;&gt;H&lt;/span&gt;   &lt;span class=&quot;built_in&quot;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="字符串" scheme="http://yorxika.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>单词的压缩编码</title>
    <link href="http://yorxika.github.io/2020/03/31/%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/"/>
    <id>http://yorxika.github.io/2020/03/31/%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/</id>
    <published>2020-03-31T01:20:33.000Z</published>
    <updated>2020-03-31T01:41:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第820题单词的压缩编码</p><p>给定一个单词列表，我们将这个列表编码成一个索引字符串 <code>S</code> 与一个索引列表 <code>A</code>。</p><p>例如，如果这个列表是 <code>[&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</code>，我们就可以将其表示为 <code>S = &quot;time#bell#&quot;</code> 和 <code>indexes = [0, 2, 5]</code>。</p><p>对于每一个索引，我们可以通过从字符串 <code>S</code> 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。</p><p>那么成功对给定单词列表进行编码的最小字符串长度是多少呢？<br><span id="more"></span><br><strong>示例：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: words = [<span class="string">&quot;time&quot;</span>, <span class="string">&quot;me&quot;</span>, <span class="string">&quot;bell&quot;</span>]</span><br><span class="line">输出: <span class="number">10</span></span><br><span class="line">说明: <span class="symbol">S</span> = <span class="string">&quot;time#bell#&quot;</span> ， indexes = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>] 。</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>题目的意思大概就是将输入里的字符串按某种方式编码，最后返回编码字符串的长度，考虑到字符串S可能是字符串T的后缀，这样的话字符串S就不用加入到编码字符串里了，于是可以考虑先将字符串按长度排序，字符串长的排在前面，如果遍历到的字符串i在包含在原本的字符串里，则不加入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumLengthEncoding</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">     <span class="comment">//先按长度倒叙，长的在前面，保证能够框住后面的字符。</span></span><br><span class="line">    Arrays.sort(words, (a1,a2)-&gt; a2.length() - a1.length());</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    result.append(words[<span class="number">0</span>]+<span class="string">&quot;#&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span>  <span class="operator">=</span> result.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt; words.length;i++)&#123;</span><br><span class="line">        <span class="comment">//如果前面的字符包含了后面的字符，则个数不变，否则加上后面字符长度</span></span><br><span class="line">        <span class="keyword">if</span>(result.indexOf(words[i]+<span class="string">&quot;#&quot;</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            result.append(words[i] + <span class="string">&quot;#&quot;</span>);</span><br><span class="line">            total = total +<span class="number">1</span> + words[i].length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="翻转字符串"><a href="#翻转字符串" class="headerlink" title="翻转字符串"></a>翻转字符串</h3><p>来自<a href="https://leetcode-cn.com/problems/short-encoding-of-words/solution/wu-xu-zi-dian-shu-qing-qing-yi-fan-zhuan-jie-guo-j/">nettee</a></p><p><img src="/2020/03/31/%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/03/31/%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/dba07d67627a9ab2e34231359d5079a9c039c306f97f6b0cee8aeccab171a0ba.jpg" alt="string-suffix-tree"></p><p>可以看到，字符串 <code>me</code> 的路径已经完全和 <code>time</code> 重合了，而 <code>lime</code> 和 <code>time</code> 只是部分重合。我们只需要把所有<strong>有自己独立起点</strong>的字符串作为编码字符串就可以了。</p><p>其实这道题我们的思路很简单：<strong>如果有一对单词 s 和 t，使得 t 是 s 的后缀，例如 <code>me</code> 是 <code>time</code> 的后缀，我们就删掉单词 t。最后剩下来的单词，就是构成索引字符串的单词。</strong></p><p>那么，如何找到这些 s 和 t 呢？考虑到 s 和 t 的最后几个字母是一样的，我们可以从单词的最后一个字母向前考虑。先把所有的单词按照最后一个字母分成 26 组，这样 s 和 t 肯定在同一组；再在每一个组中按照倒数第二个字母分成 26 组……</p><p>我们发现这样排序太麻烦，不如直接<strong>把所有单词反转</strong>（reverse），让倒的变成正的。Amazing！所有单词反转之后，我们的单词排序规则变成了<strong>字典顺序</strong>，也就是各种语言中比较字符串的默认顺序。</p><p>不信你看，假设我们将 <code>[&quot;time&quot;, &quot;me&quot;, &quot;lime&quot;, &quot;sometime&quot;, &quot;hell&quot;, &quot;shell&quot;]</code> 几个单词反转后排序：</p><p><img src="/2020/03/31/%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/03/31/%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/a175eba7060cddbcf43ebbedf3e838b9a3592923a4a8776ec765e66c391882c8.jpg" alt="process"></p><p>我们发现，<strong>如果 t 是 s 的后缀，那么反转之后 t’ 就是 s’ 的前缀。在反转+排序之后，s’ 一定紧跟在 t’ 的后面！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumLengthEncoding</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> words.length;</span><br><span class="line">    <span class="comment">//从字符串高位开始遍历排序</span></span><br><span class="line">    Arrays.sort(words, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> o1.length();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> o2.length();</span><br><span class="line">            <span class="type">char</span>[] arry1 = o1.toCharArray();</span><br><span class="line">            <span class="type">char</span>[] arry2 = o2.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; Math.min(len1,len2);++i)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> Character.compare(arry1[len1 - <span class="number">1</span> - i],arry2[len2 - <span class="number">1</span> - i]);</span><br><span class="line">                <span class="keyword">if</span>(c != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(len1,len2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> &lt; len &amp;&amp; words[i+<span class="number">1</span>].endsWith(words[i])) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans += words[i].length()+<span class="number">1</span>;  <span class="comment">//加上&#x27;#&#x27;的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><p>见<a href="https://leetcode-cn.com/problems/short-encoding-of-words/solution/99-java-trie-tu-xie-gong-lue-bao-jiao-bao-hui-by-s/">sweetiee</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第820题单词的压缩编码&lt;/p&gt;
&lt;p&gt;给定一个单词列表，我们将这个列表编码成一个索引字符串 &lt;code&gt;S&lt;/code&gt; 与一个索引列表 &lt;code&gt;A&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如，如果这个列表是 &lt;code&gt;[&amp;quot;time&amp;quot;, &amp;quot;me&amp;quot;, &amp;quot;bell&amp;quot;]&lt;/code&gt;，我们就可以将其表示为 &lt;code&gt;S = &amp;quot;time#bell#&amp;quot;&lt;/code&gt; 和 &lt;code&gt;indexes = [0, 2, 5]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于每一个索引，我们可以通过从字符串 &lt;code&gt;S&lt;/code&gt; 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。&lt;/p&gt;
&lt;p&gt;那么成功对给定单词列表进行编码的最小字符串长度是多少呢？&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="字符串" scheme="http://yorxika.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>卡牌分组</title>
    <link href="http://yorxika.github.io/2020/03/31/%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84/"/>
    <id>http://yorxika.github.io/2020/03/31/%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84/</id>
    <published>2020-03-31T01:01:21.000Z</published>
    <updated>2020-03-31T01:10:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第914题卡牌分组</p><p>给定一副牌，每张牌上都写着一个整数。</p><p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p><ul><li>每组都有 <code>X</code> 张牌。</li><li>组内所有的牌上都写着相同的整数。</li></ul><p>仅当你可选的 <code>X &gt;= 2</code> 时返回 <code>true</code>。<br><span id="more"></span><br><strong>示例 1：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="selector-attr">[1,2,3,4,4,3,2,1]</span></span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 <span class="selector-attr">[1,1]</span>，<span class="selector-attr">[2,2]</span>，<span class="selector-attr">[3,3]</span>，<span class="selector-attr">[4,4]</span></span><br></pre></td></tr></table></figure><h3 id="求最大公因子"><a href="#求最大公因子" class="headerlink" title="求最大公因子"></a>求最大公因子</h3><p>首先遍历数组，将牌上的整数放入对应的桶中，最后遍历桶，如果桶里的计数有最大公因子，就返回真，否则假。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasGroupsSizeX</span><span class="params">(<span class="type">int</span>[] deck)</span> &#123;</span><br><span class="line">    <span class="comment">// 计数</span></span><br><span class="line">    <span class="type">int</span>[] counter = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num: deck) &#123;</span><br><span class="line">        counter[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求gcd</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> cnt: counter) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = gcd(x, cnt);</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辗转相除法</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">gcd</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        c = b % a;</span><br><span class="line">        b = c;</span><br><span class="line">        a = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第914题卡牌分组&lt;/p&gt;
&lt;p&gt;给定一副牌，每张牌上都写着一个整数。&lt;/p&gt;
&lt;p&gt;此时，你需要选定一个数字 &lt;code&gt;X&lt;/code&gt;，使我们可以将整副牌按下述规则分成 1 组或更多组：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每组都有 &lt;code&gt;X&lt;/code&gt; 张牌。&lt;/li&gt;
&lt;li&gt;组内所有的牌上都写着相同的整数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仅当你可选的 &lt;code&gt;X &amp;gt;= 2&lt;/code&gt; 时返回 &lt;code&gt;true&lt;/code&gt;。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>水壶问题</title>
    <link href="http://yorxika.github.io/2020/03/22/%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://yorxika.github.io/2020/03/22/%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-22T05:43:01.000Z</published>
    <updated>2020-03-22T08:08:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第365题水壶问题</p><p>有两个容量分别为 <em>x</em>升 和 <em>y</em>升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 <em>z</em>升 的水？</p><p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 <em>z升</em> 水。</p><p>你允许：</p><ul><li>装满任意一个水壶</li><li>清空任意一个水壶</li><li>从一个水壶向另外一个水壶倒水，直到装满或者倒空<span id="more"></span><strong>示例 1:</strong> (From the famous <a href="https://www.youtube.com/watch?v=BVtQNK_ZUJg"><em>“Die Hard”</em> example</a>)</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: x = 3, y = 5, z = 4</span></span><br><span class="line"><span class="section">输出: True</span></span><br></pre></td></tr></table></figure><hr><h3 id="求最大公因数"><a href="#求最大公因数" class="headerlink" title="求最大公因数"></a>求最大公因数</h3><p>来自<a href="https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/">官方题解</a></p><p>预备知识：<a href="https://baike.baidu.com/item/裴蜀定理/5186593?fromtitle=贝祖定理&amp;fromid=5185441">贝祖定理</a></p><p>对任何<a href="https://baike.baidu.com/item/整数">整数</a>a、b和它们的最大公约数d，关于<a href="https://baike.baidu.com/item/未知数">未知数</a>x和y的线性不定方程（称为裴蜀等式）：若a,b是整数,且gcd(a,b)=d，那么对于任意的整数x,y,ax+by都一定是d的倍数，特别地，一定存在整数x,y，使ax+by=d成立。</p><p>它的一个重要推论是：a,b<a href="https://baike.baidu.com/item/互质/577412">互质</a>的充要条件是存在<a href="https://baike.baidu.com/item/整数">整数</a>x,y使ax+by=1.</p><p>${(\frac{m}{d}(x_0 + \frac{kb}{d}),\frac{m}{d}(y_0 + \frac{ka}{d})) | k \in Z}$</p><p>在题目所给的操作下，两个桶不可能同时有水且不满。因为观察题目中的所有操作的结果都至少有一个桶是空的或者满的；</p><p>其次，对一个不满的桶加水是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于直接从初始状态给这个桶加满水；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态分别给两个桶加满；</p><p>再次，把一个不满的桶里面的水倒掉是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于回到初始状态；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态直接给另一个桶倒满。</p><p>因此，我们可以认为每次操作只会给水的总量带来 <code>x</code> 或者 <code>y</code> 的变化量。因此我们的目标可以改写成：找到一对整数 a, b，使得</p><p>$ax+by=z$</p><p>而只要满足 $z\leq x+y$，且这样的 a, b 存在，那么我们的目标就是可以达成的。这是因为：</p><ul><li><p>若 $a\geq 0, b\geq 0$，那么显然可以达成目标。</p></li><li><p>若 $a\lt 0$，那么可以进行以下操作：</p><ol><li>往 <code>y</code> 壶倒水；</li><li>把 <code>y</code> 壶的水倒入 <code>x</code> 壶；</li><li>如果 <code>y</code> 壶不为空，那么 <code>x</code> 壶肯定是满的，把 <code>x</code> 壶倒空，然后再把 <code>y</code> 壶的水倒入 <code>x</code> 壶。</li></ol><p>重复以上操作直至某一步时 <code>x</code> 壶进行了 <em>a</em> 次倒空操作，<code>y</code> 壶进行了 <em>b</em> 次倒水操作。</p></li><li><p>若 $b\lt 0$，方法同上，<code>x</code> 与 <code>y</code> 互换。</p></li></ul><p>而贝祖定理告诉我们，$ax+by=z$ 有解当且仅当 z 是 x, y的最大公约数的倍数。因此我们只需要找到 x, y的最大公约数并判断 z是否是它的倍数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canMeasureWater</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x + y &lt; z)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span> || y == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> z == <span class="number">0</span> || x + y == z;</span><br><span class="line">        <span class="keyword">while</span>(y != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> y;</span><br><span class="line">            y = x % y;</span><br><span class="line">            x = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> z % x == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>摘自<a href="https://leetcode-cn.com/problems/water-and-jug-problem/solution/tu-de-yan-du-you-xian-bian-li-by-liweiwei1419/">题解</a></p><p>题目说：</p><blockquote><p>你允许：</p><ul><li>装满任意一个水壶</li><li>清空任意一个水壶</li><li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li></ul></blockquote><p>为了方便说明，我们做如下定义：</p><p>装满任意一个水壶，定义为「操作一」，分为：<br>（1）装满 <code>A</code>，包括 <code>A</code> 为空和 <code>A</code> 非空的时候把 <code>A</code> 倒满的情况；<br>（2）装满 <code>B</code>，包括 <code>B</code> 为空和 <code>B</code> 非空的时候把 <code>B</code> 倒满的情况。</p><p>清空任意一个水壶，定义为「操作二」，分为<br>（1）清空 <code>A</code>；<br>（2）清空 <code>B</code>。</p><p>从一个水壶向另外一个水壶倒水，直到装满或者倒空，定义为「操作三」，其实根据描述「装满」或者「倒空」就知道可以分为 4 种情况：</p><p>（1）从 <code>A</code> 到 <code>B</code>，使得 <code>B</code> 满，<code>A</code> 还有剩；<br>（2）从 <code>A</code> 到 <code>B</code>，此时 <code>A</code> 的水太少，<code>A</code> 倒尽，<code>B</code> 没有满；<br>（3）从 <code>B</code> 到 <code>A</code>，使得 <code>A</code> 满，<code>B</code> 还有剩余；<br>（4）从 <code>B</code> 到 <code>A</code>，此时 <code>B</code> 的水太少，<code>B</code> 倒尽，<code>A</code> 没有满。</p><p>因此，从当前「状态」最多可以进行 8 种操作，得到 8 个新「状态」，对这 8 个新「状态」，依然可以扩展，一直做下去，直到某一个状态满足题目要求。</p><p>建议大家在草稿纸上做一个简单的计算，看一下这 8 种操作怎么写，需要注意哪些边界的情况，相信是一个不错的练习。</p><p>然后请大家自己尝试写一下代码，广度优先遍历常见的写法有 2 种，由于这里不用求路径最短的长度，在出队的时候不用读取队列的长度。</p><ul><li>从当前状态可以扩展出 8 种相邻的状态；</li><li>因为状态有重复，因此是一个「有向」且「有环」的图，在遍历的时候，需要判断该结点设置是否访问过；</li><li>有序整数对 <code>(a, b)</code> 可以自定义成一个私有的类；</li><li>图的遍历，可以使用「深度优先遍历」和「广度优先遍历」，因为状态空间很大，广搜是相对较快；</li><li>尽量「剪枝」，跳过不必要的搜索；</li><li>当然最快的是数学方法。</li></ul><p>要重写qeuals和hashcode方法，不然会超时，这和HashSet的判断重复有关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canMeasureWater</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x + y &lt; z)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> z == <span class="number">0</span> || x + y == z;</span><br><span class="line">    Queue&lt;Pair&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Pair</span> <span class="variable">start</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    queue.add(start);  <span class="comment">//增加初始状态(0,0)</span></span><br><span class="line">    HashSet&lt;Pair&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    visited.add(start);</span><br><span class="line">    Pair temp;</span><br><span class="line">    <span class="type">int</span> curX, curY,tmp;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        temp = queue.poll();</span><br><span class="line">        curX = temp.x;</span><br><span class="line">        curY = temp.y;</span><br><span class="line">        <span class="keyword">if</span> (curX == z || curY == z || curX + curY == z) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curX == <span class="number">0</span>) &#123;  <span class="comment">//转移状态1，将x装满</span></span><br><span class="line">            temp = <span class="keyword">new</span> <span class="title class_">Pair</span>(x, curY);</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(temp)) &#123;</span><br><span class="line">                visited.add(temp);</span><br><span class="line">                queue.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curY == <span class="number">0</span>) &#123;  <span class="comment">//转移状态1，将y装满</span></span><br><span class="line">            temp = <span class="keyword">new</span> <span class="title class_">Pair</span>(curX, y);</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(temp)) &#123;</span><br><span class="line">                visited.add(temp);</span><br><span class="line">                queue.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curY &lt; y) &#123; <span class="comment">// 转移状态3，将x倒空</span></span><br><span class="line">            temp = <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="number">0</span>, curY);</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(temp)) &#123;</span><br><span class="line">                visited.add(temp);</span><br><span class="line">                queue.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curX &lt; x) &#123; <span class="comment">// 转移状态3，将x倒空</span></span><br><span class="line">            temp = <span class="keyword">new</span> <span class="title class_">Pair</span>(curX, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(temp)) &#123;</span><br><span class="line">                visited.add(temp);</span><br><span class="line">                queue.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp = Math.min(curX, y - curY);</span><br><span class="line">        <span class="comment">// y - curY是第二个桶还可以再加的水的升数，但是最多只能加curX升水。</span></span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">Pair</span>(curX - tmp, curY + tmp);</span><br><span class="line">        <span class="keyword">if</span> (!visited.contains(temp)) &#123;</span><br><span class="line">            visited.add(temp);</span><br><span class="line">            queue.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp = Math.min(curY, x - curX);</span><br><span class="line">        <span class="comment">// y - curY是第二个桶还可以再加的水的升数，但是最多只能加curX升水。</span></span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">Pair</span>(curX + tmp, curY - tmp);</span><br><span class="line">        <span class="keyword">if</span> (!visited.contains(temp)) &#123;</span><br><span class="line">            visited.add(temp);</span><br><span class="line">            queue.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span> || getClass() != obj.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Pair</span> <span class="variable">p</span> <span class="operator">=</span> (Pair)obj;</span><br><span class="line">        <span class="keyword">return</span> p.x == <span class="built_in">this</span>.x &amp;&amp; p.y == <span class="built_in">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.x * <span class="number">10000</span> + <span class="built_in">this</span>.y / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第365题水壶问题&lt;/p&gt;
&lt;p&gt;有两个容量分别为 &lt;em&gt;x&lt;/em&gt;升 和 &lt;em&gt;y&lt;/em&gt;升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 &lt;em&gt;z&lt;/em&gt;升 的水？&lt;/p&gt;
&lt;p&gt;如果可以，最后请用以上水壶中的一或两个来盛放取得的 &lt;em&gt;z升&lt;/em&gt; 水。&lt;/p&gt;
&lt;p&gt;你允许：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;装满任意一个水壶&lt;/li&gt;
&lt;li&gt;清空任意一个水壶&lt;/li&gt;
&lt;li&gt;从一个水壶向另外一个水壶倒水，直到装满或者倒空&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>最小的k个数</title>
    <link href="http://yorxika.github.io/2020/03/22/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
    <id>http://yorxika.github.io/2020/03/22/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</id>
    <published>2020-03-22T05:35:42.000Z</published>
    <updated>2020-03-22T05:37:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自面试题40.最小的k个数</p><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。<br><span id="more"></span><br><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = <span class="comment">[3,2,1]</span>, k = 2</span><br><span class="line">输出：<span class="comment">[1,2]</span> 或者 <span class="comment">[2,1]</span></span><br></pre></td></tr></table></figure><hr><h2 id="快排partition"><a href="#快排partition" class="headerlink" title="快排partition"></a>快排partition</h2><p>利用快排里的partition操作，将第i大的数据固定在第i位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个参数表示我们要找的是下标为k-1的数</span></span><br><span class="line">        <span class="keyword">return</span> quickSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] quickSearch(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(nums, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span></span><br><span class="line">        <span class="keyword">return</span> j &gt; k? quickSearch(nums, lo, j - <span class="number">1</span>, k): quickSearch(nums, j + <span class="number">1</span>, hi, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> nums[lo];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt;= hi &amp;&amp; nums[i] &lt; v);</span><br><span class="line">            <span class="keyword">while</span> (--j &gt;= lo &amp;&amp; nums[j] &gt; v);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[j];</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line">            nums[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[lo] = nums[j];</span><br><span class="line">        nums[j] = v;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自面试题40.最小的k个数&lt;/p&gt;
&lt;p&gt;输入整数数组 &lt;code&gt;arr&lt;/code&gt; ，找出其中最小的 &lt;code&gt;k&lt;/code&gt; 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>面试相关</title>
    <link href="http://yorxika.github.io/2020/03/20/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    <id>http://yorxika.github.io/2020/03/20/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/</id>
    <published>2020-03-20T02:49:12.000Z</published>
    <updated>2020-03-20T02:58:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>鹅厂一面有关：</p><ol><li><p>询问项目经历  与技术相关</p></li><li><p>equals 和 Hashcode 的关系</p></li><li><p>== 和 equals</p></li><li><p>HashMap底层原理 （Node数组+链表/红黑树</p><span id="more"></span></li><li><p>HashSet 和 HashMap的区别</p></li><li><p>HashMap 和 HashTable的比较 </p></li><li><p>对线程安全的理解 </p></li><li><p>设计模式 具体讲一种（23种工厂模式</p></li><li><p>GC机制（引用计数器，新生代复制算法忘了没说出来</p></li><li><p>C 指针和引用的区别</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><p>引用的好处之一就是在函数调用时在内存中不会生成副本。</p></li><li><p>讲一下安卓的有关知识</p></li><li><p>安卓生命周期</p></li><li><p>如何在线程里实现下载进度提示 </p></li><li><p>线程间通信方式</p></li><li><p>问有没有学过一些框架</p></li><li><p>TCP协议和UDP协议的区别</p></li><li><p>TCP协议的3次握手和4次握手</p></li><li><p>HTTP和HTTPS （HTTPS没讲好，像TLS/SSL都没有讲</p></li><li><p>DNS协议</p></li><li><p>快速排序原理和时间复杂度</p></li><li><p>ACM算法有关</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;鹅厂一面有关：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;询问项目经历  与技术相关&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;equals 和 Hashcode 的关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;== 和 equals&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HashMap底层原理 （Node数组+链表/红黑树&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JAVA" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://yorxika.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>丑数II</title>
    <link href="http://yorxika.github.io/2020/03/18/%E4%B8%91%E6%95%B0II/"/>
    <id>http://yorxika.github.io/2020/03/18/%E4%B8%91%E6%95%B0II/</id>
    <published>2020-03-18T00:34:16.000Z</published>
    <updated>2020-03-18T00:54:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第264题丑数II</p><p>编写一个程序，找出第 <code>n</code> 个丑数。</p><p>丑数就是只包含质因数 <code>2, 3, 5</code> 的<strong>正整数</strong>。<br><span id="more"></span><br><strong>示例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: n = 10</span></span><br><span class="line"><span class="section">输出: 12</span></span><br><span class="line"><span class="section">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span></span><br></pre></td></tr></table></figure><hr><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>来自<a href="https://leetcode-cn.com/problems/ugly-number-ii/solution/chou-shu-ii-by-leetcode/">官方题解</a></p><p>从堆中包含一个数字开始：1，去计算下一个丑数。将 1 从堆中弹出然后将三个数字添加到堆中：1 * 2，1 * 3和 1 * 5。</p><p>现在堆中最小的数字是 2。为了计算下一个丑数，要将 2 从堆中弹出然后添加三个数字：2×2, 2×3，和 2×5。</p><p>重复该步骤计算所有丑数。在每个步骤中，弹出堆中最小的丑数 k<em>k</em>，并在堆中添加三个丑数：<em>k</em>×2, k<em>×3，和 k</em>×5。</p><ul><li>初始化预计算用到的数组 <code>nums</code>，堆 <code>heap</code> 和哈希表 <code>seen</code> 跟踪在堆中出现过的元素，避免重复。<ul><li>循环计算丑数，每个步骤：<ul><li>弹出堆中最小的数字 <code>k</code> 并添加到数组 <code>nums</code> 中。</li><li>若 <code>2k</code>，<code>3k</code>，<code>5k</code> 不存在在哈希表中，则将其添加到栈中并更新哈希表。</li></ul></li></ul></li><li>返回在数组中预先计算好的丑数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ugly</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1690</span>];</span><br><span class="line">  Ugly() &#123;</span><br><span class="line">    HashSet&lt;Long&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">    PriorityQueue&lt;Long&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Long&gt;();</span><br><span class="line">    seen.add(<span class="number">1L</span>);</span><br><span class="line">    heap.add(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> currUgly, newUgly;</span><br><span class="line">    <span class="type">int</span>[] primes = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1690</span>; ++i) &#123;</span><br><span class="line">      currUgly = heap.poll();</span><br><span class="line">      nums[i] = (<span class="type">int</span>)currUgly;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j : primes) &#123;</span><br><span class="line">        newUgly = currUgly * j;</span><br><span class="line">        <span class="keyword">if</span> (!seen.contains(newUgly)) &#123;</span><br><span class="line">          seen.add(newUgly);</span><br><span class="line">          heap.add(newUgly);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Ugly</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ugly</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> u.nums[n - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三指针"><a href="#三指针" class="headerlink" title="三指针"></a>三指针</h3><p>从数组中只包含一个丑数数字 1 开始，使用三个指针 i_2<em>i</em>2, i_3<em>i</em>3 和 i_5<em>i</em>5，标记所指向丑数要乘以的因子。</p><p>算法很简单：在 $2 \times \textrm{nums}[i_2]，3 \times \textrm{nums}[i_3] 和 5 \times \textrm{nums}[i_5]$ 选出最小的丑数并添加到数组中。并将该丑数对应的因子指针往前走一步。重复该步骤直到计算完 1690 个丑数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ugly</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1690</span>];</span><br><span class="line">  Ugly() &#123;</span><br><span class="line">    nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ugly, i2 = <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">1690</span>; ++i) &#123;</span><br><span class="line">      ugly = Math.min(Math.min(nums[i2] * <span class="number">2</span>, nums[i3] * <span class="number">3</span>), nums[i5] * <span class="number">5</span>);</span><br><span class="line">      nums[i] = ugly;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ugly == nums[i2] * <span class="number">2</span>) ++i2;</span><br><span class="line">      <span class="keyword">if</span> (ugly == nums[i3] * <span class="number">3</span>) ++i3;</span><br><span class="line">      <span class="keyword">if</span> (ugly == nums[i5] * <span class="number">5</span>) ++i5;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Ugly</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ugly</span>();</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> u.nums[n - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第264题丑数II&lt;/p&gt;
&lt;p&gt;编写一个程序，找出第 &lt;code&gt;n&lt;/code&gt; 个丑数。&lt;/p&gt;
&lt;p&gt;丑数就是只包含质因数 &lt;code&gt;2, 3, 5&lt;/code&gt; 的&lt;strong&gt;正整数&lt;/strong&gt;。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="堆" scheme="http://yorxika.github.io/tags/%E5%A0%86/"/>
    
    <category term="三指针" scheme="http://yorxika.github.io/tags/%E4%B8%89%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>笔记整理</title>
    <link href="http://yorxika.github.io/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>http://yorxika.github.io/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</id>
    <published>2020-03-16T12:04:37.000Z</published>
    <updated>2020-09-27T06:48:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><p>栈内存:栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。<br><span id="more"></span><br>堆内存:存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</p><p>当一个实体，没有引用数据类型指向的时候，它在堆内存中不会被释放，而被当做一个垃圾，在不定时的时间内自动回收，因为Java有一个自动回收机制，（而c++没有，需要程序员手动回收，如果不回收就越堆越多，直到撑满内存溢出，所以Java在内存管理上优于c++）。自动回收机制（程序）自动监测堆里是否有垃圾，如果有，就会自动的做垃圾回收的动作，但是什么时候收不一定。</p><p>​       所以堆与栈的区别很明显：</p><p>​      1.栈内存存储的是局部变量而堆内存存储的是实体；</p><p>​      2.栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</p><p>​      3.栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</p><hr><h3 id="float中的32bit中哪些代表符号位，小数位，整数位，指数位？"><a href="#float中的32bit中哪些代表符号位，小数位，整数位，指数位？" class="headerlink" title="float中的32bit中哪些代表符号位，小数位，整数位，指数位？"></a>float中的32bit中哪些代表符号位，小数位，整数位，指数位？</h3><!--more--><p>答：float：<br>1bit（符号位） 8bits（指数位） 23bits（尾数位）<br>double：<br>1bit（符号位） 11bits（指数位） 52bits（尾数位）<br>于是，float的指数范围为-128~+127，而double的指数范围为-1024~+1023，并且指数位是按补码的形式来划分的。float的范围为-2^128 ~ +2^127，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1024 ~ +2^1023，也即-1.79E+308 ~ +1.79E+308。</p><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>答：事物在运行过程中存在不同的状态。多态的存在有<strong>三个前提</strong>:<br><strong>1.要有继承关系</strong><br><strong>2.子类要重写父类的方法</strong><br><strong>3.父类引用指向子类对</strong><br>多态成员访问的特点：<br><strong>成员变量</strong><br>编译看左边(父类),运行看左边(父类)<br><strong>成员方法</strong><br>编译看左边(父类)，运行看右边(子类)。动态绑定<br><strong>静态方法</strong><br>编译看左边(父类)，运行看左边(父类)。<br>(静态和类相关，算不上重写，所以，访问还是左边的)<br><strong>只有非静态的成员方法,编译看左边,运行看右边</strong><br><strong>多态的弊端，就是：不能使用子类特有的成员属性和子类特有的成员方法。</strong></p><hr><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>答：子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><hr><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>1.当子类和父类存在同一个方法，子类重写了父类的方法，程序在运行时调用的是父类的方法还是子类的重写方法呢（尤其是存在向上类型转换的情况）？</p><p>2.当一个类中存在方法名相同但参数不同（重载）的方法，程序在执行的时候该如何辨别区分使用哪个方法呢？</p><p>答：</p><h4 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h4><p>在程序执行以前已经被绑定（即在编译过程中就已经知道这个方法到底是哪个类中的方法）。</p><p>java当中的方法只有final、static、private修饰的方法和构造方法是静态绑定的。</p><p>private修饰的方法：private修饰的方法是不能被继承的，因此子类无法访问父类中private修饰的方法。所以只能通过父类对象来调用该方法体。因此可以说private方法和定义这个方法的类绑定在了一起。</p><p>final修饰的方法：可以被子类继承，但是不能被子类重写（覆盖），所以在子类中调用的实际是父类中定义的final方法。（使用final修饰方法的两个好处：（1）防止方法被覆盖；（2）关闭java中的动态绑定）。</p><p>static修饰的方法：可以被子类继承，但是不能被子类重写（覆盖），但是可以被子类隐藏。（这里意思是说如果父类里有一个static方法，它的子类里如果没有对应的方法，那么当子类对象调用这个方法时就会使用父类中的方法，而如果子类中定义了相同的方法，则会调用子类中定义的方法，唯一的不同就是：当子类对象向上类型转换为父类对象时，不论子类中有没有定义这个静态方法，该对象都会使用父类中的静态方法，因此这里说静态方法可以被隐藏而不能被覆盖。这与子类隐藏父类中的成员变量是一样的。隐藏和覆盖的区别在于，子类对象转换成父类对象后，能够访问父类被隐藏的变量和方法，而不能访问父类被覆盖的方法）。</p><p>构造方法：构造方法也是不能被继承的（因为子类是通过super方法调用父类的构造函数，或者是jvm自动调用父类的默认构造方法），因此编译时也可以知道这个构造方法方法到底是属于哪个类的。</p><p>因此，一个方法被继承，或者是被继承后不能被覆盖，那么这个方法就采用静态绑定</p><h4 id="动态绑定-1"><a href="#动态绑定-1" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>在运行时期根据具体对象的类型进行绑定。</p><p>若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的，但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。</p><p>动态绑定的过程：</p><p>1.虚拟机提取对象实际类型的方法表</p><p>2.虚拟机搜索方法签名</p><p>3.调用方法</p><p>java中重载的方法使用静态绑定，重写的方法使用动态绑定。</p><hr><h3 id="String-stringbuffer-stringbuider区别"><a href="#String-stringbuffer-stringbuider区别" class="headerlink" title="String, stringbuffer, stringbuider区别"></a>String, stringbuffer, stringbuider区别</h3><h4 id="String-字符串常量"><a href="#String-字符串常量" class="headerlink" title="String 字符串常量"></a>String 字符串常量</h4><p>StringBuffer 字符串变量（线程安全）<br>StringBuilder 字符串变量（非线程安全）<br> 简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。<br> 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢。</p><h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a><strong>StringBuffer</strong></h4><p>Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。<br>可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。<br>StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。</p><h4 id="java-lang-StringBuilder"><a href="#java-lang-StringBuilder" class="headerlink" title="java.lang.StringBuilder"></a><strong>java.lang.StringBuilder</strong></h4><p>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。</p><hr><h3 id="通过反射是可以修改所谓的“不可变”对象"><a href="#通过反射是可以修改所谓的“不可变”对象" class="headerlink" title="通过反射是可以修改所谓的“不可变”对象"></a><strong>通过反射是可以修改所谓的“不可变”对象</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符串&quot;Hello World&quot;， 并赋给引用s</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s); <span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取String类中的value字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">valueFieldOfString</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变value属性的访问权限</span></span><br><span class="line">valueFieldOfString.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取s对象上的value属性的值</span></span><br><span class="line"><span class="type">char</span>[] value = (<span class="type">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变value所引用的数组中的第5个字符</span></span><br><span class="line">value[<span class="number">5</span>] = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s); <span class="comment">// Hello_World</span></span><br></pre></td></tr></table></figure><p>解析：</p><p>用反射可以访问私有成员， 然后反射出 String 对象中的 value 属性， 进而改变通过获得的 value 引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p><hr><h3 id="重写hashcode-是否需要重写equals-不重写会有什么后果"><a href="#重写hashcode-是否需要重写equals-不重写会有什么后果" class="headerlink" title="重写hashcode()是否需要重写equals(),不重写会有什么后果"></a>重写hashcode()是否需要重写equals(),不重写会有什么后果</h3><p>我们先来看一下Object.hashCode的通用约定（摘自《Effective Java》第45页）</p><ol><li>在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，那么，对该对象调用hashCode方法多次，它必须始终如一地返回 同一个整数。在同一个应用程序的多次执行过程中，这个整数可以不同，即这个应用程序这次执行返回的整数与下一次执行返回的整数可以不一致。</li><li>如果两个对象根据equals(Object)方法是相等的，那么调用这两个对象中任一个对象的hashCode方法必须产生同样的整数结果。</li><li>如果两个对象根据equals(Object)方法是不相等的，那么调用这两个对象中任一个对象的hashCode方法，不要求必须产生不同的整数结果。然而，程序员应该意识到这样的事实，对于不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能。</li></ol><p><strong>如果只重写了equals方法而没有重写hashCode方法的话，则会违反约定的第二条：相等的对象必须具有相等的散列码（hashCode）。</strong></p><p>   <strong>同时对于HashSet和HashMap这些基于散列值（hash）实现的类。</strong>HashMap的底层处理机制是以数组的方法保存放入的数据的(Node<K,V>[] table)，其中的关键是数组下标的处理。<strong>数组的下标是根据传入的元素hashCode方法的返回值再和特定的值异或决定的。</strong>如果该数组位置上已经有放入的值了，且传入的键值相等则不处理，若不相等则覆盖原来的值，如果数组位置没有条目，则插入，并加入到相应的链表中。检查键是否存在也是根据hashCode值来确定的。所以如果不重写hashCode的话，<strong>可能导致HashSet、HashMap不能正常的运作、</strong></K,V></p><p>  如果我们将某个自定义对象存到HashMap或者HashSet及其类似实现类中的时候，<strong>如果该对象的属性参与了hashCode的计算，那么就不能修改该对象参数hashCode计算的属性了。</strong>有可能会移除不了元素，导致内存泄漏。</p><p><strong>ArrayList只根据equals()来判断</strong>两个对象是否相等，而不管hashCode是否不相等。<strong>HashSet</strong>判断流程则不一样，①<strong>先判断两个对象的hashCode方法是否一样</strong>；②如果不一样，立即认为两个对象equals不相等，并不调用equals方法；③当hashCode相等时，再根据equals方法判断两个对象是否相等。</p><p>当我们所写的类可能用于存放在Hash相关的集合类中时，<strong>在重写equals时，需要重写hashCode，不然会出现与预期不符的结果</strong>。</p><hr><h3 id="既然有GC-机制，为什么还会有内存泄露的情况"><a href="#既然有GC-机制，为什么还会有内存泄露的情况" class="headerlink" title="既然有GC 机制，为什么还会有内存泄露的情况"></a>既然有GC 机制，为什么还会有内存泄露的情况</h3><p>理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是 Java 被广泛使用于服务器端编程的一个重要原因）。然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被 GC 回收，因此也会导致内存泄露的发生。<br>例如 hibernate 的 Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。<br>下面例子中的代码也会导致内存泄露。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.EmptyStackException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INIT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        elements = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[INIT_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T elem)</span> &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = elem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(elements.length == size) &#123;</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的 pop 方法却存在内存泄露的问题，当我们用 pop 方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsoletereference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发 Disk Paging （物理内存与硬盘的虚拟内存交换数据），甚至造成 OutOfMemoryError。</p><hr><h3 id="Java-的GC-什么时候回收垃圾"><a href="#Java-的GC-什么时候回收垃圾" class="headerlink" title="Java 的GC 什么时候回收垃圾"></a>Java 的GC 什么时候回收垃圾</h3><p>在面试中经常会碰到这样一个问题：如何判断一个对象已经死去？<br>很容易想到的一个答案是：对一个对象添加引用计数器。每当有地方引用它时，计数器值加1；当引用失效时，计数器值减1.而当计数器的值为0 时这个对象就不会再被使用，判断为已死。是不是简单又直观。然而，很遗憾。这种做法是错误的！为什么是错的呢？事实上，用引用计数法确实在大部分情况下是一个不错的解决方案，而在实际的应用中也有不少案例，但它却无法解决对象之间的循环引用问题。比如对象A 中有一个字段指向了对象B，而对象B 中也有一个字段指向了对象A，而事实上他们俩都不再使用，但计数器的值永远都不可能为0，也就不会被回收，然后就发生了内存泄露。<br>所以，正确的做法应该是怎样呢？<br>在Java，C#等语言中，比较主流的判定一个对象已死的方法是：可达性分析(Reachability Analysis).<br>所有生成的对象都是一个称为”GC Roots”的根的子树。从GC Roots 开始向下搜索，搜索所经过的路径称为引用链(Reference Chain)，当一个对象到GC Roots 没有任何引用链可以到达时，就称这个对象是不可达的（不可引用的），也就是可以被GC 回收了。<br>无论是引用计数器还是可达性分析，判定对象是否存活都与引用有关！那么，如何定义对象的引用呢？<br>我们希望给出这样一类描述：当内存空间还够时，能够保存在内存中；如果进行了垃圾回收之后内存空间仍旧非常紧张，则可以抛弃这些对象。所以根据不同的需求，给出如下四种引用，根据引用类型的不同，GC 回收时也会有不同的操作：<br>1)强引用(Strong Reference):Object obj = new Object();只要强引用还存在，GC 永远不会回收掉被引用的对象。<br>2)软引用(Soft Reference)：描述一些还有用但非必需的对象。在系统将会发生内存溢出之前，会把这些对象列入回收范围进行二次回收（即系统将会发生内存溢出了，才会对他们进行回收。）<br>弱引用(Weak Reference):程度比软引用还要弱一些。这些对象只能生存到下次GC 之前。当GC 工作时，无论内存是否足够都会将其回收（即只要进行GC，就会对他们进行回收。）<br>虚引用(Phantom Reference):一个对象是否存在虚引用，完全不会对其生存时间构成影响。<br>关于方法区中需要回收的是一些废弃的常量和无用的类。<br>1.废弃的常量的回收。这里看引用计数就可以了。没有对象引用该常量就可以放心的回收了。<br>2.无用的类的回收。什么是无用的类呢？<br>A.该类所有的实例都已经被回收。也就是Java 堆中不存在该类的任何实例；<br>B.加载该类的ClassLoader 已经被回收；<br>C.该类对应的java.lang.Class 对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。<br>总而言之:<br>对于堆中的对象，主要用可达性分析判断一个对象是否还存在引用，如果该对象没有任何引用就应该被回收。而根据我们实际对引用的不同需求，又分成了4 中引用，每种引用的回收机制也是不同的。<br>对于方法区中的常量和类，当一个常量没有任何对象引用它，它就可以被回收了。而对于类，如果可以判定它为无用类，就可以被回收了。</p><h4 id="新生代与复制算法"><a href="#新生代与复制算法" class="headerlink" title="新生代与复制算法"></a>新生代与复制算法</h4><p>目前大部分JVM的GC对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。一般将新生代划分为一块较大的Eden空间和两个较小的Survivor空间(From Space, To Space)，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor空间中。</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/image-20200324095521916.png" alt="image-20200324095521916"></p><p>复制算法</p><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/image-20200324100444414.png" alt="image-20200324100444414"></p><h4 id="老年代与标记复制算法"><a href="#老年代与标记复制算法" class="headerlink" title="老年代与标记复制算法"></a>老年代与标记复制算法</h4><p>而老年代因为每次只回收少量对象，因而采用Mark-Compact算法。</p><ol><li>JAVA虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储class类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。</li><li>对象的内存分配主要在新生代的Eden Space和Survivor Space的From Space(Survivor目前存放对象的那一块)，少数情况会直接分配到老生代。 </li><li>当新生代的Eden Space和From Space空间不足时就会发生一次GC，进行GC后，Eden Space和From Space区的存活对象会被挪到To Space，然后将Eden Space和From Space进行清理。 </li><li>如果To Space无法足够存储某个对象，则将这个对象存储到老生代。</li><li>在进行GC后，使用的便是Eden Space和To Space了，如此反复循环。 </li><li>当对象在Survivor区躲过一次GC后，其年龄就会+1。默认情况下年龄到达15的对象会被移到老生代中。</li></ol><p>标记-整理算法</p><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/image-20200324100456084.png" alt="image-20200324100456084"></p><hr><h3 id="HashMap的底层数据结构，局限性与线程安全"><a href="#HashMap的底层数据结构，局限性与线程安全" class="headerlink" title="HashMap的底层数据结构，局限性与线程安全"></a>HashMap的底层数据结构，局限性与线程安全</h3><h4 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h4><p>哈希表结构（链表散列：数组+链表）实现，结合数组和链表的优点。当链表长度超过8时，链表转换为红黑树。</p><p> transient Node<K,V>[] table;</K,V></p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1184092-20190220113622746-1879492177.png" alt="img"></p><h4 id="HashMap的工作原理"><a href="#HashMap的工作原理" class="headerlink" title="HashMap的工作原理"></a>HashMap的工作原理</h4><p>A：HashMap底层是hash数组和单向链表实现，数组中的每个元素都是链表，由Node内部类（实现Map.Entry<k,V>接口）实现，HashMap通过put&amp;get方法存储和获取。</k,V></p><p><strong>存储对象时，将K/V键值对传给put（）方法；</strong></p><p>①、调用hash（K）方法计算K的hash值，然后结合数组长度，计算得数组下标；</p><p>②、调整数组大小（当容器中得元素个数大于capacity*loadFactor时，容器会进行resize为2n）</p><p>③、</p><p>i、如果K的hash值在HashMap不存在，则执行插入；若存在，则发生碰撞；</p><p>ii、如果K的hash值在HashMap存在，且它们两者equals返回true，则更新键值对；</p><p>iii、如果K的hash值在HashMap存在，且它们两者equals返回false，则插入链表的尾部（尾插法）或者红黑树（树的添加方式）</p><p>（JDK1.7 之前使用头插法、JDK 1.8 使用尾插法）</p><p>（注意：当碰撞导致链表大于TREEIFY_THRESHOLD = 8时，就把链表转换为红黑树）</p><p>（注意：当碰撞导致链表大于TREEIFY_THRESHOLD = 8时，就把链表转换为红黑树）</p><p><strong>获取对象时，将K传给get（）方法：</strong></p><p>①、调用hash（K）方法（计算K的hash值）从而获取该键值对所在链表的数组下标；</p><p>②、顺序遍历链表，equals（）方法查找相同Node链表K值对应的V值</p><p>hashCode是定位的，存储位置；</p><p>equals是定性的，比较两者是否相等。</p><h4 id="当两个对象的hashCode相同会发生什么？"><a href="#当两个对象的hashCode相同会发生什么？" class="headerlink" title="当两个对象的hashCode相同会发生什么？"></a>当两个对象的hashCode相同会发生什么？</h4><p>A：因为hashCode相同，不一定就是相等的（equals方法比较），所以两个对象所在数组下标相同，“碰撞”就此发生。又因为HashMap使用链表存储对象，这个Node会存储到链表下。</p><h4 id="你知道hash的实现吗？为什么要这样实现？"><a href="#你知道hash的实现吗？为什么要这样实现？" class="headerlink" title="你知道hash的实现吗？为什么要这样实现？"></a>你知道hash的实现吗？为什么要这样实现？</h4><p>A：JDK1.8中，是通过hashCode（）的高16位异或低16位实现的：（h = k.hashCode()^(h&gt;&gt;&gt;16)）</p><p>主要是从速度、功效和质量来考虑的，减少系统的开销，也不会造成因为高位没有参与下标的计算，从而引起的碰撞。</p><h4 id="为什么要用异或运算符？"><a href="#为什么要用异或运算符？" class="headerlink" title="为什么要用异或运算符？"></a>为什么要用异或运算符？</h4><p>A：保持了对象的hashCode的32位值只要有一位发生改变，整个hash（）返回值就会改变。尽可能的减少碰撞。</p><h4 id="HashMap的table的容量如何确定？loadFactor是什么？该容量如何变化？这种变化会带来什么问题？"><a href="#HashMap的table的容量如何确定？loadFactor是什么？该容量如何变化？这种变化会带来什么问题？" class="headerlink" title="HashMap的table的容量如何确定？loadFactor是什么？该容量如何变化？这种变化会带来什么问题？"></a>HashMap的table的容量如何确定？loadFactor是什么？该容量如何变化？这种变化会带来什么问题？</h4><p>A：</p><p>①、table数组大小是由capacity这个参数确定的，默认是16，也可以构造时传入，最大限制为1&lt;&lt;30；</p><p>②、loadFactor是负载因子，主要目的是用来确认table数组是否需要动态扩展，默认值是0.75，比如table数组大小为16，装载因子为0.75时，threshold就是12，当table的实际大小超过12时，table就需要动态扩容；</p><p>③、扩容时，调用resize（）方法，将table长度变为原来的两倍（注意是table长度，而不是threshold）</p><p>④、如果数据很大的情况下，扩展时将会带来性能的损失，在性能要求很高的地方，这种损失很可能很致命。</p><h4 id="HashMap、LinkedHashMap、TreeMap有什么区别？"><a href="#HashMap、LinkedHashMap、TreeMap有什么区别？" class="headerlink" title="HashMap、LinkedHashMap、TreeMap有什么区别？"></a>HashMap、LinkedHashMap、TreeMap有什么区别？</h4><p>A：HashMap参考其他问题；</p><p>LinkedHashMap保存了记录得插入顺序，用iterator遍历时，先取到得记录肯定是先插入得；遍历比HashMap慢；</p><p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以知道排序得比较器）</p><h4 id="HashMap和HashTable有什么区别？"><a href="#HashMap和HashTable有什么区别？" class="headerlink" title="HashMap和HashTable有什么区别？"></a>HashMap和HashTable有什么区别？</h4><p>A：</p><p>①、HashMap是线程不安全，HashTable是线程安全的；</p><p>②、由于线程安全，所以HashTable的效率比不上HashMap；</p><p>③、HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而HashTable不允许；</p><p>④、HashMao默认初始化数组的大小为16，HashTable为11，前者扩容时，扩大两倍，后者扩大两倍+1；</p><p>⑤、HashMap需要重新计算hash值，而HashTable直接使用对象的hashCode。</p><h4 id="同样是线程类，ConcurrentHashMap-和-HashTable-在线程同步上有什么不同"><a href="#同样是线程类，ConcurrentHashMap-和-HashTable-在线程同步上有什么不同" class="headerlink" title="同样是线程类，ConcurrentHashMap 和 HashTable 在线程同步上有什么不同"></a>同样是线程类，ConcurrentHashMap 和 HashTable 在线程同步上有什么不同</h4><p>A：ConcurrentHashMap类（是Java并发包java.util.concurrent中提供的一个线程安全且高效的Hash Map实现）</p><p>HashTable是使用synchronize关键字加锁的原理（就是对对象加锁）</p><p>而针对ConcurrentHashMap，在JDK1.7 中采用分段锁的方式，JDK1.8 中直接采用了CAS（无锁算法）+ synchronized。</p><h4 id="HashMap-amp-ConcurrentHashMap-的区别？"><a href="#HashMap-amp-ConcurrentHashMap-的区别？" class="headerlink" title="HashMap &amp; ConcurrentHashMap 的区别？"></a>HashMap &amp; ConcurrentHashMap 的区别？</h4><p> A：除了加锁，原理上无太大区别。</p><p>另外，HashMap的键值对允许有null，但是ConcurrentHashMap 都不允许。</p><h4 id="为什么-ConcurrentHashMap-比-HashTable-效率要高？"><a href="#为什么-ConcurrentHashMap-比-HashTable-效率要高？" class="headerlink" title="为什么 ConcurrentHashMap 比 HashTable 效率要高？"></a>为什么 ConcurrentHashMap 比 HashTable 效率要高？</h4><p>A：HashTable使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞；</p><p>ConcurrentHashMap ：</p><p>JDK1.7使用分段锁（ReentrantLock + Segment + HashEntry）相当于把一个HashMap分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：基于Segment，包含多个HashEntry。</p><p>JDK1.8使用CAS + synchronized + Node + 红黑树。 锁粒度：Node（首结点）（实现Map.Entry<K,V>）。锁粒度降低了。</K,V></p><p>因为多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。</p><hr><h3 id="Collections-sychronizedMap与ConcurrentHashMap的区别"><a href="#Collections-sychronizedMap与ConcurrentHashMap的区别" class="headerlink" title="Collections.sychronizedMap与ConcurrentHashMap的区别"></a>Collections.sychronizedMap与ConcurrentHashMap的区别</h3><p>Collections.synchronizedMap()与ConcurrentHashMap主要区别是：Collections.synchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步，而ConcurrentHashMap的实现却更加精细，它对map中的所有桶加了锁。所以，只要要有一个线程访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map执行某些操作。这样，ConcurrentHashMap在性能以及安全性方面，明显比Collections.synchronizedMap()更加有优势。同时，同步操作精确控制到桶，所以，即使在遍历map时，其他线程试图对map进行数据修改，也不会抛出ConcurrentModificationException。<br>  但是，细心的朋友可能发现了，上面的例子，即使map=map3时，最后打印的结果可以并没有100行。由于，不论Collections.synchronizedMap()还是ConcurrentHashMap对map同步的原子操作都是作用的map的方法上，map在读取与清空之间，线程间是不同步的。上面代码的不足在于，我们对这些同步的map过于信任，而忽略了混合操作带来的影响。正确的方法是，把map的读取和清空看成一个原子操作，给整个代码块加锁。</p><p>还有一个区别是：ConcurrentHashMap从类的命名就能看出，它必然是个HashMap。而Collections.synchronizedMap()可以接收任意Map实例，实现Map的同步。</p><hr><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal顾名思义是线程私有的局部变量存储容器，可以理解成每个线程都有自己专属的存储容器，它用来存储线程私有变量，其实它只是一个外壳，内部真正存取是一个Map，后面会仔细讲解。每个线程可以通过<code>set()</code>和<code>get()</code>存取变量，多线程间无法访问各自的局部变量，相当于在每个线程间建立了一个隔板。只要线程处于活动状态，它所对应的ThreadLocal实例就是可访问的，线程被终止后，它的所有实例将被垃圾收集。总之记住一句话：<strong>ThreadLocal存储的变量属于当前线程</strong>。</p><p>ThreadLocal ，也叫线程本地变量，可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了所使用的的变量副本。使用起来都是在线程的本地工作内存中操作，并且提供了set和get方法来访问拷贝过来的变量副本。底层也是封装了ThreadLocalMap集合类来绑定当前线程和变量副本的关系，各个线程独立并且访问安全。</p><p>set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">   <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//1.首先获取当前线程对象</span></span><br><span class="line">       <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//2.获取该线程对象的ThreadLocalMap</span></span><br><span class="line">       <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">           map.set(<span class="built_in">this</span>, value);<span class="comment">//如果map不为空，执行set操作，以当前threadLocal对象为key，实际存储对象为value进行set操作</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           createMap(t, value);<span class="comment">//如果map为空，则为该线程创建ThreadLocalMap</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>(1) ThreadLocal仅仅是个变量访问的入口；</strong></p><p><strong>(2) 每一个Thread对象都有一个ThreadLocalMap对象，这个ThreadLocalMap持有对象的引用；</strong></p><p><strong>(3) ThreadLocalMap以当前的threadLocal对象为key，以真正的存储对象为value。get()方法时通过threadLocal实例就可以找到绑定在当前线程上的副本对象。</strong></p><p>ThreadLocal这样设计有两个目的：</p><p>第一：可以保证当前线程结束时，相关对象可以立即被回收；第二：ThreadLocalMap元素会大大减少，因为Map过大容易造成哈希冲突而导致性能降低。</p><p>get方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//1.首先获取当前线程</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//2.获取线程的map对象</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;<span class="comment">//3.如果map不为空，以threadlocal实例为key获取到对应Entry，然后从Entry中取出对象即可。</span></span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> (T)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();<span class="comment">//如果map为空，也就是第一次没有调用set直接get（或者调用过set，又调用了remove）时，为其设定初始值</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal对象通常用于防止对可变的单实例变量或全局变量进行共享。例如：由于JDBC的连接对象不是线程安全的，因此，当多个线程应用程序在没有协同的情况下，使用全局变量时，就是线程不安全的。通过将JDBC的连接对象保存到ThreadLocal中，每个线程都会拥有自己的连接对象副本。</p><hr><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><strong><a href="https://baike.baidu.com/item/JAVA反射机制/6015990">JAVA反射机制</a>是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</strong></p><p><strong>静态编译和动态编译</strong></p><ul><li><strong>静态编译：</strong>在编译时确定类型，绑定对象</li><li><p><strong>动态编译：</strong>运行时确定类型，绑定对象</p><p>反射机制优缺点</p></li><li><p><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</p></li><li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。</li></ul><p>反射的应用场景</p><p><strong>反射是框架设计的灵魂。</strong></p><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p><p>举例：① 我们在使用 JDBC 连接数据库时使用 <code>Class.forName()</code>通过反射加载数据库的驱动程序；②Spring 框架也用到很多反射机制，最经典的就是 xml 的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java 类里面解析 xml 或 properties 里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的 Class 实例; 4)动态配置实例的属性</p><p><strong>推荐阅读：</strong></p><ul><li><a href="https://segmentfault.com/a/1190000010162647?utm_source=tuicool&amp;utm_medium=referral">Reflection：Java 反射机制的应用场景</a></li><li><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078">Java 基础之—反射（非常重要）</a></li></ul><hr><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20160421004103005.png" alt="img"></p><p>在整个Java.io包中最重要的就是5个类和一个接口。5个类指的是File、OutputStream、InputStream、Writer、Reader；一个接口指的是Serializable.掌握了这些IO的核心操作那么对于Java中的IO体系也就有了一个初步的认识了</p><p>Java I/O主要包括如下几个层次，包含三个部分：</p><p> <strong>1.流式部分</strong>――IO的主体部分；</p><p> <strong>2.非流式部分</strong>――主要包含一些辅助流式部分的类，如：File类、RandomAccessFile类和FileDescriptor等类；</p><p> <strong>3.其他类</strong>—文件读取部分的与安全相关的类，如：SerializablePermission类，以及与本地操作系统相关的文件系统的类，如：FileSystem类和Win32FileSystem类和WinNTFileSystem类。</p><ol><li><p>File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等。</p></li><li><p>InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。</p></li><li><p>OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。</p></li><li><p>Reader（文件格式操作）：抽象类，基于字符的输入操作。</p></li><li><p>Writer（文件格式操作）：抽象类，基于字符的输出操作。</p></li><li><p>RandomAccessFile（随机文件操作）：一个独立的类，直接继承至Object.它的功能丰富，<strong>可以从文件的任意位置进行存取（输入输出）操作</strong>。</p></li></ol><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20160421004203974.png" alt="img"></p><p>流：代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象<Thinking in java></Thinking></p><p>流的本质:数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 </p><p><strong>流的作用：为数据源和目的地建立一个输送通道。</strong></p><p>   Java中将输入输出抽象称为流，就好像水管，将两个容器连接起来。流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流.</p><h4 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a><strong>IO流的分类</strong></h4><p>·    根据处理数据类型的不同分为：字符流和字节流</p><p>·    根据数据流向不同分为：输入流和输出流</p><p>·    按数据来源（去向）分类：</p><p>​     1、File（文件）： FileInputStream, FileOutputStream, FileReader, FileWriter<br>​     2、byte[]：ByteArrayInputStream, ByteArrayOutputStream<br>​     3、Char[]: CharArrayReader,CharArrayWriter<br>​     4、String:StringBufferInputStream, StringReader, StringWriter<br>​     5、网络数据流：InputStream,OutputStream, Reader, Writer </p><p>字符流和字节流</p><p>流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种：</p><p> <strong>1)</strong>  <strong>字节流：</strong>数据流中最小的数据单元是字节<br> <strong>2)</strong>  <strong>字符流：</strong>数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节。</p><p><strong>字符流的由来：</strong> Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。</p><p>输入流和输出流</p><p>根据数据的输入、输出方向的不同对而将流分为输入流和输出流。</p><p><strong>1) 输入流</strong></p><p>   程序从输入流读取数据源。数据源包括外界(键盘、文件、网络…)，即是将数据源读入到程序的通信通道</p><p>   <img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20160421004522335.png" alt="img"></p><p>2) 输出流</p><p>  程序向输出流写入数据。将程序中的数据输出到外界（显示器、打印机、文件、网络…）的通信通道。</p><p>  <img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20160421004605951.png" alt="img"></p><p>​     </p><p>采用数据流的目的就是使得输出输入独立于设备。</p><p>输入流( Input  Stream )不关心数据源来自何种设备（键盘，文件，网络）。<br>输出流( Output Stream )不关心数据的目的是何种设备（键盘，文件，网络）。</p><p><strong>3）特性</strong></p><p> 相对于程序来说，输出流是往存储介质或数据通道写入数据，而输入流是从存储介质或数据通道中读取数据，一般来说关于流的特性有下面几点：</p><p>1、先进先出，最先写入输出流的数据最先被输入流读取到。</p><p>2、顺序存取，可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据。（RandomAccessFile<strong>可以从文件的任意位置进行存取（输入输出）操作</strong>）</p><p>3、只读或只写，每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流。</p><p>IO流对象</p><p><strong>1.输入字节流InputStream</strong></p><p> <img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20160421004733383.png" alt="img"></p><p>IO 中输入字节流的继承图可见上图，可以看出：</p><ol><li><p>InputStream是所有的输入字节流的父类，它是一个抽象类。</p></li><li><p>ByteArrayInputStream、StringBufferInputStream(上图的StreamBufferInputStream)、FileInputStream是三种基本的介质流，它们分别从Byte数组、StringBuffer、和本地文件中读取数据。</p></li><li><p>PipedInputStream是从与其它线程共用的管道中读取数据.</p></li><li><p>ObjectInputStream和所有FilterInputStream的子类都是装饰流（装饰器模式的主角）。</p></li></ol><p><strong>InputStream中的三个基本的读方法</strong><br>   abstract int read() ：读取一个字节数据，并返回读到的数据，如果返回-1，表示读到了输入流的末尾。<br>   intread(byte[]?b) ：将数据读入一个字节数组，同时返回实际读取的字节数。如果返回-1，表示读到了输入流的末尾。<br>   intread(byte[]?b, int?off, int?len) ：将数据读入一个字节数组，同时返回实际读取的字节数。如果返回-1，表示读到了输入流的末尾。off指定在数组b中存放数据的起始偏移位置；len指定读取的最大字节数。</p><p>流结束的判断：方法read()的返回值为-1时；readLine()的返回值为null时。</p><p><strong>其它方法</strong><br>   long skip(long?n)：在输入流中跳过n个字节，并返回实际跳过的字节数。<br>   int available() ：返回在不发生阻塞的情况下，可读取的字节数。<br>   void close() ：关闭输入流，释放和这个流相关的系统资源。<br>   voidmark(int?readlimit) ：在输入流的当前位置放置一个标记，如果读取的字节数多于readlimit设置的值，则流忽略这个标记。<br>   void reset() ：返回到上一个标记。<br>   booleanmarkSupported() ：测试当前流是否支持mark和reset方法。如果支持，返回true，否则返回false。</p><p>输出字节流OutputStream</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20160421004936555.png" alt="img"></p><p>IO 中输出字节流的继承图可见上图，可以看出：</p><ol><li><p>OutputStream是所有的输出字节流的父类，它是一个抽象类。</p></li><li><p>ByteArrayOutputStream、FileOutputStream是两种基本的介质流，它们分别向Byte数组、和本地文件中写入数据。PipedOutputStream是向与其它线程共用的管道中写入数据。</p></li><li><p>ObjectOutputStream和所有FilterOutputStream的子类都是装饰流。</p></li></ol><p>outputStream中的三个基本的写方法   abstract void write(int?b)：往输出流中写入一个字节。    void write(byte[]?b) ：往输出流中写入数组b中的所有字节。    void write(byte[]?b, int?off, int?len) ：往输出流中写入数组b中从偏移量off开始的len个字节的数据。</p><p>其它方法   void flush() ：刷新输出流，强制缓冲区中的输出字节被写出。    void close() ：关闭输出流，释放和这个流相关的系统资源。</p><hr><h3 id="volatile关键字的含义"><a href="#volatile关键字的含义" class="headerlink" title="volatile关键字的含义"></a>volatile关键字的含义</h3><p>volatile关键字是由JVM提供的最轻量级同步机制。与被滥用的synchronized不同，我们并不习惯使用它。</p><p>Java内存模型由Java虚拟机规范定义，用来屏蔽各个平台的硬件差异。简单来说:</p><ul><li>所有变量储存在主内存。</li><li>每条线程拥有自己的工作内存，其中保存了主内存中线程使用到的变量的副本。</li><li>线程不能直接读写主内存中的变量，所有操作均在工作内存中完成。</li></ul><p>线程，主内存，工作内存的交互关系如图。</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/2018092713195033.png" alt="在这里插入图片描述"></p><p>内存间的交互操作有很多，和volatile有关的操作为：</p><ul><li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li></ul><p>对被volatile修饰的变量进行操作时，需要满足以下规则：</p><ul><li>规则1：线程对变量执行的前一个动作是load时才能执行use，反之只有后一个动作是use时才能执行load。线程对变量的read，load，use动作关联，必须连续一起出现。——-这保证了线程每次使用变量时都需要从主存拿到最新的值，保证了其他线程修改的变量本线程能看到。</li><li>规则2：线程对变量执行的前一个动作是assign时才能执行store，反之只有后一个动作是store时才能执行assign。线程对变量的assign，store，write动作关联，必须连续一起出现。——-这保证了线程每次修改变量后都会立即同步回主内存，保证了本线程修改的变量其他线程能看到。</li><li>规则3：有线程T，变量V、变量W。假设动作A是T对V的use或assign动作，P是根据规则2、3与A关联的read或write动作；动作B是T对W的use或assign动作，Q是根据规则2、3与B关联的read或write动作。如果A先与B，那么P先与Q。———这保证了volatile修饰的变量不会被指令重排序优化，代码的执行顺序与程序的顺序相同。</li></ul><p>1.被volatile修饰的变量保证对所有线程可见。</p><p>由上文的规则1、2可知，volatile变量对所有线程是立即可见的，在各个线程中不存在一致性问题。volatile关键字只保证可见性，所以在以下情况中，需要使用锁来保证原子性：</p><ul><li>运算结果依赖变量的当前值，并且有不止一个线程在修改变量的值。</li><li>变量需要与其他状态变量共同参与不变约束</li></ul><p><strong>2.禁止指令重排序优化。</strong></p><p>jvm会把代码中没有依赖赋值的地方打乱执行顺序，由于一些规则限定，我们在单线程内观察不到打乱的现象（线程内表现为串行的语义），但是在并发程序中，从别的线程看另一个线程，操作是无序的。</p><p><strong>总结</strong></p><p>并发三特征可见性和有序性和原子性中，volatile通过新值立即同步到主内存和每次使用前从主内存刷新机制保证了可见性。<br>通过禁止指令重排序保证了有序性。<br>无法保证原子性。<br>而我们知道，synchronized关键字通过lock和unlock操作保证了原子性，<br>通过对一个变量unlock前，把变量同步回主内存中保证了可见性，<br>通过一个变量在同一时刻只允许一条线程对其进行lock操作保证了有序性。<br>他的“万能”也间接导致了我们对synchronized关键字的滥用，越泛用的控制，对性能的影响也越大，虽然jvm不断的对synchronized关键字进行各种各样的优化，但是我们还是要在合适的时候想起volatile关键字。</p><hr><h3 id="JAVA-NIO"><a href="#JAVA-NIO" class="headerlink" title="JAVA NIO"></a>JAVA NIO</h3><p>NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p><p>NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p><p>IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p><p>首先说一下Channel，国内大多翻译成“通道”。Channel和IO中的Stream(流)是差不多一个等级的。只不过Stream是单向的，譬如：InputStream, OutputStream.而Channel是双向的，既可以用来进行读操作，又可以用来进行写操作。</p><p>NIO中的关键Buffer实现有：ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer，分别对应基本数据类型: byte, char, double, float, int, long, short。当然NIO中还有MappedByteBuffer, HeapByteBuffer, DirectByteBuffer等这里先不进行陈述。</p><p>Selector运行单线程处理多个Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用Selector就会很方便。例如在一个聊天服务器中。要使用Selector, 得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收等。</p><hr><h3 id="String-不可变"><a href="#String-不可变" class="headerlink" title="String 不可变"></a>String 不可变</h3><p>String 底层实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//other codes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 的底层实现是依靠 char[] 数组，既然依靠的是基础类型变量，那么他一定是可变的， String 之所以不可变，是因为 Java 的开发者通过技术实现，隔绝了使用者对 String 的底层数据的操作。但是，我们可以同反射的机制，操作 String 的底层，检验其不可变的猜想。</p><p><strong>为什么会将 String 设计为不可变</strong></p><ul><li>安全<ul><li>引发安全问题，譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞</li><li>保证线程安全，在并发场景下，多个线程同时读写资源时，会引竞态条件，由于 String 是不可变的，不会引发线程的问题而保证了线程</li><li>HashCode，当 String 被创建出来的时候，hashcode也会随之被缓存，hashcode的计算与value有关，若 String 可变，那么 hashcode 也会随之变化，针对于 Map、Set 等容器，他们的键值需要保证唯一性和一致性，因此，String 的不可变性使其比其他对象更适合当容器的键值。</li></ul></li><li>性能<ul><li>当字符串是不可变时，字符串常量池才有意义。字符串常量池的出现，可以减少创建相同字面量的字符串，让不同的引用指向池中同一个字符串，为运行时节约很多的堆内存。若字符串可变，字符串常量池失去意义，基于常量池的String.intern()方法也失效，每次创建新的 String 将在堆内开辟出新的空间，占据更多的内存</li></ul></li></ul><hr><h3 id="jre-jdk-jvm-的关系"><a href="#jre-jdk-jvm-的关系" class="headerlink" title="jre , jdk , jvm 的关系"></a>jre , jdk , jvm 的关系</h3><p><strong>JVM</strong> ：英文名称（Java Virtual Machine），就是我们耳熟能详的 Java 虚拟机。它只认识 xxx.class 这种类型的文件，它能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。所以说，jvm 是 Java 能够跨平台的核心，具体的下文会详细说明。</p><p><strong>什么是字节码?采用字节码的好处是什么?</strong></p><blockquote><p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p></blockquote><p><strong>Java 程序从源代码到运行一般有下面 3 步：</strong></p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/TIM截图20200401215950.jpg" alt="TIM截图20200401215950"></p><p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p><p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p><p><strong>总结：</strong></p><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p><p><strong>JRE</strong> ：英文名称（Java Runtime Environment），我们叫它：Java 运行时环境。它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。</p><p><strong>JDK</strong> ：英文名称（Java Development Kit），Java 开发工具包。jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。例如：javac.exe，java.exe，jar.exe 等。</p><p>显然，这三者的关系是：一层层的嵌套关系。<strong>JDK&gt;JRE&gt;JVM</strong>。</p><hr><h3 id="什么是字节码？采用字节码的最大好处是什么？"><a href="#什么是字节码？采用字节码的最大好处是什么？" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么？"></a>什么是字节码？采用字节码的最大好处是什么？</h3><p><strong>先看下 java 中的编译器和解释器：</strong></p><p>Java 中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在 Java 中，这种供虚拟机理解的代码叫做<code>字节码</code>（即扩展名为<code>.class</code>的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了 Java 的编译与解释并存的特点。</p><p>Java 源代码——&gt;编译器——&gt;jvm 可执行的 Java 字节码(即虚拟指令)——&gt;jvm——&gt;jvm 中解释器——-&gt;机器可执行的二进制机器码——&gt;程序运行。</p><p><strong>采用字节码的好处：</strong></p><p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同的计算机上运行。</p><hr><h3 id="接口和抽象类的区别是什么"><a href="#接口和抽象类的区别是什么" class="headerlink" title="接口和抽象类的区别是什么?"></a>接口和抽象类的区别是什么?</h3><ol><li>接口的方法默认是 public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法</li><li>接口中的实例变量默认是 final 类型的，而抽象类中则不一定</li><li>一个类可以实现多个接口，但最多只能实现一个抽象类</li><li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</li><li>接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li></ol><p>注意：Java8 后接口可以有默认实现( default )。</p><p>重载和重写的区别</p><p>重载</p><p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>重写</p><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写,发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。另外，如果父类方法访问修饰符为 private 则子类就不能重写该方法。<strong>也就是说方法提供的行为改变，而方法的外貌并没有改变。</strong></p><hr><h3 id="Java-面向对象编程三大特性-封装-继承-多态"><a href="#Java-面向对象编程三大特性-封装-继承-多态" class="headerlink" title="Java 面向对象编程三大特性: 封装 继承 多态"></a>Java 面向对象编程三大特性: 封装 继承 多态</h3><p>封装</p><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><p>继承</p><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><p>多态</p><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><hr><h3 id="什么是线程和进程"><a href="#什么是线程和进程" class="headerlink" title="什么是线程和进程?"></a>什么是线程和进程?</h3><h4 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a>何为进程?</h4><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><h4 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程?"></a>何为线程?</h4><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p><strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行</strong>。</p><hr><h3 id="请简要描述线程与进程的关系-区别及优缺点？"><a href="#请简要描述线程与进程的关系-区别及优缺点？" class="headerlink" title="请简要描述线程与进程的关系,区别及优缺点？"></a>请简要描述线程与进程的关系,区别及优缺点？</h3><h4 id="从-JVM-角度说进程和线程之间的关系"><a href="#从-JVM-角度说进程和线程之间的关系" class="headerlink" title="从 JVM 角度说进程和线程之间的关系"></a><strong>从 JVM 角度说进程和线程之间的关系</strong></h4><p>图解进程和线程的关系</p><p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。如果你对 Java 内存区域 (运行时数据区) 这部分知识不太了解的话可以阅读一下这篇文章：<a href="https://github.com/Snailclimb/JavaGuide/blob/3965c02cc0f294b0bd3580df4868d5e396959e2e/Java相关/可能是把Java内存区域讲的最清楚的一篇文章.md">《可能是把 Java 内存区域讲的最清楚的一篇文章》</a></p><p><img src="https://camo.githubusercontent.com/a66819fd82c6adfa69b368edf3c52b1fa9cdc89d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67" alt="img"></p><p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p><p><strong>总结：</strong> 线程 是 进程 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反</p><p>下面是该知识点的扩展内容！</p><p>下面来思考这样一个问题：为什么<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是线程私有的呢？为什么堆和方法区是线程共享的呢？</p><p>程序计数器为什么是私有的?</p><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><p>虚拟机栈和本地方法栈为什么是私有的?</p><ul><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><p>一句话简单了解堆和方法区</p><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><hr><h3 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h3><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p><p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p><hr><h3 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h3><h4 id="认识线程死锁"><a href="#认识线程死锁" class="headerlink" title="认识线程死锁"></a>认识线程死锁</h4><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><h4 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁?"></a>如何避免线程死锁?</h4><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p><p><strong>破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p><p><strong>破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p><p><strong>破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><hr><h3 id="Object-类有哪些方法"><a href="#Object-类有哪些方法" class="headerlink" title="Object 类有哪些方法?"></a>Object 类有哪些方法?</h3><p>这个问题，面试中经常出现。我觉得不论是出于应付面试还是说更好地掌握 Java 这门编程语言，大家都要掌握！</p><h4 id="Object-类的常见方法总结"><a href="#Object-类的常见方法总结" class="headerlink" title="Object 类的常见方法总结"></a>Object 类的常见方法总结</h4><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure><blockquote><p>问完上面这个问题之后，面试官很可能紧接着就会问你“hashCode 与 equals”相关的问题。</p></blockquote><h4 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode 与 equals"></a>hashCode 与 equals</h4><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？”</p><h4 id="hashCode-介绍"><a href="#hashCode-介绍" class="headerlink" title="hashCode()介绍"></a>hashCode()介绍</h4><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h4 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h4><p><strong>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong></p><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head fist java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p>hashCode()与 equals()的相关规定</p><ol><li>如果两个对象相等，则 hashcode 一定也是相同的</li><li>两个对象相等，对两个对象分别调用 equals 方法都返回 true</li><li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li><li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><h4 id="为什么两个对象有相同的-hashcode-值-它们也不一定是相等的"><a href="#为什么两个对象有相同的-hashcode-值-它们也不一定是相等的" class="headerlink" title="为什么两个对象有相同的 hashcode 值,它们也不一定是相等的?"></a>为什么两个对象有相同的 hashcode 值,它们也不一定是相等的?</h4><p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p><p>因为 hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。</p><p>我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。</p><hr><h3 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h3><p><strong>① 两者都是可重入锁</strong></p><p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p><p><strong>② synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></p><p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><p><strong>③ ReentrantLock 比 synchronized 增加了一些高级功能</strong></p><p>相比 synchronized，ReentrantLock 增加了一些高级功能。主要来说主要有三点：<strong>① 等待可中断；② 可实现公平锁；③ 可实现选择性通知（锁可以绑定多个条件）</strong></p><ul><li><strong>ReentrantLock 提供了一种能够中断等待锁的线程的机制</strong>，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>ReentrantLock 可以指定是公平锁还是非公平锁。而 synchronized 只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReentrantLock 默认情况是非公平的，可以通过 ReentrantLock 类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li>synchronized 关键字与 wait()和 notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock 类当然也可以实现，但是需要借助于 Condition 接口与 newCondition() 方法。Condition 是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个 Lock 对象中可以创建多个 Condition 实例（即对象监视器），<strong>线程对象可以注册在指定的 Condition 中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用 notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用 ReentrantLock 类结合 Condition 实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。而 synchronized 关键字就相当于整个 Lock 对象中只有一个 Condition 实例，所有的线程都注册在它一个身上。如果执行 notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而 Condition 实例的 signalAll()方法 只会唤醒注册在该 Condition 实例中的所有等待线程。</li></ul><p>如果你想使用上述功能，那么选择 ReentrantLock 是一个不错的选择。</p><p><strong>④ 两者的性能已经相差无几</strong></p><p>在 JDK1.6 之前，synchronized 的性能是比 ReentrantLock 差很多。具体表示为：synchronized 关键字吞吐量随线程数的增加，下降得非常严重。而 ReentrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。JDK1.6 之后，synchronized 和 ReentrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReentrantLock 的文章都是错的！JDK1.6 之后，性能已经不是选择 synchronized 和 ReentrantLock 的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的 synchronized，所以还是提倡在 synchronized 能满足你的需求的情况下，优先考虑使用 synchronized 关键字来进行同步！优化后的 synchronized 和 ReentrantLock 一样，在很多地方都是用到了 CAS 操作。</p><hr><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile 是一个类型修饰符。volatile 的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略。</p><h4 id="volatile-的特性"><a href="#volatile-的特性" class="headerlink" title="volatile 的特性"></a>volatile 的特性</h4><ul><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（实现可见性）</li><li>禁止进行指令重排序。（实现有序性）</li><li>volatile 只能保证对单次读/写的原子性。i++ 这种操作不能保证原子性。</li></ul><h4 id="volatile-可见性实现"><a href="#volatile-可见性实现" class="headerlink" title="volatile 可见性实现"></a>volatile 可见性实现</h4><ul><li>volatile 变量的内存可见性是基于内存屏障（Memory Barrier）实现。</li><li>内存屏障，又称内存栅栏，是一个 CPU 指令。</li><li>在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。</li><li>写一段简单的 Java 代码，声明一个 volatile 变量，并赋值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 hsdis 和 jitwatch 工具可以得到编译后的汇编代码。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">  <span class="number">0x0000000002951563</span>: and    $<span class="number">0xffffffffffffff87</span>,%rdi</span><br><span class="line">  <span class="number">0x0000000002951567</span>: je     <span class="number">0x00000000029515f8</span></span><br><span class="line">  <span class="number">0x000000000295156d</span>: test   $<span class="number">0x7</span>,%rdi</span><br><span class="line">  <span class="number">0x0000000002951574</span>: jne    <span class="number">0x00000000029515bd</span></span><br><span class="line">  <span class="number">0x0000000002951576</span>: test   $<span class="number">0x300</span>,%rdi</span><br><span class="line">  <span class="number">0x000000000295157d</span>: jne    <span class="number">0x000000000295159c</span></span><br><span class="line">  <span class="number">0x000000000295157f</span>: and    $<span class="number">0x37f</span>,%rax</span><br><span class="line">  <span class="number">0x0000000002951586</span>: mov    %rax,%rdi</span><br><span class="line">  <span class="number">0x0000000002951589</span>: or     %r15,%rdi</span><br><span class="line">  <span class="number">0x000000000295158c</span>: lock cmpxchg %rdi,(%rdx)  <span class="comment">//在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令</span></span><br><span class="line">  <span class="number">0x0000000002951591</span>: jne    <span class="number">0x0000000002951a15</span></span><br><span class="line">  <span class="number">0x0000000002951597</span>: jmpq   <span class="number">0x00000000029515f8</span></span><br><span class="line">  <span class="number">0x000000000295159c</span>: mov    <span class="number">0x8</span>(%rdx),%edi</span><br><span class="line">  <span class="number">0x000000000295159f</span>: shl    $<span class="number">0x3</span>,%rdi</span><br><span class="line">  <span class="number">0x00000000029515a3</span>: mov    <span class="number">0xa8</span>(%rdi),%rdi</span><br><span class="line">  <span class="number">0x00000000029515aa</span>: or     %r15,%rdi</span><br><span class="line">......</span><br></pre></td></tr></table></figure><ul><li>lock 前缀的指令在多核处理器下会引发两件事情。<ul><li>1）将当前处理器缓存行的数据写回到系统内存。</li><li>2）写回内存的操作会使在其他 CPU 里缓存了该内存地址的额数据无效。</li></ul></li><li>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2 或其他）后再进行操作，但操作完不知道何时会写到内存。</li><li>如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</li><li>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议（MESI），每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。<ul><li>所有多核处理器下还会完成：3）当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</li></ul></li><li>volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。</li></ul><h5 id="lock-指令"><a href="#lock-指令" class="headerlink" title="lock 指令"></a>lock 指令</h5><ul><li>在 Pentium 和早期的 IA-32 处理器中，lock 前缀会使处理器执行当前指令时产生一个 LOCK# 信号，会对总线进行锁定，其它 CPU 对内存的读写请求都会被阻塞，直到锁释放。</li><li>后来的处理器，加锁操作是由高速缓存锁代替总线锁来处理。<ul><li>因为锁总线的开销比较大，锁总线期间其他 CPU 没法访问内存。</li><li>这种场景多缓存的数据一致通过缓存一致性协议（MESI）来保证。</li></ul></li></ul><h5 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h5><ul><li>缓存是分段（line）的，一个段对应一块存储空间，称之为缓存行，它是 CPU 缓存中可分配的最小存储单元，大小 32 字节、64 字节、128 字节不等，这与 CPU 架构有关，通常来说是 64 字节。</li><li>LOCK# 因为锁总线效率太低，因此使用了多组缓存。<ul><li>为了使其行为看起来如同一组缓存那样。因而设计了 <strong>缓存一致性协议</strong>。</li><li>缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 “ <strong>嗅探</strong>（snooping）” 协议。</li></ul></li><li>所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。</li><li>缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁（同一个指令周期中，只有一个 CPU 缓存可以读写内存）。</li><li>CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。</li><li>当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。<ul><li>只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。</li></ul></li></ul><h4 id="volatile-禁止重排序"><a href="#volatile-禁止重排序" class="headerlink" title="volatile 禁止重排序"></a>volatile 禁止重排序</h4><ul><li>为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。</li><li>Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。</li><li>JMM 会针对编译器制定 volatile 重排序规则表。</li></ul><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/5714666-390c861ed043ef94.webp" alt="img"></p><p>volatile 重排序规则表</p><ul><li>“ NO “ 表示禁止重排序。<ul><li>为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</li><li>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。<ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul></li></ul></li><li>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</li></ul><div class="table-container"><table><thead><tr><th>内存屏障</th><th>说明</th></tr></thead><tbody><tr><td>StoreStore 屏障</td><td>禁止上面的普通写和下面的 volatile 写重排序。</td></tr><tr><td>StoreLoad 屏障</td><td>防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。</td></tr><tr><td>LoadLoad 屏障</td><td>禁止下面所有的普通读操作和上面的 volatile 读重排序。</td></tr><tr><td>LoadStore 屏障</td><td>禁止下面所有的普通写操作和上面的 volatile 读重排序。</td></tr></tbody></table></div><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/5714666-42b7250449160dc2.webp" alt="img"></p><p>volatile 写插入内存屏障</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/5714666-cce9ccf139acf1a4.webp" alt="img"></p><p>volatile 读插入内存屏障</p><h4 id="为什么num-多线程不安全？"><a href="#为什么num-多线程不安全？" class="headerlink" title="为什么num++多线程不安全？"></a>为什么num++多线程不安全？</h4><p>原因如图<br><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20200321025739906.png" alt="在这里插入图片描述"><br>一个num++操作java来写是一句，但执行时候汇编成字节码是4句：从主内存取到工作内存、压栈、加操作、放回主内存。</p><hr><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池?"></a>为什么要用线程池?</h4><p>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：</p><ul><li><strong>降低资源消耗。</strong> 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度。</strong> 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性。</strong> 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h4 id="Java-提供了哪几种线程池-他们各自的使用场景是什么"><a href="#Java-提供了哪几种线程池-他们各自的使用场景是什么" class="headerlink" title="Java 提供了哪几种线程池?他们各自的使用场景是什么?"></a>Java 提供了哪几种线程池?他们各自的使用场景是什么?</h4><h5 id="Java-主要提供了下面-4-种线程池"><a href="#Java-主要提供了下面-4-种线程池" class="headerlink" title="Java 主要提供了下面 4 种线程池"></a>Java 主要提供了下面 4 种线程池</h5><ul><li><strong>FixedThreadPool：</strong> 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li><strong>ScheduledThreadPoolExecutor：</strong> 主要用来在给定的延迟后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor 又分为：ScheduledThreadPoolExecutor（包含多个线程）和 SingleThreadScheduledExecutor （只包含一个线程）两种。</li></ul><h5 id="各种线程池的适用场景介绍"><a href="#各种线程池的适用场景介绍" class="headerlink" title="各种线程池的适用场景介绍"></a>各种线程池的适用场景介绍</h5><ul><li><strong>FixedThreadPool：</strong> 适用于为了满足资源管理需求，而需要限制当前线程数量的应用场景。它适用于负载比较重的服务器；</li><li><strong>SingleThreadExecutor：</strong> 适用于需要保证顺序地执行各个任务并且在任意时间点，不会有多个线程是活动的应用场景；</li><li><strong>CachedThreadPool：</strong> 适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器；</li><li><strong>ScheduledThreadPoolExecutor：</strong> 适用于需要多个后台执行周期任务，同时为了满足资源管理需求而需要限制后台线程的数量的应用场景；</li><li><strong>SingleThreadScheduledExecutor：</strong> 适用于需要单个后台线程执行周期任务，同时保证顺序地执行各个任务的应用场景。</li></ul><h4 id="创建的线程池的方式"><a href="#创建的线程池的方式" class="headerlink" title="创建的线程池的方式"></a>创建的线程池的方式</h4><p><strong>（1） 使用 Executors 创建</strong></p><p>我们上面刚刚提到了 Java 提供的几种线程池，通过 Executors 工具类我们可以很轻松的创建我们上面说的几种线程池。但是实际上我们一般都不是直接使用 Java 提供好的线程池，另外在《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Executors 返回线程池对象的弊端如下：</span><br><span class="line"></span><br><span class="line">FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</span><br><span class="line">CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</span><br></pre></td></tr></table></figure><p><strong>（2） ThreadPoolExecutor 的构造函数创建</strong></p><p>我们可以自己直接调用 ThreadPoolExecutor 的构造函数来自己创建线程池。在创建的同时，给 BlockQueue 指定容量就可以了。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">13</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">13</span>));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, // <span class="number">1</span></span></span><br><span class="line"><span class="params">                             <span class="type">int</span> maximumPoolSize,  // <span class="number">2</span></span></span><br><span class="line"><span class="params">                             <span class="type">long</span> keepAliveTime,  // <span class="number">3</span></span></span><br><span class="line"><span class="params">                             TimeUnit unit,  // <span class="number">4</span></span></span><br><span class="line"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue, // <span class="number">5</span></span></span><br><span class="line"><span class="params">                             ThreadFactory threadFactory,  // <span class="number">6</span></span></span><br><span class="line"><span class="params">                             RejectedExecutionHandler handler )</span> &#123; <span class="comment">//7</span></span><br><span class="line">       <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">           keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">       <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">       <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">       <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">       <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">       <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">       <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">       <span class="built_in">this</span>.handler = handler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>序号</th><th>名称</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>corePoolSize</td><td>int</td><td>核心线程池大小</td></tr><tr><td>2</td><td>maximumPoolSize</td><td>int</td><td>最大线程池大小</td></tr><tr><td>3</td><td>keepAliveTime</td><td>long</td><td>线程最大空闲时间</td></tr><tr><td>4</td><td>unit</td><td>TimeUnit</td><td>时间单位</td></tr><tr><td>5</td><td>workQueue</td><td>BlockingQueue<Runnable></Runnable></td><td>线程等待队列</td></tr><tr><td>6</td><td>threadFactory</td><td>ThreadFactory</td><td>线程创建工厂</td></tr><tr><td>7</td><td>handler</td><td>RejectedExecutionHandler</td><td>拒绝策略</td></tr></tbody></table></div><p>这种情况下，一旦提交的线程数超过当前可用线程数时，就会抛出 java.util.concurrent.RejectedExecutionException，这是因为当前线程池使用的队列是有边界队列，队列已经满了便无法继续处理新的请求。但是异常（Exception）总比发生错误（Error）要好。</p><p><strong>（3） 使用开源类库</strong></p><p>Hollis 大佬之前在他的文章中也提到了：“除了自己定义 ThreadPoolExecutor 外。还有其他方法。这个时候第一时间就应该想到开源类库，如 apache 和 guava 等。”他推荐使用 guava 提供的 ThreadFactoryBuilder 来创建线程池。下面是参考他的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorsDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ThreadFactory</span> <span class="variable">namedThreadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">        .setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">200</span>,</span><br><span class="line">        <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> <span class="title class_">SubThread</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述方式创建线程时，不仅可以避免 OOM 的问题，还可以自定义线程名称，更加方便的出错的时候溯源。</p><h4 id="workQueue任务队列"><a href="#workQueue任务队列" class="headerlink" title="workQueue任务队列"></a><strong>workQueue任务队列</strong></h4><p><strong>它一般分为直接提交队列、有界任务队列、无界任务队列、优先任务队列；</strong></p><p>1、<strong>直接提交队列</strong>：设置为SynchronousQueue队列，SynchronousQueue是一个特殊的BlockingQueue，它没有容量，没执行一个插入操作就会阻塞，需要再执行一个删除操作才会被唤醒，反之每一个删除操作也都要等待对应的插入操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//maximumPoolSize设置为2 ，拒绝策略为AbortPolic策略，直接抛出异常</span></span><br><span class="line">        pool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),Executors.defaultThreadFactory(),<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> <span class="title class_">ThreadTask</span>());</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadTask</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*pool-1-thread-1</span></span><br><span class="line"><span class="comment">pool-1-thread-2</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task com.hhxx.test.ThreadTask@55f96302 rejected from java.util.concurrent.ThreadPoolExecutor@3d4eac69[Running, pool size = 2, active threads = 0, queued tasks = 0, completed tasks = 2]</span></span><br><span class="line"><span class="comment">    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(Unknown Source)</span></span><br><span class="line"><span class="comment">    at java.util.concurrent.ThreadPoolExecutor.reject(Unknown Source)</span></span><br><span class="line"><span class="comment">    at java.util.concurrent.ThreadPoolExecutor.execute(Unknown Source)</span></span><br><span class="line"><span class="comment">    at com.hhxx.test.ThreadPool.main(ThreadPool.java:17)*/</span></span><br></pre></td></tr></table></figure><p>可以看到，当任务队列为SynchronousQueue，创建的线程数大于maximumPoolSize时，直接执行了拒绝策略抛出异常。</p><p>使用SynchronousQueue队列，提交的任务不会被保存，总是会马上提交执行。如果用于执行任务的线程数量小于maximumPoolSize，则尝试创建新的进程，如果达到maximumPoolSize设置的最大值，则根据你设置的handler执行拒绝策略。因此这种方式你提交的任务不会被缓存起来，而是会被马上执行，在这种情况下，你需要对你程序的并发量有个准确的评估，才能设置合适的maximumPoolSize数量，否则很容易就会执行拒绝策略；</p><p>2、<strong>有界的任务队列</strong>：有界的任务队列可以使用ArrayBlockingQueue实现，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">10</span>),Executors.defaultThreadFactory(),<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br></pre></td></tr></table></figure><p>使用ArrayBlockingQueue有界任务队列，若有新的任务需要执行时，线程池会创建新的线程，直到创建的线程数量达到corePoolSize时，则会将新的任务加入到等待队列中。若等待队列已满，即超过ArrayBlockingQueue初始化的容量，则继续创建线程，直到线程数量达到maximumPoolSize设置的最大线程数量，若大于maximumPoolSize，则执行拒绝策略。在这种情况下，线程数量的上限与有界任务队列的状态有直接关系，如果有界队列初始容量较大或者没有达到超负荷的状态，线程数将一直维持在corePoolSize以下，反之当任务队列已满时，则会以maximumPoolSize为最大线程数上限。</p><p>3、<strong>无界的任务队列</strong>：有界任务队列可以使用LinkedBlockingQueue实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),Executors.defaultThreadFactory(),<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br></pre></td></tr></table></figure><p>使用无界任务队列，线程池的任务队列可以无限制的添加新的任务，而线程池创建的最大线程数量就是你corePoolSize设置的数量，也就是说在这种情况下maximumPoolSize这个参数是无效的，哪怕你的任务队列中缓存了很多未执行的任务，当线程池的线程数达到corePoolSize后，就不会再增加了；若后续有新的任务加入，则直接进入队列等待，当使用这种任务队列模式时，一定要注意你任务提交与处理之间的协调与控制，不然会出现队列中的任务由于无法及时处理导致一直增长，直到最后资源耗尽的问题。</p><p>4<strong>、优先任务队列：</strong>优先任务队列通过PriorityBlockingQueue实现，下面我们通过一个例子演示下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//优先任务队列</span></span><br><span class="line">        pool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>&lt;Runnable&gt;(),Executors.defaultThreadFactory(),<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> <span class="title class_">ThreadTask</span>(i));</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>,Comparable&lt;ThreadTask&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> priority;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> priority)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadTask</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadTask</span><span class="params">(<span class="type">int</span> priority)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前对象和其他对象做比较，当前优先级大就返回-1，优先级小就返回1,值越小优先级越高</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(ThreadTask o)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span>  <span class="built_in">this</span>.priority&gt;o.priority?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//让线程阻塞，使后续任务进入缓存队列</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;priority:&quot;</span>+<span class="built_in">this</span>.priority+<span class="string">&quot;,ThreadName:&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">priority:0,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">priority:9,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">priority:8,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">priority:7,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">priority:6,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">priority:5,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">priority:4,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">priority:3,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">priority:2,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">priority:1,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到除了第一个任务直接创建线程执行外，其他的任务都被放入了优先任务队列，按优先级进行了重新排列执行，且线程池的线程数一直为corePoolSize，也就是只有一个。</p><p>通过运行的代码我们可以看出PriorityBlockingQueue它其实是一个特殊的无界队列，它其中无论添加了多少个任务，线程池创建的线程数也不会超过corePoolSize的数量，只不过其他队列一般是按照先进先出的规则处理任务，而PriorityBlockingQueue队列可以自定义规则根据任务的优先级顺序先后执行。</p><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a><strong>拒绝策略</strong></h4><p>一般我们创建线程池时，为防止资源被耗尽，任务队列都会选择创建有界任务队列，但种模式下如果出现任务队列已满且线程池创建的线程数达到你设置的最大线程数时，这时就需要你指定ThreadPoolExecutor的RejectedExecutionHandler参数即合理的拒绝策略，来处理线程池”超载”的情况。ThreadPoolExecutor自带的拒绝策略如下：</p><p><strong>1、AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作；</strong></p><p><strong>2、CallerRunsPolicy策略：如果线程池的线程数量达到上限，该策略会把任务队列中的任务放在调用者线程当中运行；</strong></p><p><strong>3、DiscardOledestPolicy策略：该策略会丢弃任务队列中最老的一个任务，也就是当前任务队列中最先被添加进去的，马上要被执行的那个任务，并尝试再次提交；</strong></p><p><strong>4、DiscardPolicy策略：该策略会默默丢弃无法处理的任务，不予任何处理。当然使用此策略，业务场景中需允许任务的丢失；</strong></p><p>以上内置的策略均实现了RejectedExecutionHandler接口，当然你也可以自己扩展RejectedExecutionHandler接口，定义自己的拒绝策略，我们看下示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//自定义拒绝策略</span></span><br><span class="line">        pool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">5</span>),</span><br><span class="line">                Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">                System.out.println(r.toString()+<span class="string">&quot;执行了拒绝策略&quot;</span>);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> <span class="title class_">ThreadTask</span>());</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//让线程阻塞，使后续任务进入缓存队列</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;ThreadName:&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">com.hhxx.test.ThreadTask@33909752执行了拒绝策略</span></span><br><span class="line"><span class="comment">com.hhxx.test.ThreadTask@55f96302执行了拒绝策略</span></span><br><span class="line"><span class="comment">com.hhxx.test.ThreadTask@3d4eac69执行了拒绝策略</span></span><br><span class="line"><span class="comment">ThreadName:pool-1-thread-2</span></span><br><span class="line"><span class="comment">ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">ThreadName:pool-1-thread-2</span></span><br><span class="line"><span class="comment">ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">ThreadName:pool-1-thread-2</span></span><br><span class="line"><span class="comment">ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到由于任务加了休眠阻塞，执行需要花费一定时间，导致会有一定的任务被丢弃，从而执行自定义的拒绝策略；</p><h4 id="ThreadFactory自定义线程创建"><a href="#ThreadFactory自定义线程创建" class="headerlink" title="ThreadFactory自定义线程创建"></a><strong>ThreadFactory自定义线程创建</strong></h4><p> 线程池中线程就是通过ThreadPoolExecutor中的ThreadFactory，线程工厂创建的。那么通过自定义ThreadFactory，可以按需要对线程池中创建的线程进行一些特殊的设置，如命名、优先级等，下面代码我们通过ThreadFactory对线程池中创建的线程进行记录与命名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//自定义线程工厂</span></span><br><span class="line">        pool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">5</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+r.hashCode()+<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">                <span class="comment">//线程命名</span></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">th</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;threadPool&quot;</span>+r.hashCode());</span><br><span class="line">                <span class="keyword">return</span> th;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> <span class="title class_">ThreadTask</span>());</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//输出执行线程的名称</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ThreadName:&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程118352462创建</span></span><br><span class="line"><span class="comment">线程1550089733创建</span></span><br><span class="line"><span class="comment">线程865113938创建</span></span><br><span class="line"><span class="comment">ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">ThreadName:threadPool118352462</span></span><br><span class="line"><span class="comment">线程1442407170创建</span></span><br><span class="line"><span class="comment">ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">ThreadName:threadPool865113938</span></span><br><span class="line"><span class="comment">ThreadName:threadPool865113938</span></span><br><span class="line"><span class="comment">ThreadName:threadPool118352462</span></span><br><span class="line"><span class="comment">ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">ThreadName:threadPool1442407170</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="ThreadPoolExecutor扩展"><a href="#ThreadPoolExecutor扩展" class="headerlink" title="ThreadPoolExecutor扩展"></a><strong>ThreadPoolExecutor扩展</strong></h4><p>ThreadPoolExecutor扩展主要是围绕beforeExecute()、afterExecute()和terminated()三个接口实现的，</p><p><strong>1、beforeExecute：线程池中任务运行前执行</strong></p><p><strong>2、afterExecute：线程池中任务运行完毕后执行</strong></p><p><strong>3、terminated：线程池退出后执行</strong></p><p>通过这三个接口我们可以监控每个任务的开始和结束时间，或者其他一些功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//实现自定义接口</span></span><br><span class="line">        pool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">5</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+r.hashCode()+<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">                <span class="comment">//线程命名</span></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">th</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;threadPool&quot;</span>+r.hashCode());</span><br><span class="line">                <span class="keyword">return</span> th;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeExecute</span><span class="params">(Thread t,Runnable r)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;准备执行：&quot;</span>+ ((ThreadTask)r).getTaskName());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable r,Throwable t)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行完毕：&quot;</span>+((ThreadTask)r).getTaskName());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">terminated</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程池退出&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> <span class="title class_">ThreadTask</span>(<span class="string">&quot;Task&quot;</span>+i));</span><br><span class="line">        &#125;    </span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> String taskName;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTaskName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> taskName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTaskName</span><span class="params">(String taskName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskName = taskName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadTask</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setTaskName(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//输出执行线程的名称</span></span><br><span class="line">        System.out.println(<span class="string">&quot;TaskName&quot;</span>+<span class="built_in">this</span>.getTaskName()+<span class="string">&quot;---ThreadName:&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程118352462创建</span></span><br><span class="line"><span class="comment">线程1550089733创建</span></span><br><span class="line"><span class="comment">准备执行：Task0</span></span><br><span class="line"><span class="comment">准备执行：Task1</span></span><br><span class="line"><span class="comment">TaskNameTask0---ThreadName:threadPool118352462</span></span><br><span class="line"><span class="comment">线程865113938创建</span></span><br><span class="line"><span class="comment">执行完毕：Task0</span></span><br><span class="line"><span class="comment">TaskNameTask1---ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">执行完毕：Task1</span></span><br><span class="line"><span class="comment">准备执行：Task3</span></span><br><span class="line"><span class="comment">TaskNameTask3---ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">执行完毕：Task3</span></span><br><span class="line"><span class="comment">准备执行：Task2</span></span><br><span class="line"><span class="comment">准备执行：Task4</span></span><br><span class="line"><span class="comment">TaskNameTask4---ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">执行完毕：Task4</span></span><br><span class="line"><span class="comment">准备执行：Task5</span></span><br><span class="line"><span class="comment">TaskNameTask5---ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">执行完毕：Task5</span></span><br><span class="line"><span class="comment">准备执行：Task6</span></span><br><span class="line"><span class="comment">TaskNameTask6---ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">执行完毕：Task6</span></span><br><span class="line"><span class="comment">准备执行：Task8</span></span><br><span class="line"><span class="comment">TaskNameTask8---ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">执行完毕：Task8</span></span><br><span class="line"><span class="comment">准备执行：Task9</span></span><br><span class="line"><span class="comment">TaskNameTask9---ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">准备执行：Task7</span></span><br><span class="line"><span class="comment">执行完毕：Task9</span></span><br><span class="line"><span class="comment">TaskNameTask2---ThreadName:threadPool118352462</span></span><br><span class="line"><span class="comment">TaskNameTask7---ThreadName:threadPool865113938</span></span><br><span class="line"><span class="comment">执行完毕：Task7</span></span><br><span class="line"><span class="comment">执行完毕：Task2</span></span><br><span class="line"><span class="comment">线程池退出</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到通过对beforeExecute()、afterExecute()和terminated()的实现，我们对线程池中线程的运行状态进行了监控，在其执行前后输出了相关打印信息。另外使用shutdown方法可以比较安全的关闭线程池， 当线程池调用该方法后，线程池中不再接受后续添加的任务。但是，此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。</p><hr><h3 id="抽象类-abstract-class-和接口-interface-有什么异同？"><a href="#抽象类-abstract-class-和接口-interface-有什么异同？" class="headerlink" title="抽象类(abstract class)和接口(interface)有什么异同？"></a>抽象类(abstract class)和接口(interface)有什么异同？</h3><p>不同：<br>抽象类：<br>1.抽象类中可以定义构造器<br>2.可以有抽象方法和具体方法<br>3.接口中的成员全都是public 的<br>4.抽象类中可以定义成员变量<br>5.有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法<br>6.抽象类中可以包含静态方法<br>7.一个类只能继承一个抽象类<br>接口：<br>1.接口中不能定义构造器<br>2.方法全部都是抽象方法<br>3.抽象类中的成员可以是 private、默认、protected、public<br>4.接口中定义的成员变量实际上都是常量<br>5.接口中不能有静态方法<br>6.一个类可以实现多个接口<br>相同：<br>1.不能够实例化<br>2.可以将抽象类和接口类型作为引用类型<br>3.一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要<br>被声明为抽象类</p><hr><h3 id="sleep-方法和-wait-方法区别和共同点"><a href="#sleep-方法和-wait-方法区别和共同点" class="headerlink" title="sleep() 方法和 wait() 方法区别和共同点"></a>sleep() 方法和 wait() 方法区别和共同点</h3><ul><li>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong> 。</li><li>两者都可以暂停线程的执行。</li><li>Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</li><li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。</li></ul><hr><h3 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h3><p>这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p><p>new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p><hr><h3 id="Java-为什么能跨平台，实现一次编写，多处运行？"><a href="#Java-为什么能跨平台，实现一次编写，多处运行？" class="headerlink" title="Java 为什么能跨平台，实现一次编写，多处运行？"></a><strong>Java 为什么能跨平台，实现一次编写，多处运行？</strong></h3><p>Java 能够跨平台运行的核心在于 JVM 。不是 Java 能够跨平台，而是它的 jvm 能够跨平台。我们知道，不同的操作系统向上的 API 肯定是不同的，那么如果我们想要写一段代码调用系统的声音设备，就需要针对不同系统的 API 写出不同的代码来完成动作。</p><p>而 Java 引入了字节码的概念，jvm 只能认识字节码，并将它们解释到系统的 API 调用。针对不同的系统有不同的 jvm 实现，有 Linux 版本的 jvm 实现，也有 Windows 版本的 jvm 实现，但是同一段代码在编译后的字节码是一样的。引用上面的例子，在 Java API 层面，我们调用系统声音设备的代码是唯一的，和系统无关，编译生成的字节码也是唯一的。但是同一段字节码，在不同的 jvm 实现上会映射到不同系统的 API 调用，从而实现代码的不加修改即可跨平台运行。</p><hr><h3 id="jvm-的内容模型"><a href="#jvm-的内容模型" class="headerlink" title="jvm 的内容模型"></a>jvm 的内容模型</h3><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/300854081661499.jpg" alt="img"></p><p><strong>其实JVM内部不仅仅只有栈和堆</strong><br><strong>包括 程序计数器 、 Java 虚拟机栈 、本地方法栈、Java 堆、方法区等</strong></p><p><strong>1. 程序计数器</strong></p><p>线程私有，较小的内存空间，如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。</p><p><strong>2. Java 虚拟机栈（栈区）</strong><br>线程私有，每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p><strong>3.本地方法栈</strong><br>与虚拟机栈所发挥的作用是非常相似的，区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务，有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError。</p><p><strong>4.Java 堆（堆区）</strong><br><strong>线程共享</strong>，此内存区域的唯一目的就是创建并存放对象实例，也是GC区。分代收集算法：内存区大概分为新生代，老年代，永久代。<br>新生代从Eden区创建，复制到Survivor区（2个 from 和 to）。 GC分为minor GC 和 Full GC 。<br><strong>minor GC：</strong> Eden满了就触发minor GC，minorGC会将Eden区仍然存活的会复制到ToSurvivor，FromSurvivor一部分复制到老年代，一部分复制ToSurvivor，此时原Eden和From的数据清空,from和to互换，这样的过程直到To被填满，复制到老年代。<br><strong>FullGC：</strong>(1)年老代内存不足;(2)持久代内存不足;(3)统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间（4）调用System.gc()方法的时候，</p><p><strong>5. 方法区（类级/静态）</strong><br><strong>线程共享</strong>,存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它别名叫做Non-Heap（非堆）即“永久代”,不进行GC，只是针对常量池的回收和对类型的卸载 。<br><strong>运行时常量池：</strong>是方法区的一部分，Class常量池存放编译期生成的各种字面量和符号引用，运行时常量池相对于Class 文件常量池的另外一个重要特征是具备动态性，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String 类的intern() 方法（这个方法会首先检查字符串池中是有”ab”这个字符串，如果存在则返回这个字符串的引用，否则就将这个字符串添加到字符串常量池中，然会返回这个字符串的引用，这可以实现字符串的”= =”比较。new String 不进入常量池，直接赋值会进入常量池）。</p><hr><h3 id="new-一个对象的过程和-clone-一个对象的过程区别"><a href="#new-一个对象的过程和-clone-一个对象的过程区别" class="headerlink" title="new 一个对象的过程和 clone 一个对象的过程区别"></a>new 一个对象的过程和 clone 一个对象的过程区别</h3><p>new 操作符的本意是分配内存。程序执行到 new 操作符时，首先去看 new 操作符后面的类型，因为知道了类型， 才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对 象。 clone 在第一步是和 new 相似的，都是分配内存，调用 clone 方法时，分配的内存和原对象（即调用 clone 方法 的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域，填充完成之后，clone 方法返回，一个新的相同 的对象被创建，同样可以把这个新对象的引用发布到外部。</p><hr><h3 id="为什么-Java-中只有值传递"><a href="#为什么-Java-中只有值传递" class="headerlink" title="为什么 Java 中只有值传递"></a>为什么 Java 中只有值传递</h3><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是 Java)中方法参数传递方式。</p><p>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</p><p>Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按 值传递的。</p><p>下面再总结一下 Java 中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><hr><h3 id="与-equals"><a href="#与-equals" class="headerlink" title="==与 equals"></a>==与 equals</h3><p>== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)</p><p>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况 1：类没有覆盖 equals()方法。则通过 equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况 2：类覆盖了 equals()方法。一般，我们都覆盖 equals()方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。</li></ul><p>说明：</p><ul><li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li></ul><hr><h3 id="hashCode-与-equals-1"><a href="#hashCode-与-equals-1" class="headerlink" title="hashCode 与 equals"></a>hashCode 与 equals</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><p><strong>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong><br>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head fist java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p><strong>hashCode（）与 equals（）的相关规定</strong></p><ol><li>如果两个对象相等，则 hashcode 一定也是相同的</li><li>两个对象相等,对两个对象分别调用 equals 方法都返回 true</li><li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li><li>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><hr><h3 id="双亲委托模型"><a href="#双亲委托模型" class="headerlink" title="双亲委托模型"></a>双亲委托模型</h3><p><a href="https://blog.csdn.net/xuemengrui12/article/details/82707473">类加载过程</a></p><p>当Java程序需要使用某个类时，如果该类还未被加载到内存中，JVM会通过加载、连接(验证、准备和解析)、初始化三个步骤来对该类进行初始化。</p><p>类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备(为静态变量分配内存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤。最后JVM对类进行初始化，包括：</p><p>1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类;</p><p>2)如果类中存在初始化语句，就依次执行这些初始化语句。</p><p><a href="https://www.jianshu.com/p/46d3668b357a">Java类加载器(ClassLoader)</a></p><p>类加载器就是寻找类或接口字节码文件进行解析并构造JVM内部对象表示的组件，在java中类装载器把一个类装入JVM，经过以下步骤：</p><p>1、加载：查找和导入Class文件</p><p>2、链接：其中解析步骤是可以选择的 （a）检查：检查载入的class文件数据的正确性 （b）准备：给类的静态变量分配存储空间 （c）解析：将符号引用转成直接引用</p><p>3、初始化：对静态变量，静态代码块执行初始化工作</p><p>双亲委派模式要求<strong>除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器</strong>，请注意双亲委派模式中的父子关系并非通常所说的类继承关系，而是<strong>采用组合关系来复用父类加载器的相关代码</strong>，类加载器间的关系如下：</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/5982616-aad63782162c9ae5.webp" alt="img"></p><p>双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就<strong>成功返回</strong>，倘若父类加载器无法完成此加载任务，<strong>子加载器才会尝试自己去加载</strong>，这就是双亲委派模式</p><p>双亲委派模式优势</p><ul><li>采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种<strong>带有优先级的层次关系</strong>，通过这种层级关可以<strong>避免类的重复加载</strong>，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</li><li>其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以<strong>防止核心API库被随意篡改</strong>。</li></ul><hr><h3 id="为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？"><a href="#为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？" class="headerlink" title="为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？"></a><strong>为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</strong></h3><p>因为 hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。</p><p>我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。</p><hr><h3 id="闭包和回调区别"><a href="#闭包和回调区别" class="headerlink" title="闭包和回调区别"></a>闭包和回调区别</h3><ul><li><strong>闭包</strong>是指可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。 —《百度百科》</li><li>是引用了自由变量的函数。这个函数通常被定义在另一个外部函数中，并且引用了外部函数中的变量。 – &lt;&gt;</li><li>是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。– &lt;</li></ul><p><strong>闭包</strong>能够将一个<strong>方法</strong>作为一个<strong>变量</strong>去存储，这个方法有能力去访问所在类的<strong>自由变量</strong>。</p><p>闭包的价值在于可以作为函数对象或者匿名函数，持有上下文数据，作为第一级对象进行传递和保存。闭包广泛用于回调函数、函数式编程中。</p><p>在Java中，闭包是 通过“接口与内部类实现的”</p><p>通过这种仿闭包的非静态内部类，可以很方便地实现回调功能，回调就是某个方法一旦获得了内部类对象的引用后，就可以在合适时候反过来调用外部类的方法。所谓回调，就是允许客户类通过内部类引用来调用其外部类的方法，这是一种非常灵活的功能。</p><hr><h3 id="回调和观察者的区别"><a href="#回调和观察者的区别" class="headerlink" title="回调和观察者的区别"></a>回调和观察者的区别</h3><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。观察者模式完美的将观察者和被观察的对象分离开，一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。<br>回调函数其实也算是一种观察者模式的实现方式，回调函数实现的观察者和被观察者往往是一对一的依赖关系。<br>所以最明显的区别是观察者模式是一种设计思路，而回调函数式一种具体的实现方式；另一明显区别是一对多还是多对多的依赖关系方面。</p><hr><h3 id="MVP和MVC模式差别"><a href="#MVP和MVC模式差别" class="headerlink" title="MVP和MVC模式差别"></a>MVP和MVC模式差别</h3><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20180322204213875" alt="img"></p><p>MVC</p><p>View：布局的xml文件，或者纯Java写的布局，可以把页面显示的逻辑直接放在View中。</p><p>Model：数据处理层，可以直接和View进行交互。</p><p>Controller：把特定的功能逻辑抽离出来，作为控制层，保证View层和Model层的功能单一性，便于维护。</p><p>MVP</p><p>View：Activity作为显示层。</p><p>Presenter：逻辑层，从Activity中抽离出功能逻辑，简化Activity的代码。</p><p>Model：数据处理层，主要负责网络请求，本地数据加载等操作，进一步简化Activity的代码</p><p>1、Presenter与Controller都扮演了逻辑层的角色，但是Presenter层的功能相对更复杂，因为他负责和View的双向交互，Controller只是单向的中介。因为Presenter是从View层抽离出来的，通常和View是一对一的关系，而Controller是面向业务的，往往是单例模式或者提供静态方法。</p><p>2、MVP中View和Model是不能进行通信的，虽然加重了P层的负担，但是有利于维护View层和Model层，如果条件允许，我们还可以对Presenter进一步拆分，来弥补Presenter负担过重的问题。</p><ol><li><p>MVC中View和Model层可以直接交互，虽然方便了两者之间的交互，但是耦合性相对较高。</p></li><li><p><strong>Activity职责不同</strong>，Activity在MVP中是View层，在MVC中是Controller层，这是MVC和MVP很主要的一个区别，可以说Android从MVC转向MVP开发也主要是优化Activity的代码，避免Activity的代码臃肿庞大。</p></li><li><strong>View层不同</strong>，MVC的View层指的是XML布局文件或者是用Java自定义的View，MVP的View层是Activity或者Fragment。使用传统的MVC，其中的View，对应的是各种Layout布局文件，但是这些布局文件中并不像Web端那样强大，能做的事情非常有限。MVP的View层Activity在实际项目中，随着逻辑的复杂度越来越大，Activity臃肿的缺点仍然体现出来了，因为Activity中还是充满了大量与View层无关的代码，比如各种事件的处理派发，就如MVC中的那样View层和Controller代码耦合在一起无法自拔。</li><li><strong>控制层不同</strong>，MVC的控制层是Activity，或者是Fragment，Controller对应的是Activity，而Activity中却又具有操作UI的功能，我们在实际的项目中也会有很多UI操作在这一层，也做了很多View中应该做的事情，当然Controller层Activity中也包含Controller应该做的事情，比如各种事件的派发回调，而且在一层中我们会根据事件再去调用Model层操作数据，所以这种MVC的方式在实际项目中，Activity所在的Controller是非常重的，各层次之间的耦合情况也比较严重，不方便单元测试。MVP的控制层是Presenter，里面没有很多的实际东西，主要是做Model和View层的交互。</li><li><strong>关系链不同</strong>，MVP中Model层与View是没有关系的，彼此不会通讯和操作，Model与View的通讯都是Presenter层来传达的。但是在MVC中，Model层和View是曾在交互的。比如我们自定义的View控件里面肯定是要使用Model的数据的，View也要根据不同的Model数据做出不同的展现！这点尤其是体现在自定义的View中，自定义View需要设置数据，用户操作了自定义控件需要改变数据，View要操作Model怎么办？有人说把Controller传到自定义的View啊，现实是不可能没一个自定义View都去持有Controller的引用，其实在MVP中就不会这么尴尬，接口就可以完成。</li><li><strong>适用范围不同</strong>，在Android中，MVP和MVC都用自己的适用情况，使用MVP可以更好的解耦三大模块，模块之间比较清晰，也很方便使用MVP来组件化架构整体项目。但是MVC也是有用武之地的，在组件化的Module或者中间件我们可以使用MVC来做，Module或者中间件不会存在很复杂的View层，使用MVC可以更加方便我们实现功能。</li><li><strong>交互方式不同</strong>，MVP中通讯交互基本都是通过接口的，MVC中的通讯交互很多时候都是实打实的调用对象的方法，简单粗暴！</li><li><strong>实现方法不同</strong> ，MVC和MVP的Model几乎一样的，都是处理数据，只要不在Activity或者Fragment中请求数据，其他的所有控制都放在Activity或者Fragment中，这样写就基本是MVC的模式，这样写不麻烦，但是很容易把Activity写出上万行代码。用MVP的时候我们需要写很多View和Presenter接口来实现模块之间的通讯，会增加很多类。</li></ol><p><strong>（1）相同点：</strong><br><strong>优点：</strong><br>1.降低耦合度<br>2.模块职责划分明显<br>3.利于测试驱动开发<br>4.代码复用<br>5.隐藏数据<br>6.代码灵活性<br><strong>缺点：</strong><br>额外的代码复杂度及学习成本。</p><p><strong>（2）不同点：</strong><br><strong>MVP模式：</strong><br>1.View不直接与Model交互，而是通过与Presenter交互来与Model间接交互<br>2.Presenter与View的交互是通过接口来进行的，更有利于添加单元测试<br>3.通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑，业务相似的时候也可以多同个View共享一个Presenter。<br><strong>MVC模式：</strong><br>1.View可以与Model直接交互<br>2.Controller是基于行为的，并且可以被多个View共享<br>3.Controller可以负责决定显示哪个View</p><hr><h3 id="4种引用"><a href="#4种引用" class="headerlink" title="4种引用"></a>4种引用</h3><p><a href="https://www.jianshu.com/p/825cca41d962">https://www.jianshu.com/p/825cca41d962</a></p><hr><h3 id="线程同步方法"><a href="#线程同步方法" class="headerlink" title="线程同步方法"></a>线程同步方法</h3><p>volatile、synchronized、Concurrent包中的BlockingQueue、Semaphore。</p><p>然后展开讲了一下volatile的原理、底层实现内存屏障、应用、synchronized底层的WaitSet、onDeck、Owner、BlockingQueue。</p><p>然后讲了一下BlockingQueue的两种常用形式利用信号量帮助编程人员更轻松使用BlockingQueue。</p><hr><h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><ul><li><strong>序列化：将对象写入到IO流中</strong></li><li><strong>反序列化：从IO流中恢复对象</strong></li><li><strong>意义：序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。</strong></li><li><strong>使用场景：所有可在网络上传输的对象都必须是可序列化的，</strong>比如RMI（remote method invoke,即远程方法调用），传入的参数或返回的对象都是可序列化的，否则会出错；<strong>所有需要保存到磁盘的java对象都必须是可序列化的。通常建议：程序创建的每个JavaBean类都实现Serializeable接口。</strong></li></ul><p>如果需要将某个对象保存到磁盘上或者通过网络传输，那么这个类应该实现<strong>Serializable</strong>接口或者<strong>Externalizable</strong>接口之一。</p><h4 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h4><p>Serializable接口是一个标记接口，不用实现任何方法。一旦实现了此接口，该类的对象就是可序列化的。</p><ol><li><strong>序列化步骤：</strong></li></ol><ul><li><strong>步骤一：创建一个ObjectOutputStream输出流；</strong></li><li><strong>步骤二：调用ObjectOutputStream对象的writeObject输出可序列化对象。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写到二进制文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> out :输出流对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream out)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        out.writeObject(docIdToDocPathMapping);</span><br><span class="line">        out.writeObject(termToPostingListMapping);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * 从索引文件里加载已经构建好的索引.内部调用FileSerializable接口方法readObject即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file ：索引文件</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(File file)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ObjectInputStream输入流；</span></span><br><span class="line">        <span class="comment">//调用ObjectInputStream对象的readObject()得到序列化的对象。</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">        readObject(inputStream);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>反序列化步骤：</strong></li></ol><ul><li><strong>步骤一：创建一个ObjectInputStream输入流；</strong></li><li><strong>步骤二：调用ObjectInputStream对象的readObject()得到序列化的对象。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从二进制文件读</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> in ：输入流对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        docIdToDocPathMapping = (Map&lt;Integer, String&gt;) in.readObject();</span><br><span class="line">        termToPostingListMapping = (Map&lt;AbstractTerm, AbstractPostingList&gt;) in.readObject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * 从索引文件里加载已经构建好的索引.内部调用FileSerializable接口方法readObject即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file ：索引文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(File file)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ObjectInputStream输入流；</span></span><br><span class="line">        <span class="comment">//调用ObjectInputStream对象的readObject()得到序列化的对象。</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">        readObject(inputStream);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java序列化同一对象，并不会将此对象序列化多次得到多个对象。</strong></p><ul><li><strong>Java序列化算法</strong></li></ul><ol><li><strong>所有保存到磁盘的对象都有一个序列化编码号</strong></li><li><strong>当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。</strong></li><li><strong>如果此对象已经序列化过，则直接输出编号即可。</strong></li></ol><p>由于java序利化算法不会重复序列化同一个对象，只会记录已序列化对象的编号。<strong>如果序列化一个可变对象（对象内的内容可更改）后，更改了对象内容，再次序列化，并不会再次将此对象转换为字节序列，而只是保存序列化编号。</strong></p><p>有些时候，我们有这样的需求，某些属性不需要序列化。<strong>使用transient关键字选择不需要序列化的字段。</strong></p><p><strong>使用transient修饰的属性，java序列化时，会忽略掉此字段，所以反序列化出的对象，被transient修饰的属性是默认值。对于引用类型，值是null；基本类型，值是0；boolean类型，值是false。</strong></p><p>使用transient虽然简单，但将此属性完全隔离在了序列化之外。java提供了<strong>可选的自定义序列化。</strong>可以进行控制序列化的方式，或者对序列化数据进行编码加密等。通过重写writeObject与readObject方法，可以自己选择哪些属性需要序列化， 哪些属性不需要。如果writeObject使用某种规则序列化，则相应的readObject需要相反的规则反序列化，以便能正确反序列化出对象。</p><h4 id="Externalizable：强制自定义序列化"><a href="#Externalizable：强制自定义序列化" class="headerlink" title="Externalizable：强制自定义序列化"></a>Externalizable：强制自定义序列化</h4><p>通过实现Externalizable接口，必须实现writeExternal、readExternal方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Externalizable</span> <span class="keyword">extends</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExPerson</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//注意，必须加上pulic 无参构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExPerson</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExPerson</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//将name反转后写入二进制流</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">reverse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(name).reverse();</span><br><span class="line">        System.out.println(reverse.toString());</span><br><span class="line">        out.writeObject(reverse);</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//将读取的字符串反转后赋值给name实例变量</span></span><br><span class="line">        <span class="built_in">this</span>.name = ((StringBuffer) in.readObject()).reverse().toString();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="built_in">this</span>.age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ExPerson.txt&quot;</span>));</span><br><span class="line">             <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;ExPerson.txt&quot;</span>))) &#123;</span><br><span class="line">            oos.writeObject(<span class="keyword">new</span> <span class="title class_">ExPerson</span>(<span class="string">&quot;brady&quot;</span>, <span class="number">23</span>));</span><br><span class="line">            <span class="type">ExPerson</span> <span class="variable">ep</span> <span class="operator">=</span> (ExPerson) ois.readObject();</span><br><span class="line">            System.out.println(ep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//ydarb</span></span><br><span class="line"><span class="comment">//brady</span></span><br><span class="line"><span class="comment">//ExPerson&#123;name=&#x27;brady&#x27;, age=23&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意：Externalizable接口不同于Serializable接口，实现此接口必须实现接口中的两个方法实现自定义序列化，这是强制性的；特别之处是必须提供pulic的无参构造器，因为在反序列化的时候需要反射创建对象。</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">实现Serializable接口</th><th style="text-align:left">实现Externalizable接口</th></tr></thead><tbody><tr><td style="text-align:left">系统自动存储必要的信息</td><td style="text-align:left">程序员决定存储哪些信息</td></tr><tr><td style="text-align:left">Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持</td><td style="text-align:left">必须实现接口内的两个方法</td></tr><tr><td style="text-align:left">性能略差</td><td style="text-align:left">性能略好</td></tr></tbody></table></div><p><strong>虽然Externalizable接口带来了一定的性能提升，但变成复杂度也提高了，所以一般通过实现Serializable接口进行序列化。</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>所有需要网络传输的对象都需要实现序列化接口，通过建议所有的javaBean都实现Serializable接口。</li><li>对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、transient实例变量都不会被序列化。</li><li>如果想让某个变量不被序列化，使用transient修饰。</li><li>序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错。</li><li>反序列化时必须有序列化对象的class文件。</li><li>当通过文件、网络来读取序列化后的对象时，必须按照实际写入的顺序读取。</li><li>单例类序列化，需要重写readResolve()方法；否则会破坏单例原则。</li><li>同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化。</li><li>建议所有可序列化的类加上serialVersionUID 版本号，方便项目升级。</li></ol><hr><h3 id="JAVA中各种锁机制"><a href="#JAVA中各种锁机制" class="headerlink" title="JAVA中各种锁机制"></a>JAVA中各种锁机制</h3><p><a href="https://www.cnblogs.com/jyroy/p/11365935.html">https://www.cnblogs.com/jyroy/p/11365935.html</a></p><hr><h3 id="JAVA异常机制"><a href="#JAVA异常机制" class="headerlink" title="JAVA异常机制"></a>JAVA异常机制</h3><p><a href="https://www.cnblogs.com/yc211/p/9910949.html">https://www.cnblogs.com/yc211/p/9910949.html</a></p><hr><h3 id="JAVA类加载"><a href="#JAVA类加载" class="headerlink" title="JAVA类加载"></a>JAVA类加载</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载是类加载过程的一个阶段，这两个概念一定不要混淆。在加载阶段, 虚拟机需要完成以下三件事情:</p><p>1)通过一个类的全限定名来获取定义此类的二进制字节流。</p><p>2 )将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p><p>3 ) 将类的class文件读入内存，并为之创建一个java.lang.Class对象，也就是说当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象, 作为方法区这个类的各种数据的访问入口。</p><p>通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源：</p><ul><li>从本地文件系统加载class文件；</li><li>从一个ZIP、 JAR、 CAB或者其他某种归档文件中提取Java class文件，JDBC编程时使用到的数据库驱动就是放在JAR文件中，JVM可以直接从JAR包中加载class文件；</li><li>通过网络加载class文件，这种场景最典型的应用就是 Applet；</li><li>把一个java源文件动态编译、并执行加载</li><li>运行时计算生成, 这种场景使用得最多的就是动态代理接术, 在 java.lang.reflect.Proxy中 , 就是用了 ProxyGenerator.generateProxyClass来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。</li></ul><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>当类被加载后，系统为之生成一个对应的Class对象，接着会进入连接阶段，连接阶段将会负责把类的二进制文件合并到JRE中。类连接分为如下三个阶段：</p><ul><li>验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致；</li><li>准备：准备阶段则负责为类的静态属性分配内存，并设置默认初始值；</li><li>解析：将类的二进制数据中的符号引用替换成直接引用（符号引用是用一组符号描述所引用的目标；直接引用是指向目标的指针）</li></ul><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证是连接阶段的第一步, 这一阶段的目的是为了确保 Class文件的字节流中包含的信息符合当前虚拟机的要求, 井且不会危害虚拟机自身的安全。</p><p>Java语言本身是相对安全的语言，但前面已经说过, Class文件并不一定要求用 Java源码编译而来, 可以使用任何途径, 包括用十六进制编译器直接编写来产生 Class 文件。在字节码的语言层面上, 上述 Java代码无法做到的事情都是可以实现的, 至少语义上是可以表达出来的。虚拟机如果不检査输入的字节流,对其完全信任的话, 很可能会因为载入了有害的字节流而导致系统崩溃 , 所以验证是虚拟机对自身保护的一项重要工作。从整体上看，验证阶段会完成下面四个阶段的检验过程: 文件格式验证、 元数据验证、 字节码验证、符号引用验证。</p><p><strong>1、文件格式验证</strong></p><p>第一阶段要验证字节流是否符合 Class文件格式的规范, 井且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：</p><ul><li>是否以魔数 0xCAFEBABE开头</li><li>主、次版本号是否在当前虚拟机处理范围之内 。</li><li>常量池的常量中是否有不被支持的常量类型(检査常量tag 标志)。</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合装型的常量 。</li><li>CONSTANT_Utf8_info型的常量中是否有不符合 UTF8编码的数据</li><li>Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息</li></ul><p>实际上第一阶段的验证点还远不止这些, 上面这些只是从 HotSpot虚拟机源码中摘抄的一小部分而已。只有通过了这个阶段的验证之后, 字节流才会进入内存的方法区中进行存储, 所以后面的三个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</p><p><strong>2、元数据验证</strong></p><p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求,这个阶段可能包括的验证点如下:</p><p>这个类是否有父类(除了 java.lang.0bject之外,所有的类都应当有父类)</p><p>这个类的父类是否继承了不允许被继承的类(被finaI修饰的类)</p><p>如果这个类不是抽象类, 是否实現了其父类或接口之中要求实现的所有方法</p><p>类中的字段、 方法是否与父类产生了矛盾(例如覆盖了父类的final字段, 或者出現不符合规则的方法重载, 例如方法参数都一致, 但返回值类型却不同等)</p><p>第二阶段的验证点同样远不止这些，这一阶段的主要目的是对类的元数据信息进行语义检验, 保证不存在不符合 Java语言规范的元数据信息。</p><p><strong>3、字节码验证</strong></p><p>第三阶段是整个验证过程中最复杂的一个阶段, 主要目的是通过数据流和控制流的分析，确定语义是合法的。符号逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：</p><ul><li>保证任意时刻操作数栈的数据装型与指令代码序列都能配合工作, 例如不会出现类似这样的情况:在操作栈中放置了一个 int类型的数据, 使用时却按long类型来加载入本地变量表中。</li><li>保证跳转指令不会跳转到方法体以外的字节码指令上</li><li>保证方法体中的类型转换是有效的, 例如可以把一个子类对象赋值给父类数据装型，这是安全的,但是把父类对象意赋值给子类数据类型,甚至把对象赋值给与它毫无继承关系、 完全不相干的一个数据类型, 则是危险和不合法的。</li></ul><p>即使一个方法体通过了字节码验证, 也不能说明其一定就是安全的。</p><p><strong>4、符号引用验证</strong></p><p>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候 , 这个转化动作将在连接的第三个阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外(常量池中的各种符号引用) 的信息进行匹配性的校验, 通常需要校验以下内容:</p><ul><li>符号引用中通过字将串描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段 。</li><li>符号引用中的类、字段和方法的访问性(private、 protected、 public、 default)是否可被当前类访问</li></ul><p>符号引用验证的目的是确保解析动作能正常执行, 如果无法通过符号引用验证, 将会抛出一个 java.lang.IncompatibleClassChangError异常的子类, 如 java.lang.IllegalAccessError、 java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</p><p>对于虚拟机的装加载机制来说 ,验证阶段是一个非常重要的、 但不一定是必要的阶段（因为对程序没有影响）。如果所运行的全部代码(包括自己编写的以及第三方包中的代码)都已经被反复使用和验证过 , 那么在实施阶段就可以考虑使用一Xverify;none 参数来关闭大部分的验证措施, 以缩短虚拟机类加载的时间。</p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配 。这个阶段中有两个容易产生混淆的概念需要强调一下, 首先，这时候进行内存分配的仅包括类变量(被static修饰的变量)，而不包括实例变量,实例变量将会在对象实例化时随着对象一起分配在 Java 堆中 。 其次，这里所说的初始值“通常情况”下是数据类型的零值。</p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程， 解新动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行,分别对应于常量池的CONSTANT_Class_info、 CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_IntrfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info7种常量类型,解析阶段中所说的直接引用与符号引用关系如下：</p><ul><li>符号引用(Symlxiuc References):符号引用以一组符号来描述所引用的日标,符号可以是任何形式的字面量, 只要使用时能无歧义地定位到目标即可, 特号引用与配組机实现的内存1布.局11i-美 , 引用的日标并不一定已组加裁到内存中</li><li>直接引用(Direct References):直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的 , 同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同. 如果有了直接引用, 那引用的目标必定已经在内存中存在</li></ul><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段是类加载过程的最后一步 , 前面的几个阶段, 除了在加载阶段用户应用程序可以通过自定 义类加载器參与之外, 其余动作完全由虚拟机主导和控制。到了初始化阶段, 才真正开始执行类中定义的 Java程序代码。从代码角度，初始化阶段是执行类构造器<clinit>()方法的过程。我们先看一下<clinit>()方法执行过程中可能会影响程序运行行为的特点和细节：</clinit></clinit></p><ul><li><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静志语句块(static{}块)中的语句合并产生的, 编译器收集的顺序是由语句在源文件中出现的顺序所决定的, 静态语句块中只能访问到定义在静态语句块之前的变量, 定义在它之后的変量 , 在前面的静态语句块可以赋值 , 但是不能访问</clinit></li><li><clinit>()方法与类的构造函数 (或者说实例构造器<init>()方法)不同，它不需要显式地调用父类构造器, 虚期机会保证在子类的<clinit>()方法执行之前, 父类的<clinit>()方法已经执行完毕, 因此在虚期机中第一个被执行的<clinit>()方法的类肯定是 java,lang.Object</clinit></clinit></clinit></init></clinit></li><li>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作</clinit></li><li><clinit>()方法对于类或接口来说并不是必须的, 如果一个类中没有静态语句块,也没有对变量的赋值操作, 那么编译器可以不为这个类生成<clinit>()方法</clinit></clinit></li><li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作, 因此接口与类一样都会生成<clinit>()方法。 但接口与类不同的是, 执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量被使用时, 父接口才会被初始化。 另外, 接口的实现类在初始化时也一样不会执行接口的<clinit>()方法</clinit></clinit></clinit></clinit></li><li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()法,其他线程部需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作, 那就可能造成多个进程阻塞, 在实际应用中这种阻塞往往是隐蔽的。</clinit></clinit></clinit></clinit></li></ul><p>类的初始化阶段主要是对类变量进行初始化，在Java类中对类变量指定初始值有两种方式：</p><ul><li>声明类变量时指定初始值</li><li>使用静态初始化块为类变量指定初始值</li></ul><p>JVM初始化一个类一般包括如下几个步骤：</p><ol><li>假如这个类还没有被加载和连接，程序先加载并连接该类；</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类；</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ol><p>当执行第二步时，系统对直接父类的初始化也遵循此1、2、3步骤，如果该直接父类又有直接父类，系统再次重复这三步，所以JVM最先初始化的总是java.lang.Object类。</p><hr><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><a href="https://blog.csdn.net/javazejian/article/details/72828483">https://blog.csdn.net/javazejian/article/details/72828483</a></p><p>synchronized锁释放有两种机制，一种就是执行完释放；另外一种就是发送异常，虚拟机释放。图中第二个monitorexit就是发生异常时执行的流程，这就是我开头说的“会有2个流程存在“。</p><hr><h3 id="synchronized-和-lock的区别"><a href="#synchronized-和-lock的区别" class="headerlink" title="synchronized 和 lock的区别"></a>synchronized 和 lock的区别</h3><div class="table-container"><table><thead><tr><th>类别</th><th>synchronized</th><th>Lock</th></tr></thead><tbody><tr><td>存在层次</td><td>Java的关键字，在jvm层面上</td><td>是一个类</td></tr><tr><td>锁的释放</td><td>1、以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁</td><td>在finally中必须释放锁，不然容易造成线程死锁</td></tr><tr><td>锁的获取</td><td>假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待</td><td>分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待</td></tr><tr><td>锁状态</td><td>无法判断</td><td>可以判断</td></tr><tr><td>锁类型</td><td>可重入 不可中断 非公平</td><td>可重入 可判断 可公平（两者皆可）</td></tr><tr><td>性能</td><td>少量同步</td><td>大量同步</td></tr></tbody></table></div><p>Lock支持的功能:</p><ul><li>公平锁：Synchronized是非公平锁，Lock支持公平锁，默认非公平锁</li><li>可中断锁：ReentrantLock提供了lockInterruptibly（）的功能，可以中断争夺锁的操作，抢锁的时候会check是否被中断，中断直接抛出异常，退出抢锁。而Synchronized只有抢锁的过程，不可干预，直到抢到锁以后，才可以编码控制锁的释放。</li><li>快速反馈锁：ReentrantLock提供了trylock（） 和 trylock（tryTimes）的功能，不等待或者限定时间等待获取锁，更灵活。可以避免死锁的发生。</li><li>读写锁：ReentrantReadWriteLock类实现了读写锁的功能，类似于Mysql，锁自身维护一个计数器，读锁可以并发的获取，写锁只能独占。而synchronized全是独占锁</li><li>Condition：ReentrantLock提供了比Sync更精准的线程调度工具，Condition，一个lock可以有多个Condition，比如在生产消费的业务下，一个锁通过控制生产Condition和消费Condition精准控制。</li></ul><hr><h3 id="copyonwritelist的原理"><a href="#copyonwritelist的原理" class="headerlink" title="copyonwritelist的原理"></a>copyonwritelist的原理</h3><p><strong>CopyOnWriteArrayList</strong>是Java并发包中提供的一个并发容器，它是个<strong>线程安全且读操作无锁的ArrayList</strong>，写操作则通过创建底层数组的新副本来实现，是一种<strong>读写分离</strong>的并发策略，我们也可以称这种容器为”写时复制器”，Java并发包中类似的容器还有CopyOnWriteSet。</p><p>　我们都知道，集合框架中的ArrayList是非线程安全的，Vector虽是线程安全的，但由于简单粗暴的锁同步机制，性能较差。而CopyOnWriteArrayList则提供了另一种不同的并发处理策略（当然是针对特定的并发场景）。</p><p>　　很多时候，我们的系统应对的都是<strong>读多写少</strong>的并发场景。CopyOnWriteArrayList容器允许并发读，读操作是无锁的，性能较高。至于写操作，比如向容器中添加一个元素，<strong>则首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。</strong></p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1024555-20170521150621182-1289355418.png" alt="img"></p><p>　　<strong>优缺点分析</strong></p><p>　　了解了CopyOnWriteArrayList的实现原理，分析它的优缺点及使用场景就很容易了。</p><p>　　<strong>优点：</strong></p><p>　　读操作性能很高，因为无需任何同步措施，比较适用于<strong>读多写少</strong>的并发场景。Java的list在遍历时，若中途有别的线程对list容器进行修改，则会抛出<strong>ConcurrentModificationException</strong>异常。而CopyOnWriteArrayList由于其”读写分离”的思想，遍历和修改操作分别作用在不同的list容器，所以在使用迭代器进行遍历时候，也就不会抛出ConcurrentModificationException异常了</p><p>　　<strong>缺点：</strong></p><p>　　缺点也很明显，<strong>一是内存占用问题</strong>，毕竟每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁GC；<strong>二是无法保证实时性</strong>，Vector对于读写操作均加锁同步，可以保证读和写的强一致性。而CopyOnWriteArrayList由于其实现策略的原因，写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="comment">//ReentrantLock加锁，保证线程安全</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="comment">//拷贝原容器，长度为原容器长度加一</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//在新副本上执行添加操作</span></span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            <span class="comment">//将原容器引用指向新副本</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>添加的逻辑很简单，先将原容器copy一份，然后在新副本上执行写操作，之后再切换引用。当然此过程是要加锁的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(elements, index);</span><br><span class="line">            <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> len - index - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//如果要删除的是列表末端数据，拷贝前len-1个数据到新副本上，再切换引用</span></span><br><span class="line">                setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则，将除要删除元素之外的其他元素拷贝到新副本中，并切换引用</span></span><br><span class="line">                Object[] newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[len - <span class="number">1</span>];</span><br><span class="line">                System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">                System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                                 numMoved);</span><br><span class="line">                setArray(newElements);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>删除操作同理，将除要删除元素之外的其他元素拷贝到新副本中，然后切换引用，将原容器引用指向新副本。同属写操作，需要加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="G1-GC"><a href="#G1-GC" class="headerlink" title="G1 GC"></a>G1 GC</h3><p><a href="http://ghoulich.xninja.org/2018/01/27/understanding-g1-garbage-collector-in-java/">http://ghoulich.xninja.org/2018/01/27/understanding-g1-garbage-collector-in-java/</a></p><hr><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><h3 id="Activty生命周期"><a href="#Activty生命周期" class="headerlink" title="Activty生命周期"></a>Activty生命周期</h3><p>活动在系统中被活动堆栈管理。当一个新的活动开始时，将会强加于堆栈的顶端并成为运行活动状态。而之前的活动总是被放置在这个活动下面的堆栈中，并且不会被移动到前台直到新的活动退出为止。<br>   活动从开始到结束经历各种状态。从一个状态到另一个状态的转变，从无到有再到无，这样一个过程中所经历的各个状态就叫做生命周期。Activity拥有自己的生命周期，而它的意义就在于，当我们对当前的界面进行展示的过程中，本身也会经历各个阶段去准备和处理当前的activity，然后展示给用户，而开发者为了界面上一些炫酷的效果与功能，做一些特殊处理时，就离不开这些生命周期。</p><p>关于activity的四个状态：<br><strong>running-poused-stopped-killed</strong></p><ol><li>running-&gt;当前显示在屏幕的activity(位于任务栈的顶部)，用户可见状态。</li><li>poused-&gt;依旧在用户可见状态，但是界面焦点已经失去，此Activity无法与用户进行交互。</li><li>stopped-&gt;用户看不到当前界面,也无法与用户进行交互 完全被覆盖.</li><li>killed-&gt;当前界面被销毁，等待这系统被回收</li></ol><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20140810102151522.png" alt="4个的状态"></p><p>由上图我们得知：<br>Starting ——–&gt;Running 所执行的生命周期顺序 onCreate()-&gt;onstart()-&gt;onResume()</p><blockquote><p>当前称为活动状态（Running），此activity所处于任务栈的top中，可以与用户进行交互。</p></blockquote><p>Running ——&gt;Paused 所执行Activity生命周期中的onPause（）</p><blockquote><p>当前称为暂停状态（Paused），该Activity已失去了焦点但仍然是可见的状态(包括部分可见)。</p></blockquote><p>Paused ——&gt;Running所执行的生命周期为:OnResume()</p><blockquote><p>当前重新回到活动状态(Running),此情况用户操作home键，然后重新回到当前activity界面发生。</p></blockquote><p>Paused ——&gt;Stoped所执行的生命周期为:onStop()</p><blockquote><p>该Activity被另一个Activity完全覆盖的状态,该Activity变得不可见，所以系统经常会由于内存不足而将该Activity强行结束。</p></blockquote><p>Stoped——&gt;killed所执行的生命周期为:onDestroy()</p><blockquote><p>该Activity被系统销毁。当一个Activity处于暂停状态或停止状态时就随处可能进入死亡状态，因为系统可能因内存不足而强行结束该Activity。</p></blockquote><p>注：还有一种情况由于系统内存不足可能在Paused状态中直接被系统杀死达到killed状态。</p><p>activity的<strong>生命周期</strong></p><p><strong>oncreate()-&gt;onstart()-&gt;onResume()-&gt;onRestart()-&gt;onPouse()-&gt;onStop()-&gt;onDestory()</strong></p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/12239817-57bb34bbf201853d.webp" alt="img"></p><p>onCreate():<br>当我们点击activity的时候，系统会调用activity的oncreate()方法，在这个方法中我们会初始化当前布局setContentLayout（）方法。<br>onStart():<br>onCreate()方法完成后，此时activity进入onStart()方法,当前activity是用户可见状态，但没有焦点，与用户不能交互，一般可在当前方法做一些动画的初始化操作。<br>onResume():<br>onStart()方法完成之后，此时activity进入onResume()方法中，当前activity状态属于运行状态 (Running)，可与用户进行交互。<br>onPause()<br>当另外一个activity覆盖当前的acitivty时，此时当前activity会进入到onPause()方法中，当前activity是可见的，但不能与用户交互状态。<br>onStop()<br>onPouse()方法完成之后，此时activity进入onStop()方法，此时activity对用户是不可见的，在系统内存紧张的情况下，有可能会被系统进行回收。所以一般在当前方法可做资源回收。<br>onDestory()<br>onStop()方法完成之后，此时activity进入到onDestory()方法中，结束当前activity。<br>onRestart()<br>onRestart()方法在用户按下home()之后，再次进入到当前activity的时候调用。调用顺序onPouse()-&gt;onStop()-&gt;onRestart()-&gt;onStart()-&gt;onResume().</p><p><strong>onSaveInstanceState(Bundle outState):</strong></p><blockquote><p>onSaveInstanceState函数在Activity生命周期中执行。<br>outState 参数作用 :<br>数据保存 : Activity 声明周期结束的时候, 需要保存 Activity 状态的时候, 会将要保存的数据使用键值对的形式 保存在 Bundle 对象中;</p><hr><p>调用时机 :<br>Activity 被销毁的时候调用, 也可能没有销毁就调用了;<br>按下Home键 : Activity 进入了后台, 此时会调用该方法;<br>按下电源键 : 屏幕关闭, Activity 进入后台;<br>启动其它 Activity : Activity 被压入了任务栈的栈底;<br>横竖屏切换 : 会销毁当前 Activity 并重新创建；</p><hr><p>onSaveInstanceState方法调用注意事项 :<br>用户主动销毁不会调用 : 当用户点击回退键 或者 调用了 finish() 方法, 不会调用该方法;<br>调用时机不固定 : 该方法一定是在 onStop() 方法之前调用, 但是不确定是在 onPause() 方法之前 还是 之后调用;<br>布局中组件状态存储 : 每个组件都 实现了 onSaveInstance() 方法, 在调用函数的时候, 会自动保存组件的状态, 注意, 只有有 id 的组件才会保存;<br>关于默认的 super.onSaveInstanceState(outState) : 该默认的方法是实现 组件状态保存的;</p></blockquote><p><strong>onRestoreInstanceState(Bundle outState):</strong></p><blockquote><p>方法回调时机 : 在 Activity 被系统销毁之后 恢复 Activity 时被调用, 只有销毁了之后重建的时候才调用, 如果内存充足, 系统没有销毁这个 Activity, 就不需要调用;<br>– Bundle 对象传递 : 该方法保存的 Bundle 对象在 Activity 恢复的时候也会通过参数传递到 onCreate() 方法中;</p></blockquote><p><strong>activity的进程优先级。</strong></p><blockquote><p>前台进程&gt;可见进程&gt;service进程&gt;后台进程&gt;空进程</p></blockquote><hr><h3 id="fragmengt生命周期"><a href="#fragmengt生命周期" class="headerlink" title="fragmengt生命周期"></a>fragmengt生命周期</h3><p>Fragment是可以让你的app纵享丝滑的设计，如果你的app想在现在基础上性能大幅度提高，并且<strong>占用内存降低</strong>，同样的界面Activity占用内存比Fragment要多，响应速度Fragment比Activty在中低端手机上快了很多，甚至能达到好几倍！如果你的app当前或以后有<strong>移植平板</strong>等平台时，可以让你节省大量时间和精力。</p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fapp%2FFragment.html">Fragment</a>表示 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fapp%2FActivity.html">Activity</a> 中的行为或用户界面部分。您可以将多个片段(片段就是指 Fragment )组合在一个 Activity 中来构建多窗格 UI，以及在多个 Activity 中重复使用某个片段。您可以将片段视为 Activity 的模块化组成部分，它具有自己的生命周期，能接收自己的输入事件，并且您可以在 Activity 运行时添加或移除片段（有点像您可以在不同 Activity 中重复使用的“子 Activity”）。</p><p>片段必须始终嵌入在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。 例如，当 Activity 暂停时，其中的所有片段也会暂停；当 Activity 被销毁时，所有片段也会被销毁。</p><p>当您将片段作为 Activity 布局的一部分添加时，它存在于 Activity 视图层次结构的某个 ViewGroup 内部，并且片段会定义其自己的视图布局。您可以通过在 Activity 的布局文件中声明片段，将其作为 `` 元素插入您的 Activity 布局中，即静态添加。或者通过将其添加到某个现有 ViewGroup，利用应用代码进行动态插入。不过，片段并非必须成为 Activity 布局的一部分；您还可以将没有自己 UI 的片段用作 Activity 的不可见工作线程。</p><p>下图是文档中给出的一个Fragment分别对应手机与平板间不同情况的处理图：</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/7508328-dea3e88fded20350.webp" alt="img"></p><p>Fragment 生命周期</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1688279-0424d62f50035b43.webp" alt="img"></p><p>可以看到 Fragment 的生命周期和 Activity 很相似，只是多了一下几个方法：<br><strong>onAttach()</strong> 在Fragment 和 Activity 建立关联是调用（Activity 传递到此方法内）<br><strong>onCreateView()</strong> 当Fragment 创建视图时调用<br><strong>onActivityCreated()</strong> 在相关联的 Activity 的 onCreate() 方法已返回时调用。<br><strong>onDestroyView()</strong> 当Fragment中的视图被移除时调用<br><strong>onDetach()</strong> 当Fragment 和 Activity 取消关联时调用。</p><p>可以看下几种操作情况下Fragment 的生命周期变化</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1688279-e34d09c9351c7084.webp" alt="img"></p><p>管理 Fragment 生命周期和 Activity 生命周期很相似，同时 Activity 的生命周期对 Fragment 的生命周期也有一定的影响，如下图所示</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1688279-e513845a80659860.webp" alt="img"></p><p>用下图（<a href="https://www.jianshu.com/p/184f0c8857d6">来源</a>）来表示 Activity 和 Fragment 的生命周期变化的先后过程是:</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1688279-020ad51ed5443cce.webp" alt="img"></p><p>Activity 和 Fragment 生命周期执行过程</p><p>Fragment 生命周期与 Activity 生命周期的一个关键区别就在于，Fragment 的生命周期方法是由托管Activity而不是操作系统调用的。Activity 中生命周期方法都是 protected，而 Fragment 都是 public，也能印证了这一点，因为 Activity 需要调用 Fragment 那些方法并管理它。</p><p><strong>加载 Fragment</strong></p><ul><li>静态加载</li><li>动态加载</li></ul><ol><li><p>静态加载 在 Activity 的布局文件内声明片段，其中 fragment 中的 android:name 属性要指定 fragment 对应的具体包名路径，当系统创建此 Activity 布局时，会实例化在布局中指定的每个 fragment，并为每个 fragment 调用 onCreateView()方法，以检索每个 fragment 的布局。系统会直接插入 fragment 返回的 View 来替代 fragment 元素。</p><p>并且在 Activity 活动里可以直接使用 findViewById() 方法获取 fragment 对应布局里的控件。同样在 fragment 里可以直接使用 getActivity()方法获得绑定的主 Activity 实例，并调用 Activity 里的方法或其他 fragment 实例。</p></li><li><p>动态加载 通过编程方式将 fragment 添加到某个activity布局里现有的 <strong>ViewGroup</strong> （例如 LinearLayout 或 FrameLayout）里。<br>要想在 Avtivity 中执行 Fragment 事务 (如添加、删除或替换 Fragment)，必须使用 FragmentTransaction 中的 API。可以使用下面这样从 Activity 中获取一个 FragmentTransaction。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FragmentManager</span>  <span class="variable">fragmentManager</span> <span class="operator">=</span> getFragmentManager();</span><br><span class="line"><span class="type">FragmentTransaction</span> <span class="variable">fragmentTransaction</span> <span class="operator">=</span> fragmentManager.beginTransaction();</span><br></pre></td></tr></table></figure><p>然后可以使用 add()方法添加一个 fragment ，指定要添加的 fragment 和插入到哪个视图。例如</p></li></ol>   <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExampleFragment  exampleFragment = <span class="keyword">new</span> ExampleFragment();</span><br><span class="line">fragmentTransaction.<span class="keyword">add</span>(R.id.frame_layout,exampleFragment);</span><br><span class="line">fragmentTransaction.commit();</span><br></pre></td></tr></table></figure><p>   add 方法中第一个参数是一个activity 对应布局文件中的 ViewGroup，即应该放置 fragment 的位置，由资源 ID 指定，第二个参数是加入的 fragment ，一旦通过 fragmentTransaction 做了更改，最后必须使用 commit 方法以使更改生效。</p><p>   在 Activity 中使用 Fragment 可以很方便的进行添加 add、替换 replace、移除 remove 等操作，这样提交给 Activity 的每组更改都可以称为<strong>事务</strong>。像上边动态添加 fragment 那样，使用 FragmentTransaction 里的 API 就可以执行一项事务。同时也可以将此事务保存到 Activity 管理的返回栈中，从而用户可以回退到 fragment 改变之前的状态（类似于 activity 回退到上一个页面）。</p><p><strong>Fragment 与 Activity 通信</strong></p><p>上边说过，在 fragment 中可以调用 getActivity() 获取 activity 的实例并调用 activity 里的方法和布局，同样在 activity 里也可以通过 findFragmentById()（对于在 activity 提供 fragment 布局的） 或 findFragmentByTag() （对于在 activity 提供或者不提供 fragment 布局的）方法获取 fragment 的实例，例如在 activity 中从 FragmentManager 获取对 Fragment 的引用来调用 fragment 中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fragment fragment = getFragmentManager.findFragmentById(R.id.fragment_container);</span><br></pre></td></tr></table></figure><p>使用 FragmentManager 还可以执行的操作包括：</p><ul><li>通过 findFragmentById 或 findFragmentByTag 获取 activity 中存在的 fragment 的实例</li><li>通过 popBackStack （<em>模拟用户点击返回按钮操作</em>）将 fragment 从返回栈中弹出</li><li>通过 addOnBackStackChangedListener() 注册一个监听返回栈改变的监听器</li><li>像上边生成 fragmentTransaction 的方法，可以使用 fragmentManager 生成一个 fragmentTransaction 来执行某些事务，比如添加、替换、移除、addToBackStack（）等。</li></ul><hr><h3 id="Activity中View的生命周期方法回调"><a href="#Activity中View的生命周期方法回调" class="headerlink" title="Activity中View的生命周期方法回调"></a>Activity中View的生命周期方法回调</h3><p>Activity有生命周期，同样的，View从添加到界面到从界面中移除也有一个生命周期，在<a href="https://link.jianshu.com/?t=https://developer.android.google.cn/reference/android/view/View.html">官方文档</a>中介绍了自定义View需要重写的一些方法，可以认为这些方法就是View的生命周期方法。</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/2083810-82ee9f1ceb9c6b95.webp" alt="img"></p><p>从Activity启动到退出，这个View 的过程是这样的。</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/2083810-e496916704fa4dfa.webp" alt="img"></p><p><strong>在Activity的onCreate()方法中调用setContentView方法，Activity显示到界面时的View的回调</strong></p><ol><li>构造方法，这是肯定的，View也是一个Java类。</li><li>onFinishInflate，这个一般是通过LayoutInflater进行填充的时候会走这个方法。如果我们是直接在代码中new出来的View进行添加，是不会走这个方法的。</li><li>onAttachedToWindow，这个方法表明现在这个View已经跟它对应的Window已经绑定了</li><li>onWindowVisibilitChanged(int visibility) ，这个值等于 View.VISIBLE，代表View所在的Window已经可见了。</li><li>onMeasure，开始测量。我们发现，这个measure过程是在Window可见的情况下才会去调用了，仔细想想这个也不难理解，如果你都不准备显示，我何必去花精力测量你呢。这个测量过程可能会多次调用。</li><li>onSizeChanged ，测量之后会回调这个方法。onSizeChanged，顾名思义就是当尺寸发生变化的时候会调用。一般是第一次测量之后调用，后面再测量，如果尺寸没变化就不会再去调用了。</li><li>onLayout，测量时候就进行布局，这个时候如果是View的话一般不用去管，因为具体放在哪个位置是由父控件去控制的，如果是ViewGroup，就需要去确定子View的位置。</li><li>onDraw，确定完位置和宽高，就可以进行绘制了。</li><li>onWindowFocusChanged(boolean hasWindowFocus)，为true这个说明View所绑定的Window开始获取焦点</li></ol><p><strong>当按back键退出当前Activity后，走下面几个方法</strong></p><ol><li>onWindowVisibilitChanged(int visibility) ，这个值等于 View.GONE，此时Window已经不可见了</li><li>onWindowFocusChanged(boolean hasWindowFocus)，这个也变为false，说明已经没有焦点了。有一点比较奇怪，为什么是先不可见才是没有焦点的呢？</li><li>onDetachedFromWindow， 当前View与它对应的Window解除绑定。</li></ol><p><strong>结合与Activity的启动过程可以看到</strong></p><ol><li><strong>Activity</strong> 调用onCreate方法，这个时候我们setContentView加载了带View的布局</li><li><strong>Activity</strong> 调用onWindowAttributesChanged 方法，而且这个方法连续调用多次</li><li><code>View</code> 调用构造方法</li><li><code>View</code> 调用onFinishInflate方法，说明这个时候View已经填充完毕，但是这个时候还没开始触发绘制过程</li><li><strong>Activity</strong> 调用onstart方法</li><li><strong>Activity</strong> 再次调用 onWindowAttributesChanged 方法，说明这个方法在onResume之前会多次调用</li><li><strong>Activity</strong> 调用onResume，我们一般认为当Activity调用onResume的时候，整个Activit已经可以和用户进行交互了，但事实上可能并不是这样，后面解释原因。</li><li><strong>Activity</strong> 调用onAttachedToWindow，说明跟Window进行了绑定。发现了吗，Activity在onResume之后才跟Window进行了绑定。</li><li><code>View</code> 调用onAttachedToWindow，View开始跟Window进行绑定，这个过程肯定是在Activity绑定之后才进行的。</li><li><code>View</code> 调用 onWindowVisibilityChanged(int visibility)，参数变为 <code>View.VISIABLE</code>，说明Window已经可见了，这个时候我们发现一个问题就是其实onResume的时候似乎并不代表Activity中的View已经可见了。</li><li><code>View</code> 调用onMeasure，开始测量</li><li><code>View</code> 调用onSizeChanged，表示测量完成，尺寸发生了变化</li><li><code>View</code> 调用onLayout，开始摆放位置</li><li><code>View</code> 调用 onDraw，开始绘制</li><li><strong>Activity</strong> 调用onWindowFocusChanged(boolean hasFocus)，此时为true，代表窗体已经获取了焦点</li><li><code>View</code> 调用 onWindowFocusChanged(boolean hasWindowFocus)，此时为true，代表当前的控件获取了Window焦点，当调用这个方法后说明当前Activity中的View才是真正的可见了。</li></ol><p><strong>当退出当前的Activity的时候</strong></p><ol><li><strong>Activity</strong> 调用 onPause</li><li><code>View</code> 调用 onWindowVisibilityChanged(int visibility)，参数变为 <code>View.GONE</code>，View中对应的Window隐藏</li><li><strong>Activity</strong> 调用onWindowFocusChanged(boolean hasFocus)，此时为false，说明Actvity所在的Window已经失去焦点</li><li><strong>Activity</strong> 调用 onStop，此时Activity已经切换到后台</li><li><strong>Activity</strong> 调用 onDestory，此时Activity开始准备销毁，实际上调用onDestory并不代表Activity已经销毁了。</li><li><code>View</code> 调用 onDetachedFromWindow，此时View 与Window解除绑定</li><li><strong>Activity</strong> 调用 onDetathedFromWindow ，此时Activity 与Window 解除绑定</li></ol><p>当View进行与Window解除绑定之后，View即将被销毁。我们可以在 View 的 <code>onDetachedFromWindow</code> 方法中可以做一些资源的释放，防止内存泄漏。</p><hr><h3 id="android进程间通信"><a href="#android进程间通信" class="headerlink" title="android进程间通信"></a>android进程间通信</h3><div class="table-container"><table><thead><tr><th>名称</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>Bundle</td><td>简单易用</td><td>只能传输Bundle支持的数据类型</td><td>四大组件间的进程间通信</td></tr><tr><td>文件共享</td><td>简单易用</td><td>不适用高并发场景，并且无法做到进程间即时通信</td><td>适用于无关发的情况下，交换简单的数据，对实时性要求不高的场景。</td></tr><tr><td>AIDL</td><td>功能强大，支持一对多实时并发通信</td><td>使用稍复杂，需要处理好线程间的关系</td><td>一对多通信且有RPC需求</td></tr><tr><td>Messenger</td><td>功能一般，支持一对多串行通信，支持实时通信</td><td>不能很好地处理高并发的情形，不支持RPC，由于数据通过Message传输，因此只能传输Bundle支持的数据类型</td><td>低并发的一对多实时通信，无RPC需求，或者无需要返回结果的RPC需求</td></tr><tr><td>ContentProvider</td><td>支持一对多的实时并发通信，在数据源共享方面功能强大，可通过Call方法扩展其它操作</td><td>可以理解为受约束的AIDL，主要提供对数据源的CRUD操作</td><td>一对多的进程间数据共享</td></tr><tr><td>BroadcastReceiver</td><td>操作简单，对持一对多实时通信</td><td>只支持数据单向传递，效率低且安全性不高</td><td>一对多的低频率单向通信</td></tr><tr><td>Socket</td><td>功能强大，可通过网络传输字节流，支持一对多实时并发通信</td><td>实现细节步骤稍繁琐，不支持直接的RPC</td><td>网络间的数据交换</td></tr></tbody></table></div><hr><h3 id="Android中PX、DP、SP的区别"><a href="#Android中PX、DP、SP的区别" class="headerlink" title="Android中PX、DP、SP的区别"></a>Android中PX、DP、SP的区别</h3><p>px</p><p>Pixels 我们看到屏幕上的图像由一个个像素组成，像素里包含色彩信息。<br> 如常说的手机分辨率：1080 x 1920 指的是手机宽度可展示1080像素，高度可展示1920像素。</p><p>ppi</p><p>Pixels Per Inch 每英寸长度所具有的像素个数，单位面积内像素越多，图像显示越清晰。<br> ppi一般用在显示器、手机、平板等描述屏幕精细度。</p><p>dpi</p><p>Dots Per Inch 每英寸长度所具有的点数。<br> dpi一般用来描述打印（书本、杂志、电报）的精细度</p><p>dp/dip</p><p>density-independent pixels (device-independent pixels 我查了一下，官网更多时候使用前者，有的时候也显示后者），dip是缩写，也可以更简单些称作dp。该单位的目的是屏蔽不同设备密度差异，后面细说。</p><p>sp</p><p>Scalable pixels 用于设置字体，在用户更改字体大小时候会适配。</p><p>Android系统使用dpi来描述屏幕的密度，使用dp来描述密度与像素的关系。<br> A设备dpi=240<br> B设备dpi=420<br> Android系统最终识别的单位是px，怎么将dpi和px关联起来呢？，答案是dp。<br> Android规定当dpi=160时，1dp=1px，当dpi=240时，1dp=1.5px，依此类推，并且给各个范围的dpi取了简易的名字加以直观的识别，如120&lt;dpi&lt;=160，称作为mdpi，120&lt;dpi&lt;=240 称作hdpi，最终形成如下规则：</p><blockquote><p>ldpi（value &lt;= 120 dpi)<br> mdpi（120 dpi &lt; value &lt;= 160 dpi）<br> hdpi（160 dpi &lt; value &lt;= 240 dpi）<br> xhdpi（240 dpi &lt; value &lt;= 320 dpi）<br> xxhdpi（320 dpi &lt; value &lt;= 480 dpi）<br> xxxhdpi（480 dpi &lt; value &lt;= 640 dpi）</p></blockquote><p>现在知道了dp能够在不同dpi设备上对应不同px，相当于中间转换层，我们只需要将view长宽单位设置为合适的dp，就无需关注设备之间密度差异，系统会帮我们完成dp-px转换。</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/944365-2b5dc928ab334440.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">scale</span> <span class="operator">=</span> mContext.getResources().getDisplayMetrics().density;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">scaledDensity</span> <span class="operator">=</span> mContext.mContext.getResources().getDisplayMetrics().scaledDensity;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp转成px</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dipValue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dip2px</span><span class="params">(<span class="type">float</span> dipValue)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>) (dipValue * scale + <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * px转成dp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pxValue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">px2dip</span><span class="params">(<span class="type">float</span> pxValue)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>) (pxValue / scale + <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sp转成px</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> spValue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">sp2px</span><span class="params">(<span class="type">float</span> spValue, <span class="type">int</span> type)</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> CHINESE:</span><br><span class="line"><span class="keyword">return</span> spValue * scaledDensity;</span><br><span class="line"><span class="keyword">case</span> NUMBER_OR_CHARACTER:</span><br><span class="line"><span class="keyword">return</span> spValue * scaledDensity * <span class="number">10.0f</span> / <span class="number">18.0f</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> spValue * scaledDensity;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="点击应用图标以后的流程"><a href="#点击应用图标以后的流程" class="headerlink" title="点击应用图标以后的流程"></a>点击应用图标以后的流程</h3><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20180429164552531.jfif" alt="这里写图片描述"></p><p><strong>Instrumentation</strong>: 监控应用与系统相关的交互行为。<br><strong>ActivityManagerService（AMS）</strong>：组件管理调度中心，什么都不干，但是什么都管。<br><strong>ActivityStarter</strong>：Activity启动的控制器，处理Intent与Flag对Activity启动的影响，具体说来有：1 寻找符合启动条件的Activity，如果有多个，让用户选择；2 校验启动参数的合法性；3 返回int参数，代表Activity是否启动成功。<br><strong>ActivityStackSupervisior</strong>：这个类的作用你从它的名字就可以看出来，它用来管理任务栈。<br><strong>ActivityStack</strong>：用来管理任务栈里的Activity。<br><strong>ActivityThread</strong>：在Android中它就代表了Android的主线程，注意是代表而不是说它就是一个Thread类，它是创建完新进程之后（肯定是在<br>一个线程中啊），main函数被加载，然后执行一个loop的循环使当前线程进入消息循环，并且作为主线程。<br><strong>ApplicationThread</strong>：最终干活的人，是ActivityThread的内部类，也是一个Binder对象。在此处它是作为IApplicationThread对象的server端等待client端的请求然后进行处理，最大的client就是AMS.Activity、Service、BroadcastReceiver的启动、切换、调度等各种操作都在这个类里完成。</p><p>注意：这里单独提一下ActivityStackSupervisior，这是高版本才有的类，它用来管理多个ActivityStack，早期的版本只有一个ActivityStack对应着手机屏幕，后来高版本支持多屏以后，就有了多个ActivityStack，于是就引入了ActivityStackSupervisior用来管理多个ActivityStack。</p><p>整个流程主要涉及四个进程：</p><ol><li>调用者进程，如果是在桌面启动应用就是Launcher应用进程。</li><li>ActivityManagerService等所在的System Server进程，该进程主要运行着系统服务组件。</li><li>Zygote进程，该进程主要用来fork新进程。</li><li>新启动的应用进程，该进程就是用来承载应用运行的进程了，它也是应用的主线程（新创建的进程就是主线程），处理组件生命周期、界面绘制等相关事情。</li></ol><p>整个流程如下</p><ol><li>点击桌面应用图标，Launcher进程将启动Activity（MainActivity）的请求以Binder的方式发送给了AMS。</li><li>AMS接收到启动请求后，交付ActivityStarter处理Intent和Flag等信息，然后再交给ActivityStackSupervisior/ActivityStack处理Activity进栈相关流程。同时以Socket方式请求Zygote进程fork新进程。</li><li>Zygote接收到新进程创建请求后fork出新进程。</li><li>在新进程里创建ActivityThread对象，新创建的进程就是应用的主线程，在主线程里开启Looper消息循环，开始处理创建Activity。ActivityThread利用ClassLoader去加载Activity、创建Activity实例，并回调Activity的onCreate()方法。这样便完成了Activity的启动。</li></ol><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20190610223539273.jpg" alt="img"></p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20190610223705714.png" alt="img"></p><p>Launcher：Launcher通知AMS要启动activity。<br>startActivitySafely-&gt;startActivity-&gt;Instrumentation.execStartActivity()(AMP.startActivity)-&gt;AMS.startActivity<br>AMS:PMS的resoveIntent验证要启动activity是否匹配。<br>如果匹配，通过ApplicationThread发消息给Launcher所在的主线程，暂停当前Activity(Launcher);<br>暂停完，在该activity还不可见时，通知AMS，根据要启动的Activity配置ActivityStack。然后判断要启动的Activity进程是否存在?<br>存在：发送消息LAUNCH_ACTIVITY给需要启动的Activity主线程，执行handleLaunchActivity<br>不存在：通过socket向zygote请求创建进程。进程启动后，ActivityThread.attach<br>判断Application是否存在，若不存在，通过LoadApk.makeApplication创建一个。在主线程中通过thread.attach方法来关联ApplicationThread。<br>在通过ActivityStackSupervisor来获取当前需要显示的ActivityStack。<br>继续通过ApplicationThread来发送消息给主线程的Handler来启动Activity（handleLaunchActivity）。<br>handleLauchActivity：调用了performLauchActivity，里边Instrumentation生成了新的activity对象，继续调用activity生命周期。</p><hr><h3 id="AMS"><a href="#AMS" class="headerlink" title="AMS"></a>AMS</h3><p><a href="https://www.cnblogs.com/ganchuanpu/p/8384471.html">https://www.cnblogs.com/ganchuanpu/p/8384471.html</a></p><hr><h3 id="activity与service通信"><a href="#activity与service通信" class="headerlink" title="activity与service通信"></a>activity与service通信</h3><p><strong>为何要进行Secvice和Activity的通信</strong>？</p><p>常用的服务一般是普通服务，即是不可交互的后台服务，该服务在活动中启动，但是启动之后，活动基本就和服务没有什么关系了。确实如此，我们在普通服务里是用startService()方法来启动Service这个服务的，之后服务会一直处于运行状态，但具体运行的是什么逻辑，活动控制不了，活动并不知道服务到底做了什么，完成的如何。</p><p>但是在很多场景下，活动是需要和服务进行交互的，比如<strong>音乐播放界面</strong>，用户可以根据播放进度条掌握播放的<strong>进度</strong>，用户也可以自己根据歌词的进度选择调整整首歌的进度。</p><p>要实现上面所示的功能，就要选择服务的另外一种类型——<strong>*可交互的后台服务</strong>。以最常见的后台下载，前台显示的操作为例。实现这个功能的思路是创建一个专门的<strong>Binder类</strong>来对下载进行管理。</p><p><a href="https://blog.csdn.net/weixin_41101173/article/details/79718718">https://blog.csdn.net/weixin_41101173/article/details/79718718</a></p><hr><h3 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h3><p><a href="https://www.jianshu.com/p/3c94ae673e2a">https://www.jianshu.com/p/3c94ae673e2a</a></p><p>WebView是android中一个非常重要的控件，它的作用是用来展示一个web页面。它使用的内核是<code>webkit</code>引擎，4.4版本之后，直接使用Chrome作为内置网页浏览器。</p><p>作用：</p><ol><li>显示和渲染网页；</li><li>可与页面JavaScript交互，实现混合开发。</li></ol><p>加载页面一般有以下几种形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：加载一个网页</span></span><br><span class="line">webView.loadUrl(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：加载应用资源文件内的网页</span></span><br><span class="line">webView.loadUrl(<span class="string">&quot;file:///android_asset/test.html&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三：加载一段代码</span></span><br><span class="line">webView.loadData(String data,String mimeType, String encoding);</span><br></pre></td></tr></table></figure><p>其中，方式一和方式二比较好理解，方式三可能有些朋友不明白，我在这里解释一下。</p><p><code>WebView.loadData()</code>和<code>WebView.loadDataWithBaseURL()</code>是表示加载某一段代码，其中，<code>WebView.loadDataWithBaseURL()</code>兼容性更好，适用场景更多，因此，我着重介绍一下这个方法。</p><p><code>WebView.loadDataWithBaseURL(String baseUrl, String data, String mimeType, String encoding, String historyUrl))</code>的五个参数：<code>baseUrl</code>表示基础的网页，<code>data</code>表示要加载的内容，<code>mimeType</code>表示加载网页的类型，<code>encoding</code>表示编码格式，<code>historyUrl</code>表示可用历史记录，可以为<code>null</code>值。<br>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;示例：这里有个img标签，地址是相对路径&lt;img src=&#x27;/uploads/allimg/130923/1FP02V7-0.png&#x27; /&gt;&quot;</span>;</span><br><span class="line">webView.loadDataWithBaseURL(<span class="string">&quot;http://www.jcodecraeer.com&quot;</span>, body, <span class="string">&quot;text/html&quot;</span>, <span class="string">&quot;utf-8&quot;</span>,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/12359382-84191a7b9aee861e.webp" alt="img"></p><p>WebView的生命周期一般跟随Activity：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onResume();</span><br><span class="line">    <span class="comment">//恢复webview的状态（不靠谱）</span></span><br><span class="line">    webView.resumeTimers();</span><br><span class="line">    <span class="comment">//激活webView的状态，能正常加载网页</span></span><br><span class="line">    webView.onResume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onPause();</span><br><span class="line">    <span class="comment">//当页面被失去焦点被切换到后台不可见状态，需要执行onPause</span></span><br><span class="line">    <span class="comment">//通过onPause动作通知内核暂停所有的动作，比如DOM的解析、plugin的执行、JavaScript执行。</span></span><br><span class="line">    webView.onPause();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当应用程序(存在webview)被切换到后台时，这个方法不仅仅针对当前的webview而是全局的全应用程序的webview</span></span><br><span class="line">    <span class="comment">//它会暂停所有webview的layout，parsing，javascripttimer。降低CPU功耗。（不靠谱）</span></span><br><span class="line">    webView.pauseTimers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在关闭了Activity时，如果Webview的音乐或视频，还在播放。就必须销毁Webview</span></span><br><span class="line"><span class="comment">//但是注意：webview调用destory时,webview仍绑定在Activity上</span></span><br><span class="line"><span class="comment">//这是由于自定义webview构建时传入了该Activity的context对象</span></span><br><span class="line"><span class="comment">//因此需要先从父容器中移除webview,然后再销毁webview:</span></span><br><span class="line"><span class="type">ViewGroup</span> <span class="variable">parent</span> <span class="operator">=</span> findViewById(R.id.container);</span><br><span class="line">parent.removeView(webView);</span><br><span class="line">webView.destroy();</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/3e0136c9e748">https://www.jianshu.com/p/3e0136c9e748</a></p><hr><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p><a href="https://blog.csdn.net/weixin_41101173/article/details/79684183">https://blog.csdn.net/weixin_41101173/article/details/79684183</a></p><hr><h3 id="Activity启动模式"><a href="#Activity启动模式" class="headerlink" title="Activity启动模式"></a>Activity启动模式</h3><p>在实际的项目中我们应该根据特定的需求为每个活动指定恰当的启动模式。<br>启动模式一共有4种。<strong>standard、singleTop、singleTask</strong>和<strong>singleInstance</strong><br>通过在AndroidManifest.xml中给<activity>标签指定<code>android:launchMode</code>属性来选择启动模式。</activity></p><h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p>默认模式，可以不用写配置。在这个模式下，都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。</p><p>在该模式下，每当启动一个新活动，它就会在返回栈中入栈，并处于栈顶的位置，并且，不管此活动是否已经存在于返回栈中，每次启动都会创建该活动的一个新实例。</p><p>例如：</p><p>若我有一个Activity名为A1, 上面有一个按钮可跳转到A1。那么如果我点击按钮，便会新启一个Activity A1叠在刚才的A1之上，再点击，又会再新启一个在它之上……</p><p>点back键会依照栈顺序依次退出。</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1674835-cbec07958657c4a8.webp" alt="img"></p><h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p>可以有多个实例，但是不允许多个相同Activity叠加。即，如果Activity在栈顶的时候，启动相同的Activity，不会创建新的实例，而会调用其onNewIntent方法。不过当FirstActivity并未处于栈顶时，若再启动FirstActivity还是会创建新的实例。</p><p>例如：</p><p>若我有两个Activity名为B1,B2,两个Activity内容功能完全相同，都有两个按钮可以跳到B1或者B2，唯一不同的是B1为standard，B2为singleTop。</p><p>若我意图打开的顺序为B1-&gt;B2-&gt;B2，则实际打开的顺序为B1-&gt;B2（后一次意图打开B2，实际只调用了前一个的onNewIntent方法）</p><p>若我意图打开的顺序为B1-&gt;B2-&gt;B1-&gt;B2，则实际打开的顺序与意图的一致，为B1-&gt;B2-&gt;B1-&gt;B2。</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1674835-7e2417de609e171e.webp" alt="img"></p><h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p>使用 single Top模式可以很好地解决重复创建栈顶活动的问题，但是如你在上一节所看到的，如果该活动并没有处于栈顶的位置，还是可能会创建多个活动实例的。那么有没有什么办法可以让某个活动在整个应用程序的上下文中只存在一个实例呢?这就要借助 singleTask模式来实现了。当活动的启动模式指定为 singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。</p><p>只有一个实例。在同一个应用程序中启动他的时候，若Activity不存在，则会在当前task创建一个新的实例，若存在，则会把task中在其之上的其它Activity destory掉并调用它的onNewIntent方法。</p><p>如果是在别的应用程序中启动它，则会新建一个task，并在该task中启动这个Activity，singleTask允许别的Activity与其在一个task中共存，也就是说，如果我在这个singleTask的实例中再打开新的Activity，这个新的Activity还是会在singleTask的实例的task中。</p><p>例如：</p><p>若我的应用程序中有三个Activity,C1,C2,C3，三个Activity可互相启动，其中C2为singleTask模式，那么，无论我在这个程序中如何点击启动，如：C1-&gt;C2-&gt;C3-&gt;C2-&gt;C3-&gt;C1-C2，C1,C3可能存在多个实例，但是C2只会存在一个，并且这三个Activity都在同一个task里面。</p><p>但是C1-&gt;C2-&gt;C3-&gt;C2-&gt;C3-&gt;C1-C2，这样的操作过程实际应该是如下这样的，因为singleTask会把task中在其之上的其它Activity destory掉。</p><p>操作：C1-&gt;C2     C1-&gt;C2-&gt;C3     C1-&gt;C2-&gt;C3-&gt;C2      C1-&gt;C2-&gt;C3-&gt;C2-&gt;C3-&gt;C1      C1-&gt;C2-&gt;C3-&gt;C2-&gt;C3-&gt;C1-C2</p><p>实际：C1-&gt;C2     C1-&gt;C2-&gt;C3     C1-&gt;C2               C1-&gt;C2-&gt;C3-&gt;C1               C1-&gt;C2</p><p>若是别的应用程序打开C2，则会新启一个task。</p><p>如别的应用Other中有一个activity，taskId为200，从它打开C2，则C2的taskIdI不会为200，例如C2的taskId为201，那么再从C2打开C1、C3，则C2、C3的taskId仍为201。</p><p>注意：如果此时你点击home，然后再打开Other，发现这时显示的肯定会是Other应用中的内容，而不会是我们应用中的C1 C2 C3中的其中一个。</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1674835-dcef4bb069cc5d6f.webp" alt="img"></p><h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p>singleInstance模式算是4种启动模式中最复杂的一个了，不同于以上三种模式，该模式下活动会启用一个新的返回栈来管理这个活动(其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈)。</p><p>那么这样做有什么意义呢?想象以下场景，假设我们的程序中有一个活动是允许其他程序调用的，如果我们想实现其他程序和我们的程序可以共享这个活动的实例，应该如何实现呢?使用前面3种启动模式肯定是做不到的，因为每个应用程序都会有自己的返回栈，同一个活动在不同的返回栈中入栈时必然是创建了新的实例。而使用singlelnstance模式就可以解决这个问题，在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了共享活动实例的问题。</p><p>只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。</p><p>例如：</p><p>程序有三个ActivityD1,D2,D3，三个Activity可互相启动，其中D2为singleInstance模式。那么程序从D1开始运行，假设D1的taskId为200，那么从D1启动D2时，D2会新启动一个task，即D2与D1不在一个task中运行。假设D2的taskId为201，再从D2启动D3时，D3的taskId为200，也就是说它被压到了D1启动的任务栈中。</p><p>若是在别的应用程序打开D2，假设Other的taskId为200，打开D2，D2会新建一个task运行，假设它的taskId为201，那么如果这时再从D2启动D1或者D3，则又会再创建一个task，因此，若操作步骤为other-&gt;D2-&gt;D1，这过程就涉及到了3个task了。</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1674835-7cf53bd4d1af899b.webp" alt="img"></p><hr><h3 id="触摸事件分发机制"><a href="#触摸事件分发机制" class="headerlink" title="触摸事件分发机制"></a>触摸事件分发机制</h3><p><a href="https://blog.csdn.net/qq_43652500/article/details/100186032">见【Android】 触摸事件分发机制</a></p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20180307161324186" alt="img"></p><p>手机屏幕我们可以称为一个窗口，也就是一个window，在android中这个window类是一个抽象类，它规定了一些管理窗口的方法，但是具体实现是由它的唯一实现类phonewindow去实现的，这样phonewindow就是整个屏幕的实际“掌控者”，而phonewindow又是通过它的内部类decorview去对view进行管理；</p><p>接下来进行流程分析，我们就以点击事件为例：</p><p>当用户点击了屏幕，首先Activity先监测到，事件先传递到Activity中，Activity通过它的dispatchTouchEvent将事件分发到phoneWindow，phonewindow则会调用superdispatchTouchEvent方法的内部是调用了其内部类DecorView的superdispatchTouchEvent，而DecorView又会调用dispatchTouchEvent去进行事件分发，如果不拦截事件，那么就会继续下传到rootview，rootview中的操作是一样的，同样在dispatchTouchEvent内部调用onInterceptTouchEvent去判断是否拦截，不拦截就会把事件分发给下一个viewgroupA，拦截就直接在onTouchEvent返回true，viewgroupA中做的判断也是一样，最后事件传递到view1，view1是最底层控件，不会有onInterceptTouchEvent，它的选择就只有处理后不处理，处理就在onTouchEvent进行处理并返回true，不处理的话事件也不会被销毁，view1这时会把事件回传，经过上述流程后回传给activity，如果Activity还不处理，那么这个事件才会被销毁；</p><ol><li>Android中的控件都是直接或者间接继承View的，Viewgroup也是继承View的，ViewGroup中可以包含View，也可以包含ViewGroup，我们平时接触的譬如说LinearLayout啊、RelativeLayout就是ViewGroup的子类。</li><li>Android的事件分发机制我有看过它的源码，总的来说就是Android中触摸事件的传递都是先传递到ViewGroup，再传递到View的。我就举Button点击这个例子来讲解一下Android中触摸事件分发的大致流程吧。</li><li>当点击Button的时候，会调用这个控件所在布局的dispatchTouchEvent()，然后在这个布局中dispatchTouchEvent()方法中找到被点击控件的dispatchTouchEvent()方法。</li><li>在调用被点击控件的dispatchTouchEvent()方法之前会有一次触摸事件的拦截判断，如果触摸事件被拦截了，就不会再去执行被点击控件的dispatchTouchEvent函数了，也就不会再执行onClick点击事件了。而是执行ViewGroup控件中的dispatchTouchEvent()的onTouch触摸事件然后返回。</li><li>如果触摸事件没被拦截的话又是怎么做呢，就会ViewGroup中dispatchTouchEvent()方法中被点击控件的dispatchTouchEvent()方法，就不会执行ViewGroup中的onTouch方法了。</li><li>以上只是阐述了touch事件在ViewGroup中和View中的事件分发过程，但是具体得在一个View中的touch事件分发机制又是怎么样的呢，我们继续往下看</li><li>android里面当触摸到任何一个控件的时候就一定会调用这个控件的dispatchTouchEvent方法。dispatchTouchEvent方法中的源码首先会调用onTouch方法，不过这个方法要执行的话也需要有两个前提条件，一个是这个控件注册了触摸监听、第二个是这个控件的状态要是enabled的。</li><li>执行完onTouch方法之后，会有一个返回值，如果返回这为true的话代表这个点击事件不继续往下传递了，为false的话就表示点击事件继续往下传递，就会执行onTouchEvent方法，onClick方法就是在onTouchEvent中被调用的。</li><li>这样的话一个控件的触摸事件在ViewGroup以及View中的分发过程就完成了。</li></ol><hr><h3 id="handler机制，多个handler怎么确定哪个handler处理哪个Message"><a href="#handler机制，多个handler怎么确定哪个handler处理哪个Message" class="headerlink" title="handler机制，多个handler怎么确定哪个handler处理哪个Message"></a>handler机制，多个handler怎么确定哪个handler处理哪个Message</h3><p><strong>一、Handler是什么？</strong></p><p>Handler在我们android开发中是一项非常重要的机制，那Handler是什么呢？Handler是android提供用于更新UI的一套机制，也是消息处理机制。</p><p><a href="https://blog.csdn.net/qq_30379689/article/details/53394061">https://blog.csdn.net/qq_30379689/article/details/53394061</a></p><p><strong><em>Handler</em>的主要作用有两个：</strong></p><p>​    <strong><em>(1).</em>在新启动的线程中发送消息</strong></p><p>​           <strong>(2).在主线程中获取，处理消息。</strong></p><p>解释：(1) 当应用程序启动时，Android首先会开启一个主线程 (也就是UI线程) ， 主线程为管理界面中的UI控件， 进行事件分发， 比如说， 你要是点击一个 Button ，Android会分发事件到Button上，来响应你的操作。 主线程（UI线程）就是android程序从启动运行到最后的程序。</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20161129184124711" alt="img"></p><p>(2) 如果此时需要一个耗时的操作，例如: 联网读取数据，或者读取本地较大的一个文件的时候，你不能把这些操作放在主线程中，如果你放在主线程中的话，界面会出现假死现象， 如果5秒钟还没有完成的话，会收到Android系统的一个错误提示 “强制关闭”。</p><p>(3)这个时候我们需要把这些耗时的操作，放在一个子线程中，因为子线程涉及到UI更新，Android主线程是线程不安全的， 也就是说，更新UI只能在主线程中更新，子线程中操作是危险的。</p><p>(4)这个时候，Handler就出现了。来解决这个复杂的问题 ，由于Handler运行在主线程中(UI线程中)， 它与子线程可以通过Message对象来传递数据， 这个时候，Handler就承担着接受子线程传过来的(子线程用sendMessage()方法传递)Message对象(里面包含数据) ， 把这些消息放入主线程队列中，配合主线程进行更新UI。</p><p><strong>二、为什么要用Handler</strong></p><p>如果我们不用Handler去发送消息，更新UI可以吗？</p><p>答案是不行的。 <strong>Android</strong>在设计的时候，就封装了一套消息创建，传递，处理机制，如果不遵循这样的机制，就没有办法更新UI信息的，就会抛出异常信息。</p><p>抛出异常的描述：不能在非UI线程中去更新UI</p><p><strong>三、</strong> <strong>Handler</strong>怎么用</p><p> handler可以分发Message对象和Runnable对象到主线程中，每个Handler实例，都会绑定到创建他的线程中(一般是位于主程)，它有两个作用：</p><p>   (1)合理调度安排消息和runnable对象，使它们在将来的某个点被执行</p><p>​    (2)安排一个动作在不同的线程中执行</p><p><strong>Handler中开启线程和分发消息的一些方法:</strong></p><p>   <strong>post(Runnable)</strong>直接开启Runnable线程</p><p>   <strong>postAtTime(Runnable，long)</strong>在指定的时间long，开始启动线程</p><p>   <strong>postDelayed(Runnable long)</strong>在延迟long时间后，启动Runnable线程</p><p>   <strong>sendEmptyMessage(int)</strong> 发送指定的消息，通过参数<em>int**来区分不同的消息</em></p><p>   <strong>sendMessage(Message)</strong>发送消息到UI线程中</p><p>   sendMessageAtTime(Message，long)   这个long代表的是系统时间，不推荐用</p><p>  sendMessageDelayed(Message,long)  此方法long代表调用后几秒后执行。</p><p>  sendMessage类方法， 允许你安排一个带数据的Message对象到队列中，等待更新.</p><p><strong>handler基本使用：</strong> 1)在主线程中，使用handler很简单，new一个Handler对象实现其handleMessage方法，在 handleMessage 中提供收到消息后相应的处理方法即可。（接收消息，并且更新UI）</p><p>​           2)在新启动的线程中发送消息</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.handleMessage(msg);</span><br><span class="line">            tv.setText(<span class="string">&quot;msg.arg1:&quot;</span>+msg.arg1+<span class="string">&quot;--msg.arg2:&quot;</span>+msg.arg2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> TextView tv;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_handler);</span><br><span class="line">        initView();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();<span class="comment">//实例化消息对象</span></span><br><span class="line">                msg.arg1 = <span class="number">99</span>;<span class="comment">//携带参数</span></span><br><span class="line">                msg.arg2 = <span class="number">100</span>;<span class="comment">//携带参数</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//实例化对象</span></span><br><span class="line">                msg.obj = str; <span class="comment">//携带参数为实体类对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initView</span><span class="params">()</span> &#123;</span><br><span class="line">        tv = (TextView) findViewById(R.id.tv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>handler运行机制：</strong></p><p><strong><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20180818235134804.png" alt="img"></strong> </p><p> Handler机制也可叫异步消息机制，它主要由4个部分组成：<strong>Message,Handler,MessageQueue,Looper</strong>,在上面图中我们已经有了大致印象,接下来我们对4个成员进行着重的了解：</p><p><strong>1.Message</strong><br>  Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。使用Message的arg1和arg2便可携带int数据，使用obj便可携带Object类型数据。</p><p><strong>2.Handler</strong><br>  Handler顾名思义就是处理者的意思，它只要用于在子线程发送消息对象Message,在UI线程处理消息对象Message，在子线程调用sendMessage方法发送消息对象Message，而发送的消息经过一系列地辗转之后最终会被传递到Handler的handleMessage方法中,最终在handleMessage方法中消息对象Message被处理。</p><p><strong>3.MessageQueue</strong><br>  MessageQueue就是消息队列的意思,它只要用于存放所有通过Handler发送过来的消息。这部分消息会一直存放于消息队列当中，等待被处理。每个线程中只会有一个MessageQueue对象，请牢记这句话。其实从字面上就可以看出，MessageQueue底层数据结构是队列，而且这个队列只存放Message对象。</p><p><strong>4.Looper</strong><br>  Looper是每个线程中的MessageQueue的管家，调用Looper的loop()方法后，就会进入到一个无限循环当中，然后每当MesssageQueue中存在一条消息，Looper就会将这条消息取出，并将它传递到Handler的handleMessage()方法中。每个线程只有一个Looper对象。</p><p>  了解了上述Handler机制的4个成员后，我们再来把思路理一遍：<strong>首先在UI线程我们创建了一个Handler实例对象，无论是匿名内部类还是自定义类生成的Handler实例对象，我们都需要对handleMessage方法进行重写，在handleMessage方法中我们可以通过参数msg来写接受消息过后UIi线程的逻辑处理，接着我们创建子线程，在子线程中需要更新UI的时候，新建一个Message对象，并且将消息的数据记录在这个消息对象Message的内部，比如arg1,arg2,obj等，然后通过前面的Handler实例对象调用sendMessge方法把这个Message实例对象发送出去，之后这个消息会被存放于MessageQueue中等待被处理，此时MessageQueue的管家Looper正在不停的把MessageQueue存在的消息取出来，通过回调dispatchMessage方法将消息传递给Handler的handleMessage方法，最终前面提到的消息会被Looper从MessageQueue中取出来传递给handleMessage方法，最终得到处理。这就是Handler机制整个的工作流程。</strong></p><hr><h3 id="避免ANR"><a href="#避免ANR" class="headerlink" title="避免ANR"></a>避免ANR</h3><p>ANR(Application Not Responding)定义</p><p>在Android上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，这个对话框称作应用程序无响应（ANR：Application Not Responding）对话框。用户可以选择“等待”而让程序继续运行，也可以选择“强制关闭”。所以一个流畅的合理的应用程序中不能出现anr，而让用户每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要，这样系统不会显示ANR给用户。默认情况下，在android中Activity的最长执行时间是5秒，BroadcastReceiver的最长执行时间则是10秒。</p><p>Android应用程序通常是运行在一个单独的线程（例如，main）里。这意味着你的应用程序所做的事情如果在<a href="https://baike.baidu.com/item/主线程">主线程</a>里占用了太长的时间的话，就会引发ANR对话框，因为你的应用程序并没有给自己机会来处理输入事件或者Intent广播。</p><p>因此，运行在主线程里的任何方法都尽可能少做事情。特别是，Activity应该在它的关键生命周期方法（如onCreate()和onResume()）里尽可能少的去做创建操作。潜在的耗时操作，例如网络或数据库操作，或者高耗时的计算如改变位图尺寸，应该在子线程里（或者以数据库操作为例，通过异步请求的方式）来完成。然而，不是说你的<a href="https://baike.baidu.com/item/主线程">主线程</a>阻塞在那里等待子线程的完成——也不是调用Thread.wait()或是Thread.sleep()。替代的方法是，主线程应该为子线程提供一个Handler，以便完成时能够提交给主线程。以这种方式设计你的应用程序，将能保证你的主线程保持对输入的响应性并能避免由于5秒输入事件的超时引发的ANR对话框。这种做法应该在其它显示UI的线程里效仿，因为它们都受相同的超时影响。</p><p>IntentReceiver执行时间的特殊限制意味着它应该做：在后台里做小的、琐碎的工作如保存设定或者注册一个Notification。和在<a href="https://baike.baidu.com/item/主线程">主线程</a>里调用的其它方法一样，应用程序应该避免在BroadcastReceiver里做耗时的操作或计算。但不再是在子线程里做这些任务（因为BroadcastReceiver的生命周期短），替代的是，如果响应Intent广播需要执行一个耗时的动作的话，应用程序应该启动一个Service。顺便提及一句，你也应该避免在Intent Receiver里启动一个Activity，因为它会创建一个新的画面，并从当前用户正在运行的程序上抢夺焦点。如果你的应用程序在响应Intent广播时需要向用户展示什么，你应该使用Notification Manager来实现。</p><p>一般来说，在应用程序里，100到200ms是用户能感知阻滞的时间阈值。因此，这里有一些额外的技巧来避免ANR，并有助于让你的应用程序看起来有响应性。</p><p>如果你的应用程序为响应用户输入正在后台工作的话，可以显示工作的进度（ProgressBar和ProgressDialog对这种情况来说很有用）。</p><p>特别是游戏，在子线程里做移动的计算。</p><p>如果你的应用程序有一个耗时的初始化过程的话，考虑可以显示一个Splash Screen或者快速显示主画面并异步来填充这些信息。在这两种情况下，你都应该显示正在进行的进度，以免用户认为应用程序被冻结了。</p><p>ThreadLocal-&gt;Looper-&gt;MessageQueue-&gt;Message-&gt;target-&gt;handler</p><p><a href="https://blog.csdn.net/zl18603543572/article/details/89196436?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">见</a></p><p>不会，一句话谁发送的消息，谁处理，为什么，因为每个Message消息都会绑定一个target来指定这个消息由谁来处理。</p><p>Message消息在被发送时会被绑定Handler</p><p>追溯源码发现，无论使用Handler的哪个方法来发送消息，最终都会调用到下面方法来发送，在这里 msg对象会被绑定target，而这里的值为this，正是发送消息的Handler的本身，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    msg.target = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Message消息在被处理的时候</p><p>追溯源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">       <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> me.mQueue;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">       <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">       Binder.clearCallingIdentity();</span><br><span class="line">       <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block</span></span><br><span class="line">           <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">           <span class="type">Printer</span> <span class="variable">logging</span> <span class="operator">=</span> me.mLogging;</span><br><span class="line">           <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">               logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                       msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           msg.target.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">               logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">           <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">           <span class="keyword">final</span> <span class="type">long</span> <span class="variable">newIdent</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">           <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">               Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                       + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                       + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                       + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                       + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           msg.recycleUnchecked();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>msg.target.dispatchMessage(msg); 关键的这一句，msg调用了自身绑定的target的dispatchMessage方法来处理消息，而这里的target正是msg在被发送的时候所绑定的handler.</p><hr><h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><p>AIDL是Android中<strong>IPC（Inter-Process Communication）</strong>方式中的一种，AIDL是<strong>Android Interface definition language</strong>的缩写，对于小白来说，AIDL的作用是让你可以在自己的APP里绑定一个其他APP的service，这样你的APP可以和其他APP交互。</p><hr><h3 id="线程通信方式"><a href="#线程通信方式" class="headerlink" title="线程通信方式"></a>线程通信方式</h3><p><a href="https://blog.csdn.net/liuxingyuzaixian/article/details/78893392">https://blog.csdn.net/liuxingyuzaixian/article/details/78893392</a></p><hr><h3 id="Intent显示跳转与隐式跳转"><a href="#Intent显示跳转与隐式跳转" class="headerlink" title="Intent显示跳转与隐式跳转"></a>Intent显示跳转与隐式跳转</h3><p><a href="https://blog.csdn.net/sinat_22949049/article/details/80064261">https://blog.csdn.net/sinat_22949049/article/details/80064261</a></p><hr><h3 id="apk编译-apk安装过程"><a href="#apk编译-apk安装过程" class="headerlink" title="apk编译,apk安装过程"></a>apk编译,apk安装过程</h3><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20180710175536508.png" alt="这里写图片描述"></p><ol><li>Android通过<code>AAPT工具</code>将.xml资源文件编译成R.java的二进制文件，除了assets、raw目录下的文件；</li><li>将java文件编译成.class文件；</li><li>通过dex工具将.class文件转换成.dex文件</li><li>优化dex文件 ： Davlik模式下使用 <code>dexopt</code>工具将.dex文件优化得到<code>.odex</code>文件 ; Art模式下使用<code>dexoat</code>工具将.dex文件优化得到<code>.oat</code>文件;</li><li><code>apkbuilder</code>会将.dex文件和未被编译的文件编译成apk;</li><li><code>apkSinger</code>对apk签名；</li><li><code>zipalign</code>对签名后的apk进行优化</li></ol><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20180710175548750.png" alt="这里写图片描述"></p><p>Android 安装的apk文件实际上是以.zip结尾的压缩文件，解压后的文件内容如上图所示</p><ul><li>AndroidManifest.xml对应源代码中的AndroidManifest.xml, 但这里是编译过的，文件内容已经不同了；</li><li>assets对应源代码的assets目录， 是直接复制过来的；</li><li>classes.dex（classes2.dex、classes3.dex等等）是包含所有Java文件对应的字节码，其中<code>classes.dex</code>是程序主包;</li><li>lib目录对应源代码中的libs目录，包含so文件；</li><li>META-INF目录包含CERT.RSA、CERT.SF、MANIFEST.MF等， 保存了各个资源文件的SHA1值，用于校验资源文件是否被篡改，从而防止二次打包时资源文件被替换；</li><li>res目录对应源码的res目录， 包含各种图片、xml等；</li><li>resources.arsc包含了各个资源文件的映射， 可以理解为索引， 通过该文件能找到对应的资源文件信息。</li></ul><hr><h3 id="androidManifest文件的作用"><a href="#androidManifest文件的作用" class="headerlink" title="androidManifest文件的作用"></a>androidManifest文件的作用</h3><p>AndroidManifest.xml是Android应用的入口文件，它描述了package中暴露的组件（activities, services, 等等），他们各自的实现类，各种能被处理的数据和启动位置。 除了能声明程序中的Activities, ContentProviders, Services, 和Intent Receivers,还能指定permissions和instrumentation（安全控制和测试）。 </p><p><a href="https://blog.csdn.net/weixin_41729259/article/details/87910512">https://blog.csdn.net/weixin_41729259/article/details/87910512</a></p><hr><h3 id="ProGuard"><a href="#ProGuard" class="headerlink" title="ProGuard"></a>ProGuard</h3><p>ProGuard 是一款免费的Java类文件压缩器、优化器和混淆器。它能发现并删除无用类、字段（field）、方法和属性值（attribute）。它也能优化字节码 并删除无用的指令。最后，它使用简单无意义的名字来重命名你的类名、字段名和方法名。经过以上操作的jar文件会变得更小，并很难进行逆向工程。这里提到 了ProGuard的主要功能是压缩、优化和混淆，下面我就先介绍一下这些概念，然后再介绍ProGuard的基本使用方法。</p><p>ProGuard支持那些种类的优化：</p><p>除了在压缩操作删除的无用类，字段和方法外，ProGuard也能在字节码级提供性能优化，内部方法有：</p><p>² 常量表达式求值</p><p>² 删除不必要的字段存取</p><p>² 删除不必要的方法调用</p><p>² 删除不必要的分支</p><p>² 删除不必要的比较和instanceof验证</p><p>² 删除未使用的代码</p><p>² 删除只写字段</p><p>² 删除未使用的方法参数</p><p>² 像push/pop简化一样的各种各样的peephole优化</p><p>² 在可能的情况下为类添加static和final修饰符</p><p>² 在可能的情况下为方法添加private, static和final修饰符</p><p>² 在可能的情况下使get/set方法成为内联的</p><p>² 当接口只有一个实现类的时候，就取代它</p><p>² 选择性的删除日志代码</p><hr><h3 id="Service的onBind和onStart差别"><a href="#Service的onBind和onStart差别" class="headerlink" title="Service的onBind和onStart差别"></a>Service的onBind和onStart差别</h3><p>Service的生命周期方法比Activity少一些，只有onCreate, onStart, onDestroy<br>　　我们有两种方式启动一个Service,他们对Service生命周期的影响是不一样的。</p><p>　　1 通过startService<br>　　Service会经历 onCreate —&gt; onStart<br>　　stopService的时候直接onDestroy</p><p>　　如果是 调用者 直接退出而没有调用stopService的话，Service会一直在后台运行。<br>　　下次调用者再起来仍然可以stopService。</p><p>　　2 通过bindService<br>　　Service只会运行onCreate， 这个时候 调用者和Service绑定在一起</p><p>　　调用者退出了，Srevice就会调用onUnbind—&gt;onDestroyed<br>　　所谓绑定在一起就共存亡了。</p><p>　　注意：Service的onCreate的方法只会被调用一次，<br>　　就是你无论多少次的startService又 bindService，Service只被创建一次。<br>　　如果先是bind了，那么start的时候就直接运行Service的onStart方法，<br>　　如果先是start，那么bind的时候就直接运行onBind方法。如果你先bind上了，就stop不掉了，<br>　　只能先UnbindService, 再StopService,所以是先start还是先bind行为是有区别的。</p><p>　　Android中的服务和windows中的服务是类似的东西，服务一般没有用户操作界面，它运行于系统中不容易被用户发觉，可以使用它开发如监控之类的程序。</p><p>　　服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。<br>　　这两个方法都可以启动Service，但是它们的使用场合有所不同。使用startService()方法启用服务，调用者与服务之间没有关连，<br>　　即使调用者退出了，服务仍然运行。使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。</p><p>　　如果打算采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，<br>　　接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次创建服务，<br>　　但会导致多次调用onStart()方法。采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。</p><p>　　如果打算采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，<br>　　接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，<br>　　接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，<br>　　多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。<br>　　如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()—&gt;onDestroy()方法.</p><p>　　onBind将返回给客户端一个IBind接口实例，IBind允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。这个时候调用者会和Service绑定在一起,但onBind只能一次，不可多次绑定。<br>　　在Service每一次的开启关闭过程中，只有onStart可被多次调用(通过多次startService调用)，其他onCreate，onBind，onUnbind，onDestory在一个生命周期中只能被调用一次。</p><p>　　由于Android 中的Service使用了onBind 的方法去绑定服务，返回一个I<a href="https://www.baidu.com/s?wd=binder&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">binder</a>对象进行操作，而我们要获取具体的Service方法的内容的时候，我们需要I<a href="https://www.baidu.com/s?wd=binder&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">binder</a>对象返回具体的Service对象才能操作，所以说具体的Service对象必须首先实现<a href="https://www.baidu.com/s?wd=Binder&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">Binder</a>对象，这个样子的话我们才能利用bindService的方法对Service进行绑定，获取Binder对象之后获取具体的Service对象，然后才获取Service中的方法等等。</p><p>　　与采用Context.startService()方法启动服务有关的生命周期方法<br>　　onCreate() —onStart() —onDestroy()<br>　　onCreate()该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，服务也只被创建一次。<br>　　onStart() 只有采用Context.startService()方法启动服务时才会回调该方法。该方法在服务开始运行时被调用。多次调用startService()方法尽管不会多次创建服务，但onStart() 方法会被多次调用。<br>　　onDestroy()该方法在服务被终止时调用。</p><p>　　与采用Context.bindService()方法启动服务有关的生命周期方法<br>　　onCreate()— onBind() — onUnbind() — onDestroy()<br>　　onBind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务绑定时被调用，当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。</p><hr><h3 id="View的绘制过程"><a href="#View的绘制过程" class="headerlink" title="View的绘制过程"></a>View的绘制过程</h3><p><a href="https://www.jianshu.com/p/c151efe22d0d">https://www.jianshu.com/p/c151efe22d0d</a></p><hr><h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p><a href="https://www.jianshu.com/p/4920c7781afe">https://www.jianshu.com/p/4920c7781afe</a></p><hr><h3 id="自定义view"><a href="#自定义view" class="headerlink" title="自定义view"></a>自定义view</h3><p><a href="https://www.jianshu.com/p/31a76bf6b816">https://www.jianshu.com/p/31a76bf6b816</a></p><p>对于自定义view，很多时候需要使用到自定义属性，我们向实现一个view的自定义属性，需要遵循以下几部：<br>a.自定义一个CustomView(extends View )类<br>b.编写values/attrs.xml，在其中编写styleable和item等标签元素<br>c.在布局文件中CustomView使用自定义的属性（注意namespace）<br>导入自定义属性，以下两种方式都可(namespace)<br><a href="http://schemas.android.com/apk/res/包名">http://schemas.android.com/apk/res/包名</a><br><a href="http://schemas.android.com/apk/res-auto">http://schemas.android.com/apk/res-auto</a><br>d.在CustomView的构造方法中通过TypedArray获取</p><hr><h3 id="图片三级缓存"><a href="#图片三级缓存" class="headerlink" title="图片三级缓存"></a>图片三级缓存</h3><h4 id="使用三级缓存目的"><a href="#使用三级缓存目的" class="headerlink" title="使用三级缓存目的"></a>使用三级缓存目的</h4><ul><li>速度快，可以提升用户体验度</li><li>避免重复请求网络，重复加载，节省流量</li></ul><h4 id="三级缓存简介"><a href="#三级缓存简介" class="headerlink" title="三级缓存简介"></a>三级缓存简介</h4><ul><li>内存缓存, 优先加载, 速度最快（加载到内存，就容易出现OOM）</li><li>本地缓存, 次优先加载, 速度快</li><li>网络缓存, 不优先加载, 速度慢,浪费流量</li></ul><hr><h3 id="ListView与RecyclerView对比浅析"><a href="#ListView与RecyclerView对比浅析" class="headerlink" title="ListView与RecyclerView对比浅析"></a>ListView与RecyclerView对比浅析</h3><p><a href="https://www.jianshu.com/p/193fb966e954">https://www.jianshu.com/p/193fb966e954</a></p><hr><h3 id="内存溢出OOM"><a href="#内存溢出OOM" class="headerlink" title="内存溢出OOM"></a>内存溢出OOM</h3><ul><li>Android默认给每个app只分配16M的内存（个别的不是）</li><li>java中的引用<ul><li>强引用 垃圾回收器不会回收, java默认引用都是强引用</li><li>软引用 SoftReference 在内存不够时,垃圾回收器会考虑回收</li><li>弱引用 WeakReference 在内存不够时,垃圾回收器会优先回收</li><li>虚引用 PhantomReference 在内存不够时,垃圾回收器最优先回收</li></ul></li></ul><p>注意: Android2.3+, 系统会优先将SoftReference的对象提前回收掉, 即使内存够用</p><p>所以：一般都只使用强引用，弱引用太弱了</p><hr><h3 id="viewStub"><a href="#viewStub" class="headerlink" title="viewStub"></a>viewStub</h3><p><a href="https://www.jianshu.com/p/175096cd89ac">https://www.jianshu.com/p/175096cd89ac</a></p><hr><h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><h3 id="三次握手四次挥手使用哪个协议"><a href="#三次握手四次挥手使用哪个协议" class="headerlink" title="三次握手四次挥手使用哪个协议"></a>三次握手四次挥手使用哪个协议</h3><p>建立TCP需要三次握手才能建立，而断开连接则需要四次握手。首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p><p>在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。</p><p><strong>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong><br>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p>第三次失败会怎么样</p><p>当客户端收到服务端的SYN+ACK应答后，其状态变为ESTABLISHED，并会发送ACK包给服务端，准备发送数据了。如果此时ACK在网络中丢失，过了超时计时器后，那么Server端会重新发送SYN+ACK包，重传次数根据/proc/sys/net/ipv4/tcp_synack_retries来指定，默认是5次。如果重传指定次数到了后，仍然未收到ACK应答，那么一段时间后，Server自动关闭这个连接。但是Client认为这个连接已经建立，如果Client端向Server写数据，Server端将以RST包响应，方能感知到Server的错误。</p><p>当失败时服务器并不会重传ack报文，而是直接发送RTS报文段，进入CLOSED状态。这样做的目的是为了防止SYN洪泛攻击。</p><hr><h3 id="TCP和UDP区别，工作在哪一层，这一层的主要功能，数据在TCP下有什么变化；（增加tcp头部，udp头部）"><a href="#TCP和UDP区别，工作在哪一层，这一层的主要功能，数据在TCP下有什么变化；（增加tcp头部，udp头部）" class="headerlink" title="TCP和UDP区别，工作在哪一层，这一层的主要功能，数据在TCP下有什么变化；（增加tcp头部，udp头部）"></a>TCP和UDP区别，工作在哪一层，这一层的主要功能，数据在TCP下有什么变化；（增加tcp头部，udp头部）</h3><p>TCP和<a href="https://www.baidu.com/s?wd=UDP协议&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">UDP协议</a>都是传输层的协议。</p><p>TCP与UDP基本区别<br> 1.基于连接与无连接<br> 2.TCP要求系统资源较多，UDP较少；<br> 3.UDP程序结构较简单<br> 4.流模式（TCP）与数据报模式(UDP);<br> 5.TCP保证数据正确性，UDP可能丢包<br> 6.TCP保证数据顺序，UDP不保证 </p><p>UDP应用场景：<br> 1.面向数据报方式<br> 2.网络数据大多为短消息<br> 3.拥有大量Client<br> 4.对数据安全性无特殊要求<br> 5.网络负担非常重，但对响应速度要求高</p><p>TCP编程的服务器端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt(); * 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();<br>　　4、开启监听，用函数listen()；<br>　　5、接收客户端上来的连接，用函数accept()；<br>　　6、收发数据，用函数send()和recv()，或者read()和write();<br>　　7、关闭网络连接；<br>　　8、关闭监听； </p><p>TCP编程的客户端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();<em> 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();</em> 可选<br>　　4、设置要连接的对方的IP地址和端口等属性；<br>　　5、连接服务器，用函数connect()；<br>　　6、收发数据，用函数send()和recv()，或者read()和write();<br>　　7、关闭网络连接；</p><p><strong><em>\</em>UDP:**</strong><br>与之对应的UDP编程步骤要简单许多，分别如下：<br>　　UDP编程的服务器端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();* 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();<br>　　4、循环接收数据，用函数recvfrom();<br>　　5、关闭网络连接； </p><p>UDP编程的客户端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();<em> 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();</em> 可选<br>　　4、设置对方的IP地址和端口等属性;<br>　　5、发送数据，用函数sendto();<br>　　6、关闭网络连接；</p><p>TCP补充：<br> TCP充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p><p>TCP与UDP区别总结：<br>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保  证可靠交付<br>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br> UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p><p>TCP头部</p><p>/<em>TCP头定义，共20个字节</em>/<br>typedef struct _TCP_HEADER<br>{<br> short m_sSourPort;    　　　　　　// 源端口号16bit<br> short m_sDestPort;    　　　　　 // 目的端口号16bit<br> unsigned int m_uiSequNum;    　// 序列号32bit<br> unsigned int m_uiAcknowledgeNum; // 确认号32bit<br> short m_sHeaderLenAndFlag;   　　// 前4位：TCP头长度；中6位：保留；后6位：标志位<br> short m_sWindowSize;    　　　　// 窗口大小16bit<br> short m_sCheckSum;    　　　　　 // 检验和16bit<br> short m_surgentPointer;   　　　　 // 紧急数据偏移量16bit<br>}<strong>attribute</strong>((packed))TCP_HEADER, *PTCP_HEADER;</p><ol><li><p>TCP layer 没有IP地址的概念，那个是IP 层的，所以前4个字节是<strong>源端口和目的端口</strong></p></li><li><p>Sequence Number：传输数据过程中，为每一个封包分配一个序号，<strong>保证网络传输数据的顺序性</strong></p></li><li><p>Acknowledgment Number：用来确认确实有收到相关封包，内容表示期望收到下一个报文的序列号，<strong>用来解决丢包的问题</strong></p></li><li><p>TCP Flags：这部分主要标志数据包的属性，比如SYN，RST，FIN等，操控TCP的状态机</p></li><li><p>Window：滑动窗口，主要用于解决流控拥塞的问题</p></li><li><p>Checksum：校验值</p></li><li><p>Urgent Pointer：紧急指针，可以告知紧急的数据位置，需要和Flag的U flag 配合使用</p></li><li><p>TCP Options：一般包含在三次握手中，有Option的选项！</p></li></ol><p><strong>UDP头结构的定义</strong></p><p>/<em>UDP头定义，共8个字节</em>/</p><p>typedef struct _UDP_HEADER<br>{<br> unsigned short m_usSourPort;  　　　// 源端口号16bit<br> unsigned short m_usDestPort;  　　　// 目的端口号16bit<br> unsigned short m_usLength;  　　　　// 数据包长度16bit<br> unsigned short m_usCheckSum;  　　// 校验和16bit<br>}<strong>attribute</strong>((packed))UDP_HEADER, *PUDP_HEADER;</p><hr><h3 id="http使用了哪些技术？Get-post区别"><a href="#http使用了哪些技术？Get-post区别" class="headerlink" title="http使用了哪些技术？Get,post区别"></a>http使用了哪些技术？Get,post区别</h3><p><a href="https://blog.fundebug.com/2019/02/22/compare-http-method-get-and-post/">https://blog.fundebug.com/2019/02/22/compare-http-method-get-and-post/</a></p><ol><li><p>GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以？分割URL和传输数据，参数之间以&amp;相连，如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母或数字，则原样发送；如果是空格，转换为+；如果是中文或其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII码值。而与之对应的，POST把提交的数据放置在HTTP包的包体中，文章最下面将会有代码示例。</p></li><li><p>POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为：(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击（CSRF,跨站请求伪造，也被称为：one click attack/session riding）。</p></li></ol><p>HTTP 协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议 TLS/SSL 具有身份验证、信息加密和完整性校验的功能，可以避免此类问题。<br>TLS/SSL 全称安全传输层协议 Transport Layer Security, 是介于 TCP 和 HTTP 之间的一层安全协议，不影响原有的 TCP 协议和 HTTP 协议，所以使用 HTTPS 基本上不需要对 HTTP 页面进行太多的改造。</p><p>HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，本节分析安全协议的实现原理。</p><p>TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。<img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/2snzFs9.gif" alt="img"></p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/1260476-20171116160813812-635766483.png" alt="img"></p><ul><li>在使用HTTPS是需要保证服务端配置正确了对应的安全证书</li><li>客户端发送请求到服务端</li><li>服务端返回公钥和证书到客户端</li><li>客户端接收后会验证证书的安全性,如果通过则会随机生成一个随机数,用公钥对其加密,发送到服务端</li><li>服务端接受到这个加密后的随机数后会用私钥对其解密得到真正的随机数,随后用这个随机数当做私钥对需要发送的数据进行对称加密</li><li>客户端在接收到加密后的数据使用私钥(即生成的随机值)对数据进行解密并且解析数据呈现结果给客户</li><li>SSL加密建立</li></ul><hr><h3 id="如何实现UDP的可靠传输"><a href="#如何实现UDP的可靠传输" class="headerlink" title="如何实现UDP的可靠传输"></a>如何实现UDP的可靠传输</h3><p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p><p>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p><ul><li>1、添加seq/ack机制，确保数据发送到对端</li><li>2、添加发送和接收缓冲区，主要是用户超时重传。</li><li>3、添加超时重传机制。</li></ul><p>详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p><hr><h3 id="TIME-WAIT状态处在哪一方以及为什么需要它"><a href="#TIME-WAIT状态处在哪一方以及为什么需要它" class="headerlink" title="TIME_WAIT状态处在哪一方以及为什么需要它"></a>TIME_WAIT状态处在哪一方以及为什么需要它</h3><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/3971776-9550b64ff16dbb0b.webp" alt="img"></p><p>在TCP连接中四次挥手关闭连接时，主动关闭连接的一方（上图中时Client）会在发送最后一条ACK报文后维持一段时长2MSL（MSL指的是数据包在网络中的最大生存时间）的等待时间后才会真正关闭连接到CLOSED状态，该时间段内主动关闭方的状态为TIME_WAIT。即在TIME_WAIT状态时，定义这个连接的四元组（源/目的IP、源/目的端口）不能被使用。</p><p>为实现TCP连接的可靠释放</p><ol><li><p>若主动断开连接方（上图中Client）最后一次ACK报文丢失了，会触发被动方（上图中Server）的超时重传机制，Server再次向Client发送FIN+ACK报文，如果Client在发送完最后一次ACK后立即断开连接（没有TIME_WAIT状态），则Server会收到RST=1的报文响应，表示连接建立异常，而此时并非异常，只是正常的关闭连接过程，进而导致Server端不能正常关闭连接。因此，Client必须维护2MSL的等待时间，确保在Server端第二次发送的FIN+ACK被Client正常接收，收到后Client立即发送ACK给Server，并重新启动2MSL计时器。（因为极端情况涉及两次报文传输（Client向Server的ACK，Server向Client的FIN+ACK），所以等待时间为2MSL）</p></li><li><p>为使旧的重复数据包在网络中因过期而消失</p><p>可能存在一些数据包在传输过程中出现异常而导致严重推迟，而在它到来之前发送方已经重发了该报文，并完成其任务。如果在被推迟的报文未抵达前接收方断开了连接，随后又建立了一个与之前相同IP、Port的连接，而之前被推迟的报文在这时恰好到达，而此时此新连接非彼连接，从而会发生数据错乱，进而导致无法预知的情况。因此必须维持一段等待时间，使迟到的报文在网络中完全消失，并且在等待时间内，因为连接并未关闭，所以不能建立相同四元组的新连接，就不会出现数据错乱。</p></li></ol><p>在高并发短连接的TCP服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于TIME_WAIT状态，服务器维护每一个连接需要一个socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些连接失败。</p><p>可设置套接字选项为SO_REUSEADDR，该选项的意思是，告诉操作系统，如果端口忙，但占用该端口TCP连接处于TIME_WAIT状态，并且套接字选项为SO_REUSEADDR，则该端口可被重用。如果TCP连接处于其他状态，依然返回端口被占用。该选项对服务程序重启非常有用。</p><hr><h3 id="HTTPs的握手过程"><a href="#HTTPs的握手过程" class="headerlink" title="HTTPs的握手过程"></a>HTTPs的握手过程</h3><p><a href="https://razeencheng.com/post/ssl-handshake-detail">https://razeencheng.com/post/ssl-handshake-detail</a></p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/555379-20160210231313448-2027205313.png" alt="img"></p><ol><li><p>客户端发起HTTPS请求</p></li><li><p>服务端的配置</p></li></ol><p>采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。</p><ol><li>传送证书</li></ol><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。</p><ol><li>客户端解析证书</li></ol><p>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。</p><ol><li>传送加密信息</li></ol><p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p><ol><li>服务段解密信息</li></ol><p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p><ol><li>传输加密后的信息</li></ol><p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p><ol><li>客户端解密信息</li></ol><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。</p><p>PS: 整个握手过程第三方即使监听到了数据，也束手无策。</p><p>总结</p><p>为什么HTTPS是安全的？</p><p>在HTTPS握手的第四步中，如果站点的证书是不受信任的，会显示出现下面确认界面，确认了网站的真实性。另外第六和八步，使用客户端私钥加密解密，保证了数据传输的安全。</p><p>HTTPS和HTTP的区别</p><ol><li><p>https协议需要到ca申请证书或自制证书。</p></li><li><p>http的信息是明文传输，https则是具有安全性的ssl加密。</p></li><li><p>http是直接与TCP进行数据传输，而https是经过一层SSL（OSI表示层），用的端口也不一样，前者是80（需要国内备案），后者是443。</p></li><li><p>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p></li></ol><p>注意https加密是在传输层 </p><p>https报文在被包装成tcp报文的时候完成加密的过程，无论是https的header域也好，body域也罢都是会被加密的。</p><p>当使用tcpdump或者wireshark之类的tcp层工具抓包，获取是加密的内容，而如果用应用层抓包，使用Charels(Mac)、Fildder(Windows)抓包工具，那当然看到是明文的。</p><hr><h3 id="为什么数据传输不用非对称加密"><a href="#为什么数据传输不用非对称加密" class="headerlink" title="为什么数据传输不用非对称加密"></a>为什么数据传输不用非对称加密</h3><p>因为非对称加密加密解密算法效率较低，不适合客户端和服务器端这样高频率的通信过程，在某些极端情况下，甚至能比非对称加密慢上1000倍。</p><p>非对称加密的优势在于它可以很好帮助完成秘钥的交换，所以前期交换秘钥必须使用非对称加密算法。</p><p>对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；为什么叫对称加密？</p><p>一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文。他们之间的关系如下：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">明文 <span class="attribute">&lt;-&gt;</span> 密钥 <span class="attribute">&lt;-&gt;</span> 密文</span><br></pre></td></tr></table></figure><p>常见的对称加密算法：DES，AES，3DES等等。</p><p>而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</p><p>非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20190314090627135.png" alt="img"></p><p>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。<br>但是此时交换的两个公钥不一定正确</p><p>常见的非对称加密算法：RSA，ECC</p><hr><h3 id="转发和重定向的区别"><a href="#转发和重定向的区别" class="headerlink" title="转发和重定向的区别"></a>转发和重定向的区别</h3><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p><p><strong>转发（Forword）</strong> 通过 RequestDispatcher 对象的<code>forward（HttpServletRequest request,HttpServletResponse response）</code>方法实现的。<code>RequestDispatcher</code> 可以通过<code>HttpServletRequest</code> 的 <code>getRequestDispatcher()</code>方法获得。例如下面的代码就是跳转到 login_success.jsp 页面。</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">request</span>.getRequestDispatcher(<span class="string">&quot;login_success.jsp&quot;</span>).forward(<span class="built_in">request</span>, <span class="built_in">response</span>);</span><br></pre></td></tr></table></figure><p><strong>重定向（Redirect）</strong> 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 HttpServletRequestResponse 的 setStatus(int status)方法设置状态码。如果服务器返回 301 或者 302，则浏览器会到新的网址重新请求该资源。</p><ol><li><strong>从地址栏显示来说</strong>：forward 是服务器请求资源，服务器直接访问目标地址的 URL，把那个 URL 的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址。redirect 是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址。所以地址栏显示的是新的 URL。</li><li><strong>从数据共享来说</strong>：forward：转发页面和转发到的页面可以共享 request 里面的数据。redirect：不能共享数据。</li><li><strong>从运用地方来说</strong>：forward：一般用于用户登陆的时候，根据角色转发到相应的模块。redirect：一般用于用户注销登陆时返回主页面和跳转到其它的网站等。</li><li><strong>从效率来说</strong>：forward：高。redirect：低。</li></ol><hr><h3 id="在浏览器中输入-url-地址到显示主页的过程-整个过程会使用哪些协议"><a href="#在浏览器中输入-url-地址到显示主页的过程-整个过程会使用哪些协议" class="headerlink" title="在浏览器中输入 url 地址到显示主页的过程,整个过程会使用哪些协议"></a>在浏览器中输入 url 地址到显示主页的过程,整个过程会使用哪些协议</h3><p><img src="https://camo.githubusercontent.com/c6bda910351aff0fc39247088fde335ab5bbf3c8/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f2545352539302538342545372541372538442545372542442539312545372542422539432545382541462542372545362542312538322545372539342541382545352538382542302545372539412538342545352538442538462545382541452541452e6a7067" alt="各种网络请求用到的协议"></p><p>总体来说分为以下几个过程:</p><ol><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p>具体可以参考下面这篇文章：</p><ul><li><a href="https://segmentfault.com/a/1190000006879700">https://segmentfault.com/a/1190000006879700</a></li></ul><hr><h3 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select poll epoll"></a>select poll epoll</h3><p><a href="https://blog.csdn.net/nanxiaotao/article/details/90612404">https://blog.csdn.net/nanxiaotao/article/details/90612404</a></p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20190527231438974.png" alt="img"></p><p><strong><em>\</em>select——&gt;**</strong></p><p><strong><em>\</em>原理概述：**</strong></p><p>select 的核心功能是调用tcp文件系统的poll函数，不停的查询，如果没有想要的数据，主动执行一次调度（防止一直占用cpu），直到有一个连接有想要的消息为止。从这里可以看出select的执行方式基本就是不同的调用poll,直到有需要的消息为止。</p><p><strong>缺点：</strong></p><p>1、每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；</p><p>2、同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大；</p><p>3、select支持的文件描述符数量太小了，默认是1024。</p><p><strong><em>\</em>优点：**</strong></p><p>1、select的可移植性更好，在某些Unix系统上不支持poll()。</p><p>2、select对于超时值提供了更好的精度：微秒，而poll是毫秒。</p><p><strong><em>\</em>poll——&gt;**</strong></p><p><strong><em>\</em>原理概述：**</strong></p><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p><p><strong><em>\</em>缺点：**</strong></p><p>1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义；</p><p>2、与select一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p><p><strong><em>\</em>优点：**</strong></p><p>1、poll() 不要求开发者计算最大文件描述符加一的大小。</p><p>2、poll() 在应付大数目的文件描述符的时候速度更快，相比于select。</p><p>3、它没有最大连接数的限制，原因是它是基于链表来存储的。</p><p><strong><em>\</em>epoll——&gt;**</strong></p><p><strong><em>\</em>原理概述：**</strong></p><p>epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时， 返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一 个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射技术，这 样便彻底省掉了这些文件描述符在系统调用时复制的开销。 </p><p><strong><em>\</em>epoll的优点就是改进了前面所说缺点：**</strong></p><p>1、支持一个进程打开大数目的socket描述符：相比select，epoll则没有对FD的限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</p><p>2、IO效率不随FD数目增加而线性下降：epoll不存在这个问题，它只会对”活跃”的socket进行操作—- 这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有”活跃”的socket才会主动的去调用 callback函数，其他idle状态socket则不会，在这点上，epoll实现了一个”伪”AIO，因为这时候推动力在os内核。在一些 benchmark中，如果所有的socket基本上都是活跃的—-比如一个高速LAN环境，epoll并不比select/poll有什么效率，相 反，如果过多使用epoll_ctl,效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境,epoll的效率就远在select/poll之上了。</p><p>3、使用mmap加速内核与用户空间的消息传递：这点实际上涉及到epoll的具体实现了。无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就 很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的。</p><p><strong><em>\</em>三者对比与区别：**</strong></p><p>   1、select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p><p>​    2、select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p><hr><h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><h3 id="线程和进程区别-线程可以脱离进程单独运行吗"><a href="#线程和进程区别-线程可以脱离进程单独运行吗" class="headerlink" title="线程和进程区别,线程可以脱离进程单独运行吗?"></a>线程和进程区别,线程可以脱离进程单独运行吗?</h3><p><strong>1.定义</strong></p><p>进程:具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</p><p>线程:进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p><p><strong>2.关系</strong></p><p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p><p>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的<strong>栈空间</strong>，拥有独立的<strong>执行序列</strong>。</p><p><strong>3.区别</strong></p><p>　　进程和线程的主要差别在于它们是<strong>不同的操作系统资源管理方式</strong>。进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。<strong>但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</strong></p><p><strong>1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</strong></p><p>2) 线程的划分尺度小于进程，使得多线程程序的并发性高。</p><p>3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p><p>4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。<strong>但是线程不能够独立执行，</strong>必须依存在应用程序中，由应用程序提供多个线程执行控制。</p><p>5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。</p><p>6)体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。</p><p>7)属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符。而不同过的进程相互独立。</p><p>8)线程又称为轻量级进程，进程有进程控制块，线程有线程控制块。</p><p>9)线程必定也只能属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程。</p><hr><h3 id="死锁概念-他的四个必要条件-什么是资源独占"><a href="#死锁概念-他的四个必要条件-什么是资源独占" class="headerlink" title="死锁概念,他的四个必要条件,什么是资源独占"></a>死锁概念,他的四个必要条件,什么是资源独占</h3><ul><li>互斥条件：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。</li><li>不可剥夺条件：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。</li><li>请求和保持条件：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。</li><li>循环等待条件：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源。<br>以上给出了导致死锁的四个必要条件，只要系统发生死锁则以上四个条件至少有一个成立。事实上<strong>循环等待</strong>的成立蕴含了前三个条件的成立，似乎没有必要列出然而考虑这些条件对死锁的预防是有利的，因为可以通过破坏四个条件中的任何一个来预防死锁的发生。</li></ul><p>1.临界资源：我们将一次只允许一个进程使用的资源成为临界资源，临界资源又名 独占资源。</p><p>2.临界区：进程中访问临界资源的那段代码，称为临界区，又名 临界段。</p><hr><h3 id="什么是僵尸进程"><a href="#什么是僵尸进程" class="headerlink" title="什么是僵尸进程"></a>什么是僵尸进程</h3><p>我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。</p><p>　　<strong>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p><p>　　<strong>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</strong></p><p>由于子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程 到底什么时候结束. 那么会不会因为父进程太忙来不及wait子进程，或者说不知道 子进程什么时候结束，而丢失子进程结束时的状态信息呢? 不会。因为UNⅨ提供了一种机制可以保证只要<a href="https://baike.baidu.com/item/父进程">父进程</a>想知道子进程结束时的状态信息， 就可以得到。这种机制就是： 在每个进程退出的时候，<a href="https://baike.baidu.com/item/内核">内核</a>释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息（包括进程号the process ID，退出状态the termination status of the process，运行时间the amount of CPU time taken by the process等）。直到<a href="https://baike.baidu.com/item/父进程">父进程</a>通过wait / waitpid来取时才释放. 但这样就导致了问题，如果进程不调用wait / waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生<a href="https://baike.baidu.com/item/僵尸进程">僵尸进程</a>，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</p><p><strong>孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上</strong>，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。<strong>因此孤儿进程并不会有什么危害。</strong></p><p>　　<strong>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。</strong>这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p><p><strong>僵尸进程的避免</strong></p><p>⒈父进程通过wait和waitpid等函数等待子进程结束，这会导致父进程挂起。</p><p>⒉ 如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler，因为子进程结束后， 父进程会收到该信号，可以在handler中调用wait回收。</p><p>⒊ 如果<a href="https://baike.baidu.com/item/父进程">父进程</a>不关心子进程什么时候结束，那么可以用signal（SIGCHLD,SIG_IGN） 通知<a href="https://baike.baidu.com/item/内核">内核</a>，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收， 并不再给父进程发送信号。</p><p>⒋ 还有一些技巧，就是fork两次，父进程fork一个子进程，然后继续工作，子进程fork一 个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收 还要自己做。</p><hr><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p><strong>协程是一种用户态的轻量级线程，</strong>协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p><p>1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。</p><p>2) 线程进程都是同步机制，而协程则是异步</p><p>3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</p><p>协程的特点：</p><ol><li>线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换。</li><li>线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程。</li><li>由于在同一个线程上，因此可以避免竞争关系而使用锁。</li></ol><p>协程是怎么来处理的呢，就是对于一个阻塞的业务操作，我们不是用线程来处理，而是用用协程，这样当出现IO阻塞的时候，并且你还没运行完时间片，你不会让CPU跑掉，而是调起你的另一个协程任务，让他继续进行计算。而通常我们知道，代码纯计算执行是非常快的，5ms可能跑了N个方法了，因此这样充分的利用时间片，并且减少CPU切换的时间。</p><hr><h3 id="多线程和线程池"><a href="#多线程和线程池" class="headerlink" title="多线程和线程池"></a>多线程和线程池</h3><p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的<a href="https://baike.baidu.com/item/堆栈/1682032">堆栈</a>大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在<a href="https://baike.baidu.com/item/托管代码/2886980">托管代码</a>中空闲（如正在等待某个事件）,则线程池将插入另一个<a href="https://baike.baidu.com/item/辅助线程/4746601">辅助线程</a>来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p><p>线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。 例如，线程数一般取cpu数量+2比较合适，线程数过多会导致额外的线程切换开销。</p><p>任务调度以执行线程的常见方法是使用同步队列，称作任务队列。池中的线程等待队列中的任务，并把执行完的任务放入完成队列中。</p><p>线程池模式一般分为两种：HS/HA半同步/半异步模式、L/F领导者与跟随者模式。</p><ul><li>半同步/半异步模式又称为生产者消费者模式，是比较常见的实现方式，比较简单。分为同步层、队列层、异步层三层。同步层的主线程处理工作任务并存入工作队列，工作线程从工作队列取出任务进行处理，如果工作队列为空，则取不到任务的工作线程进入挂起状态。由于线程间有数据通信，因此不适于大数据量交换的场合。</li><li>领导者跟随者模式，在线程池中的线程可处在3种状态之一：领导者leader、追随者follower或工作者processor。任何时刻线程池只有一个领导者线程。事件到达时，领导者线程负责消息分离，并从处于追随者线程中选出一个来当继任领导者，然后将自身设置为工作者状态去处置该事件。处理完毕后工作者线程将自身的状态置为追随者。这一模式实现复杂，但避免了线程间交换任务数据，提高了CPU cache相似性。在<a href="https://baike.baidu.com/item/ACE">ACE</a>(Adaptive Communication Environment)中，提供了领导者跟随者模式实现。</li></ul><p>线程池的<a href="https://baike.baidu.com/item/伸缩性">伸缩性</a>对性能有较大的影响。</p><ul><li>创建太多线程，将会浪费一定的资源，有些线程未被充分使用。</li><li>销毁太多线程，将导致之后浪费时间再次创建它们。</li><li>创建线程太慢，将会导致长时间的等待，性能变差。</li><li>销毁线程太慢，导致其它线程<a href="https://baike.baidu.com/item/资源">资源</a>饥饿。 </li></ul><hr><h3 id="进程间有什么通讯方式"><a href="#进程间有什么通讯方式" class="headerlink" title="进程间有什么通讯方式"></a>进程间有什么通讯方式</h3><p>1、管道</p><p>我们来看一条 Linux 的语句</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tulnp <span class="string">| grep 8080</span></span><br></pre></td></tr></table></figure><p>学过 Linux 命名的估计都懂这条语句的含义，其中”|“是<strong>管道</strong>的意思，它的作用就是把前一条命令的输出作为后一条命令的输入。在这里就是把 netstat -tulnp 的输出结果作为 grep 8080 这条命令的输入。如果两个进程要进行通信的话，就可以用这种<strong>管道</strong>来进行通信了，并且我们可以知道这条<strong>竖线</strong>是没有名字的，所以我们把这种通信方式称之为<strong>匿名管道</strong>。</p><p>并且这种通信方式是<strong>单向</strong>的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道。</p><p>居然有匿名管道，那也意味着有<strong>命名</strong>管道，下面我们来创建一个命名管道。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span>  <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>这条命令创建了一个名字为 test 的命名管道。</p><p>接下来我们用一个进程向这个管道里面写数据，然后有另外一个进程把里面的数据读出来。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;this is a pipe&quot;</span> &gt; test   <span class="regexp">//</span> 写数据</span><br></pre></td></tr></table></figure><p>这个时候管道的内容没有被读出的话，那么这个命令就会一直停在这里，只有当另外一个进程把 test 里面的内容读出来的时候这条命令才会结束。接下来我们用另外一个进程来读取</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cat</span> &lt; <span class="keyword">test</span>  <span class="comment">// 读数据</span></span><br></pre></td></tr></table></figure><p>我们可以看到，test 里面的数据被读取出来了。上一条命令也执行结束了。</p><p>从上面的例子可以看出，管道的通知机制类似于<strong>缓存</strong>，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，并且是管道是<strong>单向传输的。</strong></p><p>这种通信方式有什么缺点呢？显然，这种通信方式<strong>效率低下</strong>，你看，a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回。</p><p>所以管道不适合频繁通信的进程。当然，他也有它的优点，例如比较简单，能够保证我们的数据已经真的被其他进程拿走了。我们平时用 Linux 的时候，也算是经常用。</p><p>2、消息队列</p><p>那我们能不能把进程的数据放在某个内存之后就马上让进程返回呢？无需等待其他进程来取就返回呢？</p><p>答是可以的，我们可以用<strong>消息队列</strong>的通信模式来解决这个问题，例如 a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的<br>消息队列里取出来。同理，b 进程要个 a 进程发送消息也是一样。这种通信方式也类似于<strong>缓存</strong>吧。</p><p>这种通信方式有缺点吗？答是有的，如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了。因为 a 发送的数据很大的话，意味<strong>发送消息（拷贝）</strong>这个过程需要花很多时间来读内存。</p><p>哪有没有什么解决方案呢？答是有的，请继续往下看。</p><p>3、共享内存</p><p><strong>共享内存</strong>这个通信方式就可以很好着解决<strong>拷贝</strong>所消耗的时间了。</p><p>这个可能有人会问了，每个进程不是有自己的独立内存吗？两个进程怎么就可以共享一块内存了？</p><p>我们都知道，系统加载一个进程的时候，分配给进程的内存并不是<strong>实际物理内存</strong>，而是<strong>虚拟内存空间</strong>。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了<strong>内存共享</strong>机制了。</p><p>4、信号量</p><p>共享内存最大的问题是什么？没错，就是多进程竞争内存的问题，就像类似于我们平时说的<strong>线程安全</strong>问题。如何解决这个问题？这个时候我们的<strong>信号量</strong>就上场了。</p><p>信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问<strong>内存1</strong>的时候，我们就把信号量的值设为 0，然后进程b 也要来访问<strong>内存1</strong>的时候，看到信号量的值为 0 就知道已经有进程在访问<strong>内存1</strong>了，这个时候进程 b 就会访问不了<strong>内存1</strong>。所以说，信号量也是进程之间的一种通信方式。</p><p>5、Socket</p><p>上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？</p><p>答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。</p><p>总结</p><p>所以，进程之间的通信方式有：</p><p>1、管道</p><p>2、消息队列</p><p>3、共享内存</p><p>4、信号量</p><p>5、Socket</p><hr><h3 id="虚拟内存-页表"><a href="#虚拟内存-页表" class="headerlink" title="虚拟内存 页表"></a>虚拟内存 页表</h3><p>每条指令在被执行时，读取操作数时需要给出操作数所在的内存地址，这个地址不能是物理主存地址，因为<strong>该程序在哪种硬件设置的机器上运行并不能事前确定，那操作系统就不能在此给出对应于某台机器的物理地址</strong>。</p><p><strong>一、物理内存和虚拟内存</strong></p><p>我们先来了解一下，什么是物理内存，什么又是虚拟内存？<br><strong>1.物理内存</strong>：指通过物理内存条而获得的内存空间，主要作用是在计算机运行时为操作系统和各种程序提供临时储存。<br><strong>2.虚拟内存</strong>：对内存架构(内存、缓存、硬盘)进行管理(<strong>内存管理</strong>系统)的一种手段。简单理解就是在硬盘上划分出一块区域作为内存使用。</p><p>2.1 对于用户：<br>计算机主要面向的是对操作系统等计算机知识几乎没有了解的普通大众，他们大多是不了解什么主存外存的，所以为了<strong>方便用户的使用</strong>，就有必要使得程序不管是位于内存架构的哪个层次，对于用户来说都是一样的。<strong>虚拟内存就是让内存管理实现媒介透明的手段</strong>。</p><p>2.2 对于主存：<br>众所周知，一个程序要想运行，就必须加载到物理主存(内存)中，但是<strong>物理主存的容量是非常有限的</strong>，我们当然可以选择购买更大的物理主存，可是很费钱，那么还有没有什么办法可以在不明显增加成本的基础上扩大内存容量的呢？<br>虚拟内存就可以做到，它的手段就是<strong>将物理主存扩大到便宜、容量大的磁盘上，即将磁盘空间也看作是主存空间的一部分</strong>。</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20171104153250986" alt="这里写图片描述"></p><p><strong>用户程序可以存放在主存，也可以部分存放在主存、部分存放在磁盘</strong>，那么程序发出的地址到底是在哪里是由操作系统的内存管理模块负责的。</p><p>虚拟内存让用户“感觉”内存容量大大增加了，内存速度也加快了，就像魔法师一样，让观众觉得小箱子能够“装下”一只巨大的雄狮。</p><p><strong>二、内存管理——分页内存管理</strong></p><p><strong>1.内存管理使用的方法</strong></p><p>内存管理的方法有许多种，固定加载地址的、固定分区的、非固定分区的和<strong>交换内存管理</strong>，其中只有第一种固定加载地址的内存管理适用于单道编程，其余三种则适合<strong>多道编程</strong>。与此同时，它们的共同实现机制是——<strong>基址和极限</strong>。</p><p><strong>2.交换内存管理中的机制——基址和极限</strong></p><p>交换内存管理是这些方法中最灵活的。它使用的基址和极限机制实际上就是“<strong>将程序发出的虚拟地址加上基址得到物理地址</strong>”。</p><p>见下图：<br><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20171104150653809" alt="这里写图片描述"></p><p><strong>3.交换内存管理的两大问题</strong></p><p>3.1 空间浪费：程序不断的执行并释放的过程中，造成了内存空间中的可用空间不连续就，难以加以应用，这种现象也称为“外部碎片化”。<br>见下图：</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20171104145803969" alt="这里写图片描述"></p><p>3.2 程序大小受限<br>当程序需要更多的内存空间时，需要将其全部从物理内存中“倒出”到磁盘上，再在内存中找到更大的一片区域去存放增长了的程序，这样使得<strong>程序的增长效率低下</strong>。同时，一个程序的大小还不能超过物理内存空间的大小。</p><p><strong>4. 解决方法——分页内存管理</strong></p><p>4.1 分页内存管理<br><strong>将虚拟内存空间和物理内存空间皆划分成大小相同的页面</strong>，例如4KB、8KB和16KB等。并将<strong>页作为内存空间的最小分配单位</strong>，一个程序的一个页面(虚拟页面)可以存放在任何一个物理页面中。</p><p>一个程序发出的虚拟地址由<strong>虚拟页面号</strong>和<strong>页内偏移值</strong>两部分组成，组成见下：<br><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20171104143925766" alt="这里写图片描述"></p><p><strong>4.2 分页内存管理是如何解决交换内存管理中的两个问题的？</strong></p><p>1.空间浪费：通过将内存空间划分成大小一样的页面，并且将其作为内存分配的基本单位，这样就避免了大量外部碎片的积累，让内存空间得到有效利用。</p><p>2.程序受限：分页内存管理下，允许一个进程的部分虚拟页面存放在物理压面(物理内存)中，另一部分存放在磁盘上，等到需要使用时再将其从磁盘中加载到物理内存中。也就是说，<strong>当程序需要额外的空间时，只需要对其分配新的页即可</strong>，这样做使得程序的增长效率较高。</p><p>4.3 虚拟地址-&gt;物理地址的转化(地址翻译)</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20171104153228649" alt="这里写图片描述"><br>翻译工作则是交给<strong>MMU(内存管理单元</strong>)，它只对虚拟地址的<strong>页面号进行翻译</strong>，而<strong>不处理页内偏移值</strong>。</p><p>MMU为每一个程序都配备了一个页表，里面<strong>存放的是虚拟页面到物理页面的映射</strong>，如果MMU接收到了程序发出的虚拟地址，在查找相对应的物理页面号时，<strong>没有找到</strong>，那么将会通过<strong>缺页中断</strong>来将需要的虚拟页面从磁盘中加载到物理内存的页面中。</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20171104155233026" alt="这里写图片描述"></p><p>并且随着虚拟页面的进出内存，<strong>页表的内容也是不断地变化</strong>的。</p><p>4.4 页表中的具体信息<br>MMU为每一个程序配备的页表除了有虚拟地址到物理地址的映射(虚拟页面号到物理页面号)，还有其他的<strong>与页面的管理活动有关的信息</strong>，因为mmu要依赖页表来进行与页面相关的管理活动。</p><p>例如，页表如何知道需要的虚拟页面是否在物理页面中？那么<strong>页表中就有一项信息记录的是该虚拟页面是否在当前的物理页面中——在内存否</strong>。<br>再说，有一些虚拟页面是受到保护的，对它的读、写和执行操作是有限制的，记录该页面的保护信息的则是——保护标识区。<br>等等。</p><p>可以参考下图中，页表中存储的具体内容：</p><p><img src="/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/20171104155825300" alt="这里写图片描述"></p><hr><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><p><a href="https://www.jianshu.com/p/673c9e4817a8">https://www.jianshu.com/p/673c9e4817a8</a></p><p><a href="https://blog.csdn.net/u011080472/article/details/51217754">https://blog.csdn.net/u011080472/article/details/51217754</a></p><ul><li>先来先服务</li><li>短作业优先</li><li>最短剩余时间优先</li><li>高相应比优先</li><li>优先级</li><li>时间片轮转</li></ul><hr><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p><a href="https://blog.csdn.net/jankin6/article/details/78179320">https://blog.csdn.net/jankin6/article/details/78179320</a></p><hr><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="B-树与红黑树的区别"><a href="#B-树与红黑树的区别" class="headerlink" title="B+树与红黑树的区别"></a>B+树与红黑树的区别</h3><p><strong>红黑树：带有平衡性的二叉搜索树增强版</strong></p><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:</p><p>　　性质1. 节点是红色或黑色。</p><p>　　性质2. 根节点是黑色。</p><p>　　性质3 每个叶节点是黑色的。</p><p>　　性质4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p><p>　　性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p><p>这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。</p><p>要知道为什么这些特性确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</p><p>考虑一棵黑色高度为3的红黑树：从根结点到叶结点的最短路径长度显然是2(黑-黑-黑)，最长路径为4(黑-红-黑-红-黑)。由于性质4，不可能在最长路经中加入更多的黑色 结点， 此外根据性质3，红色结点的子结点必须是黑色的，因此在同一简单路径中不允许有两个连续的红色结点。综上，我们能够建立的最长路经将是一个红黑交替的路径。</p><p>由此我们可以得出结论：<strong>对于给定的黑色高度为n的红黑树，从根到叶结点的简单路径的最短长度为n-1，最大长度为2(n-1)。</strong></p><p><strong>B, B-, B+树总结：</strong></p><p>B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</p><p>B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；<strong>（关键字可以在非叶子节点和叶子节点）M指的是树的阶数</strong></p><p>B+树：在B-树基础上，为叶子结点增加链表指针，<strong>所有关键字都在叶子结点中出现</strong>，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p><p> B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</p><p>性能比较：</p><p>性能相当，都等价于在关键字全集做一次二分查找；</p><p>B-树 改善了B树的平衡问题，</p><p>B+树比 B-树 更适合文件索引系统(结构上的改善)，</p><p>B*树比B+树改善了空间利用率。</p><p>红黑树：</p><p>(1)并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树能够以O(log2 n) 的时间复杂度进行搜索、插入、删除操作。</p><p>(2)此外，由于它的设计，任何不平衡都会在三次旋转之内解决。红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高。</p><p>B树</p><p>二叉排序树（Binary Sort Tree）又称二叉查找（二路搜索）树，也叫B树。　　它或者是一棵空树；或者是具有下列性质的二叉树：　　</p><p>(1)若左子树不空，则左子树上所有结点的值均小于左子树所在树的根结点的值；　　</p><p>(2)若右子树不空，则右子树上所有结点的值均大于右子树所在树的根结点的值；</p><p>(3)左、右子树也分别为二叉排序树；</p><p>B树的特点：</p><p>1.所有非叶子结点至多拥有两个儿子（Left和Right）；</p><p>2.所有结点存储一个关键字；</p><p>3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</p><p>B树的搜索：从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；如果B树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么B树的搜索性能逼近二分查找</p><p>B-树</p><p>B-树是一种平衡的<strong>多路查找树</strong>，在文件系统中有所应用。<strong>主要用作文件的索引</strong>。</p><p>B-树是一种多路搜索树（并不是二叉的）：</p><p>​    1.定义任意非叶子结点最多只有M个儿子；且M&gt;2；</p><p>​    2.根结点的儿子数为[2, M]；</p><p>​    3.除根结点以外的非叶子结点的儿子数为[M/2, M]；</p><p>​    4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</p><p>​    5.非叶子结点的关键字个数=指向儿子的指针个数-1；</p><p>​    6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</p><p>​    7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</p><p>​    8.所有叶子结点位于同一层；如：（M=3）</p><p> B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；</p><p>B-树的特性： </p><p>​      1.<strong>关键字集合分布在整颗树中；</strong></p><p>​      2.任何一个关键字出现且只出现在一个结点中；</p><p>​      3.搜索有可能在非叶子结点结束；</p><p>​      4.其搜索性能等价于在关键字全集内做一次二分查找；</p><p>​      5.自动层次控制；</p><p>B+树</p><p>B+树是应文件系统所需而出的一种B-树的变型树。</p><p>B+树是B-树的变体，也是一种多路搜索树：</p><p>​             1.其定义基本与B-树同，除了：</p><p>​            2<strong>.非叶子结点的子树指针与关键字个数相同；</strong></p><p>​            3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</p><p>​           4.为所有叶子结点增加一个链指针；</p><p>​           5.<strong>所有关键字都在叶子结点出现；</strong></p><p>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p><p>B+的特性： 1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</p><p>​             2.不可能在非叶子结点命中；</p><p>​             3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</p><p>​            4.更适合文件索引系统；</p><p><strong>B树和B+树的区别</strong></p><p>B/B+树用在磁盘文件组织、数据索引和数据库索引中。其中B+树比B 树更适合实际应用中操作系统的文件索引和数据库索引，因为：</p><p>1、B+树的磁盘读写代价更低</p><p>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p>2、B+-tree的查询效率更加稳定</p><p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><p>3、B树在元素遍历的时候效率较低</p><p>B+树只要遍历叶子节点就可以实现整棵树的遍历。在数据库中基于范围的查询相对频繁，所以此时B+树优于B树。</p><p>??一言而知就是树的深度较高，在磁盘I/O方面的表现不如B树。</p><p>??要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定。</p><p>??所以，在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。在这方面，B树表现相对优异，B树可以有多个子女，从几十到上千，可以降低树的高度。</p><hr><h3 id="共享内存与Socket的优缺点与性能比较"><a href="#共享内存与Socket的优缺点与性能比较" class="headerlink" title="共享内存与Socket的优缺点与性能比较"></a>共享内存与Socket的优缺点与性能比较</h3><p>要使用一块共享内存，进程必须首先分配它。随后需要访问这个共享内存块的每一个进程都必须将这个共享内存绑定到自己的地址空间中。当完成通信之后，所有进程都将脱离共享内存，并且由一个进程释放该共享内存块。理解 Linux 系统内存模型可以有助于解释这个绑定的过程。在 Linux 系统中，每个进程的虚拟内存是被分为许多页面的。这些内存页面中包含了实际的数据。每个进程都会维护一个从内存地址到虚拟内存页面之间的映射关系。尽管每个进程都有自己的内存地址，不同的进程可以同时将同一个内存页面映射到自己的地址空间中，从而达到共享内存的目的。分配一个新的共享内存块会创建新的内存页面。因为所有进程都希望共享对同一块内存的访问，只应由一个进程创建一块新的共享内存。再次分配一块已经存在的内存块不会创建新的页面，而只是会返回一个标识该内存块的标识符。一个进程如需使用这个共享内存块，则首先需要将它绑定到自己的地址空间中。这样会创建一个从进程本身虚拟地址到共享页面的映射关系。当对共享内存的使用结束之后，这个映射关系将被删除。当再也没有进程需要使用这个共享内存块的时候，必须有一个（且只能是一个）进程负责释放这个被共享的内存页面。</p><p>共享内存号称是最快的进程间通信方式，她在系统内存中开辟一块内存区，分别映射到各个进程的虚拟地址空间中，任何一个进程操作了内存区都会反映到其他进程中，各个进程之间的通信并没有像copy数据一样从内核到用户，再从用户到内核的拷贝。这种方式可以像访问自己的私有空间一样访问共享内存区，但是这事这种特性加大了共享内存的编程难度，对于数据的同步问题是一个难点，没有一定的经验很 容易造成数据的混乱。但是我们可以使用一个折中的方法，我们可以结合它和管道来使用。</p><p>这样就不会因为，多个进程同时鞋一块内存造成数据的混乱了，看起来是不是有点像管道，其实就是管道的机制，但是不同的是，她的速度要比管道快的多，他的数据大小没有限制（当然不能超过系统的内存大小），当然也不会有阻塞问题。但是这种方式也有明显的缺点，它只适合点对点的通信，如果要多个进程间通信，内存区的数量会呈线性增长，会造成数据的冗余，并且管理起来也会变得困难,如果你的进程数量在各位数着中方式是一个好的选择，否则就要采用一块共享内存，同时做好数据的同步了。</p><p>它是基于内存的，所以他只能在同一主机上使用，如果我们要做分布式应用或者跨物理机通信，那么socket就是我们唯一的选择了。</p><p>共享内存通信(SHARED MEMORY)<br>   针对消息缓冲需要占用CPU进行消息复制的缺点．OS提供了一种进程间直接进行数据交换的通信方式一共享内存 顾名思义．这种通信方式允许多个进程在外部通信协议或同步，互斥机制的支持下使用同一个内存段(作为中间介质)进行通信．它是一种最有效的数据通信方式，其特点是没有中间环节．直接将共享的内存页面通过附接．映射到相互通信的进程各自的虚拟地址空间中．从而使多个进程可以直接访问同一个物理内存页面．如同访问自己的私有空间一样(但实质上不是私有的而是共享的)。因此这种进程间通信方式是在同一个计算机系统中的诸进程间实现通信的最快捷的方法．而它的局限性也在于此．即共享内存的诸进程必须共处同一个计算机系统．有物理内存可以共享才行。</p><p>共享内存针对消息缓冲的缺点改而利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。但是共享内存的通信方式是通过将共享的内存缓冲区直接附加到进程的虚拟地址空间中来实现的．因此，这些进程之间的读写操作的同步问题操作系统无法实现。必须由各进程利用其他同步工具解决。另外，由于内存实体存在于计算机系统中．所以只能由处于同一个计算机系统中的诸进程共享。不方便网络通信。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="帧率，比特率，分辨率"><a href="#帧率，比特率，分辨率" class="headerlink" title="帧率，比特率，分辨率"></a>帧率，比特率，分辨率</h3><p><strong>帧速率</strong></p><p>帧速率也称为FPS(Frames PerSecond)的缩写——帧/秒。是指每秒钟刷新的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次。越高的帧速率可以得到更流畅、更逼真的动画。每秒钟帧数(FPS)越多，所显示的动作就会越流畅。</p><p><strong>比特率</strong></p><p>比特率是指每秒传送的比特(bit)数。单位为bps(Bit Per Second)，比特率越高，传送的数据越大。在视频领域,比特率常翻译为码率 !!!</p><p>比特率表示经过编码（压缩）后的音、视频数据每秒钟需要用多少个比特来表示，而比特就是二进制里面最小的单位，要么是0，要么是1。比特率与音、视频压缩的关系，简单的说就是比特率越高，音、视频的质量就越好，但编码后的文件就越大；如果比特率越少则情况刚好相反。</p><p>比特率是指将数字声音、视频由模拟格式转化成数字格式的采样率，采样率越高，还原后的音质、画质就越好。</p><p>常见编码模式：</p><p>VBR（Variable Bitrate）动态比特率 也就是没有固定的比特率，压缩软件在压缩时根据音频数据即时确定使用什么比特率，这是以质量为前提兼顾文件大小的方式，推荐编码模式；</p><p>ABR（Average Bitrate）平均比特率 是VBR的一种插值参数。LAME针对CBR不佳的文件体积比和VBR生成文件大小不定的特点独创了这种编码模式。ABR在指定的文件大小内，以每50帧（30帧约1秒）为一段，低频和不敏感频率使用相对低的流量，高频和大动态表现时使用高流量，可以做为VBR和CBR的一种折衷选择。</p><p>CBR（Constant Bitrate），常数比特率 指文件从头到尾都是一种位速率。相对于VBR和ABR来讲，它压缩出来的文件体积很大，而且音质相对于VBR和ABR不会有明显的提高。</p><p><strong>分辨率</strong> </p><p>就是帧大小每一帧就是一副图像。</p><p>720p对应的分辨率为像素1280*720=92w像素</p><p>1080p对应的分辨率为1920*1080=207w像素</p><p>640*480分辨率的视频，建议视频的码速率设置在700以上，音频采样率44100就行了</p><p>一个音频编码率为128Kbps，视频编码率为800Kbps的文件，其总编码率为928Kbps，意思是经过编码后的数据每秒钟需要用928K比特来表示。</p><p>计算输出文件大小公式：<br>（音频编码率（KBit为单位）/8 +视频编码率（KBit为单位）/8）×影片总长度（秒为单位）=文件大小（MB为单位）</p><p>电影一般是24帧的，24帧的视频就能满足人眼，然后大家墨守成规，同时为了音画同步，大家就都统一使用24帧的画面。即便是在数字时代，更高的帧数依然需要高昂的成本，24帧依然是主流。当然也有一些例外，如《霍比特人》使用了48帧技术，《比利林恩的中场故事》使用了120帧技术。更高的帧数会有什么效果呢？可以在b站就可以找到很多60帧视频。李安使用4K加取120 帧技术绝对是一项技术革命，从光源，到播放技术，到演员的表演，因为在这种清晰度下真的是毫发毕现，但是这也造成了一种电视剧感，因为我们理解的电影就因为是有一种距离感，一种old school的美学。为什么帧率越高越清晰呢？电影不是连续曝光，24帧是在一秒内拍摄了24张照片，但是不是说每一张照片的曝光时间就是1/24秒，曝光时间应该是1/48秒。曝光时间是通过叫做叶子板的半圆形装置进行的，通过改变开角就可以调整曝光时间，可以理解为快门。只要快门时间不为0，理论上就会造成残影。更高的帧率就代表了每一张照片的曝光时间更短，对比于30帧的视频，60帧的视频中每一幅画面的快门时间更短，造成的模糊效应更小，所以虽然分辨率没有改变，但是视频更加清晰。</p><p>电视剧等电视节目与电影除了美学方面的区别，还有很多技术方面的区别：电视的显像管的扫描方式是隔行扫描，而即便是胶片电影，其形成的数字中间片是逐行扫描的；在帧率方面，PAL和SECAM制式是25fps，在美国等一些国家使用的电视扫描频率是59.94Hz，帧率是29.97fps。</p><p>我国和大多数欧洲国家使用的交流电是50Hz，由于采用隔行扫描，在PAL或者SECAM视频标准中播放是25 frames per second(fps)，PAL标准中为电视节目录制的电影也是25 frames per second，所以对于每一个film frame，捕获得到一个video frame。但是对于最初以24frames/s拍摄的电影，在播放时要加快1/24来匹配，这样就会导致声音不同步，需要使用音高变换器进行校正。使用pulldown方法可以避免加速的过程。为了适应mismatch，需要将24电影帧分配在50个PAL fields中。</p><p>NTSC制下交流电频率信号是60Hz，而如果采用间隔扫描下，其实每秒是30张图片，就是30fps，为了把信号和载波区分开，频率降低千分之一，变成了29.97fps。而在电影上播放时，要变成24帧，问题是你不能随便删掉开头的6帧或者结尾的6帧，这样画面会变得很不连续，所以就想出一个方法，叫做2：3pulldown，硬是把5帧的内容缩成了4帧第一个电影帧显示两次，第二帧显示3次，第三帧又显示两次，按照这个规律循环，这样29.97*4/5就是23.976fps了。</p><p><strong>隔行扫描</strong></p><p>　　每一帧被分割为两场，每一场包含了一帧中所有的奇数扫描行或者偶数扫描行，通常是先扫描奇数行得到第一场，然后扫描偶数行得到第二场。</p><p>　　无论是逐行扫描还是隔行扫描，都有视频文件、传输和显像三个概念，这三个概念相通但不相同。最早出现的是隔行扫描显像，同时就配套产生了隔行传输。而隔行扫描视频文件是到数字视频时代才出现的，其目的是为了兼容原有的隔行扫描体系(隔行扫描还依然在广泛应用)。</p><p>　　通常显示器分“隔行扫描” 和 “逐行扫描”两种扫描方式。逐行扫描相对于隔行扫描是一种先进的扫描方式，它是指显示屏显示图像进行扫描时，从屏幕左上角的第一行开始逐行进行，整个图像扫描一次完成。因此图像显示画面闪烁小，显示效果好。先进的显示器大都采用逐行扫描方式。</p><p>　　隔行扫描情况下，由于视觉暂留效应，人眼将会看到平滑的运动而不是闪动的半帧半帧的图像。但是这种方法造成了两幅图像显示的时间间隔比较大，从而导致图像画面闪烁较大。 因此该种扫描方式较为落后，通常用在早期的显示产品中。</p><p>每一帧图像由电子束顺序地一行接着一行连续扫描而成，这种扫描方式称为逐行扫描。把每一帧图像通过两场扫描完成则是隔行扫描，两场扫描中，第一场(奇数场)只扫描奇数行，依次扫描1、3、5…行，而第二场(偶数场)只扫描偶数行，依次扫描2、4、6…行。隔行扫描技术在传送信号带宽不够的情况下起了很大作用，逐行扫描和隔行扫描的显示效果主要区别在稳定性上面，隔行扫描的行间闪烁比较明显，逐行扫描克服了隔行扫描的缺点，画面平滑自然无闪烁。</p><hr><h3 id="高数据库读写效率"><a href="#高数据库读写效率" class="headerlink" title="高数据库读写效率"></a>高数据库读写效率</h3><p>可以从以下多个方面优化数据库设计提高数据库查询效率</p><p>a. 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><p>b. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0</p><p>c. 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时,查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p><p>d. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p><p>e. 应尽可能的避免更新索引数据列，因为索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新索引数据列，那么需要考虑是否应将该索引建为索引。</p><p>f. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><p>g. 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><p>h. 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p><p>i. 避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><p>j. 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p><p>k. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p><p>l. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p><p>可以从以下多个方面比较数据库写入效率：</p><p>一、普通方式 </p><p>​    普通采用jdbc插入</p><p>​    时间:10万条:16672ms 折合100万条 = 166.72秒</p><p>二、事务提交 </p><p>​    jdbc用事务进行提交  —&gt; 事务提交是把语句一起执行</p><p>​    时间:10万条:13558ms 折合100万条 = 135.5秒</p><p>三、批处理</p><p>​    内部实现是是把 values 后面的插入值变成成 values(,,,),(,,,,)<br>​    特别注意:需要url参数加:rewriteBatchedStatements=true<br>​    url范例: jdbc:mysql://127.0.0.1/XXX?characterEncoding=UTF-8&amp;rewriteBatchedStatements=true<br>​    时间 : 10万条:1273ms 折合100万条 = 12.73秒 </p><p>四、事务+批处理并且分批执行</p><p>​    结论:加事务时间无影响，但是分批次能提供效率的增加</p><p>​    时间:100万条:9900ms 折合100万条 = 9.99秒</p><p>​    时间:500万条:46943ms = 47秒</p><p>综合以上比较结论是: 普通方式 &lt; 事务提交 &lt; 批处理 &lt; 事务+批处理</p><p>必要的话配合存储过程应该会进一步提升效率，，，</p><p>最后就是在系统架构设计上实施分库分表，再配合外部存储比如redis、缓存、队列等优化对数据库的压力</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;JAVA&quot;&gt;&lt;a href=&quot;#JAVA&quot; class=&quot;headerlink&quot; title=&quot;JAVA&quot;&gt;&lt;/a&gt;JAVA&lt;/h2&gt;&lt;h3 id=&quot;堆和栈的区别&quot;&gt;&lt;a href=&quot;#堆和栈的区别&quot; class=&quot;headerlink&quot; title=&quot;堆和栈的区别&quot;&gt;&lt;/a&gt;堆和栈的区别&lt;/h3&gt;&lt;p&gt;栈内存:栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JAVA" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JAVA/"/>
    
    
    <category term="JAVA" scheme="http://yorxika.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>零钱兑换</title>
    <link href="http://yorxika.github.io/2020/03/13/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <id>http://yorxika.github.io/2020/03/13/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</id>
    <published>2020-03-13T15:36:30.000Z</published>
    <updated>2020-03-13T16:11:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第322题零钱兑换</p><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [1, 2, 5], amount = 11</span><br><span class="line">输出:<span class="number"> 3 </span></span><br><span class="line">解释:<span class="number"> 11 </span>=<span class="number"> 5 </span>+<span class="number"> 5 </span>+ 1</span><br></pre></td></tr></table></figure><hr><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>从面额最大的货币开始找零，并遍历完当前硬币数组，当剩余金额为0时返回上层搜索，当目前已用总数大于已知最小硬币数时也返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] coin;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line">        <span class="built_in">this</span>.coin = coins;</span><br><span class="line">        dfs(coin.length-<span class="number">1</span>,amount,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> amount,<span class="type">int</span> count)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="type">int</span> rest,tmp_count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> amount /coin[index];i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            rest = amount - i * coin[index];</span><br><span class="line">            tmp_count = count + i;</span><br><span class="line">            <span class="keyword">if</span>(rest == <span class="number">0</span>)&#123;</span><br><span class="line">                ans = Math.min(ans,tmp_count);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp_count + <span class="number">1</span> &gt;= ans)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            dfs(index-<span class="number">1</span>,rest,tmp_count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>来自<a href="https://leetcode-cn.com/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/">官方题解</a></p><p>仍定义 F(i) 为组成金额 <em>i</em> 所需最少的硬币数量，假设在计算 <em>F</em>(<em>i</em>) 之前，我们已经计算出 <em>F</em>(0)−<em>F</em>(<em>i</em>−1) 的答案。 则 <em>F</em>(<em>i</em>) 对应的转移方程应为</p><script type="math/tex; mode=display">F(i)=\min_{j=0 \ldots n-1}{F(i -c_j)} + 1</script><p>其中 $c_j$代表的是第 <em>j</em> 枚硬币的面值，即我们枚举最后一枚硬币面额是 $c_j$，那么需要从 $i-c_j$ 这个金额的状态 $F(i-c_j)$转移过来，再算上枚举的这枚硬币数量 1 的贡献，由于要硬币数量最少，所以 $F(i$)为前面能转移过来的状态的最小值加上枚举的硬币数量 1 。</p><p>例子1：假设</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">coins</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br></pre></td></tr></table></figure><p>则，当 $i==0$ 时无法用硬币组成，为 0 。当 $i&lt;0$时，忽略 $F(i)$</p><div class="table-container"><table><thead><tr><th>F(i)</th><th>最小硬币数量</th></tr></thead><tbody><tr><td>F(0)</td><td>0 //金额为0不能由硬币组成</td></tr><tr><td>F(1)</td><td>1 //$F(1)=min(F(1-1),F(1-2),F(1-5))+1=1$</td></tr><tr><td>F(2)</td><td>1 //$F(2)=min(F(2-1),F(2-2),F(2-5))+1=1$</td></tr><tr><td>F(3)</td><td>2 //$F(3)=min(F(3-1),F(3-2),F(3-5))+1=2$</td></tr><tr><td>F(4)</td><td>2 /$/F(4)=min(F(4-1),F(4-2),F(4-5))+1=2$</td></tr><tr><td>…</td><td>…</td></tr><tr><td>F(11)</td><td>3 //$F(11)=min(F(11-1),F(11-2),F(11-5))+1=3$</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> amount + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, max);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">          dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第322题零钱兑换&lt;/p&gt;
&lt;p&gt;给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 &lt;code&gt;-1&lt;/code&gt;。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="贪心" scheme="http://yorxika.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>字符串最大公因子</title>
    <link href="http://yorxika.github.io/2020/03/13/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/"/>
    <id>http://yorxika.github.io/2020/03/13/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/</id>
    <published>2020-03-13T15:19:24.000Z</published>
    <updated>2020-03-13T15:34:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第1071题字符串最大公因子</p><p>对于字符串 <code>S</code> 和 <code>T</code>，只有在 <code>S = T + ... + T</code>（<code>T</code> 与自身连接 1 次或多次）时，我们才认定 “<code>T</code> 能除尽 <code>S</code>”。</p><p>返回最长字符串 <code>X</code>，要求满足 <code>X</code> 能除尽 <code>str1</code> 且 <code>X</code> 能除尽 <code>str2</code>。<br><span id="more"></span></p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">str1</span> = <span class="string">&quot;ABCABC&quot;</span>, <span class="attr">str2</span> = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">输出：<span class="string">&quot;ABC&quot;</span></span><br></pre></td></tr></table></figure><h3 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h3><p>如果它们有公因子 <code>abc</code>，那么 <code>str1</code> 就是 <em>m</em> 个 <code>abc</code> 的重复，<code>str2</code> 是 <em>n</em> 个 <code>abc</code> 的重复，连起来就是 <em>m</em>+<em>n</em> 个 <code>abc</code>，好像 <em>m</em>+<em>n</em> 个 <code>abc</code> 跟 <em>n</em>+<em>m</em> 个 <code>abc</code> 是一样的。</p><p>所以如果 <code>str1 + str2 === str2 + str1</code> 就意味着有解。</p><p>我们也很容易想到 <code>str1 + str2 !== str2 + str1</code> 也是无解的<strong>充要条件</strong>。</p><p>当确定有解的情况下，最优解是长度为 <code>gcd(str1.length, str2.length)</code> 的字符串。</p><pre><code class="lang-JAVA">    public String gcdOfStrings(String str1, String str2) &#123;        // 假设str1是N个x，str2是M个x，那么str1+str2肯定是等于str2+str1的。        if (!(str1 + str2).equals(str2 + str1)) &#123;            return &quot;&quot;;        &#125;        // 辗转相除法求gcd。        return str1.substring(0, gcd(str1.length(), str2.length()));    &#125;    private int gcd(int a, int b) &#123;        return b == 0? a: gcd(b, a % b);    &#125;</code></pre><p>迭代形式的gdc</p><pre><code class="lang-JAVA">private int gcd(int a, int b)&#123;       while(b != 0)&#123;           int tmp = b;           b = a%b;           a = tmp;       &#125;       return a;   &#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第1071题字符串最大公因子&lt;/p&gt;
&lt;p&gt;对于字符串 &lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt;，只有在 &lt;code&gt;S = T + ... + T&lt;/code&gt;（&lt;code&gt;T&lt;/code&gt; 与自身连接 1 次或多次）时，我们才认定 “&lt;code&gt;T&lt;/code&gt; 能除尽 &lt;code&gt;S&lt;/code&gt;”。&lt;/p&gt;
&lt;p&gt;返回最长字符串 &lt;code&gt;X&lt;/code&gt;，要求满足 &lt;code&gt;X&lt;/code&gt; 能除尽 &lt;code&gt;str1&lt;/code&gt; 且 &lt;code&gt;X&lt;/code&gt; 能除尽 &lt;code&gt;str2&lt;/code&gt;。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>和为s的连续整数序列</title>
    <link href="http://yorxika.github.io/2020/03/08/%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97/"/>
    <id>http://yorxika.github.io/2020/03/08/%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97/</id>
    <published>2020-03-08T07:30:15.000Z</published>
    <updated>2020-03-08T07:51:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode面试题57-II 和为s的连续整数序列</p><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。<br><span id="more"></span><br><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="number">9</span></span><br><span class="line">输出：<span class="string">[[2,3,4],[4,5]]</span></span><br></pre></td></tr></table></figure><hr><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><ul><li>当窗口的和小于 <code>target</code> 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动</li><li>当窗口的和大于 <code>target</code> 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动</li><li>当窗口的和恰好等于 <code>target</code> 的时候，我们需要记录此时的结果。设此时的窗口为 [i, j)，那么我们已经找到了一个 i 开头的序列，也是唯一一个 i 开头的序列，接下来需要找 i+1开头的序列，所以窗口的左边界要向右移动</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] findContinuousSequence(<span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 滑动窗口的左边界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 滑动窗口的右边界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 滑动窗口中数字的和</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= target / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 右边界向右移动</span></span><br><span class="line">            sum += right;</span><br><span class="line">            right++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 左边界向右移动</span></span><br><span class="line">            sum -= left;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 记录结果</span></span><br><span class="line">            <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[right-left];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left; k &lt; right; k++) &#123;</span><br><span class="line">                arr[k-left] = k;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(arr);</span><br><span class="line">            <span class="comment">// 左边界向右移动</span></span><br><span class="line">            sum -= left;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode面试题57-II 和为s的连续整数序列&lt;/p&gt;
&lt;p&gt;输入一个正整数 &lt;code&gt;target&lt;/code&gt; ，输出所有和为 &lt;code&gt;target&lt;/code&gt; 的连续正整数序列（至少含有两个数）。&lt;/p&gt;
&lt;p&gt;序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="双指针" scheme="http://yorxika.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="滑动窗口" scheme="http://yorxika.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>分糖果II</title>
    <link href="http://yorxika.github.io/2020/03/08/%E5%88%86%E7%B3%96%E6%9E%9C/"/>
    <id>http://yorxika.github.io/2020/03/08/%E5%88%86%E7%B3%96%E6%9E%9C/</id>
    <published>2020-03-08T07:16:30.000Z</published>
    <updated>2020-03-08T07:27:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第1103题分糖果II</p><p>排排坐，分糖果。</p><p>我们买了一些糖果 <code>candies</code>，打算把它们分给排好队的 <strong><code>n = num_people</code></strong> 个小朋友。</p><p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 <code>n</code> 颗糖果。</p><p>然后，我们再回到队伍的起点，给第一个小朋友 <code>n + 1</code> 颗糖果，第二个小朋友 <code>n + 2</code> 颗，依此类推，直到给最后一个小朋友 <code>2 * n</code> 颗糖果。</p><p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p><p>返回一个长度为 <code>num_people</code>、元素之和为 <code>candies</code> 的数组，以表示糖果的最终分发情况（即 <code>ans[i]</code> 表示第 <code>i</code> 个小朋友分到的糖果数）。<br><span id="more"></span></p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：candies = 7, num_people = 4</span><br><span class="line">输出：<span class="comment">[1,2,3,1]</span></span><br><span class="line">解释：</span><br><span class="line">第一次，ans<span class="comment">[0]</span> += 1，数组变为 <span class="comment">[1,0,0,0]</span>。</span><br><span class="line">第二次，ans<span class="comment">[1]</span> += 2，数组变为 <span class="comment">[1,2,0,0]</span>。</span><br><span class="line">第三次，ans<span class="comment">[2]</span> += 3，数组变为 <span class="comment">[1,2,3,0]</span>。</span><br><span class="line">第四次，ans<span class="comment">[3]</span> += 1（因为此时只剩下 1 颗糖果），最终数组变为 <span class="comment">[1,2,3,1]</span>。</span><br></pre></td></tr></table></figure><hr><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>不断地遍历数组，如果还有糖就一直分，直到没有糖为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] distributeCandies(<span class="type">int</span> candies, <span class="type">int</span> num_people) &#123;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[num_people];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (candies != <span class="number">0</span>) &#123;</span><br><span class="line">        ans[i % num_people] += Math.min(candies, i + <span class="number">1</span>);</span><br><span class="line">        candies -= Math.min(candies, i + <span class="number">1</span>);</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h3><p>来自<a href="https://leetcode-cn.com/problems/distribute-candies-to-people/solution/xiang-xi-jie-shi-shu-xue-fang-fa-zen-yao-zuo-gao-z/">题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] distributeCandies(<span class="type">int</span> candies, <span class="type">int</span> num_people) &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num_people;</span><br><span class="line">  <span class="comment">// how many people received complete gifts</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.sqrt(<span class="number">2</span> * candies + <span class="number">0.25</span>) - <span class="number">0.5</span>);</span><br><span class="line">  <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> (<span class="type">int</span>)(candies - (p + <span class="number">1</span>) * p * <span class="number">0.5</span>);</span><br><span class="line">  <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> p / n, cols = p % n;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// complete rows</span></span><br><span class="line">    d[i] = (i + <span class="number">1</span>) * rows + (<span class="type">int</span>)(rows * (rows - <span class="number">1</span>) * <span class="number">0.5</span>) * n;</span><br><span class="line">    <span class="comment">// cols in the last row</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; cols) d[i] += i + <span class="number">1</span> + rows * n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// remaining candies        </span></span><br><span class="line">  d[cols] += remaining;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第1103题分糖果II&lt;/p&gt;
&lt;p&gt;排排坐，分糖果。&lt;/p&gt;
&lt;p&gt;我们买了一些糖果 &lt;code&gt;candies&lt;/code&gt;，打算把它们分给排好队的 &lt;strong&gt;&lt;code&gt;n = num_people&lt;/code&gt;&lt;/strong&gt; 个小朋友。&lt;/p&gt;
&lt;p&gt;给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 &lt;code&gt;n&lt;/code&gt; 颗糖果。&lt;/p&gt;
&lt;p&gt;然后，我们再回到队伍的起点，给第一个小朋友 &lt;code&gt;n + 1&lt;/code&gt; 颗糖果，第二个小朋友 &lt;code&gt;n + 2&lt;/code&gt; 颗，依此类推，直到给最后一个小朋友 &lt;code&gt;2 * n&lt;/code&gt; 颗糖果。&lt;/p&gt;
&lt;p&gt;重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。&lt;/p&gt;
&lt;p&gt;返回一个长度为 &lt;code&gt;num_people&lt;/code&gt;、元素之和为 &lt;code&gt;candies&lt;/code&gt; 的数组，以表示糖果的最终分发情况（即 &lt;code&gt;ans[i]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个小朋友分到的糖果数）。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>腐烂的橘子</title>
    <link href="http://yorxika.github.io/2020/03/08/%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/"/>
    <id>http://yorxika.github.io/2020/03/08/%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</id>
    <published>2020-03-08T07:02:52.000Z</published>
    <updated>2020-03-08T07:15:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第994题腐烂的橘子</p><p>在给定的网格中，每个单元格可以有以下三个值之一：</p><ul><li>值 <code>0</code> 代表空单元格；</li><li>值 <code>1</code> 代表新鲜橘子；</li><li>值 <code>2</code> 代表腐烂的橘子。</li></ul><p>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p><p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code>。<br><span id="more"></span></p><p><strong>示例 1：</strong></p><p><strong><img src="/2020/03/08/%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/03/08/%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/oranges.png" alt="img"></strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="string">[[2,1,1],[1,1,0],[0,1,1]]</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="BFS-I"><a href="#BFS-I" class="headerlink" title="BFS I"></a>BFS I</h3><p>来自<a href="https://leetcode-cn.com/problems/rotting-oranges/solution/fu-lan-de-ju-zi-by-leetcode-solution/">官方题解</a></p><p>观察到对于所有的腐烂橘子，其实它们<strong>在广度优先搜索上是等价于同一层的节点的</strong>。</p><p>假设这些腐烂橘子刚开始是新鲜的，而有一个腐烂橘子(<strong>我们令其为超级源点</strong>)会在下一秒把这些橘子都变腐烂，而这个腐烂橘子刚开始在的时间是 -1−1 ，那么按照广度优先搜索的算法，下一分钟也就是第 00 分钟的时候，这个腐烂橘子会把它们都变成腐烂橘子，然后继续向外拓展，所以其实这些腐烂橘子是同一层的节点。那么在广度优先搜索的时候，我们将这些腐烂橘子都放进队列里进行广度优先搜索即可，最后每个新鲜橘子被腐烂的最短时间 dis[x][y]<em>d<strong>i</strong>s</em>[<em>x</em>][<em>y</em>] 其实是以这个超级源点的腐烂橘子为起点的广度优先搜索得到的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="comment">// dr,dc 配合使用得到 grid[r][c] 上grid[r-1][c]左grid[r][c-1]下grid[r+1][c]右grid[r][c+1]的元素</span></span><br><span class="line">        <span class="type">int</span>[] dr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] dc = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orangesRotting</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取二维数组的行数row 和 列数 column</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> grid.length, C = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// queue : all starting cells with rotten oranges</span></span><br><span class="line">            Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>();</span><br><span class="line">            Map&lt;Integer, Integer&gt; depth = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; R; ++r)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; C; ++c)</span><br><span class="line">                    <span class="keyword">if</span> (grid[r][c] == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> r * C + c;  <span class="comment">// 转化为索引唯一的一维数组</span></span><br><span class="line">                        queue.add(code); <span class="comment">//存储腐烂橘子</span></span><br><span class="line">                        depth.put(code, <span class="number">0</span>); <span class="comment">//存储橘子变为腐烂时的时间,key为橘子的一维数组下标，value为变腐烂的时间</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> code / C, c = code % C;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">nr</span> <span class="operator">=</span> r + dr[k];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">nc</span> <span class="operator">=</span> c + dc[k];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &lt;= nr &amp;&amp; nr &lt; R &amp;&amp; <span class="number">0</span> &lt;= nc &amp;&amp; nc &lt; C &amp;&amp; grid[nr][nc] == <span class="number">1</span>) &#123;</span><br><span class="line">                        grid[nr][nc] = <span class="number">2</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">ncode</span> <span class="operator">=</span> nr * C + nc;</span><br><span class="line">                        queue.add(ncode);</span><br><span class="line">                        <span class="comment">// 计次的关键 元素 grid[r][c] 的上左下右元素得腐烂时间应该一致</span></span><br><span class="line">                        depth.put(ncode, depth.get(code) + <span class="number">1</span>);</span><br><span class="line">                        ans = depth.get(ncode);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//检查grid，此时的grid能被感染已经都腐烂了，此时还新鲜的橘子无法被感染</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] row: grid)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v: row)</span><br><span class="line">                    <span class="keyword">if</span> (v == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="BFS-II"><a href="#BFS-II" class="headerlink" title="BFS II"></a>BFS II</h3><p>首先遍历一遍数组，将腐烂橘子入队列，新鲜橘子计数；接下来开始计时，从-1时刻开始遍历队列，将腐烂橘子出队，判断周围是否会有新鲜的橘子，如果有就入队，并且计时+1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orangesRotting</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>)</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    e++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty() &amp;&amp; e &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty() &amp;&amp; e == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] dis = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span>[] p = queue.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> p[<span class="number">0</span>] + dis[i][<span class="number">0</span>], ny = p[<span class="number">1</span>] + dis[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (check(grid, nx, ny)) &#123;</span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nx, ny&#125;);</span><br><span class="line">                        grid[nx][ny] = <span class="number">2</span>;</span><br><span class="line">                        e--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e == <span class="number">0</span> ? count : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x &lt; grid.length &amp;&amp; x &gt;= <span class="number">0</span> &amp;&amp; y &lt; grid[<span class="number">0</span>].length &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; grid[x][y] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第994题腐烂的橘子&lt;/p&gt;
&lt;p&gt;在给定的网格中，每个单元格可以有以下三个值之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;值 &lt;code&gt;0&lt;/code&gt; 代表空单元格；&lt;/li&gt;
&lt;li&gt;值 &lt;code&gt;1&lt;/code&gt; 代表新鲜橘子；&lt;/li&gt;
&lt;li&gt;值 &lt;code&gt;2&lt;/code&gt; 代表腐烂的橘子。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。&lt;/p&gt;
&lt;p&gt;返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 &lt;code&gt;-1&lt;/code&gt;。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="广度优先搜索" scheme="http://yorxika.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>搜索二维矩阵II</title>
    <link href="http://yorxika.github.io/2020/03/03/%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II/"/>
    <id>http://yorxika.github.io/2020/03/03/%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II/</id>
    <published>2020-03-02T16:42:42.000Z</published>
    <updated>2020-03-02T16:50:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第240题搜索二维矩阵II</p><p>编写一个高效的算法来搜索 <em>m</em> x <em>n</em> 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。<span id="more"></span><strong>示例:</strong></li></ul><p>现有矩阵 matrix 如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,   4,  7, 11, 15]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[2,   5,  8, 12, 19]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[3,   6,  9, 16, 22]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[10, 13, 14, 17, 24]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[18, 21, 23, 26, 30]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure><p>给定 target = <code>5</code>，返回 <code>true</code>。</p><p>给定 target = <code>20</code>，返回 <code>false</code>。</p><hr><h3 id="左下-右上遍历"><a href="#左下-右上遍历" class="headerlink" title="左下/右上遍历"></a>左下/右上遍历</h3><p>数组从左到右和从上到下都是升序的，如果从右上角出发开始遍历呢？</p><p>会发现每次都是向左数字会变小，向下数字会变大，有点和二分查找树相似。二分查找树的话，是向左数字变小，向右数字变大。</p><p>所以我们可以把 <code>target</code> 和当前值比较。</p><ul><li>如果 <code>target</code> 的值大于当前值，那么就向下走。</li><li>如果 <code>target</code> 的值小于当前值，那么就向左走。</li><li>如果相等的话，直接返回 <code>true</code> 。</li></ul><p>也可以换个角度思考。</p><p>如果 <code>target</code> 的值小于当前值，也就意味着当前值所在的列肯定不会存在 <code>target</code> 了，可以把当前列去掉，从新的右上角的值开始遍历。</p><p>同理，如果 <code>target</code> 的值大于当前值，也就意味着当前值所在的行肯定不会存在 <code>target</code> 了，可以把当前行去掉，从新的右上角的值开始遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//从右上角开始，比较target与右上角的数据的大小，如果大于target，就可以往左进一列，如果小于target，就可以往下走一行</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;m &amp;&amp; j&gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] &gt; target)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历二分"><a href="#遍历二分" class="headerlink" title="遍历二分"></a>遍历二分</h3><p>对每一行都做一次二分查找，<a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-5-4/">来自</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][matrix[i].length - <span class="number">1</span>] &lt; target)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> binarySearch(matrix[i], target);</span><br><span class="line">        <span class="keyword">if</span> (col != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第240题搜索二维矩阵II&lt;/p&gt;
&lt;p&gt;编写一个高效的算法来搜索 &lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt; 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每行的元素从左到右升序排列。&lt;/li&gt;
&lt;li&gt;每列的元素从上到下升序排列。&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="二分查找" scheme="http://yorxika.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树最近的公共祖先</title>
    <link href="http://yorxika.github.io/2020/03/03/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E8%BF%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://yorxika.github.io/2020/03/03/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E8%BF%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</id>
    <published>2020-03-02T16:10:34.000Z</published>
    <updated>2020-03-02T16:20:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第235题二叉搜索树最近的公共祖先</p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”<br><span id="more"></span><br>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="/2020/03/03/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E8%BF%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/03/03/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E8%BF%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/binarysearchtree_improved.png" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span></span><br><span class="line"><span class="section">输出: 6 </span></span><br><span class="line"><span class="section">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span></span><br></pre></td></tr></table></figure><hr><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ol><li>从根节点开始遍历树</li><li>如果节点 p<em>p</em> 和节点 q<em>q</em> 都在右子树上，那么以右孩子为根节点继续 1 的操作</li><li>如果节点 p<em>p</em> 和节点 q<em>q</em> 都在左子树上，那么以左孩子为根节点继续 1 的操作</li><li>如果条件 2 和条件 3 都不成立，这就意味着我们已经找到节 p<em>p</em> 和节点 q<em>q</em> 的 LCA 了</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pval</span> <span class="operator">=</span> p.val;</span><br><span class="line">    <span class="type">int</span> <span class="variable">qval</span> <span class="operator">=</span> q.val;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rval</span> <span class="operator">=</span> root.val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pval &gt; rval &amp;&amp; qval &gt; rval)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pval &lt; rval &amp;&amp; qval &lt; rval)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>思路同上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pval</span> <span class="operator">=</span> p.val;</span><br><span class="line">    <span class="type">int</span> <span class="variable">qval</span> <span class="operator">=</span> q.val;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rval</span> <span class="operator">=</span> root.val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">        rval = root.val;</span><br><span class="line">        <span class="keyword">if</span> (pval &gt; rval &amp;&amp; qval &gt; rval)</span><br><span class="line">            <span class="comment">//return lowestCommonAncestor(root.right, p, q);</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pval &lt; rval &amp;&amp; qval &lt; rval)</span><br><span class="line">            <span class="comment">//return lowestCommonAncestor(root.left, p, q);</span></span><br><span class="line">            root = root.left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第235题二叉搜索树最近的公共祖先&lt;/p&gt;
&lt;p&gt;给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin&quot;&gt;百度百科&lt;/a&gt;中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（&lt;strong&gt;一个节点也可以是它自己的祖先&lt;/strong&gt;）。”&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
    <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树最近的公共祖先</title>
    <link href="http://yorxika.github.io/2020/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E8%BF%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://yorxika.github.io/2020/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E8%BF%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</id>
    <published>2020-03-02T13:56:29.000Z</published>
    <updated>2020-03-02T16:07:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第236题二叉树最近的公共祖先</p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”<br><span id="more"></span><br>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="/2020/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E8%BF%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E8%BF%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/binarytree.png" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span></span><br></pre></td></tr></table></figure><hr><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>在左、右子树中分别查找是否包含p或q：</li><li>如果以下两种情况（左子树包含p，右子树包含q/左子树包含q，右子树包含p），<strong>那么此时的根节点就是最近公共祖先</strong></li><li>如果左子树包含p和q，那么到root-&gt;left中继续查找，最近公共祖先在左子树里面</li><li>如果右子树包含p和q，那么到root-&gt;right中继续查找，最近公共祖先在右子树里面</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(root == <span class="literal">null</span> || root == p || root == q)</span><br><span class="line">         <span class="keyword">return</span> root;</span><br><span class="line">     <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">     <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">     <span class="keyword">if</span>(left == <span class="literal">null</span>)</span><br><span class="line">         <span class="keyword">return</span> right;</span><br><span class="line">     <span class="keyword">if</span>(right == <span class="literal">null</span>)</span><br><span class="line">         <span class="keyword">return</span> left;</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>来自<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetcod/">官方题解</a>的解答</p><p>先深度遍历改树。当你遇到节点 <code>p</code> 或 <code>q</code> 时，返回一些布尔标记。该标志有助于确定是否在任何路径中找到了所需的节点。最不常见的祖先将是两个子树递归都返回真标志的节点。它也可以是一个节点，它本身是<code>p</code>或<code>q</code>中的一个，对于这个节点,子树递归返回一个真标志。</p><p><strong>算法：</strong></p><ol><li>从根节点开始遍历树。</li><li>如果当前节点本身是 <code>p</code> 或 <code>q</code> 中的一个，我们会将变量 <code>mid</code> 标记为 <code>true</code>，并继续搜索左右分支中的另一个节点。</li><li>如果左分支或右分支中的任何一个返回 <code>true</code>，则表示在下面找到了两个节点中的一个。</li><li>如果在遍历的任何点上，左、右或中三个标志中的任意两个变为 <code>true</code>，这意味着我们找到了节点 <code>p</code> 和 <code>q</code> 的最近公共祖先。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Variable to store LCA node.</span></span><br><span class="line">        <span class="built_in">this</span>.ans = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">recurseTree</span><span class="params">(TreeNode currentNode, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If reached the end of a branch, return false.</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Left Recursion. If left recursion returns true, set left = 1 else 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="built_in">this</span>.recurseTree(currentNode.left, p, q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Right Recursion</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="built_in">this</span>.recurseTree(currentNode.right, p, q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the current node is one of p or q</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (currentNode == p || currentNode == q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If any two of the flags left, right or mid become True</span></span><br><span class="line">        <span class="keyword">if</span> (mid + left + right &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.ans = currentNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return true if any one of the three bool values is True.</span></span><br><span class="line">        <span class="keyword">return</span> (mid + left + right &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// Traverse the tree</span></span><br><span class="line">        <span class="built_in">this</span>.recurseTree(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用父指针迭代"><a href="#使用父指针迭代" class="headerlink" title="使用父指针迭代"></a>使用父指针迭代</h3><p>还是来自官方题解</p><p>如果每个节点都有父指针，那么我们可以从 <code>p</code> 和 <code>q</code> 返回以获取它们的祖先。在这个遍历过程中，我们得到的第一个公共节点是 LCA 节点。我们可以在遍历树时将父指针保存在字典中。</p><p><strong>算法：</strong></p><ol><li>从根节点开始遍历树。</li><li>在找到 <code>p</code> 和 <code>q</code> 之前，将父指针存储在字典中。</li><li>一旦我们找到了 <code>p</code> 和 <code>q</code>，我们就可以使用父亲字典获得 <code>p</code> 的所有祖先，并添加到一个称为祖先的集合中。</li><li>同样，我们遍历节点 <code>q</code> 的祖先。如果祖先存在于为 <code>p</code> 设置的祖先中，这意味着这是 <code>p</code> 和 <code>q</code> 之间的第一个共同祖先（同时向上遍历），因此这是 LCA 节点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    HashMap&lt;TreeNode, TreeNode&gt; parent = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    parent.put(root, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//将遍历过程中每个节点的父节点保存起来</span></span><br><span class="line">    <span class="keyword">while</span> (!parent.containsKey(p) || !parent.containsKey(q)) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(cur.left);</span><br><span class="line">            parent.put(cur.left, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(cur.right);</span><br><span class="line">            parent.put(cur.right, cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    HashSet&lt;TreeNode&gt; path = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 倒着还原 p 的路径，并将每个节点加入到 set 中</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        path.add(p);</span><br><span class="line">        p = parent.get(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倒着遍历 q 的路径，判断是否在 p 的路径中</span></span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.contains(q)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q = parent.get(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第236题二叉树最近的公共祖先&lt;/p&gt;
&lt;p&gt;给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin&quot;&gt;百度百科&lt;/a&gt;中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（&lt;strong&gt;一个节点也可以是它自己的祖先&lt;/strong&gt;）。”&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
    <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>组合综合III</title>
    <link href="http://yorxika.github.io/2020/03/01/%E7%BB%84%E5%90%88%E7%BB%BC%E5%90%88III/"/>
    <id>http://yorxika.github.io/2020/03/01/%E7%BB%84%E5%90%88%E7%BB%BC%E5%90%88III/</id>
    <published>2020-03-01T15:40:26.000Z</published>
    <updated>2020-03-01T15:42:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第216题组合综合III</p><p>找出所有相加之和为 <strong><em>n</em></strong> 的 <strong><em>k\</em></strong> 个数的组合<strong><em>。\</em></strong>组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p><strong>说明：</strong></p><ul><li><p>所有数字都是正整数。</p></li><li><p>解集不能包含重复的组合。</p><span id="more"></span><p><strong>示例 1:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">输出: <span class="string">[[1,2,4]]</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">//List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();</span></span><br><span class="line">    backtrack(<span class="number">1</span>,n,k,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> target ,<span class="type">int</span> k,List&lt;Integer&gt; tmp)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp.size() &gt; k || target &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; tmp.size() == k) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; start)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        tmp.add(i);</span><br><span class="line">        backtrack(i+<span class="number">1</span>,target-i,k,tmp);</span><br><span class="line">        tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第216题组合综合III&lt;/p&gt;
&lt;p&gt;找出所有相加之和为 &lt;strong&gt;&lt;em&gt;n&lt;/em&gt;&lt;/strong&gt; 的 &lt;strong&gt;&lt;em&gt;k\&lt;/em&gt;&lt;/strong&gt; 个数的组合&lt;strong&gt;&lt;em&gt;。\&lt;/em&gt;&lt;/strong&gt;组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;所有数字都是正整数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解集不能包含重复的组合。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="回溯" scheme="http://yorxika.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>完全二叉树的结点个数</title>
    <link href="http://yorxika.github.io/2020/03/01/%E2%80%9C%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0%E2%80%9D/"/>
    <id>http://yorxika.github.io/2020/03/01/%E2%80%9C%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0%E2%80%9D/</id>
    <published>2020-03-01T14:50:22.000Z</published>
    <updated>2020-03-01T15:24:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第222题完全二叉树的结点个数</p><p>给出一个<strong>完全二叉树</strong>，求出该树的节点个数。</p><p><strong>说明：</strong></p><p><a href="https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin">完全二叉树</a>的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。<br><span id="more"></span><br><strong>示例:</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> <span class="regexp">/ \  /</span></span><br><span class="line"><span class="number">4</span>  <span class="number">5</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">6</span></span><br></pre></td></tr></table></figure><hr><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>最简单的递归遍历完所有结点，返回所有结点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="literal">null</span> ? <span class="number">0</span> : <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用定义"><a href="#利用定义" class="headerlink" title="利用定义"></a>利用定义</h3><p><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/solution/chang-gui-jie-fa-he-ji-bai-100de-javajie-fa-by-xia/">来源</a></p><p>首先需要明确完全二叉树的定义：<strong>它是一棵空树或者它的叶子节点只出在最后两层，若最后一层不满则叶子节点只在最左侧。</strong></p><p>再来回顾一下满二叉的节点个数怎么计算，如果满二叉树的层数为h，则总节点数为：2^h - 1.<br>那么我们来对root节点的左右子树进行高度统计，分别记为left和right,有以下两种结果：</p><ol><li>left == right。这说明，左子树一定是满二叉树，因为节点已经填充到右子树了，左子树必定已经填满了。所以左子树的节点总数我们可以直接得到，是2^left - 1，加上当前这个root节点，则正好是2^left。再对右子树进行递归统计。</li><li>left != right。说明此时最后一层不满，但倒数第二层已经满了，可以直接得到右子树的节点个数。同理，右子树节点+root节点，总数为2^right。再对左子树进行递归查找。</li></ol><p>关于如何计算二叉树的层数，可以利用下面的递归来算，当然对于完全二叉树，可以利用其特点，不用递归直接算，具体请参考最后的完整代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> countLevel(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> countLevel(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> countNodes(root.right) + (<span class="number">1</span>&lt;&lt;left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> countNodes(root.left) + (<span class="number">1</span>&lt;&lt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countLevel</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            level++;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第222题完全二叉树的结点个数&lt;/p&gt;
&lt;p&gt;给出一个&lt;strong&gt;完全二叉树&lt;/strong&gt;，求出该树的节点个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin&quot;&gt;完全二叉树&lt;/a&gt;的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
    <category term="二分查找" scheme="http://yorxika.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>填充每个结点的下一个右侧节点</title>
    <link href="http://yorxika.github.io/2020/02/28/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9/"/>
    <id>http://yorxika.github.io/2020/02/28/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9/</id>
    <published>2020-02-28T13:06:52.000Z</published>
    <updated>2020-02-28T13:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第116题填充每个结点的下一个右侧节点</p><p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">  int</span> val;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*left</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*right</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。<br><span id="more"></span></p><p><strong>示例：</strong></p><p><img src="/2020/02/28/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9/02/28/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9/116_sample.png" alt="img"></p><p><strong>提示：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><hr><h3 id="常规BFS"><a href="#常规BFS" class="headerlink" title="常规BFS"></a>常规BFS</h3><p>创建一个队列，按层序遍历实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Node tmp;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            size = queue.size();</span><br><span class="line">            tmp = queue.peek();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size ; ++i)&#123;  <span class="comment">//串联队列里的结点</span></span><br><span class="line">                tmp.next = queue.get(i);</span><br><span class="line">                tmp = queue.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; size ; ++i)&#123;</span><br><span class="line">                tmp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="literal">null</span>)</span><br><span class="line">                    queue.add(tmp.left);</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="literal">null</span>)</span><br><span class="line">                    queue.add(tmp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用已有的next结点"><a href="#利用已有的next结点" class="headerlink" title="利用已有的next结点"></a>利用已有的next结点</h3><p>如果不为一层的尾结点，那么其<code>next</code>指针只想的就是根节点的右孩子，或者更结点兄弟的右孩子，根节点的兄弟在上一轮递归中已经用<code>root.next</code>实现了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">        root.left.next = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">        root.right.next = root.next == <span class="literal">null</span> ? <span class="literal">null</span> : root.next.left;</span><br><span class="line">    &#125;</span><br><span class="line">    connect(root.left);</span><br><span class="line">    connect(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第116题填充每个结点的下一个右侧节点&lt;/p&gt;
&lt;p&gt;给定一个&lt;strong&gt;完美二叉树&lt;/strong&gt;，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct &lt;span class=&quot;keyword&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;  int&lt;/span&gt; val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;*left&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;*right&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;*next&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 &lt;code&gt;NULL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;初始状态下，所有 next 指针都被设置为 &lt;code&gt;NULL&lt;/code&gt;。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
    <category term="宽度优先搜索" scheme="http://yorxika.github.io/tags/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>有序链表转化二叉搜索树</title>
    <link href="http://yorxika.github.io/2020/02/27/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E5%8C%96%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yorxika.github.io/2020/02/27/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E5%8C%96%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-02-27T12:57:36.000Z</published>
    <updated>2020-02-27T13:09:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第109题有序链表转化二叉搜索树</p><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。<br><span id="more"></span><br><strong>示例:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定的有序链表： [<span class="string">-10</span>, <span class="string">-3</span>, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, <span class="string">-3</span>, 9, <span class="string">-10</span>, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   <span class="string">-3</span>   9</span><br><span class="line">   /   /</span><br><span class="line"> <span class="string">-10</span>  5</span><br></pre></td></tr></table></figure><h3 id="链表转数组"><a href="#链表转数组" class="headerlink" title="链表转数组"></a>链表转数组</h3><p>将链表转化成数组，在套用第108题的代码即可，注意在<code>Arrays.copyOfRange()</code>方法中，复制的区间是左闭又开，即[left,right)，所以右侧区间要+1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> nums.length / <span class="number">2</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">    <span class="keyword">if</span>(mid &gt; <span class="number">0</span>)</span><br><span class="line">        root.left = sortedArrayToBST(Arrays.copyOfRange(nums,<span class="number">0</span>,mid));</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; nums.length - <span class="number">1</span>)</span><br><span class="line">    root.right = sortedArrayToBST(Arrays.copyOfRange(nums,mid + <span class="number">1</span>,nums.length));</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">sortedListToBST</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; num = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">        num.add(head.val);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println();</span></span><br><span class="line">    Integer[] nums = num.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[num.size()]);</span><br><span class="line">    <span class="keyword">return</span> sortedArrayToBST(nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.<span class="keyword"> public</span> class <span class="class">ListNode &#123; int val;</span> <span class="class">ListNode next;</span> ListNode(int</span><br><span class="line"> * x) &#123; val = x; &#125; &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.<span class="keyword"> public</span> class TreeNode &#123;<span class="built_in"> int </span>val; TreeNode left; TreeNode</span><br><span class="line"> * right; TreeNode(int x) &#123; val = x; &#125; &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword"> private</span> <span class="class">List&lt;Integer&gt; values;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword"> public</span> Solution() &#123;</span><br><span class="line">    this.values =<span class="built_in"> new </span>ArrayList&lt;Integer&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword"> private</span> void mapListToValues(ListNode head) &#123;</span><br><span class="line">    while (head != null) &#123;</span><br><span class="line">      this.values.add(head.val);</span><br><span class="line">      head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword"> private</span> TreeNode convertListToBST(int left,<span class="built_in"> int </span>right) &#123;</span><br><span class="line">    // Invalid case</span><br><span class="line">   <span class="built_in"> if </span>(left &gt; right) &#123;</span><br><span class="line">     <span class="built_in"> return </span>null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Middle element forms the root.</span><br><span class="line">   <span class="built_in"> int </span>mid = (left + right) / 2;</span><br><span class="line">    TreeNode node =<span class="built_in"> new </span>TreeNode(this.values.get(mid));</span><br><span class="line"></span><br><span class="line">    // Base case for when there is only one element left in the<span class="built_in"> array</span></span><br><span class="line"><span class="built_in"></span>   <span class="built_in"> if </span>(left == right) &#123;</span><br><span class="line">     <span class="built_in"> return </span>node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Recursively form BST on the two halves</span><br><span class="line">    node.left = convertListToBST(left, mid - 1);</span><br><span class="line">    node.right = convertListToBST(mid + 1, right);</span><br><span class="line">   <span class="built_in"> return </span>node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword"> public</span> TreeNode sortedListToBST(ListNode head) &#123;</span><br><span class="line"></span><br><span class="line">    // Form an<span class="built_in"> array </span>out of the given linked list<span class="built_in"> and </span>then</span><br><span class="line">    // use the<span class="built_in"> array </span>to form the BST.</span><br><span class="line">    this.mapListToValues(head);</span><br><span class="line"></span><br><span class="line">    // Convert the<span class="built_in"> array </span>to</span><br><span class="line">   <span class="built_in"> return </span>convertListToBST(0, this.values.size() - 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>来源<a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-by-/">题解</a></p><ol><li>由于我们得到的是一个有序链表而不是数组，我们不能直接使用下标来访问元素。我们需要知道链表中的中间元素。</li><li>我们可以利用两个指针来访问链表中的中间元素。假设我们有两个指针 <code>slow_ptr</code> 和 <code>fast_ptr</code>。<code>slow_ptr</code> 每次向后移动一个节点而 <code>fast_ptr</code> 每次移动两个节点。当 <code>fast_ptr</code> 到链表的末尾时 <code>slow_ptr</code> 就访问到链表的中间元素。对于一个偶数长度的数组，中间两个元素都可用来作二叉搜索树的根。</li><li>当找到链表中的中间元素后，我们将链表从中间元素的左侧断开，做法是使用一个 <code>prev_ptr</code> 的指针记录 <code>slow_ptr</code> 之前的元素，也就是满足 <code>prev_ptr.next</code> = <code>slow_ptr</code>。断开左侧部分就是让 <code>prev_ptr.next = None</code>。</li><li>我们只需要将链表的头指针传递给转换函数，进行高度平衡二叉搜索树的转换。所以递归调用的时候，左半部分我们传递原始的头指针；右半部分传递 <code>slow_ptr.next</code> 作为头指针。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list. public class ListNode &#123; int val; ListNode next; ListNode(int</span></span><br><span class="line"><span class="comment"> * x) &#123; val = x; &#125; &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node. public class TreeNode &#123; int val; TreeNode left; TreeNode</span></span><br><span class="line"><span class="comment"> * right; TreeNode(int x) &#123; val = x; &#125; &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ListNode <span class="title function_">findMiddleElement</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The pointer used to disconnect the left half from the mid node.</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prevPtr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slowPtr</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fastPtr</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate until fastPr doesn&#x27;t reach the end of the linked list.</span></span><br><span class="line">    <span class="keyword">while</span> (fastPtr != <span class="literal">null</span> &amp;&amp; fastPtr.next != <span class="literal">null</span>) &#123;</span><br><span class="line">      prevPtr = slowPtr;</span><br><span class="line">      slowPtr = slowPtr.next;</span><br><span class="line">      fastPtr = fastPtr.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handling the case when slowPtr was equal to head.</span></span><br><span class="line">    <span class="keyword">if</span> (prevPtr != <span class="literal">null</span>) &#123;</span><br><span class="line">      prevPtr.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slowPtr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> TreeNode <span class="title function_">sortedListToBST</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the head doesn&#x27;t exist, then the linked list is empty</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the middle element for the list.</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="built_in">this</span>.findMiddleElement(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The mid becomes the root of the BST.</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(mid.val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Base case when there is just one element in the linked list</span></span><br><span class="line">    <span class="keyword">if</span> (head == mid) &#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively form balanced BSTs using the left and right halves of the original list.</span></span><br><span class="line">    node.left = <span class="built_in">this</span>.sortedListToBST(head);</span><br><span class="line">    node.right = <span class="built_in">this</span>.sortedListToBST(mid.next);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p>来自范例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ListNode head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findSize</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">ptr</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="literal">null</span>) &#123;</span><br><span class="line">      ptr = ptr.next;  </span><br><span class="line">      c += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> TreeNode <span class="title function_">convertListToBST</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="comment">// Invalid case</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First step of simulated inorder traversal. Recursively form</span></span><br><span class="line">    <span class="comment">// the left half</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="built_in">this</span>.convertListToBST(l, mid - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Once left half is traversed, process the current node</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="built_in">this</span>.head.val);</span><br><span class="line">    node.left = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Maintain the invariance mentioned in the algorithm</span></span><br><span class="line">    <span class="built_in">this</span>.head = <span class="built_in">this</span>.head.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recurse on the right hand side and form BST out of them</span></span><br><span class="line">    node.right = <span class="built_in">this</span>.convertListToBST(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> TreeNode <span class="title function_">sortedListToBST</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// Get the size of the linked list first</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="built_in">this</span>.findSize(head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.head = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Form the BST now that we know the size</span></span><br><span class="line">    <span class="keyword">return</span> convertListToBST(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第109题有序链表转化二叉搜索树&lt;/p&gt;
&lt;p&gt;给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。&lt;/p&gt;
&lt;p&gt;本题中，一个高度平衡二叉树是指一个二叉树&lt;em&gt;每个节点&lt;/em&gt; 的左右两个子树的高度差的绝对值不超过 1。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="链表" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="链表" scheme="http://yorxika.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
    <category term="双指针" scheme="http://yorxika.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>H指数</title>
    <link href="http://yorxika.github.io/2020/02/27/H%E6%8C%87%E6%95%B0/"/>
    <id>http://yorxika.github.io/2020/02/27/H%E6%8C%87%E6%95%B0/</id>
    <published>2020-02-27T11:44:44.000Z</published>
    <updated>2020-02-27T12:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第274题H指数</p><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 <em>h</em> 指数。</p><p><a href="https://baike.baidu.com/item/h-index/3991452?fr=aladdin">h 指数的定义</a>: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）<strong>至多</strong>有 h 篇论文分别被引用了<strong>至少</strong> h 次。（其余的 <em>N - h</em> 篇论文每篇被引用次数<strong>不多于</strong> <em>h</em> 次。）”<br><span id="more"></span></p><p><strong>示例:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: citations = [3,0,6,1,5]</span><br><span class="line">输出:<span class="number"> 3 </span></span><br><span class="line">解释: 给定数组表示研究者总共有<span class="number"> 5 </span>篇论文，每篇论文相应的被引用了 3, 0, 6, 1,<span class="number"> 5 </span>次。</span><br><span class="line">     由于研究者有<span class="number"> 3 </span>篇论文每篇至少被引用了<span class="number"> 3 </span>次，其余两篇论文每篇被引用不多于<span class="number"> 3 </span>次，所以她的 h 指数是 3。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 如果 <em>h</em> 有多种可能的值，<em>h</em> 指数是其中最大的那个。</p><hr><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>来源<a href="https://leetcode-cn.com/problems/h-index/solution/hzhi-shu-by-leetcode/">题解</a></p><p>我们想象一个直方图，其中 <em>x</em> 轴表示文章，y 轴表示每篇文章的引用次数。如果将这些文章按照引用次数<em>降序</em>排序并在直方图上进行表示，那么直方图上的最大的正方形的边长 <em>h</em> 就是我们所要求的 <em>h</em>。</p><p><img src="/2020/02/27/H%E6%8C%87%E6%95%B0/02/27/H%E6%8C%87%E6%95%B0/274_H_index.svg" alt="h-index"></p><p>首先我们将引用次数降序排序，在排完序的数组citations 中，如果 citations[<em>i</em>]&gt;<em>i</em>，那么说明第 0 到 <em>i</em> 篇论文都有至少 i<em>+1 次引用。因此我们只要找到最大的 i满足 citations[</em>i<em>]&gt;</em>i*，那么 h 指数即为 i+1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">    Arrays.sort(citations);</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; citations.length ;i++)&#123;</span><br><span class="line">        h = citations.length - i;</span><br><span class="line">        <span class="keyword">if</span>( h &lt;= citations[i])</span><br><span class="line">            <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p>来源<a href="https://leetcode-cn.com/problems/h-index/solution/hzhi-shu-by-leetcode/">题解</a></p><p>要得到时间复杂度更低的算法. 可以考虑最常用的不基于比较的排序，<a href="https://baike.baidu.com/item/计数排序">计数排序</a>。</p><p>然而，论文的引用次数可能会非常多，这个数值很可能会超过论文的总数 <em>n</em>，因此使用计数排序是非常不合算的（会超出空间限制）。在这道题中，我们可以通过一个不难发现的结论来让计数排序变得有用，即：</p><blockquote><p>如果一篇文章的引用次数超过论文的总数 <em>n</em>，那么将它的引用次数降低为 n 也不会改变 <em>h</em> 指数的值。</p></blockquote><p>由于 h 指数一定小于等于 <em>n</em>，因此这样做是正确的。在直方图中，将所有超过 <em>y</em> 轴值大于 <em>n</em> 的变为 <em>n</em> 等价于去掉 <em>y</em>&gt;<em>n</em> 的整个区域。</p><p><img src="/2020/02/27/H%E6%8C%87%E6%95%B0/02/27/H%E6%8C%87%E6%95%B0/274_H_index_2.svg" alt="h-index cut off"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> citations.length;</span><br><span class="line">        <span class="type">int</span>[] papers = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c: citations)</span><br><span class="line">            papers[Math.min(n, c)]++;</span><br><span class="line">        <span class="comment">// 找出最大的 k</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> papers[n]; k &gt; s; s += papers[k])</span><br><span class="line">            k--;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第274题H指数&lt;/p&gt;
&lt;p&gt;给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 &lt;em&gt;h&lt;/em&gt; 指数。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/h-index/3991452?fr=aladdin&quot;&gt;h 指数的定义&lt;/a&gt;: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）&lt;strong&gt;至多&lt;/strong&gt;有 h 篇论文分别被引用了&lt;strong&gt;至少&lt;/strong&gt; h 次。（其余的 &lt;em&gt;N - h&lt;/em&gt; 篇论文每篇被引用次数&lt;strong&gt;不多于&lt;/strong&gt; &lt;em&gt;h&lt;/em&gt; 次。）”&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="排序" scheme="http://yorxika.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux有关笔记</title>
    <link href="http://yorxika.github.io/2020/02/25/Linux%E6%9C%89%E5%85%B3%E7%AC%94%E8%AE%B0/"/>
    <id>http://yorxika.github.io/2020/02/25/Linux%E6%9C%89%E5%85%B3%E7%AC%94%E8%AE%B0/</id>
    <published>2020-02-25T07:10:48.000Z</published>
    <updated>2020-02-28T19:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容为操作系统课设期间遇到的一些问题的补充</p><h2 id="user含意"><a href="#user含意" class="headerlink" title="__user含意"></a>__user含意</h2><p><code># define __user __attribute__((noderef, address_space(1)))</code><br><span id="more"></span><br>_user这个特性，即<strong>attribute</strong>((noderef, address_space(1)))，是用来修饰一个变量的，这个变量必须是非解除参考（no dereference）的，即这个变量地址必须是有效的，而且变量所在的地址空间必须是1，即用户程序空间的。<br>这里把程序空间分成了3个部分，0表示normal space，即普通地址空间，对内核代码来说，当然就是内核空间地址了。1表示用户地址空间，这个不用多讲，还有一个2，表示是设备地址映射空间，例如硬件设备的寄存器在内核里所映射的地址空间。</p><p><strong>attribute</strong>是gnu c编译器的一个功能，它用来让开发者使用此功能给所声明的函数或者变量附加一个属性，以方便编译器进行错误检查，其实就是一个内核检查器。</p><p>linux把操作系统内存和用户区内存隔离开，<br>用户程序只能通过系统调用访问系统功能，<br>内核态可以访问用户内存，但是要做检查，因为用户区内存是不可靠的，甚至是危险的。_user就表示这个意思。</p><p>以下内容<a href="https://blog.csdn.net/Rong_Toa/article/details/86585086">来自</a></p><p>首先看一下linux内核4.20.1源码：</p><p><strong>linux/linux/compile_types.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> __user__attribute__((noderef, address_space(1)))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __kernel__attribute__((address_space(0)))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __safe__attribute__((safe))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __force__attribute__((force))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __nocast__attribute__((nocast))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __iomem__attribute__((noderef, address_space(2)))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __must_hold(x)__attribute__((context(x,1,1)))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __acquires(x)__attribute__((context(x,0,1)))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __releases(x)__attribute__((context(x,1,0)))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __acquire(x)__context__(x,1)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __release(x)__context__(x,-1)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __cond_lock(x,c)((c) ? (&#123; __acquire(x); 1; &#125;) : 0)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __percpu__attribute__((noderef, address_space(3)))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __rcu__attribute__((noderef, address_space(4)))</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __private__attribute__((noderef))</span></span><br></pre></td></tr></table></figure><p>Sparse 诞生于 2004 年, 是由linux之父开发的, 目的就是提供一个静态检查代码的工具, 从而减少linux内核的隐患. 其实在Sparse之前, 已经有了一个不错的代码静态检查工具(“SWAT”), 只不过这个工具不是免费软件, 使用上有一些限制.所以 linus 还是自己开发了一个静态检查工具.（<a href="https://blog.csdn.net/Rong_Toa/article/details/86584999">参考</a>，<a href="https://lwn.net/Articles/87538/">原文</a>）</p><p>Sparse通过 gcc 的扩展属性 <strong>attribute</strong> 以及自己定义的 <strong>context</strong> 来对代码进行静态检查.</p><div class="table-container"><table><thead><tr><th><strong>宏名称</strong></th><th><strong>宏定义</strong></th><th><strong>检查点</strong></th></tr></thead><tbody><tr><td>__bitwise</td><td><strong>attribute</strong>((bitwise))</td><td>确保变量是相同的位方式(比如 bit-endian, little-endiandeng)</td></tr><tr><td>__user</td><td><strong>attribute</strong>((noderef, address_space(1)))</td><td>指针地址必须在用户地址空间</td></tr><tr><td>__kernel</td><td><strong>attribute</strong>((noderef, address_space(0)))</td><td>指针地址必须在内核地址空间</td></tr><tr><td>__iomem</td><td><strong>attribute</strong>((noderef, address_space(2)))</td><td>指针地址必须在设备地址空间</td></tr><tr><td>__safe</td><td><strong>attribute</strong>((safe))</td><td>变量可以为空</td></tr><tr><td>__force</td><td><strong>attribute</strong>((force))</td><td>变量可以进行强制转换</td></tr><tr><td>__nocast</td><td><strong>attribute</strong>((nocast))</td><td>参数类型与实际参数类型必须一致</td></tr><tr><td>__acquires(x)</td><td><strong>attribute</strong>((context(x, 0, 1)))</td><td>参数x 在执行前引用计数必须是0,执行后,引用计数必须为1</td></tr><tr><td>__releases(x)</td><td><strong>attribute</strong>((context(x, 1, 0)))</td><td>与 __acquires(x) 相反</td></tr><tr><td>__acquire(x)</td><td><strong>context</strong>(x, 1)</td><td>参数x 的引用计数 + 1</td></tr><tr><td>__release(x)</td><td><strong>context</strong>(x, -1)</td><td>与 __acquire(x) 相反</td></tr><tr><td>__cond_lock(x,c)</td><td>((c) ? ({ __acquire(x); 1; }) : 0)</td><td>参数c 不为0时,引用计数 + 1, 并返回1</td></tr></tbody></table></div><h3 id="user-的使用"><a href="#user-的使用" class="headerlink" title="__user 的使用"></a>__user 的使用</h3><p>如果使用了 __user 宏的指针不在用户地址空间初始化, 或者指向内核地址空间, 设备地址空间等等, Sparse会给出警告.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 内核版本:v2.6.32.61  file:arch/score/kernel/signal.c 45行 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">setup_sigcontext</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, <span class="keyword">struct</span> sigcontext __user *sc)</span></span><br></pre></td></tr></table></figure><h2 id="关于get-ds-set-fs-get-fs函数的使用"><a href="#关于get-ds-set-fs-get-fs函数的使用" class="headerlink" title="关于get_ds, set_fs, get_fs函数的使用"></a>关于get_ds, set_fs, get_fs函数的使用</h2><p>在linux内核编程时，进行系统调用（如文件操作）时如果要访问用户空间的参数，可以用set_fs,get_ds等函数实现访问：</p><p>get_ds获得kernel的内存访问地址范围（IA32是4GB），</p><p>get_fs是取得当前的地址访问限制值。</p><p>set_fs是设置当前的地址访问限制值</p><p>进程由用户态进入核态，linux进程的task_struct结构中的成员addr_limit也应该由0xBFFFFFFF变为0xFFFFFFFF(addr_limit规定了进程有用户态核内核态情况下的虚拟地址空间访问范围，在用户态，addr_limit成员值是0xBFFFFFFF也就是有3GB的虚拟内存空间，在核心态，是0xFFFFFFFF,范围扩展了1GB)。使用这三个函数是为了安全性。为了保证用户态的地址所指向空间有效，函数会做一些检查工作。如果set_fs(KERNEL_DS),函数将跳过这些检查。</p><p>具体用法参考<a href="https://www.cnblogs.com/arnoldlu/p/8879800.html">示例</a></p><h2 id="copy-to-user和copy-from-user"><a href="#copy-to-user和copy-from-user" class="headerlink" title="copy_to_user和copy_from_user"></a>copy_to_user和copy_from_user</h2><p>首先解决一个问题：</p><p><strong>1. 为什么要划分为内核空间和用户空间？</strong><br>Linux Kernel是操作系统的核心，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。<br>对于Kernel这么一个高安全级别的东西，显然是不容许其它的应用程序随便调用或访问的，所以需要对Kernel提供一定的保护机制，这个保护机制用来告诉那些应用程序，你只可以访问某些许可的资源，不许可的资源是拒绝被访问的，于是就把Kernel和上层的应用程序抽像的隔离开，分别称之为Kernel Space和User Space。</p><p><strong>2. 用户空间的程序如何对内核空间进行访问？</strong><br>上面说到用户态和内核态是两个隔离的空间，虽然从逻辑上被抽像的隔离，但无可避免的是,总是会有那么一些用户空间需要访问内核空间的资源，怎么办呢？</p><p><img src="/2020/02/25/Linux%E6%9C%89%E5%85%B3%E7%AC%94%E8%AE%B0/02/25/Linux%E6%9C%89%E5%85%B3%E7%AC%94%E8%AE%B0/20151123145837317" alt="Linux内部结构"></p><p><a href="http://blog.csdn.net/ysgjiangsu/article/details/49995229">http://blog.csdn.net/ysgjiangsu/article/details/49995229</a><br>从上图结构中可以看出，Kernel Space层从下至上包括：<br>Arch：对应Kernel里arch目录，含有诸如x86, ia64, arm, s390等体系结构的支持；<br>Device Driver：对应Kernel里drivers目录，含有block, char, net, usb等不同硬件驱动的支持；<br>在Arch和Driver之上，是对内存，进程，文件系统，网络协议栈等的支持；</p><p>最上一层是System Call Interface，系统调用接口，正如其名，这层就是用户空间与内核空间的桥梁，用户空间的应用程序通过System Call这个统一入口来访问系统中的硬件资源，通过此接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。</p><p><strong>3.copy_to_user()在内核定义如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * copy_to_user: - Copy a block of data into user space.</span></span><br><span class="line"><span class="comment"> * @to: Destination address, in user space.</span></span><br><span class="line"><span class="comment"> * @from: Source address, in kernel space.</span></span><br><span class="line"><span class="comment"> * @n: Number of bytes to copy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Context: User context only. This function may sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copy data from kernel space to user space.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns number of bytes that could not be copied.</span></span><br><span class="line"><span class="comment"> * On success, this will be zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line"> <span class="title function_">copy_to_user</span><span class="params">(<span class="type">void</span> __user *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (access_ok(VERIFY_WRITE, to, n))</span><br><span class="line">         n = __copy_to_user(to, from, n);</span><br><span class="line">     <span class="keyword">return</span> n;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>其功能是将内核空间的内容复制到用户空间，所复制的内容是从from来，到to去，复制n个位。 其中又牵扯到两个函数：<strong>access_ok()</strong>和<strong>__copy_to_user()</strong>,好我们继续往下深入，先来看看第一个函数<strong>access_ok()</strong>的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* access_ok: - Checks if a user space pointer is valid</span></span><br><span class="line"><span class="comment"> * @type: Type of access: %VERIFY_READ or %VERIFY_WRITE. Note that</span></span><br><span class="line"><span class="comment"> * %VERIFY_WRITE is a superset of %VERIFY_READ - if it is safe</span></span><br><span class="line"><span class="comment"> * to write to a block, it is always safe to read from it.</span></span><br><span class="line"><span class="comment"> * @addr: User space pointer to start of block to check</span></span><br><span class="line"><span class="comment"> * @size: Size of block to check</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Context: User context only. This function may sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Checks if a pointer to a block of memory in user space is valid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns true (nonzero) if the memory block may be valid, false (zero)</span></span><br><span class="line"><span class="comment"> * if it is definitely invalid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that, depending on architecture, this function probably just</span></span><br><span class="line"><span class="comment"> * checks that the pointer is in the user space range - after calling</span></span><br><span class="line"><span class="comment"> * this function, memory access functions may still return -EFAULT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> access_ok(type,addr,size) (likely(__range_ok(addr,size) == 0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">access_ok</span><span class="params">(<span class="type">int</span> type, <span class="type">const</span> <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">long</span> memory_start, memory_end;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> val = (<span class="type">unsigned</span> <span class="type">long</span>)addr;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> ((val &gt;= memory_start) &amp;&amp; ((val + size) &lt; memory_end));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_MMU */</span></span></span><br></pre></td></tr></table></figure><p>其功能是检查用户空间是否合法，它的第一个参数：type，有两种 类型：VERIFY_READ 和VERIFY_WRITE，前者为可读，后者可写，注意：如果标志为可写（VERIFY_WRITE）时，必然可读！因为可写是可读的超集 （%VERIFY_WRITE is a superset of %VERIFY_READ）。<br>检查过程如下：addr为起始地址，size为所要复制的大小，那么从addr到addr＋size则是所要检查的空间，如果它的范围在memory_start和memory_end之间的话，则返回真。至于memory_start详细信息，我没有读。<br>到此为止，如果检查合法，那么OK，我们来实现真正的复制功能：<strong>__copy_to_user()</strong>，其源码定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">__kernel_size_t</span> __copy_to_user(<span class="type">void</span> __user *to, <span class="type">const</span> <span class="type">void</span> *from,</span><br><span class="line">  <span class="type">__kernel_size_t</span> n)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">return</span> __copy_user((<span class="type">void</span> __force *)to, from, n);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>又遇到一个函数：<strong>__copy_user()</strong>，这个函数才真正在做底层的复制工作<br><strong>__copy_user</strong><br>宏__copy_user在include/asm-i386/uaccess.h中定义，是作为从用户空间和内核空间进行内存复制的关键。这个宏扩展为汇编后如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000</span> <span class="meta">#<span class="keyword">define</span> __copy_user(to,from,size)</span></span><br><span class="line"><span class="number">001</span> <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="number">002</span> <span class="type">int</span> __d0, __d1;</span><br><span class="line"><span class="number">003</span> __asm__ __volatile__(</span><br><span class="line"><span class="number">004</span> <span class="string">&quot;0: rep; movsl\n&quot;</span></span><br><span class="line"><span class="number">005</span> <span class="string">&quot; movl %3,%0\n&quot;</span></span><br><span class="line"><span class="number">006</span> <span class="string">&quot;1: rep; movsb\n&quot;</span></span><br><span class="line"><span class="number">007</span> <span class="string">&quot;2:\n&quot;</span></span><br><span class="line"><span class="number">008</span> <span class="string">&quot;.section .fixup,\&quot;ax\&quot;\n&quot;</span></span><br><span class="line"><span class="number">009</span> <span class="string">&quot;3: lea 0(%3,%0,4),%0\n&quot;</span></span><br><span class="line"><span class="number">010</span> <span class="string">&quot; jmp 2b\n&quot;</span></span><br><span class="line"><span class="number">011</span> <span class="string">&quot;.previous\n&quot;</span></span><br><span class="line"><span class="number">012</span> <span class="string">&quot;.section __ex_table,\&quot;a\&quot;\n&quot;</span></span><br><span class="line"><span class="number">013</span> <span class="string">&quot; .align 4\n&quot;</span></span><br><span class="line"><span class="number">014</span> <span class="string">&quot; .long 0b,3b\n&quot;</span></span><br><span class="line"><span class="number">015</span> <span class="string">&quot; .long 1b,2b\n&quot;</span></span><br><span class="line"><span class="number">016</span> <span class="string">&quot;.previous&quot;</span></span><br><span class="line"><span class="number">017</span> : <span class="string">&quot;=&amp;c&quot;</span>(size), <span class="string">&quot;=&amp;D&quot;</span> (__d0), <span class="string">&quot;=&amp;S&quot;</span> (__d1)</span><br><span class="line"><span class="number">018</span> : <span class="string">&quot;r&quot;</span>(size &amp; <span class="number">3</span>), <span class="string">&quot;0&quot;</span>(size / <span class="number">4</span>), <span class="string">&quot;1&quot;</span>(to), <span class="string">&quot;2&quot;</span>(from)</span><br><span class="line"><span class="number">019</span> : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line"><span class="number">020</span> &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这段代码的主要操作就是004-007行，它的主要功能是将from处长度为size的数据复制到to处。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>详见<a href="https://blog.csdn.net/liushengxi_root/article/details/87439737">深入理解 Linux 文件系统</a></p><h2 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>系统调用是操作系统内核和应用程序之间的接口，而设备驱动程序是操作系统内核和机器硬件之间的接口。设备驱动程序为应用程序屏蔽了硬件的细节，这样在应用程序看来，硬件设备只是一个设备文件， 应用程序可以象操作普通文件一样对硬件设备进行操作。设备驱动程序是内核的一部分，它完成以下的功能：</p><ol><li>对设备初始化和释放. </li><li>把数据从内核传送到硬件和从硬件读取数据. </li><li>读取应用程序传送给设备文件的数据和回送应用程序请求的数据. </li><li>检测和处理设备出现的错误. </li></ol><p>Linux支持三中不同类型的设备：字符设备（character devices）、块设备（block devices）和网络设备（network interfaces）。字符设备和块设备的主要区别是:在对字符设备发出读/写请求时，实际的硬件I/O一般就紧接着发生了，块设备则不然，它利用一块系统内存作缓冲区，当用户进程对设备请求能满足用户的要求，就返回请求的数据，如果不能，就调用请求函数来进行实际的I/O操作.块设备是主要针对磁盘等慢速设备设计的，以免耗费过多的CPU时间来等待.</p><p>用户进程是通过设备文件来与实际的硬件打交道，每个设备文件都都有其文件属性(c/b)，表示是字符设备还是块设备。<strong>另外每个文件都有两个设备号，第一个是主设备号，标识驱动程序，第二个是从设备号，标识使用同一个设备驱动程序的不同的硬件设备，</strong>比如有两个软盘，就可以用从设备号来区分他们.设备文件的的主设备号必须与设备驱动程序在登记时申请的主设备号一致，否则用户进程将无法访问到驱动程序.。</p><p><strong>设备驱动程序工作的基本原理：</strong></p><p>用户进程利用系统调用对设备进行诸如read/write操作，系统调用通过设备文件的主设备号找到相应的设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数。</p><p>最后，在用户进程调用驱动程序时，系统进入核心态，这时不再是抢先式调度.也就是说，系统必须在你的驱动程序的子函数返回后才能进行其他的工作。如果你的驱动程序陷入死循环，你只有重新启动机器了。</p><h3 id="添加新模块的基本步骤"><a href="#添加新模块的基本步骤" class="headerlink" title="添加新模块的基本步骤"></a>添加新模块的基本步骤</h3><h4 id="写设备驱动源代码"><a href="#写设备驱动源代码" class="headerlink" title="写设备驱动源代码"></a>写设备驱动源代码</h4><p>在设备驱动程序中有一个非常重要的结构file_operations,该结构的每个域都对应着一个系统调用。用户进程利用系统调用在对设备文件进行诸如read/write操作时，系统调用通过设备文件的主设备号找到相应的设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span> </span><br><span class="line"><span class="type">int</span> (*seek) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *， <span class="type">off_t</span> ，<span class="type">int</span>); </span><br><span class="line"><span class="type">int</span> (*read) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *， <span class="type">char</span> ，<span class="type">int</span>); </span><br><span class="line"><span class="type">int</span> (*write) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *， <span class="type">off_t</span> ，<span class="type">int</span>); </span><br><span class="line"><span class="type">int</span> (*readdir) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *， <span class="keyword">struct</span> dirent * ，<span class="type">int</span>); </span><br><span class="line"><span class="type">int</span> (*select) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *， <span class="type">int</span> ，select_table *); </span><br><span class="line"><span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *， unsined <span class="type">int</span> ，<span class="type">unsigned</span> <span class="type">long</span>); </span><br><span class="line"><span class="type">int</span> (*mmap) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *， <span class="keyword">struct</span> vm_area_struct *); </span><br><span class="line"><span class="type">int</span> (*open) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *); </span><br><span class="line"><span class="type">int</span> (*release) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *); </span><br><span class="line"><span class="type">int</span> (*fsync) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *); </span><br><span class="line"><span class="type">int</span> (*fasync) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *，<span class="type">int</span>); </span><br><span class="line"><span class="type">int</span> (*check_media_change) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *); </span><br><span class="line"><span class="type">int</span> (*revalidate) (<span class="type">dev_t</span> dev); </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写设备驱动程序的<strong>主要工作是编写子函数，并填充**</strong>file_operations<strong>**的各个域</strong>。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Struct file_operations my_fops=&#123;</span><br><span class="line">       .read=my_read,</span><br><span class="line">       .write=my_write,</span><br><span class="line">       .open=my_open,</span><br><span class="line">       .release=my_release</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再定义函数my_read,my_write,my_open,my_release相应的函数体.对于可卸载的内核模块（LKM）,至少还有两个基本的模块：。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内核模块的初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">globalvar_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int register_chrdev(unsigned int major, unsigned int baseminor,unsigned int count, const char *name,const struct file_operations *fops)</span></span><br><span class="line"><span class="comment">    返回值提示操作成功还是失败。负的返回值表示错误;0 或正的返回值表明操作成功。</span></span><br><span class="line"><span class="comment">    major参数是被请求的主设备号,name 是设备的名称,该名称将出现在 /proc/devices 中, </span></span><br><span class="line"><span class="comment">    fops是指向函数指针数组的指针,这些函数是调用驱动程序的入口点,</span></span><br><span class="line"><span class="comment">    在 2.6 的内核之后，新增了一个 register_chrdev_region 函数，</span></span><br><span class="line"><span class="comment">    它支持将同一个主设备号下的次设备号进行分段，每一段供给一个字符设备驱动程序使用，使得资源利用率大大提升，</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    宏定义：#define MKDEV(major,minor) (((major) &lt;&lt; MINORBITS) | (minor))</span></span><br><span class="line"><span class="comment">    成功执行返回dev_t类型的设备编号，dev_t类型是unsigned int 类型，32位，用于在驱动程序中定义设备编号，</span></span><br><span class="line"><span class="comment">    高12位为主设备号，低20位为次设备号,可以通过MAJOR和MINOR来获得主设备号和次设备号。</span></span><br><span class="line"><span class="comment">    在module_init宏调用的函数中去注册字符设备驱动</span></span><br><span class="line"><span class="comment">    major传0进去表示要让内核帮我们自动分配一个合适的空白的没被使用的主设备号</span></span><br><span class="line"><span class="comment">    内核如果成功分配就会返回分配的主设备号；如果分配失败会返回负数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">dev_t</span> dev = MKDEV(major, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(major)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//静态申请设备编号</span></span><br><span class="line">        result = register_chrdev_region(dev, <span class="number">1</span>, <span class="string">&quot;charmem&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//动态分配设备号</span></span><br><span class="line">        result = alloc_chrdev_region(&amp;dev, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;charmem&quot;</span>);</span><br><span class="line">        major = MAJOR(dev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    file_operations这个结构体变量，让cdev中的ops成员的值为file_operations结构体变量的值。</span></span><br><span class="line"><span class="comment">    这个结构体会被cdev_add函数想内核注册cdev结构体，可以用很多函数来操作他。</span></span><br><span class="line"><span class="comment">    如：</span></span><br><span class="line"><span class="comment">    cdev_alloc：让内核为这个结构体分配内存的</span></span><br><span class="line"><span class="comment">    cdev_init：将struct cdev类型的结构体变量和file_operations结构体进行绑定的</span></span><br><span class="line"><span class="comment">    cdev_add：向内核里面添加一个驱动，注册驱动</span></span><br><span class="line"><span class="comment">    cdev_del：从内核中注销掉一个驱动。注销驱动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//注册字符设备驱动，设备号和file_operations结构体进行绑定</span></span><br><span class="line">    cdev_init(&amp;globalvar.devm, &amp;globalvar_fops);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    #define THIS_MODULE (&amp;__this_module)是一个struct module变量，代表当前模块，</span></span><br><span class="line"><span class="comment">    与那个著名的current有几分相似，可以通过THIS_MODULE宏来引用模块的struct module结构，</span></span><br><span class="line"><span class="comment">    比如使用THIS_MODULE-&gt;state可以获得当前模块的状态。</span></span><br><span class="line"><span class="comment">    现在你应该明白为啥在那个岁月里，你需要毫不犹豫毫不迟疑的将struct usb_driver结构里的owner设置为THIS_MODULE了吧，</span></span><br><span class="line"><span class="comment">    这个owner指针指向的就是你的模块自己。</span></span><br><span class="line"><span class="comment">    那现在owner咋就说没就没了那？这个说来可就话长了，咱就长话短说吧。</span></span><br><span class="line"><span class="comment">    不知道那个时候你有没有忘记过初始化owner，</span></span><br><span class="line"><span class="comment">    反正是很多人都会忘记，</span></span><br><span class="line"><span class="comment">    于是在2006年的春节前夕，在咱们都无心工作无心学习等着过春节的时候，Greg坚守一线，去掉了 owner，</span></span><br><span class="line"><span class="comment">    于是千千万万个写usb驱动的人再也不用去时刻谨记初始化owner了。</span></span><br><span class="line"><span class="comment">    咱们是不用设置owner了，可core里不能不设置，</span></span><br><span class="line"><span class="comment">    struct usb_driver结构里不是没有owner了么，</span></span><br><span class="line"><span class="comment">    可它里面嵌的那个struct device_driver结构里还有啊，设置了它就可以了。</span></span><br><span class="line"><span class="comment">    于是Greg同时又增加了usb_register_driver()这么一层，</span></span><br><span class="line"><span class="comment">    usb_register()可以通过将参数指定为THIS_MODULE去调用它，所有的事情都挪到它里面去做。</span></span><br><span class="line"><span class="comment">    反正usb_register() 也是内联的，并不会增加调用的开销。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    globalvar.devm.owner = THIS_MODULE;</span><br><span class="line">    err = cdev_add(&amp;globalvar.devm, dev, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;Error %d adding char_mem device&quot;</span>, err);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;globalvar register success\n&quot;</span>);</span><br><span class="line">        sema_init(&amp;globalvar.sem,<span class="number">1</span>); <span class="comment">//初始化信号量</span></span><br><span class="line">        init_waitqueue_head(&amp;globalvar.outq); <span class="comment">//初始化等待队列</span></span><br><span class="line">        globalvar.rd = globalvar.buffer; <span class="comment">//读指针</span></span><br><span class="line">        globalvar.wr = globalvar.buffer; <span class="comment">//写指针</span></span><br><span class="line">        globalvar.end = globalvar.buffer + MAXNUM;<span class="comment">//缓冲区尾指针</span></span><br><span class="line">        globalvar.flag = <span class="number">0</span>; <span class="comment">// 阻塞唤醒标志置 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义在/include/linux/device.h</span></span><br><span class="line"><span class="comment">    创建class并将class注册到内核中，返回值为class结构指针</span></span><br><span class="line"><span class="comment">    在驱动初始化的代码里调用class_create为该设备创建一个class，再为每个设备调用device_create创建对应的设备。</span></span><br><span class="line"><span class="comment">    省去了利用mknod命令手动创建设备节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    my_class = class_create(THIS_MODULE, <span class="string">&quot;chardev0&quot;</span>);</span><br><span class="line">    device_create(my_class, <span class="literal">NULL</span>, dev, <span class="literal">NULL</span>, <span class="string">&quot;chardev0&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">globalvar_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(my_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">    class_destroy(my_class);</span><br><span class="line">    cdev_del(&amp;globalvar.devm);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    参数列表包括要释放的主设备号和相应的设备名。</span></span><br><span class="line"><span class="comment">    参数中的这个设备名会被内核用来和主设备号参数所对应的已注册设备名进行比较,如果不同,则返回 -EINVAL。</span></span><br><span class="line"><span class="comment">    如果主设备号超出了所允许的范围,则内核同样返回 -EINVAL。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    unregister_chrdev_region(MKDEV(major, <span class="number">0</span>), <span class="number">1</span>);<span class="comment">//注销设备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译安装模块"><a href="#编译安装模块" class="headerlink" title="编译安装模块"></a>编译安装模块</h3><p>Makefile:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj-m += globalvar.o <span class="meta">#obj-m 指编译成外部模块</span></span><br><span class="line"></span><br><span class="line">build:</span><br><span class="line">make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span></span><br><span class="line">insmod globalvar.ko</span><br></pre></td></tr></table></figure><p>卸载模块：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rmmod mydev</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> start, len;</span><br><span class="line"><span class="comment">//fd = open(&quot;/dev/chardev0&quot;, O_RDWR, S_IRUSR | S_IWUSR);</span></span><br><span class="line">fd = open(<span class="string">&quot;/dev/mydev&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Open device error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">4</span> &amp;&amp; <span class="built_in">strncmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;read&quot;</span>, <span class="number">4</span>) == <span class="number">0</span>) &#123; </span><br><span class="line"><span class="comment">//static ssize_t my_read(struct file* filp, char* buf, size_t len, loff_t* off) </span></span><br><span class="line">start = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">len = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">lseek(fd, start, SEEK_SET);</span><br><span class="line">read(fd, buf, len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Character device read : %s\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">4</span> &amp;&amp; <span class="built_in">strncmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;write&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">start = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">lseek(fd, start, SEEK_CUR);</span><br><span class="line">write(fd, argv[<span class="number">3</span>], <span class="built_in">strlen</span>(argv[<span class="number">3</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage : ./executable file &lt;read | write&gt; &lt;start_offset&gt; &lt;len | string&gt;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考代码<a href="https://www.cnblogs.com/yueshangzuo/p/8078687.html">来自</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参考：深入浅出linux设备驱动开发</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNUM 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAJOR_NUM 456 <span class="comment">//主设备号 ,没有被使用</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">devm</span>;</span> <span class="comment">//字符设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> outq;<span class="comment">//等待队列,实现阻塞操作</span></span><br><span class="line">    <span class="type">int</span> flag; <span class="comment">//阻塞唤醒标志</span></span><br><span class="line">    <span class="type">char</span> buffer[MAXNUM+<span class="number">1</span>]; <span class="comment">//字符缓冲区</span></span><br><span class="line">    <span class="type">char</span> *rd,*wr,*end; <span class="comment">//读,写,尾指针</span></span><br><span class="line">&#125;globalvar;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">my_class</span>;</span></span><br><span class="line"><span class="type">int</span> major=MAJOR_NUM;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">globalvar_read</span><span class="params">(<span class="keyword">struct</span> file *,<span class="type">char</span> *,<span class="type">size_t</span> ,<span class="type">loff_t</span> *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">globalvar_write</span><span class="params">(<span class="keyword">struct</span> file *,<span class="type">const</span> <span class="type">char</span> *,<span class="type">size_t</span> ,<span class="type">loff_t</span> *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">globalvar_open</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *filp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">globalvar_release</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *filp)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结构体file_operations在头文件 linux/fs.h中定义，用来存储驱动内核模块提供的对设备进行各种操作的函数的指针。</span></span><br><span class="line"><span class="comment">该结构体的每个域都对应着驱动内核模块用来处理某个被请求的事务的函数的地址。</span></span><br><span class="line"><span class="comment">设备&quot;gobalvar&quot;的基本入口点结构变量gobalvar_fops </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">globalvar_fops</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    标记化的初始化格式这种格式允许用名字对这类结构的字段进行初始化,这就避免了因数据结构发生变化而带来的麻烦。</span></span><br><span class="line"><span class="comment">    这种标记化的初始化处理并不是标准 C 的规范,而是对 GUN 编译器的一种(有用的)特殊扩展</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//用来从设备中获取数据. 在这个位置的一个空指针导致 read 系统调用以 -EINVAL(&quot;Invalid argument&quot;) 失败. 一个非负返回值代表了成功读取的字节数( 返回值是一个 &quot;signed size&quot; 类型, 常常是目标平台本地的整数类型).</span></span><br><span class="line">    .read=globalvar_read,</span><br><span class="line">    <span class="comment">//发送数据给设备. 如果 NULL, -EINVAL 返回给调用 write 系统调用的程序. 如果非负, 返回值代表成功写的字节数.</span></span><br><span class="line">    .write=globalvar_write,</span><br><span class="line">    <span class="comment">//尽管这常常是对设备文件进行的第一个操作, 不要求驱动声明一个对应的方法. 如果这个项是 NULL, 设备打开一直成功, 但是你的驱动不会得到通知.</span></span><br><span class="line">    .open=globalvar_open,</span><br><span class="line">    <span class="comment">//当最后一个打开设备的用户进程执行close ()系统调用时，内核将调用驱动程序的release () 函数：release 函数的主要任务是清理未结束的输入/输出操作、释放资源、用户自定义排他标志的复位等。</span></span><br><span class="line">    .release=globalvar_release,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//内核模块的初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">globalvar_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int register_chrdev(unsigned int major, unsigned int baseminor,unsigned int count, const char *name,const struct file_operations *fops)</span></span><br><span class="line"><span class="comment">    返回值提示操作成功还是失败。负的返回值表示错误;0 或正的返回值表明操作成功。</span></span><br><span class="line"><span class="comment">    major参数是被请求的主设备号,name 是设备的名称,该名称将出现在 /proc/devices 中, </span></span><br><span class="line"><span class="comment">    fops是指向函数指针数组的指针,这些函数是调用驱动程序的入口点,</span></span><br><span class="line"><span class="comment">    在 2.6 的内核之后，新增了一个 register_chrdev_region 函数，</span></span><br><span class="line"><span class="comment">    它支持将同一个主设备号下的次设备号进行分段，每一段供给一个字符设备驱动程序使用，使得资源利用率大大提升，</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    宏定义：#define MKDEV(major,minor) (((major) &lt;&lt; MINORBITS) | (minor))</span></span><br><span class="line"><span class="comment">    成功执行返回dev_t类型的设备编号，dev_t类型是unsigned int 类型，32位，用于在驱动程序中定义设备编号，</span></span><br><span class="line"><span class="comment">    高12位为主设备号，低20位为次设备号,可以通过MAJOR和MINOR来获得主设备号和次设备号。</span></span><br><span class="line"><span class="comment">    在module_init宏调用的函数中去注册字符设备驱动</span></span><br><span class="line"><span class="comment">    major传0进去表示要让内核帮我们自动分配一个合适的空白的没被使用的主设备号</span></span><br><span class="line"><span class="comment">    内核如果成功分配就会返回分配的主设备号；如果分配失败会返回负数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">dev_t</span> dev = MKDEV(major, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(major)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//静态申请设备编号</span></span><br><span class="line">        result = register_chrdev_region(dev, <span class="number">1</span>, <span class="string">&quot;charmem&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//动态分配设备号</span></span><br><span class="line">        result = alloc_chrdev_region(&amp;dev, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;charmem&quot;</span>);</span><br><span class="line">        major = MAJOR(dev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    file_operations这个结构体变量，让cdev中的ops成员的值为file_operations结构体变量的值。</span></span><br><span class="line"><span class="comment">    这个结构体会被cdev_add函数想内核注册cdev结构体，可以用很多函数来操作他。</span></span><br><span class="line"><span class="comment">    如：</span></span><br><span class="line"><span class="comment">    cdev_alloc：让内核为这个结构体分配内存的</span></span><br><span class="line"><span class="comment">    cdev_init：将struct cdev类型的结构体变量和file_operations结构体进行绑定的</span></span><br><span class="line"><span class="comment">    cdev_add：向内核里面添加一个驱动，注册驱动</span></span><br><span class="line"><span class="comment">    cdev_del：从内核中注销掉一个驱动。注销驱动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//注册字符设备驱动，设备号和file_operations结构体进行绑定</span></span><br><span class="line">    cdev_init(&amp;globalvar.devm, &amp;globalvar_fops);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    #define THIS_MODULE (&amp;__this_module)是一个struct module变量，代表当前模块，</span></span><br><span class="line"><span class="comment">    与那个著名的current有几分相似，可以通过THIS_MODULE宏来引用模块的struct module结构，</span></span><br><span class="line"><span class="comment">    比如使用THIS_MODULE-&gt;state可以获得当前模块的状态。</span></span><br><span class="line"><span class="comment">    现在你应该明白为啥在那个岁月里，你需要毫不犹豫毫不迟疑的将struct usb_driver结构里的owner设置为THIS_MODULE了吧，</span></span><br><span class="line"><span class="comment">    这个owner指针指向的就是你的模块自己。</span></span><br><span class="line"><span class="comment">    那现在owner咋就说没就没了那？这个说来可就话长了，咱就长话短说吧。</span></span><br><span class="line"><span class="comment">    不知道那个时候你有没有忘记过初始化owner，</span></span><br><span class="line"><span class="comment">    反正是很多人都会忘记，</span></span><br><span class="line"><span class="comment">    于是在2006年的春节前夕，在咱们都无心工作无心学习等着过春节的时候，Greg坚守一线，去掉了 owner，</span></span><br><span class="line"><span class="comment">    于是千千万万个写usb驱动的人再也不用去时刻谨记初始化owner了。</span></span><br><span class="line"><span class="comment">    咱们是不用设置owner了，可core里不能不设置，</span></span><br><span class="line"><span class="comment">    struct usb_driver结构里不是没有owner了么，</span></span><br><span class="line"><span class="comment">    可它里面嵌的那个struct device_driver结构里还有啊，设置了它就可以了。</span></span><br><span class="line"><span class="comment">    于是Greg同时又增加了usb_register_driver()这么一层，</span></span><br><span class="line"><span class="comment">    usb_register()可以通过将参数指定为THIS_MODULE去调用它，所有的事情都挪到它里面去做。</span></span><br><span class="line"><span class="comment">    反正usb_register() 也是内联的，并不会增加调用的开销。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    globalvar.devm.owner = THIS_MODULE;</span><br><span class="line">    err = cdev_add(&amp;globalvar.devm, dev, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;Error %d adding char_mem device&quot;</span>, err);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;globalvar register success\n&quot;</span>);</span><br><span class="line">        sema_init(&amp;globalvar.sem,<span class="number">1</span>); <span class="comment">//初始化信号量</span></span><br><span class="line">        init_waitqueue_head(&amp;globalvar.outq); <span class="comment">//初始化等待队列</span></span><br><span class="line">        globalvar.rd = globalvar.buffer; <span class="comment">//读指针</span></span><br><span class="line">        globalvar.wr = globalvar.buffer; <span class="comment">//写指针</span></span><br><span class="line">        globalvar.end = globalvar.buffer + MAXNUM;<span class="comment">//缓冲区尾指针</span></span><br><span class="line">        globalvar.flag = <span class="number">0</span>; <span class="comment">// 阻塞唤醒标志置 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义在/include/linux/device.h</span></span><br><span class="line"><span class="comment">    创建class并将class注册到内核中，返回值为class结构指针</span></span><br><span class="line"><span class="comment">    在驱动初始化的代码里调用class_create为该设备创建一个class，再为每个设备调用device_create创建对应的设备。</span></span><br><span class="line"><span class="comment">    省去了利用mknod命令手动创建设备节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    my_class = class_create(THIS_MODULE, <span class="string">&quot;chardev0&quot;</span>);</span><br><span class="line">    device_create(my_class, <span class="literal">NULL</span>, dev, <span class="literal">NULL</span>, <span class="string">&quot;chardev0&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在大部分驱动程序中,open 应完成如下工作:</span></span><br><span class="line"><span class="comment">● 递增使用计数。--为了老版本的可移植性</span></span><br><span class="line"><span class="comment">● 检查设备特定的错误(诸如设备未就绪或类似的硬件问题)。</span></span><br><span class="line"><span class="comment">● 如果设备是首次打开,则对其进行初始化。</span></span><br><span class="line"><span class="comment">● 识别次设备号,并且如果有必要,更新 f_op 指针。</span></span><br><span class="line"><span class="comment">● 分配并填写被置于 filp-&gt;private_data 里的数据结构。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">globalvar_open</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    try_module_get(THIS_MODULE);<span class="comment">//模块计数加一</span></span><br><span class="line">    printk(<span class="string">&quot;This chrdev is in open\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">release都应该完成下面的任务:</span></span><br><span class="line"><span class="comment">● 释放由 open 分配的、保存在 filp-&gt;private_data 中的所有内容。</span></span><br><span class="line"><span class="comment">● 在最后一次关闭操作时关闭设备。字符设备驱动程序</span></span><br><span class="line"><span class="comment">● 使用计数减 1。</span></span><br><span class="line"><span class="comment">如果使用计数不归0,内核就无法卸载模块。</span></span><br><span class="line"><span class="comment">并不是每个 close 系统调用都会引起对 release 方法的调用。</span></span><br><span class="line"><span class="comment">仅仅是那些真正释放设备数据结构的 close 调用才会调用这个方法,</span></span><br><span class="line"><span class="comment">因此名字是 release 而不是 close。内核维护一个 file 结构被使用多少次的计数器。</span></span><br><span class="line"><span class="comment">无论是 fork 还是 dup 都不创建新的数据结构(仅由 open 创建),它们只是增加已有结构中的计数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">globalvar_release</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    module_put(THIS_MODULE); <span class="comment">//模块计数减一</span></span><br><span class="line">    printk(<span class="string">&quot;This chrdev is in release\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">globalvar_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(my_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">    class_destroy(my_class);</span><br><span class="line">    cdev_del(&amp;globalvar.devm);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    参数列表包括要释放的主设备号和相应的设备名。</span></span><br><span class="line"><span class="comment">    参数中的这个设备名会被内核用来和主设备号参数所对应的已注册设备名进行比较,如果不同,则返回 -EINVAL。</span></span><br><span class="line"><span class="comment">    如果主设备号超出了所允许的范围,则内核同样返回 -EINVAL。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    unregister_chrdev_region(MKDEV(major, <span class="number">0</span>), <span class="number">1</span>);<span class="comment">//注销设备</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ssize_t read(struct file *filp, char *buff,size_t count, loff_t *offp);</span></span><br><span class="line"><span class="comment">参数 filp 是文件指针,参数 count 是请求传输的数据长度。</span></span><br><span class="line"><span class="comment">参数 buff 是指向用户空间的缓冲区,这个缓冲区或者保存将写入的数据,或者是一个存放新读入数据的空缓冲区。</span></span><br><span class="line"><span class="comment">最后的 offp 是一个指向“long offset type(长偏移量类型)”对象的指针,这个对象指明用户在文件中进行存取操作的位置。</span></span><br><span class="line"><span class="comment">返回值是“signed size type(有符号的尺寸类型)”</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">主要问题是,需要在内核地址空间和用户地址空间之间传输数据。</span></span><br><span class="line"><span class="comment">不能用通常的办法利用指针或 memcpy来完成这样的操作。由于许多原因,不能在内核空间中直接使用用户空间地址。</span></span><br><span class="line"><span class="comment">内核空间地址与用户空间地址之间很大的一个差异就是,用户空间的内存是可被换出的。</span></span><br><span class="line"><span class="comment">当内核访问用户空间指针时,相对应的页面可能已不在内存中了,这样的话就会产生一个页面失效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">globalvar_read</span><span class="params">(<span class="keyword">struct</span> file *filp,<span class="type">char</span> *buf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(wait_event_interruptible(globalvar.outq,globalvar.flag!=<span class="number">0</span>)) <span class="comment">//不可读时 阻塞读进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -ERESTARTSYS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    down_interruptible 可以由一个信号中断,但 down 不允许有信号传送到进程。</span></span><br><span class="line"><span class="comment">    大多数情况下都希望信号起作用;否则,就有可能建立一个无法杀掉的进程,并产生其他不可预期的结果。</span></span><br><span class="line"><span class="comment">    但是,允许信号中断将使得信号量的处理复杂化,因为我们总要去检查函数(这里是 down_interruptible)是否已被中断。</span></span><br><span class="line"><span class="comment">    一般来说,当该函数返回 0 时表示成功,返回非 0 时则表示出错。</span></span><br><span class="line"><span class="comment">    如果这个处理过程被中断,它就不会获得信号量 , 因此,也就不能调用 up 函数了。</span></span><br><span class="line"><span class="comment">    因此,对信号量的典型调用通常是下面的这种形式:</span></span><br><span class="line"><span class="comment">    if (down_interruptible (&amp;sem))</span></span><br><span class="line"><span class="comment">        return -ERESTARTSYS;</span></span><br><span class="line"><span class="comment">    返回值 -ERESTARTSYS通知系统操作被信号中断。</span></span><br><span class="line"><span class="comment">    调用这个设备方法的内核函数或者重新尝试,或者返回 -EINTR 给应用程序,这取决于应用程序是如何设置信号处理函数的。</span></span><br><span class="line"><span class="comment">    当然,如果是以这种方式中断操作的话,那么代码应在返回前完成清理工作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    使用down_interruptible来获取信号量的代码不应调用其他也试图获得该信号量的函数,否则就会陷入死锁。</span></span><br><span class="line"><span class="comment">    如果驱动程序中的某段程序对其持有的信号量释放失败的话(可能就是一次出错返回的结果),</span></span><br><span class="line"><span class="comment">    那么其他任何获取该信号量的尝试都将阻塞在那里。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(down_interruptible(&amp;globalvar.sem)) <span class="comment">//P 操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -ERESTARTSYS;</span><br><span class="line">    &#125;</span><br><span class="line">    globalvar.flag = <span class="number">0</span>;</span><br><span class="line">    printk(<span class="string">&quot;into the read function\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;the rd is %c\n&quot;</span>,*globalvar.rd); <span class="comment">//读指针</span></span><br><span class="line">    <span class="keyword">if</span>(globalvar.rd &lt; globalvar.wr)</span><br><span class="line">        len = min(len,(<span class="type">size_t</span>)(globalvar.wr - globalvar.rd)); <span class="comment">//更新读写长度</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        len = min(len,(<span class="type">size_t</span>)(globalvar.end - globalvar.rd));</span><br><span class="line">    printk(<span class="string">&quot;the len is %d\n&quot;</span>,len);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    read 和 write 代码要做的工作,就是在用户地址空间和内核地址空间之间进行整段数据的拷贝。</span></span><br><span class="line"><span class="comment">    这种能力是由下面的内核函数提供的,它们用于拷贝任意的一段字节序列,这也是每个 read 和 write 方法实现的核心部分:</span></span><br><span class="line"><span class="comment">    unsigned long copy_to_user(void *to, const void *from,unsigned long count);</span></span><br><span class="line"><span class="comment">    unsigned long copy_from_user(void *to, const void *from,unsigned long count);</span></span><br><span class="line"><span class="comment">    虽然这些函数的行为很像通常的 memcpy 函数,但当在内核空间内运行的代码访问用户空间时,则要多加小心。</span></span><br><span class="line"><span class="comment">    被寻址的用户空间的页面可能当前并不在内存,于是处理页面失效的程序会使访问进程转入睡眠,直到该页面被传送至期望的位置。</span></span><br><span class="line"><span class="comment">    例如,当页面必须从交换空间取回时,这样的情况就会发生。对于驱动程序编写人员来说,</span></span><br><span class="line"><span class="comment">    结果就是访问用户空间的任何函数都必须是可重入的,并且必须能和其他驱动程序函数并发执行。</span></span><br><span class="line"><span class="comment">    这就是我们使用信号量来控制并发访问的原因.</span></span><br><span class="line"><span class="comment">    这两个函数的作用并不限于在内核空间和用户空间之间拷贝数据,它们还检查用户空间的指针是否有效。</span></span><br><span class="line"><span class="comment">    如果指针无效,就不会进行拷贝;另一方面,如果在拷贝过程中遇到无效地址,则仅仅会复制部分数据。</span></span><br><span class="line"><span class="comment">    在这两种情况下,返回值是还未拷贝完的内存的数量值。</span></span><br><span class="line"><span class="comment">    如果发现这样的错误返回,就会在返回值不为 0 时,返回 -EFAULT 给用户。</span></span><br><span class="line"><span class="comment">    负值意味着发生了错误,该值指明发生了什么错误,错误码在&lt;linux/errno.h&gt;中定义。</span></span><br><span class="line"><span class="comment">    比如这样的一些错误:-EINTR(系统调用被中断)或 -EFAULT (无效地址)。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(copy_to_user(buf,globalvar.rd,len))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT<span class="string">&quot;copy failed\n&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        up递增信号量的值,并唤醒所有正在等待信号量转为可用状态的进程。</span></span><br><span class="line"><span class="comment">        必须小心使用信号量。被信号量保护的数据必须是定义清晰的,并且存取这些数据的所有代码都必须首先获得信号量。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        up(&amp;globalvar.sem);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;the read buffer is %s\n&quot;</span>,globalvar.buffer);</span><br><span class="line">    globalvar.rd = globalvar.rd + len;</span><br><span class="line">    <span class="keyword">if</span>(globalvar.rd == globalvar.end)</span><br><span class="line">        globalvar.rd = globalvar.buffer; <span class="comment">//字符缓冲区循环</span></span><br><span class="line">    up(&amp;globalvar.sem); <span class="comment">//V 操作</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">globalvar_write</span><span class="params">(<span class="keyword">struct</span> file *filp,<span class="type">const</span> <span class="type">char</span> *buf,<span class="type">size_t</span> len,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(down_interruptible(&amp;globalvar.sem)) <span class="comment">//P 操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -ERESTARTSYS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(globalvar.rd &lt;= globalvar.wr)</span><br><span class="line">        len = min(len,(<span class="type">size_t</span>)(globalvar.end - globalvar.wr));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        len = min(len,(<span class="type">size_t</span>)(globalvar.rd-globalvar.wr<span class="number">-1</span>));</span><br><span class="line">    printk(<span class="string">&quot;the write len is %d\n&quot;</span>,len);</span><br><span class="line">    <span class="keyword">if</span>(copy_from_user(globalvar.wr,buf,len))</span><br><span class="line">    &#123;</span><br><span class="line">        up(&amp;globalvar.sem); <span class="comment">//V 操作</span></span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;the write buffer is %s\n&quot;</span>,globalvar.buffer);</span><br><span class="line">    printk(<span class="string">&quot;the len of buffer is %d\n&quot;</span>,<span class="built_in">strlen</span>(globalvar.buffer));</span><br><span class="line">    globalvar.wr = globalvar.wr + len;</span><br><span class="line">    <span class="keyword">if</span>(globalvar.wr == globalvar.end)</span><br><span class="line">    globalvar.wr = globalvar.buffer; <span class="comment">//循环</span></span><br><span class="line">    up(&amp;globalvar.sem);</span><br><span class="line">    <span class="comment">//V 操作</span></span><br><span class="line">    globalvar.flag=<span class="number">1</span>; <span class="comment">//条件成立,可以唤醒读进程</span></span><br><span class="line">    wake_up_interruptible(&amp;globalvar.outq); <span class="comment">//唤醒读进程</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line">module_init(globalvar_init);</span><br><span class="line">module_exit(globalvar_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><p>mydev:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNUM 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAJOR_NUM 300  <span class="comment">//主设备号，没有被使用  查看/proc/devices可知</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定license版本</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">devm</span>;</span> <span class="comment">//字符设备</span></span><br><span class="line"><span class="type">char</span> buf[MAXNUM + <span class="number">1</span>]; <span class="comment">//字符缓冲区</span></span><br><span class="line"><span class="type">char</span>* rd, * wr, * end; <span class="comment">//读,写,尾指针</span></span><br><span class="line">&#125;globalvar;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span>* <span class="title">my_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件打开函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_open</span><span class="params">(<span class="keyword">struct</span> inode* inode, <span class="keyword">struct</span> file* filp)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;Character device is open.\n&quot;</span>);</span><br><span class="line"><span class="comment">//try_module_get(THIS_MODULE);//模块计数加一</span></span><br><span class="line">filp-&gt;private_data = &amp;globalvar;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件释放函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_release</span><span class="params">(<span class="keyword">struct</span> inode* inode, <span class="keyword">struct</span> file* filp)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;Character device is released.\n&quot;</span>);</span><br><span class="line"><span class="comment">//module_put(THIS_MODULE); //模块计数减一</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//模块卸载函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mydev_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;Unload module: mydev.\n&quot;</span>);</span><br><span class="line">device_destroy(my_class, MKDEV(MAJOR_NUM, <span class="number">0</span>));</span><br><span class="line">class_destroy(my_class);</span><br><span class="line">cdev_del(&amp;globalvar.devm);</span><br><span class="line">cdev_del(&amp;globalvar.devm);  <span class="comment">//注销设备</span></span><br><span class="line">unregister_chrdev_region(MKDEV(MAJOR_NUM, <span class="number">0</span>), <span class="number">1</span>);  <span class="comment">//释放设备号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">my_read</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="type">char</span> __user* buf, <span class="type">size_t</span> len, <span class="type">loff_t</span>* off)</span> &#123;</span><br><span class="line">printk(KERN_INFO <span class="string">&quot;Character device start read.\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> rtn = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> free_mem = MAXNUM - *off;  <span class="comment">//剩余可用空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev</span>* <span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"><span class="keyword">if</span> (len &lt;= free_mem) &#123;  <span class="comment">//可用空间充足</span></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(buf, dev-&gt;buf + *off, len)) &#123;</span><br><span class="line">printk(KERN_ALERT <span class="string">&quot;1.Copy to user buffer failed.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line">*off += len;</span><br><span class="line">rtn = len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//可用空间不足</span></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(buf, dev-&gt;buf + *off, free_mem)) &#123;</span><br><span class="line">printk(KERN_ALERT<span class="string">&quot;2.Copy to user buffer failed.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line">*off += free_mem;</span><br><span class="line">rtn = free_mem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printk(&quot;the read buffer is %s\n&quot;, globalvar.buf);</span></span><br><span class="line">printk(KERN_INFO <span class="string">&quot;Character device has read %d bytes.\n&quot;</span>, rtn);</span><br><span class="line"><span class="keyword">return</span> rtn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">my_write</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="type">const</span> <span class="type">char</span> __user * buf, <span class="type">size_t</span> len, <span class="type">loff_t</span>* off)</span> &#123;</span><br><span class="line">printk(KERN_INFO <span class="string">&quot;Start write.\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> rtn = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> free_mem = MAXNUM - *off;  <span class="comment">//剩余可用空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev</span>* <span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"><span class="comment">//printk(KERN_DEBUG &quot;len: %d buf:%send.\n&quot;,strlen(dev-&gt;buf), dev-&gt;buf);</span></span><br><span class="line"><span class="keyword">if</span> (len &lt;= free_mem) &#123;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(dev-&gt;buf + *off, buf, len)) &#123;</span><br><span class="line">printk(KERN_ALERT <span class="string">&quot;1.Copy frome user buffer failed.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line">*off += len;</span><br><span class="line">rtn = len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(dev-&gt;buf + *off, buf, free_mem)) &#123;</span><br><span class="line">printk(KERN_ALERT<span class="string">&quot;2.Copy frome user buffer failed.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line">*off += free_mem;</span><br><span class="line">rtn = free_mem;</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">&quot;Character device has written %d bytes.\n&quot;</span>, rtn);</span><br><span class="line"><span class="keyword">return</span> rtn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件定位函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">my_llseek</span><span class="params">(<span class="keyword">struct</span> file* filp, <span class="type">loff_t</span> off, <span class="type">int</span> whence)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(KERN_INFO <span class="string">&quot;Character device start lseek.\n&quot;</span>);</span><br><span class="line"><span class="type">loff_t</span> rtn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (whence) &#123;</span><br><span class="line"><span class="keyword">case</span> SEEK_SET:</span><br><span class="line">rtn = off;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SEEK_CUR:</span><br><span class="line">rtn = filp-&gt;f_pos + off;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SEEK_END:</span><br><span class="line">rtn = MAXNUM + off;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rtn &lt; <span class="number">0</span> || rtn &gt; MAXNUM)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">printk(<span class="string">&quot;Character device set offset at %d.\n&quot;</span>, rtn);</span><br><span class="line">filp-&gt;f_pos = rtn;</span><br><span class="line"><span class="keyword">return</span> rtn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">my_fops</span> =</span> &#123;</span><br><span class="line">.open = my_open,</span><br><span class="line">.read = my_read,</span><br><span class="line">.write = my_write,</span><br><span class="line">.release = my_release,</span><br><span class="line">.llseek = my_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置初始化入口函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mydev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printk(KERN_DEBUG &quot;hello %s!!!\n&quot;, name);</span></span><br><span class="line">printk(KERN_DEBUG <span class="string">&quot;Load module: mydev\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> rtn;</span><br><span class="line"><span class="type">dev_t</span> devno = MKDEV(MAJOR_NUM, <span class="number">0</span>);  <span class="comment">//注册字符设备驱动</span></span><br><span class="line">rtn = register_chrdev_region(devno, <span class="number">1</span>, <span class="string">&quot;mydev&quot;</span>);  <span class="comment">//静态申请设备编号</span></span><br><span class="line"><span class="keyword">if</span> (rtn &lt; <span class="number">0</span>) &#123;</span><br><span class="line">printk(KERN_ALERT <span class="string">&quot;Register character device error.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> rtn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(globalvar.buf, <span class="string">&#x27;\0&#x27;</span>, MAXNUM + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//printk(KERN_DEBUG &quot;buf:%s\n&quot;, globalvar.buf);</span></span><br><span class="line">cdev_init(&amp;(globalvar.devm), &amp;my_fops); <span class="comment">//注册字符设备驱动，设备号和file_operations结构体进行绑定</span></span><br><span class="line">globalvar.devm.owner = THIS_MODULE;  <span class="comment">//通过THIS_MODULE宏来引用模块的struct module结构</span></span><br><span class="line">rtn = cdev_add(&amp;(globalvar.devm), devno, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (rtn)</span><br><span class="line">printk(KERN_ALERT <span class="string">&quot;Error %d adding mydev device.\n&quot;</span>, rtn);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">printk(KERN_INFO <span class="string">&quot;Character device register success.\n&quot;</span>);</span><br><span class="line">globalvar.rd = globalvar.buf; <span class="comment">//读指针</span></span><br><span class="line">globalvar.wr = globalvar.buf;  <span class="comment">//写指针</span></span><br><span class="line">globalvar.end = globalvar.buf + MAXNUM;  <span class="comment">//缓冲区尾指针</span></span><br><span class="line">&#125;</span><br><span class="line">my_class = class_create(THIS_MODULE, <span class="string">&quot;mydev&quot;</span>);</span><br><span class="line">device_create(my_class, <span class="literal">NULL</span>, devno, <span class="literal">NULL</span>, <span class="string">&quot;mydev&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mydev_init);</span><br><span class="line">module_exit(mydev_exit);</span><br></pre></td></tr></table></figure><h2 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h2><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><p><strong>这是一个提供内核统计信息的文件系统接口。由内核动态创建，不需要任何存储设备。多数为只读，提供观察数据，一部分可写用于控制内核行为。</strong></p><p>/proc包含很多目录，其中以进程ID命名的目录代表就是那个进程。这些目录下众多文件包含了进程的信息和统计信息，由内核数据映射而来。</p><p><img src="/2020/02/25/Linux%E6%9C%89%E5%85%B3%E7%AC%94%E8%AE%B0/02/25/Linux%E6%9C%89%E5%85%B3%E7%AC%94%E8%AE%B0/2019091016174868.png" alt="img"></p><ul><li>limits：实际的资源限制</li><li>maps：映射的内存区域</li><li>sched：CPU调度的各种统计</li><li>schedstat：CPU运行时间，延迟和时间分片</li><li>smaps：映射内存区域的使用统计</li><li>stat：进程状态和统计。包括总的CPU和内存使用情况</li><li>statm：以页为单位的内存使用总结</li><li>status：stat和statm的信息，用户可读</li><li>task：每个任务的统计目录</li></ul><p>系统级别的统计,与性能观察相关的系统级别的文件</p><p><img src="/2020/02/25/Linux%E6%9C%89%E5%85%B3%E7%AC%94%E8%AE%B0/02/25/Linux%E6%9C%89%E5%85%B3%E7%AC%94%E8%AE%B0/20190910161839417.png" alt="img"></p><ul><li>cpuinfo:物理处理器信息，包含所有虚拟CPU、型号、时钟频率和缓存大小</li><li>diskstats：对于所有磁盘设备的磁盘IO统计</li><li>interrupts：每个CPU的中断计数器</li><li>loadavg：负载平均值</li><li>meminfo：系统内存使用明细</li><li>net/dev：网络接口统计</li><li>net/tcp：活跃的TCP套接字信息</li><li>schedstat：系统级别的CPU调度器统计</li><li>self：关联当前进程ID路径的链接符号。为了方便使用</li><li>slabinfo：内核slab分配器缓存统计</li><li>stat：内核和系统资源的统计</li><li>zoneinfo：内存区信息</li></ul><h3 id="proc-pid-stat"><a href="#proc-pid-stat" class="headerlink" title="/proc/(pid)/stat"></a>/proc/(pid)/stat</h3><p>可以通过查看/usr/src/linux/Documentation/filesystems/proc.txt文件来获得更多的信息</p><p>[root@localhost ~]# cat /proc/6873/stat</p><p>6873 (a.out) R 6723 6873 6723 34819 6873 8388608 77 0 0 0 41958 31 0 0 25 0 3 0 5882654 1409024 56 4294967295 134512640 134513720 3215579040 0 2097798 0 0 0 0 0 0 0 17 0 0 0 [root@localhost ~]#</p><p>每个参数意思为：<br>参数 解释<br>pid=6873 进程(包括轻量级进程，即线程)号<br>comm=a.out 应用程序或命令的名字<br>task_state=R 任务的状态，R:runnign, S:sleeping (TASK_INTERRUPTIBLE), D:disk sleep (TASK_UNINTERRUPTIBLE), T: stopped, T:tracing stop,Z:zombie, X:dead<br>ppid=6723 父进程ID<br>pgid=6873 线程组号<br>sid=6723 c该任务所在的会话组ID<br>tty_nr=34819(pts/3) 该任务的tty终端的设备号，INT（34817/256）=主设备号，（34817-主设备号）=次设备号<br>tty_pgrp=6873 终端的进程组号，当前运行在该任务所在终端的前台任务(包括shell 应用程序)的PID。<br>task-&gt;flags=8388608 进程标志位，查看该任务的特性<br>min_flt=77 该任务不需要从硬盘拷数据而发生的缺页（次缺页）的次数<br>cmin_flt=0 累计的该任务的所有的waited-for进程曾经发生的次缺页的次数目<br>maj_flt=0 该任务需要从硬盘拷数据而发生的缺页（主缺页）的次数<br>cmaj_flt=0 累计的该任务的所有的waited-for进程曾经发生的主缺页的次数目<br>utime=1587 该任务在用户态运行的时间，单位为jiffies<br>stime=1 该任务在核心态运行的时间，单位为jiffies<br>cutime=0 累计的该任务的所有的waited-for进程曾经在用户态运行的时间，单位为jiffies<br>cstime=0 累计的该任务的所有的waited-for进程曾经在核心态运行的时间，单位为jiffies<br>priority=25 任务的动态优先级<br>nice=0 任务的静态优先级<br>num_threads=3 该任务所在的线程组里线程的个数<br>it_real_value=0 由于计时间隔导致的下一个 SIGALRM 发送进程的时延，以 jiffy 为单位.<br>start_time=5882654 该任务启动的时间，单位为jiffies<br>vsize=1409024（B） 该任务的虚拟地址空间大小（很多说明上在此误导为vsize的单位为page实际是不正确的）<br>rss=56(page) 该任务当前驻留物理地址空间的大小<br>Number of pages the process has in real memory,minu 3 for administrative purpose.<br>这些页可能用于代码，数据和栈。<br>rlim=4294967295（bytes） 该任务能驻留物理地址空间的最大值<br>start_code=134512640 该任务在虚拟地址空间的代码段的起始地址<br>end_code=134513720 该任务在虚拟地址空间的代码段的结束地址<br>start_stack=3215579040 该任务在虚拟地址空间的栈的结束地址<br>kstkesp=0 esp(32 位堆栈指针) 的当前值, 与在进程的内核堆栈页得到的一致.<br>kstkeip=2097798 指向将要执行的指令的指针, EIP(32 位指令指针)的当前值.<br>pendingsig=0 待处理信号的位图，记录发送给进程的普通信号<br>block_sig=0 阻塞信号的位图<br>sigign=0 忽略的信号的位图<br>sigcatch=082985 被俘获的信号的位图<br>wchan=0 如果该进程是睡眠状态，该值给出调度的调用点<br>nswap 被swapped的页数，当前没用<br>cnswap 所有子进程被swapped的页数的和，当前没用<br>exit_signal=17 该进程结束时，向父进程所发送的信号<br>task_cpu(task)=0 运行在哪个CPU上<br>task_rt_priority=0 实时进程的相对优先级别<br>task_policy=0 进程的调度策略，0=非实时进程，1=FIFO实时进程；2=RR实时进程 </p><p>rss是实际占用内存，以页为单位存放，一般是4K每页，所以要乘以4<br>vsize则是以B的单位存放，转化到K所以除1024 </p><h3 id="proc-cpuinfo"><a href="#proc-cpuinfo" class="headerlink" title="/proc/cpuinfo"></a>/proc/cpuinfo</h3><p>/proc/cpuinfo文件分析</p><p>　　在<a href="http://en.wikipedia.org/wiki/Linux">Linux</a>系统中，提供了<a href="http://en.wikipedia.org/wiki/Procfs">proc文件系统</a>显示系统的软硬件信息。如果想了解系统中CPU的提供商和相关配置信息，则可以通过/proc/cpuinfo文件得到。本文章针对该文件进行简单的总结。</p><p>　　基于不同指令集（ISA）的CPU产生的/proc/cpuinfo文件不一样，基于X86指令集CPU的/proc/cpuinfo文件包含如下内容：</p><p>processor　　： 0<br>vendor_id　　：GenuineIntel<br>cpu family　　：6<br>model　　　　：26<br>model name　：Intel(R) Xeon(R) CPU      E5520 @ 2.27GHz<br>stepping　　 ：5<br>cpu MHz　　  ：1600.000<br>cache size　　： 8192 KB<br>physical id　　：0<br>siblings　　　 ：8<br>core id　　　 ： 0<br>cpu cores　　 ：4<br>apicid　　    ：0<br>fpu　　　　　 ：yes<br>fpu_exception ：yes<br>cpuid level　　 ： 11<br>wp　　　　　　：yes<br>flags 　　　　　： fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm syscall nx rdtscp lm constant_tsc ida nonstop_tsc pni monitor ds_cpl vmx est tm2 cx16 xtpr popcnt lahf_lm<br>bogomips　　 ：4522.12<br>clflush size　　：64<br>cache_alignment　　： 64<br>address sizes　　　 ： 40 bits physical, 48 bits virtual<br>power management ：</p><p>以上输出项的含义如下：</p><p>processor　：系统中逻辑处理核的编号。对于单核处理器，则课认为是其CPU编号，对于多核处理器则可以是物理核、或者使用超线程技术虚拟的逻辑核<br>vendor_id　：CPU制造商<br>cpu family　：CPU产品系列代号<br>model　　　：CPU属于其系列中的哪一代的代号<br>model name：CPU属于的名字及其编号、标称主频<br>stepping　 ：CPU属于制作更新版本<br>cpu MHz　 ：CPU的实际使用主频<br>cache size  ：CPU二级缓存大小<br>physical id  ：单个CPU的标号<br>siblings    ：单个CPU逻辑物理核数<br>core id    ：当前物理核在其所处CPU中的编号，这个编号不一定连续<br>cpu cores  ：该逻辑核所处CPU的物理核数<br>apicid     ：用来区分不同逻辑核的编号，系统中每个逻辑核的此编号必然不同，此编号不一定连续<br>fpu       ：是否具有浮点运算单元（Floating Point Unit）<br>fpu_exception ：是否支持浮点计算异常<br>cpuid level  ：执行cpuid指令前，eax寄存器中的值，根据不同的值<a href="http://en.wikipedia.org/wiki/CPUID">cpuid</a>指令会返回不同的内容<br>wp       ：表明当前CPU是否在内核态支持对用户空间的写保护（Write Protection）<br>flags     ：当前CPU支持的功能<br><a href="http://en.wikipedia.org/wiki/Bogomips">bogomips</a>  ：在系统内核启动时粗略测算的CPU速度（Million Instructions Per Second）<br>clflush size ：每次刷新缓存的大小单位<br>cache_alignment ：缓存地址对齐单位<br>address sizes   ：可访问地址空间位数<br>power management ：对能源管理的支持，有以下几个可选支持功能：</p><p>　　ts：　　temperature sensor</p><p>　　fid：　 frequency id control</p><p>　　vid：　 voltage id control</p><p>　　ttp：　 thermal trip</p><p>　　tm：</p><p>　　stc：</p><p>　　100mhzsteps：</p><p>　　hwpstate：</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下内容为操作系统课设期间遇到的一些问题的补充&lt;/p&gt;
&lt;h2 id=&quot;user含意&quot;&gt;&lt;a href=&quot;#user含意&quot; class=&quot;headerlink&quot; title=&quot;__user含意&quot;&gt;&lt;/a&gt;__user含意&lt;/h2&gt;&lt;p&gt;&lt;code&gt;# define __user __attribute__((noderef, address_space(1)))&lt;/code&gt;&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://yorxika.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="http://yorxika.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>移动0</title>
    <link href="http://yorxika.github.io/2020/02/24/%E7%A7%BB%E5%8A%A80/"/>
    <id>http://yorxika.github.io/2020/02/24/%E7%A7%BB%E5%8A%A80/</id>
    <published>2020-02-24T15:11:37.000Z</published>
    <updated>2020-02-24T15:28:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第283题移动0</p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。<br><span id="more"></span><br><strong>示例:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">[0,1,0,3,12]</span></span><br><span class="line">输出: <span class="string">[1,3,12,0,0]</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><hr><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>遍历一次数组，将非空元素入队，之后出队按序填充数组，数组剩下的元素赋0.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            que.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">        nums[i++] = que.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; nums.length;i++)</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针I"><a href="#双指针I" class="headerlink" title="双指针I"></a>双指针I</h3><p>用一个指针记录当前非0元素的位置，另一个指针用于遍历数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length; i++)</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)</span><br><span class="line">            nums[pos++] = nums[i];</span><br><span class="line">    <span class="keyword">for</span>(;pos &lt; nums.length;pos++)</span><br><span class="line">        nums[pos] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针II"><a href="#双指针II" class="headerlink" title="双指针II"></a>双指针II</h3><p>如果当前元素是非 0 的，那么它的正确位置最多可以是当前位置或者更早的位置。如果是后者，则当前位置最终将被非 0 或 0 占据，该非 0 或 0 位于大于 “cur” 索引的索引处。我们马上用 0 填充当前位置，这样不像以前的解决方案，我们不需要在下一个迭代中回到这里。</p><p>换句话说，代码将保持以下不变：</p><blockquote><ol><li>慢指针（lastnonzerofoundat）之前的所有元素都是非零的。</li><li>当前指针和慢速指针之间的所有元素都是零。</li></ol></blockquote><p>因此，当我们遇到一个非零元素时，我们需要交换当前指针和慢速指针指向的元素，然后前进两个指针。如果它是零元素，我们只前进当前指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , j = <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            temp = nums[j];</span><br><span class="line">            nums[j++] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第283题移动0&lt;/p&gt;
&lt;p&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt;，编写一个函数将所有 &lt;code&gt;0&lt;/code&gt; 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="数组" scheme="http://yorxika.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>不同的二叉搜索树</title>
    <link href="http://yorxika.github.io/2020/02/24/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yorxika.github.io/2020/02/24/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-02-24T14:33:04.000Z</published>
    <updated>2020-02-24T14:42:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第96题不同的二叉搜索树</p><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？<br><span id="more"></span><br><strong>示例:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n = 3, 一共有<span class="number"> 5 </span>种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">  <span class="number"> 1 </span>       <span class="number"> 3 </span>   <span class="number"> 3 </span>    <span class="number"> 2 </span>     1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">    <span class="number"> 3 </span>   <span class="number"> 2 </span>   <span class="number"> 1 </span>    <span class="number"> 1 </span> <span class="number"> 3 </span>     2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">  <span class="number"> 2 </span>   <span class="number"> 1 </span>       <span class="number"> 2 </span>                3</span><br></pre></td></tr></table></figure><hr><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>来源<a href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/">官方题解</a></p><p>给定一个有序序列 <code>1 ... n</code>，为了根据序列构建一棵二叉搜索树。我们可以遍历每个数字 <code>i</code>，将该数字作为树根，<code>1 ... (i-1)</code> 序列将成为左子树，<code>(i+1) ... n</code> 序列将成为右子树。于是，我们可以递归地从子序列构建子树。<br>在上述方法中，由于根各自不同，每棵二叉树都保证是独特的。</p><p>可见，问题可以分解成规模较小的子问题。因此，我们可以存储并复用子问题的解，而不是递归的（也重复的）解决这些子问题，这就是动态规划法。</p><p>假设n个节点存在二叉排序树的个数是G(n)，令f(i)为以i为根的二叉搜索树的个数，则<em>G</em>(<em>n</em>)=<em>f</em>(1)+<em>f</em>(2)+<em>f</em>(3)+<em>f</em>(4)+…+<em>f</em>(<em>n</em>)</p><p>当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则<br>f(i) = G(i−1)\∗G(n−i)</p><p>综合两个公式可以得到 <a href="https://baike.baidu.com/item/卡特兰数">卡特兰数</a> 公式<em>G</em>(<em>n</em>)=<em>G</em>(0)∗<em>G</em>(<em>n</em>−1)+<em>G</em>(1)∗(<em>n</em>−2)+…+<em>G</em>(<em>n</em>−1)∗<em>G</em>(0)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// Note: we should use long here instead of int, otherwise overflow</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ans = ans * <span class="number">2</span> * (<span class="number">2</span> * i + <span class="number">1</span>) / (i + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第96题不同的二叉搜索树&lt;/p&gt;
&lt;p&gt;给定一个整数 &lt;em&gt;n&lt;/em&gt;，求以 1 … &lt;em&gt;n&lt;/em&gt; 为节点组成的二叉搜索树有多少种？&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
    <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>子集II</title>
    <link href="http://yorxika.github.io/2020/02/18/%E5%AD%90%E9%9B%86II/"/>
    <id>http://yorxika.github.io/2020/02/18/%E5%AD%90%E9%9B%86II/</id>
    <published>2020-02-18T15:12:50.000Z</published>
    <updated>2020-02-18T15:29:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第90题子集II</p><p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。<br><span id="more"></span><br><strong>示例:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="comment">[1,2,2]</span></span><br><span class="line">输出:</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  <span class="comment">[2]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,2,2]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[2,2]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,2]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>判断当前数字和上一个数字是否相同，相同的话跳过即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; an = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span>[] num;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="built_in">this</span>.num = nums;</span><br><span class="line">    helper(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> an;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span> start,List&lt;Integer&gt; tmp)</span>&#123;</span><br><span class="line">    an.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; num.length; i++)&#123;</span><br><span class="line">        <span class="comment">//和上个数字相等就跳过</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; start &amp;&amp; num[i] == num[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        tmp.add(num[i]);</span><br><span class="line">        helper(i + <span class="number">1</span>,tmp);</span><br><span class="line">        tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p><a href="https://leetcode-cn.com/problems/subsets-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-19/">来自</a></p><p>先考虑 0 个数字的所有子串，再考虑 1 个的所有子串，再考虑 2 个的所有子串。而求 n 个的所有子串，就是 【n - 1 的所有子串】和 【n - 1 的所有子串加上 n】。当有重复数字的时候，我们只考虑上一步的新解，算法中用一个指针保存每一步的新解开始的位置即可。</p><p><img src="/2020/02/18/%E5%AD%90%E9%9B%86II/02/18/%E5%AD%90%E9%9B%86II/87ba90075a0a54e867ee05a65612d6f00766624c9f50f92beb9004e8b5a3ff27-image.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());<span class="comment">// 初始化空数组</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//保存新解的开始位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans_tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历之前的所有结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ans.size(); j++) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = ans.get(j);</span><br><span class="line">            <span class="comment">//如果出现重复数字，就跳过所有旧解</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; j &lt; start) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">            tmp.add(nums[i]); <span class="comment">// 加入新增数字</span></span><br><span class="line">            ans_tmp.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        start = ans.size(); <span class="comment">//更新新解的开始位置</span></span><br><span class="line">        ans.addAll(ans_tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种思路，参考<a href="https://leetcode.com/problems/subsets-ii/discuss/30168/C%2B%2B-solution-and-explanation">这里</a>，当有重复数字出现的时候我们不再按照之前的思路走，而是单独考虑这种情况。</p><p>当有 n 个重复数字出现，其实就是在出现重复数字之前的所有解中，分别加 1 个重复数字， 2 个重复数字，3 个重复数字 … 什么意思呢，看一个例子。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">数组 [<span class="number"> 1 </span>2<span class="number"> 2 </span>2 ] </span><br><span class="line">[ ]的所有子串 [ ]</span><br><span class="line">[<span class="number"> 1 </span>] 个的所有子串 [ ] [<span class="number"> 1 </span>] </span><br><span class="line">然后出现了重复数字 2，那么我们记录重复的次数。然后遍历之前每个解即可</span><br><span class="line">对于 [ ] 这个解，</span><br><span class="line">加<span class="number"> 1 </span>个 2，变成 [<span class="number"> 2 </span>] </span><br><span class="line">加<span class="number"> 2 </span>个 2，变成 [<span class="number"> 2 </span>2 ]</span><br><span class="line">加<span class="number"> 3 </span>个 2，变成 [<span class="number"> 2 </span>2<span class="number"> 2 </span>]</span><br><span class="line">对于 [<span class="number"> 1 </span>] 这个解</span><br><span class="line">加<span class="number"> 1 </span>个 2，变成 [<span class="number"> 1 </span>2 ] </span><br><span class="line">加<span class="number"> 2 </span>个 2，变成 [<span class="number"> 1 </span>2<span class="number"> 2 </span>]</span><br><span class="line">加<span class="number"> 3 </span>个 2，变成 [<span class="number"> 1 </span>2<span class="number"> 2 </span>2 ]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] num)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; empty = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    result.add(empty);</span><br><span class="line">    Arrays.sort(num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dupCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断当前是否是重复数字，并且记录重复的次数</span></span><br><span class="line">        <span class="keyword">while</span>( ((i+<span class="number">1</span>) &lt; num.length) &amp;&amp; num[i+<span class="number">1</span>] == num[i]) &#123;</span><br><span class="line">            dupCount++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prevNum</span> <span class="operator">=</span> result.size();</span><br><span class="line">        <span class="comment">//遍历之前几个结果的每个解</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; prevNum; j++) &#123;</span><br><span class="line">            List&lt;Integer&gt; element = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(result.get(j));</span><br><span class="line">            <span class="comment">//每次在上次的结果中多加 1 个重复数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; t &lt;= dupCount; t++) &#123;</span><br><span class="line">                element.add(num[i]); <span class="comment">//加入当前重复的数字</span></span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(element));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p><a href="https://leetcode-cn.com/problems/subsets-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-19/">来自</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第90题子集II&lt;/p&gt;
&lt;p&gt;给定一个可能包含重复元素的整数数组 &lt;strong&gt;&lt;em&gt;nums&lt;/em&gt;&lt;/strong&gt;，返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;解集不能包含重复的子集。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="回溯" scheme="http://yorxika.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>n皇后</title>
    <link href="http://yorxika.github.io/2020/02/18/n%E7%9A%87%E5%90%8E/"/>
    <id>http://yorxika.github.io/2020/02/18/n%E7%9A%87%E5%90%8E/</id>
    <published>2020-02-18T14:35:23.000Z</published>
    <updated>2020-02-18T14:49:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第51题n皇后</p><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p><img src="/2020/02/18/n%E7%9A%87%E5%90%8E/02/18/n%E7%9A%87%E5%90%8E/8-queens.png" alt="img"><br><span id="more"></span><br>上图为 8 皇后问题的一种解法。</p><p>给定一个整数 <em>n</em>，返回所有不同的 <em>n</em> 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 <em>n</em> 皇后问题的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例:</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">4</span></span><br><span class="line">输出: [</span><br><span class="line"> [<span class="string">&quot;.Q..&quot;</span>,  <span class="regexp">//</span> 解法 <span class="number">1</span></span><br><span class="line">  <span class="string">&quot;...Q&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Q...&quot;</span>,</span><br><span class="line">  <span class="string">&quot;..Q.&quot;</span>],</span><br><span class="line"></span><br><span class="line"> [<span class="string">&quot;..Q.&quot;</span>,  <span class="regexp">//</span> 解法 <span class="number">2</span></span><br><span class="line">  <span class="string">&quot;Q...&quot;</span>,</span><br><span class="line">  <span class="string">&quot;...Q&quot;</span>,</span><br><span class="line">  <span class="string">&quot;.Q..&quot;</span>]</span><br><span class="line">]</span><br><span class="line">解释: <span class="number">4</span> 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><hr><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>逐行放置皇后，检查第y列和(x,y)所在的两条斜线上是否有皇后即可。</p><ol><li>检查第y列是否有皇后，比对纵坐标即可；</li><li>检查(x,y)所在的两条斜线上是否有皇后：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; que = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] board = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; n ;j++)</span><br><span class="line">                board[i][j] = <span class="string">&#x27;.&#x27;</span>;  <span class="comment">//棋盘初始化</span></span><br><span class="line">        <span class="type">int</span>[] queens = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            queens[i] = -<span class="number">1</span>;  <span class="comment">//皇后位置初始化</span></span><br><span class="line">        backtrack(board,<span class="number">0</span>,queens);</span><br><span class="line">        <span class="keyword">return</span> que;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">char</span>[][] board,<span class="type">int</span> x,<span class="type">int</span>[] queue)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == board.length)&#123;</span><br><span class="line">            <span class="comment">//有效解</span></span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span>[] row : board)</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">String</span>(row));</span><br><span class="line">            que.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span> ; y &lt; board.length;y++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(can(board,x,y,queue))&#123;</span><br><span class="line">                board[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                queue[x] = y ;<span class="comment">// 放置皇后</span></span><br><span class="line">                backtrack(board,x + <span class="number">1</span>,queue); <span class="comment">//开始回溯</span></span><br><span class="line">                <span class="comment">//取消上一次的尝试</span></span><br><span class="line">                board[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                queue[x] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查能否放置皇后</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">can</span> <span class="params">(<span class="type">char</span>[][] board,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span>[] queen)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y == board.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> dx,dy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; x; i++)&#123;</span><br><span class="line">            dy = y - queen[i];</span><br><span class="line">            <span class="keyword">if</span>(dy == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//同一列上有皇后</span></span><br><span class="line">            dx = x - i;</span><br><span class="line">            <span class="keyword">if</span>(dx == dy || dx == -dy)  <span class="comment">//对角线</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>补一个位运算的版本，看的不是很懂，不过这是针对下一题就总共解法的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> ld, <span class="type">int</span> rd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &gt;= n) &#123; res++; <span class="keyword">return</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> bits = ~(col | ld | rd) &amp; ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (bits &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> pick = bits &amp; -bits;</span><br><span class="line">            <span class="built_in">dfs</span>(n, row + <span class="number">1</span>, col | pick, (ld | pick) &lt;&lt; <span class="number">1</span>, (rd | pick) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            bits &amp;= bits - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第51题n皇后&lt;/p&gt;
&lt;p&gt;&lt;em&gt;n&lt;/em&gt; 皇后问题研究的是如何将 &lt;em&gt;n&lt;/em&gt; 个皇后放置在 &lt;em&gt;n&lt;/em&gt;×&lt;em&gt;n&lt;/em&gt; 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/02/18/n%E7%9A%87%E5%90%8E/02/18/n%E7%9A%87%E5%90%8E/8-queens.png&quot; alt=&quot;img&quot;&gt;&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="回溯" scheme="http://yorxika.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>GTK入门学习</title>
    <link href="http://yorxika.github.io/2020/02/18/GTK%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yorxika.github.io/2020/02/18/GTK%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-02-18T02:21:17.000Z</published>
    <updated>2020-02-25T08:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个简单的空白窗口"><a href="#一个简单的空白窗口" class="headerlink" title="一个简单的空白窗口"></a>一个简单的空白窗口</h3><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line">gtk_widget_show(window);</span><br><span class="line"></span><br><span class="line">gtk_main();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完代码后，我们对代码进程编译，直接用gcc编译即可，但是需要加上<code>pkg-config --cflags --libs gtk+-3.0</code></p><p>pkg-config 是一个为已经安装的包提供了include，以及实际库安装的位置编译选项的输出和管理的工具；</p><p>—cflags 选项作用为自动获得预处理参数，如宏定义，头文件的位置；</p><p>—libs 选项作用为自动获得链接参数，如库及依赖的其它库的位置，文件名及其它一些连接参数；</p><p>gtk+-3.0 选项作用为指定GTK版本。</p><p>具体编译命令如下：<br>gcc  demo.c  -o  demo  <code>pkg-config --cflags --libs gtk+-2.0</code></p><p>头文件〈gtk/gtk.h&gt; 包括了GTK+中所有的控件、变量、函数和结构的声明。</p><p><code>gtk_init (&amp;argc, &amp;argv);</code>所有 GTK应用程序都要调用该函数，而且必须在控件定义之前使用，它为我们设置一些缺省值( 例如视觉和颜色 )映射这个函数将函数库初始化，设置缺省的信号处理函数，并检查通过命令行传递给应用程序的参数，自动完成一些必要的初始化工作。</p><p><code>gtk_main()</code>是在每个Gtk应用程序都要调用的函数。程序运行停在这里等待事件(如键盘事件或鼠标事件)的发生，等待用户来操作窗口。</p><p><code>GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL);gtk_window_new()</code>的功能创建一个窗口并返回这个窗口的控件指针。GTK_WINDOW_TOPLEVEL指明窗口的类型为最上层的主窗口，它最常用。接着创建一个GtkWidget *类型的window变量来接收。GtkWidget是GTK+控件类型，GtkWidget * 能指向任何控件的指针类型。</p><p><code>gtk_widget_show(window)；</code>用来显示上一步创建的窗口控件。<br>在这个简单例子里，所有事件都被忽略。用鼠标点击窗口右上角的“×”按钮也不能将窗口关闭。我们可以在终端敲 Ctrl + C 关闭程序。</p><h3 id="控件的添加"><a href="#控件的添加" class="headerlink" title="控件的添加"></a>控件的添加</h3><p>控件是对数据和方法的封装。控件有自己的属性和方法。属性是指控件的特征。方法是指控件的一些简单而可见的功能。如按钮就是一个控件，这个按钮是方形的，里面有张图片，这是我们能看到外观属性，同时，这个按钮具备被人按下的功能。</p><p>GTK中控件主要分为两类：<strong>容器控件</strong>，<strong>非容器控件</strong>。</p><p>容器控件：它可以容纳别的控件，我们可以理解为盒子，盒子拿来装东西。容器控件又分为两类，一类<strong>只能容纳一个控件</strong>，如窗口，按钮；另一类<strong>能容纳多个控件</strong>，如布局控件。</p><p>非容器控件：它不可以容纳别的控件，如标签、行编辑。</p><p>前面我们写的空白窗口是能容纳一个控件的控件，现在我们要做的是，给这个窗口添加一个按钮。</p><p>首先，我们需要创建一个按钮，然后需要把按钮添加到窗口，接着，显示按钮控件。</p><p><strong>按钮的创建：</strong><br><code>GtkWidget *gtk_button_new_with_label(const gchar *label);</code><br>label：按钮上的字符串类型，gchar相当于C语言的char<br>返回值：按钮控件指针</p><p><strong>容器添加控件：</strong><br><code>void gtk_container_add(GtkContainer *container, GtkWidget *widget);</code><br>container：容纳控件的容器<br>widget：要添加的控件</p><p><strong>显示控件：</strong><br><code>void gtk_widget_show(GtkWidget *widget);</code><br>widget：需要显示的控件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv);   <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);  <span class="comment">//创建顶层窗口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建按钮，文本信息为&quot;Hello World&quot;</span></span><br><span class="line">GtkWidget* button = gtk_button_new_with_label(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把按钮放入窗口(窗口也是一种容器)</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(window), button);</span><br><span class="line"></span><br><span class="line">gtk_widget_show(button);<span class="comment">// 显示按钮</span></span><br><span class="line">gtk_widget_show(window);<span class="comment">// 显示窗口</span></span><br><span class="line"></span><br><span class="line">gtk_main();<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><p><code>void gtk_container_add(GtkContainer *container, GtkWidget *widget);</code><br>这里我们是把按钮添加到窗口容器里，widget为按钮指针(以上代码的button)，container为窗口指针(以上代码的window)，这里需要注意的是，我们创建的窗口(window)返回值为GtkWidget *类型，而gtk_container_add()的第一个参数为GtkContainer *类型，由于 GtkWidget *类型的变量为指向任何控件的万能指针，所以，在函数传参时，根据参数类型进行相应的转换，如：<code>gtk_container_add( (GtkContainer *)window, button);</code></p><p>C语言里，我们常用这种方法转换。在GTK中，很多内部变量指针类型转换都定义了宏定义，如：<code>#define GTK_CONTAINER(x) (GtkContainer *)(x)</code></p><p>所以，我们还可以这么写：<code>gtk_container_add(GTK_CONTAINER(window), button);</code></p><p>那么，我们如何知道，哪个类型对应哪个宏定义呢？把要转换类型名字全部变为大写，同时，单词和单词之间以下划线“_”连接，然后，这个名字就是哪个宏定义的名字，如，(GtkButton *)x用宏定义的方法为 GTK_BUTTON(x)。</p><p>假如窗口里有100个控件，还是这样一个一个地显示出来会比较麻烦，这时候，我们可以通过<code>gtk_widget_show_all()</code>显示所有的控件，里面需要传的是容纳控件的那个容器(这里为窗口)。这样，容器上的控件也会跟着显示。</p><p><code>gtk_widget_show_all(window);// 显示窗口上的所有控件</code></p><h3 id="布局容器"><a href="#布局容器" class="headerlink" title="布局容器"></a>布局容器</h3><p>如果我们希望窗口里多放添加几个控件，直接添加是不成功的，因为窗口只能容纳一个控件的容器。这时候，我们需要借助布局容器，我们先把布局容器添加到窗口里，然后再把所需要添加的控件放在布局容器里。</p><p>布局容器的主要分类：水平布局( GtkHBox)、垂直布局(GtkVBox )、表格布局(GtkTable)、固定布局(GtkFixed )。</p><h4 id="水平布局"><a href="#水平布局" class="headerlink" title="水平布局"></a>水平布局</h4><p><strong>水平布局容器的创建：</strong><br><code>GtkWidget *gtk_hbox_new( gboolean homogeneous,  gint spacing );</code><br>homogeneous：容器内控件是否大小一致( gboolean 取值为TRUE 或 FALSE )<br>spacing：控件之间的间隔( 以像素点为单位 )，gint相当于 C语言的int<br>返回值：水平布局控件指针</p><p><strong>容器添加添加控件：</strong><br><code>void gtk_container_add(GtkContainer *container, GtkWidget *widget);</code><br>container：容纳控件的容器<br>widget：要添加的控件</p><p><strong>显示容器上所有控件</strong><br><code>void gtk_widget_show_all(GtkWidget *widget);</code><br>widget：需要显示的控件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv);   <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);  <span class="comment">//创建顶层窗口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建水平布局容器</span></span><br><span class="line">GtkWidget* hbox = gtk_hbox_new(TRUE, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 把容器添加到窗口</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(window), hbox);</span><br><span class="line"></span><br><span class="line"><span class="comment">// button1</span></span><br><span class="line">GtkWidget* button = gtk_button_new_with_label(<span class="string">&quot;button1&quot;</span>);</span><br><span class="line">gtk_container_add(GTK_CONTAINER(hbox), button); <span class="comment">// 按钮添加到水平布局容器里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// button2</span></span><br><span class="line">button = gtk_button_new_with_label(<span class="string">&quot;button2&quot;</span>);</span><br><span class="line">gtk_container_add(GTK_CONTAINER(hbox), button); <span class="comment">// 按钮添加到水平布局容器里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// button3</span></span><br><span class="line">button = gtk_button_new_with_label(<span class="string">&quot;button3&quot;</span>);</span><br><span class="line">gtk_container_add(GTK_CONTAINER(hbox), button); <span class="comment">// 按钮添加到水平布局容器里</span></span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window); <span class="comment">// 显示所有控件</span></span><br><span class="line"></span><br><span class="line">gtk_main();<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="垂直布局"><a href="#垂直布局" class="headerlink" title="垂直布局"></a>垂直布局</h4><p>垂直布局和水平布局的用法基本是一样，无非是新建垂直布局容器接口，还有控件摆放的方向不同。</p><p><strong>垂直布局容器的创建：</strong><br><code>GtkWidget *gtk_vbox_new( gboolean homogeneous,  gint spacing );</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv);   <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);  <span class="comment">//创建顶层窗口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建垂直布局容器</span></span><br><span class="line">GtkWidget* hbox = gtk_vbox_new(TRUE, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 把容器添加到窗口</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(window), hbox);</span><br><span class="line"></span><br><span class="line"><span class="comment">// button1</span></span><br><span class="line">GtkWidget* button = gtk_button_new_with_label(<span class="string">&quot;button1&quot;</span>);</span><br><span class="line">gtk_container_add(GTK_CONTAINER(hbox), button); <span class="comment">// 按钮添加到水平布局容器里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// button2</span></span><br><span class="line">button = gtk_button_new_with_label(<span class="string">&quot;button2&quot;</span>);</span><br><span class="line">gtk_container_add(GTK_CONTAINER(hbox), button); <span class="comment">// 按钮添加到水平布局容器里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// button3</span></span><br><span class="line">button = gtk_button_new_with_label(<span class="string">&quot;button3&quot;</span>);</span><br><span class="line">gtk_container_add(GTK_CONTAINER(hbox), button); <span class="comment">// 按钮添加到水平布局容器里</span></span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window); <span class="comment">// 显示所有控件</span></span><br><span class="line"></span><br><span class="line">gtk_main();<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h4><p>学习水平和垂直布局容器后，我们几乎能布出任何风格的布局，只需要嵌套使用水平布局容器和垂直布局容器即可。假如我们要完成下图的布局，我们该怎么做呢？</p><p><img src="/2020/02/18/GTK%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/02/18/GTK%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/20150115175419264" alt="img"></p><p>1）创建一个垂直布局容器( A )<br>2）创建一个水平布局容器( B )，一个close按钮( C )<br>3）将水平布局容器和close按钮添加到垂直布局容器里( 将 B 和 C 添加到 A )<br>4）创建button 1按钮( D ) 和 button 2按钮( E )<br>5）再将button 1按钮 和 button 2按钮添加到水平布局容器里( 将 D 和 E 添加到 B )</p><p>这样是可以完成上图的布局，但是，假如布局里有有很多控件，我们只是通过水平和垂直容器嵌套布局会很麻烦，而且，控件越多，布局越麻烦。有没有更简单的方法呢？有，就是我们马上要学习的表格布局，具体的操作流程和水平垂直布局一样。</p><p><strong>表格布局容器的创建：</strong><br><code>GtkWidget *gtk_table_new(guint rows, guint columns, gboolean homogeneous );</code><br>rows: 行数<br>coumns: 列数<br>homogeneous：容器内表格的大小是否相等<br>返回值：表格布局容器指针</p><p><strong>布局容器添加控件：</strong><br><code>void gtk_table_attach_defaults(GtkTable *table, GtkWidget *widget,guint left_attach,guint right_attach,guint top_attach,guint bottom_attach );</code><br>table:  容纳控件的容器<br>widget: 要添加的控件？<br>后四个参数为控件摆放的坐标，规则如下：<br><img src="/2020/02/18/GTK%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/02/18/GTK%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/20150115175902717" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv);   <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);  <span class="comment">//创建顶层窗口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GtkWidget* table = gtk_table_new(<span class="number">2</span>, <span class="number">2</span>, TRUE);<span class="comment">// 表格布局，2行2列</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(window), table); <span class="comment">// 容器加入窗口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// button1</span></span><br><span class="line">GtkWidget* button = gtk_button_new_with_label(<span class="string">&quot;button1&quot;</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">// 把按钮加入布局</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// button2</span></span><br><span class="line">button = gtk_button_new_with_label(<span class="string">&quot;button2&quot;</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// button3</span></span><br><span class="line">button = gtk_button_new_with_label(<span class="string">&quot;button3&quot;</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window); <span class="comment">// 显示所有控件</span></span><br><span class="line"></span><br><span class="line">gtk_main();<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="固定布局"><a href="#固定布局" class="headerlink" title="固定布局"></a>固定布局</h4><p>前面我们学习的水平、垂直和表格布局容器，控件会跟着容器大小的变化进行自动适应，而固定布局容器里的控件则不会跟着变化( 则固定不变 )。</p><p><strong>固定布局的创建：</strong><br><code>GtkWidget *gtk_fixed_new(void);</code><br>返回值：固定布局容器指针</p><p><strong>固定布局容器添加控件：</strong><br>void gtk_fixed_put( GtkFixed <em>fixed,GtkWidget </em>widget,gint x,gint y );<br>fixed：容纳控件的容器<br>widget：要添加的控件<br>x, y：控件摆放位置的起点坐标</p><p><strong>设置控件的大小( 宽和高 )：</strong><br><code>void gtk_widget_set_size_request(GtkWidget *widget,gint width,gint height );</code><br>widget：需要设置的控件<br>width：宽度<br>height：高度</p><p><strong>移动固定布局里控件的位置：</strong><br><code>void gtk_fixed_move(   GtkFixed *fixed,GtkWidget *widget,gint x,gint y);</code><br>fixed：固定布局容器<br>widget：需要移动的控件<br>x, y: 移动的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv);   <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);  <span class="comment">//创建顶层窗口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GtkWidget* fixed = gtk_fixed_new(); <span class="comment">//创建一个固定容器</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(window), fixed); <span class="comment">// 固定放进窗口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// button1</span></span><br><span class="line">GtkWidget* button = gtk_button_new_with_label(<span class="string">&quot;button1&quot;</span>);</span><br><span class="line">gtk_fixed_put(GTK_FIXED(fixed), button, <span class="number">50</span>, <span class="number">50</span>); <span class="comment">// 按钮添加到固定布局</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// button2</span></span><br><span class="line">GtkWidget*  button2 = gtk_button_new_with_label(<span class="string">&quot;button2&quot;</span>);</span><br><span class="line">gtk_fixed_put(GTK_FIXED(fixed), button2, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 按钮添加到固定布局</span></span><br><span class="line">gtk_fixed_move(GTK_FIXED(fixed), button2, <span class="number">150</span>, <span class="number">150</span>); <span class="comment">// 移动控件的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// button3</span></span><br><span class="line"><span class="comment">//GtkWidget*  button3 = gtk_button_new_with_label(&quot;button3&quot;);</span></span><br><span class="line">gtk_widget_set_size_request(button2, <span class="number">100</span>, <span class="number">50</span>); <span class="comment">// 设置控件的大小</span></span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window); <span class="comment">// 显示所有控件</span></span><br><span class="line"></span><br><span class="line">gtk_main();<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="行编辑控件"><a href="#行编辑控件" class="headerlink" title="行编辑控件"></a>行编辑控件</h3><p><strong>行编辑的创建：</strong><br><code>GtkWidget * gtk_entry_new(void);</code><br>返回值：行编辑指针行</p><p><strong>编辑内容的设置：</strong><br><code>void gtk_entry_set_text (GtkEntry *entry,const gchar *text);</code><br>entry: 行编辑<br>text: 需要设置的内容</p><p><strong>设置行编辑是否允许编辑：</strong><br><code>void gtk_editable_set_editable(GtkEditable *editable, gboolean is_editable);</code><br>editable：行编辑<br>is_editable：TRUE代表可编辑，FALSE不允许编辑</p><p>表格布局练习之计算器<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span> <span class="comment">// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span>   argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv); <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口的操作</span></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);  <span class="comment">// 创建窗口 </span></span><br><span class="line">gtk_widget_set_size_request(window, <span class="number">270</span>, <span class="number">320</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表格的操作</span></span><br><span class="line">GtkWidget* table = gtk_table_new(<span class="number">5</span>, <span class="number">4</span>, TRUE);   <span class="comment">// 表格布局，5行4列  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 行编辑的操作</span></span><br><span class="line">GtkWidget* entry = gtk_entry_new();<span class="comment">// 行编辑的创建</span></span><br><span class="line">gtk_entry_set_text(GTK_ENTRY(entry), <span class="string">&quot;2+2=4&quot;</span>);<span class="comment">// 给行编辑设置内容</span></span><br><span class="line">gtk_editable_set_editable(GTK_EDITABLE(entry), FALSE);<span class="comment">// 设置行编辑不允许编辑，只做显示用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮的操作</span></span><br><span class="line">GtkWidget* button0 = gtk_button_new_with_label(<span class="string">&quot;0&quot;</span>);<span class="comment">// 按钮0</span></span><br><span class="line">GtkWidget* button1 = gtk_button_new_with_label(<span class="string">&quot;1&quot;</span>);<span class="comment">// 按钮1</span></span><br><span class="line">GtkWidget* button2 = gtk_button_new_with_label(<span class="string">&quot;2&quot;</span>);<span class="comment">// 按钮2</span></span><br><span class="line">GtkWidget* button3 = gtk_button_new_with_label(<span class="string">&quot;3&quot;</span>);<span class="comment">// 按钮3</span></span><br><span class="line">GtkWidget* button4 = gtk_button_new_with_label(<span class="string">&quot;4&quot;</span>);<span class="comment">// 按钮4</span></span><br><span class="line">GtkWidget* button5 = gtk_button_new_with_label(<span class="string">&quot;5&quot;</span>);<span class="comment">// 按钮5</span></span><br><span class="line">GtkWidget* button6 = gtk_button_new_with_label(<span class="string">&quot;6&quot;</span>);<span class="comment">// 按钮6</span></span><br><span class="line">GtkWidget* button7 = gtk_button_new_with_label(<span class="string">&quot;7&quot;</span>);<span class="comment">// 按钮7</span></span><br><span class="line">GtkWidget* button8 = gtk_button_new_with_label(<span class="string">&quot;8&quot;</span>);<span class="comment">// 按钮8</span></span><br><span class="line">GtkWidget* button9 = gtk_button_new_with_label(<span class="string">&quot;9&quot;</span>);<span class="comment">// 按钮9</span></span><br><span class="line">GtkWidget* button_add = gtk_button_new_with_label(<span class="string">&quot;+&quot;</span>);<span class="comment">// 加</span></span><br><span class="line">GtkWidget* button_minus = gtk_button_new_with_label(<span class="string">&quot;-&quot;</span>); <span class="comment">// 减</span></span><br><span class="line">GtkWidget* button_multiply = gtk_button_new_with_label(<span class="string">&quot;*&quot;</span>);<span class="comment">// 乘</span></span><br><span class="line">GtkWidget* button_divide = gtk_button_new_with_label(<span class="string">&quot;/&quot;</span>);<span class="comment">// 除</span></span><br><span class="line">GtkWidget* button_equal = gtk_button_new_with_label(<span class="string">&quot;=&quot;</span>);<span class="comment">// 等于</span></span><br><span class="line">GtkWidget* button_detele = gtk_button_new_with_label(<span class="string">&quot;c&quot;</span>);<span class="comment">// 退格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布局操作</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(window), table); <span class="comment">// 表格放入窗口 </span></span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), entry, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">// 行编辑放入表格</span></span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button0, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>);<span class="comment">// 按钮放入表格</span></span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button1, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button2, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button3, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button4, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button5, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button6, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button7, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button8, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button9, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button_add, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button_minus, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button_multiply, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button_divide, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button_equal, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button_detele, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window);  <span class="comment">// 显示所有控件</span></span><br><span class="line"></span><br><span class="line">gtk_main();  <span class="comment">//进入事件循环 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="信号与回调函数"><a href="#信号与回调函数" class="headerlink" title="信号与回调函数"></a>信号与回调函数</h3><p>前面我们学习的GTK界面都是静态的，我们按下按钮它是没有响应的，如何让它有响应呢？接下来我们一起学习GTK的信号与回调函数。</p><p>GTK采用了信号与回调函数来处理窗口外部传来的事件、消息或信号。当信号发生时，程序自动调用为信号连接的回调函数。</p><p>学习应用编程，我们会经常接触到“信号”这个名词。GTK中的“信号”实际上是一种软件中断。“中断”在我们生活中经常遇到，譬如，我正在房间里打游戏，突然送快递的来了，把正在玩游戏的我给“中断”了，我去签收快递( 处理中断 )，处理完成后，再继续玩我的游戏。<strong>GTK中的“信号”就是属于这么一种“中断”，当用户按下按钮的时候，就产生一个“中断”，相当于产生一个信号，接着就会处理这么一个“中断任务”(程序里体验为调用一个函数)。</strong></p><p>“信号”在GTK中可以认为一种中断的标志，如按下按钮的标志为”pressed”,释放按钮的标志为”released”，<strong>这些标志就相当于 C 语言的关键字一样，我们使用的时候必须完全按照它的名字来写。</strong>需要注意的是，每个控件的信号标志不一定都一样，如按钮（GtkButton）里有”pressed”信号，窗口(GtkWindow)里就没这个信号，每个控件具体有哪个信号，应该查看帮助文档来确定。</p><p>按钮的常用信号：</p><ul><li>“clicked” : 按下按钮时触发</li><li>“pressed” : 释放按钮时触发</li><li>“released” : 释放按钮时触发</li></ul><p>对于程序而言，我们按下按钮，是让其调用一个函数。假如有函数A, B, C，我们如何确定按下按钮后只调用函数A，而不是函数 B 或 C。这时候，我们需要一种规则规定，按下按钮后就调用函数A，就像交通规则一样，红灯走绿灯行，信号注册函数就是做这样的事情。</p><p><strong>信号注册函数：</strong><br><code>gulong g_signal_connect( gpointer instance,const gchar *detailed_signal,GCallback c_handler, gpointer data );</code><br>instance：信号发出者，可以认为我们操作的控件，如按下按钮，这个就为按钮指针<br>detailed_signal：信号标志，如”pressed”<br>c_handler：回调函数的名称，需要用G_CALLBACK()进行转换<br>data：给回调函数传的参数，gpointer 相当于C语言的 void *<br>返回值：注册函数的标志</p><p>如：<br><code>g_signal_connect(button, &quot;pressed&quot;,G_CALLBACK(callback), NULL);</code></p><p>当按下button按钮时，就会自动调用回调函数callback(相当于处理中断任务)，回调函数callback可以是任意函数，函数名字我们根据需要自行命名，如果不是库函数，我们还得定义这个回调函数，这里需要注意的是，回调函数的写法(返回值，参数)，不是我们想怎么写就怎么写，帮助文档里已经规定好了回调函数应该如何写，如果不按规定来写，可能产生意想不到的错误。</p><p><a href="http://blog.csdn.net/tennysonsky/article/details/42778635">帮助文档的使用请点此处。</a></p><p><strong>回调函数的定义：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">callback</span><span class="params">(GtkButton *button,gpointer data)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>设置容器与控件之间的间距：</strong><br><code>void gtk_container_set_border_width(GtkContainer *container,guint border_width);</code><br>container：容器<br>border_width：容器与控件之间的间距，guint相当于C语言的uint</p><p><strong>获取按钮上的文本内容：</strong><br><code>const gchar *gtk_button_get_label(GtkButton *button);</code><br>button：按钮<br>返回值：获取到的文本内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span><span class="comment">// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮按下的处理函数, gpointer 相当于 void *</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deal_pressed</span><span class="params">(GtkButton* button, gpointer user_data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// button指向main函数的button</span></span><br><span class="line"><span class="comment">// user_data 指向main函数的&quot;I am a button&quot;</span></span><br><span class="line"><span class="comment">// 获得按钮的文本信息</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* text = gtk_button_get_label(button);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s /////// %s\n&quot;</span>, (<span class="type">char</span>*)user_data, text); <span class="comment">// 打印内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv);<span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL); <span class="comment">// 创建顶层窗口</span></span><br><span class="line"><span class="comment">// 设置窗口边框的宽度(窗口里的控件与窗口边框间隔为15)</span></span><br><span class="line">gtk_container_set_border_width(GTK_CONTAINER(window), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GtkWidget* button = gtk_button_new_with_label(<span class="string">&quot;^_^&quot;</span>); <span class="comment">// 创建按钮</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(window), button);<span class="comment">// 把按钮放入窗口(窗口也是一种容器)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按钮按下(pressed)后会自动调用deal_pressed()</span></span><br><span class="line"><span class="comment"> * &quot;I am a button&quot;是传给回调函数deal_pressed()的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">g_signal_connect(button, <span class="string">&quot;pressed&quot;</span>, G_CALLBACK(deal_pressed), <span class="string">&quot;I am a button&quot;</span>);</span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window);<span class="comment">// 显示窗口全部控件</span></span><br><span class="line"></span><br><span class="line">gtk_main();<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GTK简单版计算器"><a href="#GTK简单版计算器" class="headerlink" title="GTK简单版计算器"></a>GTK简单版计算器</h3><p>接下来我们做一个简单版的计算器。</p><ol><li>获取按钮上的内容。</li><li>如果获取的内容是“ c ”，则代表进行退格操作，相当于删去最后一个字符。</li><li>如果获取的内容不是“ c ”，则把每一次获取的内容连接起来，如：第一次按了 “ 1 ”， 第二次按了 “ + ”， 第三次按了 “ 1 ”， 连起来则变为 “1+1”。</li><li>如果获取的内容是“ = ”，则需要相应的运算。先把连起来的字符串拆出来，然后再进行相应操作，最后把运算结果重新显示到行编辑上。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span> <span class="comment">// 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">50</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//全局变量，保存数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮的回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deal_num</span><span class="params">(GtkButton* button, gpointer data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* txt = gtk_button_get_label(button); <span class="comment">// 获取点击按钮的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 退格操作</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(<span class="string">&quot;c&quot;</span>, txt)) &#123; <span class="comment">// 如果是退格键</span></span><br><span class="line">buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 最后一个字符变为 0</span></span><br><span class="line"><span class="comment">//gtk_entry_set_text(GTK_ENTRY(data), buf);//重新给行编辑设定内容</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="built_in">strcat</span>(buf, txt);<span class="comment">// 内容追加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算操作</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(<span class="string">&quot;=&quot;</span>, txt)) &#123;<span class="comment">// 如果是 &quot; = &quot;</span></span><br><span class="line"><span class="built_in">sscanf</span>(buf, <span class="string">&quot;%d%c%d&quot;</span>, &amp;a, &amp;c, &amp;b);<span class="comment">// 拆包</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d, c = %c, b=%d\n&quot;</span>, a, c, b);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;+&#x27;</span> == c) &#123;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d&quot;</span>, a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;-&#x27;</span> == c) &#123;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d&quot;</span>, a - b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;*&#x27;</span> == c) &#123;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d&quot;</span>, a * b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;/&#x27;</span> == c) &#123;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d&quot;</span>, a / b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gtk_entry_set_text(GTK_ENTRY(data), buf);<span class="comment">// 给行编辑设定内容</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span>   argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv); <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口的操作</span></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);  <span class="comment">// 创建窗口 </span></span><br><span class="line">gtk_widget_set_size_request(window, <span class="number">270</span>, <span class="number">320</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表格的操作</span></span><br><span class="line">GtkWidget* table = gtk_table_new(<span class="number">5</span>, <span class="number">4</span>, TRUE);   <span class="comment">// 表格布局，5行4列  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 行编辑的操作</span></span><br><span class="line">GtkWidget* entry = gtk_entry_new();<span class="comment">// 行编辑的创建</span></span><br><span class="line"><span class="comment">//gtk_entry_set_text(GTK_ENTRY(entry), &quot;2+2=4&quot;);// 给行编辑设置内容</span></span><br><span class="line">gtk_editable_set_editable(GTK_EDITABLE(entry), FALSE);<span class="comment">// 设置行编辑不允许编辑，只做显示用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮的操作</span></span><br><span class="line">GtkWidget* button0 = gtk_button_new_with_label(<span class="string">&quot;0&quot;</span>);<span class="comment">// 按钮0</span></span><br><span class="line">GtkWidget* button1 = gtk_button_new_with_label(<span class="string">&quot;1&quot;</span>);<span class="comment">// 按钮1</span></span><br><span class="line">GtkWidget* button2 = gtk_button_new_with_label(<span class="string">&quot;2&quot;</span>);<span class="comment">// 按钮2</span></span><br><span class="line">GtkWidget* button3 = gtk_button_new_with_label(<span class="string">&quot;3&quot;</span>);<span class="comment">// 按钮3</span></span><br><span class="line">GtkWidget* button4 = gtk_button_new_with_label(<span class="string">&quot;4&quot;</span>);<span class="comment">// 按钮4</span></span><br><span class="line">GtkWidget* button5 = gtk_button_new_with_label(<span class="string">&quot;5&quot;</span>);<span class="comment">// 按钮5</span></span><br><span class="line">GtkWidget* button6 = gtk_button_new_with_label(<span class="string">&quot;6&quot;</span>);<span class="comment">// 按钮6</span></span><br><span class="line">GtkWidget* button7 = gtk_button_new_with_label(<span class="string">&quot;7&quot;</span>);<span class="comment">// 按钮7</span></span><br><span class="line">GtkWidget* button8 = gtk_button_new_with_label(<span class="string">&quot;8&quot;</span>);<span class="comment">// 按钮8</span></span><br><span class="line">GtkWidget* button9 = gtk_button_new_with_label(<span class="string">&quot;9&quot;</span>);<span class="comment">// 按钮9</span></span><br><span class="line">GtkWidget* button_add = gtk_button_new_with_label(<span class="string">&quot;+&quot;</span>);<span class="comment">// 加</span></span><br><span class="line">GtkWidget* button_minus = gtk_button_new_with_label(<span class="string">&quot;-&quot;</span>); <span class="comment">// 减</span></span><br><span class="line">GtkWidget* button_multiply = gtk_button_new_with_label(<span class="string">&quot;*&quot;</span>);<span class="comment">// 乘</span></span><br><span class="line">GtkWidget* button_divide = gtk_button_new_with_label(<span class="string">&quot;/&quot;</span>);<span class="comment">// 除</span></span><br><span class="line">GtkWidget* button_equal = gtk_button_new_with_label(<span class="string">&quot;=&quot;</span>);<span class="comment">// 等于</span></span><br><span class="line">GtkWidget* button_detele = gtk_button_new_with_label(<span class="string">&quot;c&quot;</span>);<span class="comment">// 退格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布局操作</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(window), table); <span class="comment">// 表格放入窗口 </span></span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), entry, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">// 行编辑放入表格</span></span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button0, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>);<span class="comment">// 按钮放入表格</span></span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button1, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button2, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button3, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button4, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button5, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button6, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button7, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button8, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button9, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button_add, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button_minus, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button_multiply, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button_divide, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button_equal, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">gtk_table_attach_defaults(GTK_TABLE(table), button_detele, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册信号函数，把 entry 传给回调函数 deal_num()</span></span><br><span class="line">g_signal_connect(button0, <span class="string">&quot;pressed&quot;</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">g_signal_connect(button1, <span class="string">&quot;pressed&quot;</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">g_signal_connect(button2, <span class="string">&quot;pressed&quot;</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">g_signal_connect(button3, <span class="string">&quot;pressed&quot;</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">g_signal_connect(button4, <span class="string">&quot;pressed&quot;</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">g_signal_connect(button5, <span class="string">&quot;pressed&quot;</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">g_signal_connect(button6, <span class="string">&quot;pressed&quot;</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">g_signal_connect(button7, <span class="string">&quot;pressed&quot;</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">g_signal_connect(button8, <span class="string">&quot;pressed&quot;</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">g_signal_connect(button9, <span class="string">&quot;pressed&quot;</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">g_signal_connect(button_add, <span class="string">&quot;pressed&quot;</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">g_signal_connect(button_minus, <span class="string">&quot;pressed&quot;</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">g_signal_connect(button_multiply, <span class="string">&quot;pressed&quot;</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">g_signal_connect(button_divide, <span class="string">&quot;pressed&quot;</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">g_signal_connect(button_equal, <span class="string">&quot;pressed&quot;</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">g_signal_connect(button_detele, <span class="string">&quot;pressed&quot;</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window);  <span class="comment">// 显示所有控件</span></span><br><span class="line"></span><br><span class="line">gtk_main();  <span class="comment">//进入事件循环 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h3><h4 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h4><p><strong>窗口的创建</strong>：<br><code>GtkWidget *gtk_window_new(GtkWindowType type);</code><br>GtkWindowType是一个枚举，有两种情况：</p><ul><li>GTK_WINDOW_TOPLEVEL：顶层窗口，有边框</li><li>GTK_WINDOW_POPUP：  弹式窗口，没边框<br>返回值：窗口指针</li></ul><p><strong>标题的设置：</strong><br><code>void gtk_window_set_title(GtkWindow *window, const gchar *title);</code><br>window：窗口<br>title：标题</p><p><strong>控件最小大小的设置：</strong></p><p><code>void gtk_widget_set_size_request(GtkWidget *widget,gint width,gint height);</code><br>widget：需要操作的控件，可以是任何控件<br>width：宽度<br>height：高度</p><p><strong>窗口伸缩设置：</strong><br><code>void gtk_window_set_resizable(GtkWindow *window, gboolean resizable);</code><br>window：窗口<br>resizable：TURE默认属性，可伸缩，FALSE不可伸缩</p><p>显示或隐藏所有控件：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gtk_widget_show_all</span><span class="params">(GtkWidget *widget)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gtk_widget_hide_all</span><span class="params">(GtkWidget *widget)</span>;</span><br></pre></td></tr></table></figure><br>widget：控件</p><p>窗口在显示器位置的设置：<br><code>void gtk_window_set_position(GtkWindow *window, GtkWindowPosition position);</code><br>window：窗口<br>position常用有4种情况：<br>GTK_WIN_POS_NONE：  不固定<br>GTK_WIN_POS_CENTER: 居中<br>GTK_WIN_POS_MOUSE:  出现在鼠标位置<br>GTK_WIN_POS_CENTER_ALWAYS: 窗口总是居中 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span><span class="comment">// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv);<span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建顶层窗口</span></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line"><span class="comment">// 设置窗口的标题</span></span><br><span class="line">gtk_window_set_title(GTK_WINDOW(window), <span class="string">&quot;Window&quot;</span>);</span><br><span class="line"><span class="comment">// 设置窗口在显示器中的位置为居中</span></span><br><span class="line">gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);</span><br><span class="line"><span class="comment">// 设置窗口的最小大小</span></span><br><span class="line">gtk_widget_set_size_request(window, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line"><span class="comment">// 固定窗口的大小</span></span><br><span class="line">gtk_window_set_resizable(GTK_WINDOW(window), FALSE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;destroy&quot; 和 gtk_main_quit 连接</span></span><br><span class="line">g_signal_connect(window, <span class="string">&quot;destroy&quot;</span>, G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window);<span class="comment">// 显示窗口全部控件</span></span><br><span class="line"><span class="comment">//gtk_widget_hide_all(window);// 隐藏窗口</span></span><br><span class="line"></span><br><span class="line">gtk_main();<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意这一句<code>g_signal_connect(window, &quot;destroy&quot;, G_CALLBACK(gtk_main_quit), NULL);</code><br>把”destroy” 和 gtk_main_quit 连接</strong></p><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>标签主要是显示文本信息，用作标志。</p><p><strong>标签的创建：</strong><br><code>GtkWidget *gtk_label_new(const gchar *str);</code><br>str：文本内容<br>返回值：标签指针</p><p><strong>设置标签的内容：</strong><br><code>void  gtk_label_set_text (GtkLabel *label, const gchar *str);</code><br>label：操作的标签<br>str：文本内容</p><p><strong>获取标签的内容：</strong><br><code>const gchar *gtk_label_get_text( GtkLabel *label );</code><br>label：操作的标签<br>返回值：获取到的文本内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span><span class="comment">// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv); <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);    <span class="comment">// 创建窗口</span></span><br><span class="line"></span><br><span class="line">GtkWidget* vbox = gtk_vbox_new(TRUE, <span class="number">10</span>);       <span class="comment">// 创建垂直布局容器</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(window), vbox); <span class="comment">// 把纵直布局容器放入窗口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// label one</span></span><br><span class="line">GtkWidget* label_one = gtk_label_new(<span class="string">&quot;label one&quot;</span>);<span class="comment">// 创建标签</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(vbox), label_one); <span class="comment">// 将按钮放在布局容器里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// label two</span></span><br><span class="line">GtkWidget* label_two = gtk_label_new(<span class="string">&quot;label two&quot;</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = gtk_label_get_label(GTK_LABEL(label_two)); <span class="comment">// 获得标签的内容</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str = %s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">gtk_container_add(GTK_CONTAINER(vbox), label_two); <span class="comment">// 将按钮放在布局容器里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// label three</span></span><br><span class="line">GtkWidget* label_three = gtk_label_new(<span class="string">&quot;label three&quot;</span>);</span><br><span class="line">gtk_label_set_text(GTK_LABEL(label_three), <span class="string">&quot;change the label text&quot;</span>); <span class="comment">// 设置内容</span></span><br><span class="line"></span><br><span class="line">gtk_container_add(GTK_CONTAINER(vbox), label_three); <span class="comment">// 将按钮放在布局容器里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;destroy&quot; 和 gtk_main_quit 连接</span></span><br><span class="line">g_signal_connect(window, <span class="string">&quot;destroy&quot;</span>, G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window);<span class="comment">// 显示窗口控件</span></span><br><span class="line"></span><br><span class="line">gtk_main(); <span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图片控件"><a href="#图片控件" class="headerlink" title="图片控件"></a>图片控件</h4><p>图片控件和标签的作用很类似，都是作为显示用的，只是图片控件显示的内容是图片。</p><p><strong>图片控件的创建：</strong><br><code>GtkWidget *gtk_image_new_from_file( const gchar *filename );</code><br>filename：图片的名字，带路径的话需要加上路径( 相对或绝对 )<br>返回值：图片控件指针</p><p>通过上面方法创建的图片控件，以图片默认大小来显示，不能修改其大小。如果要改变图片的大小，我们要借助图片资源对象GdkPixbuf，需要注意的是，GdkPixbuf不属于控件类，它以 Gdk 开头。</p><p><strong>图片资源对象pixbuf的创建：</strong></p><p><code>GdkPixbuf *gdk_pixbuf_new_from_file(const gchar *filename, GError **error);</code><br>filename：图片的名字，带路径的话需要加上路径( 相对或绝对 )<br>error：储存错误的指针<br>返回值：pixbuf指针</p><p><strong>设置图片的大小：</strong><br><code>GdkPixbuf *gdk_pixbuf_scale_simple(const GdkPixbuf *src, int dest_width, int dest_height, GdkInterpType interp_type);</code><br>src：gdk_pixbuf_new_from_file()的返回值<br>dest_width：图片的宽度<br>dest_height：图片的高度<br>interp_type：是一个枚举变量，标志图片的加载速度和质量，常用GDK_INTERP_BILINEAR<br>返回值：指定大小好的pixbuf指针</p><p>通过gdk_pixbuf_new_from_file(), gdk_pixbuf_scale_simple()创建的pixbuf，它会动态分配空间，占用资源，用完后，需要人为释放资源。</p><p><strong>释放资源：</strong><br><code>void g_object_unref(GtkObject *object);</code><br>object：需要释放的对象</p><p><strong>通过pixbuf来创建图片控件：</strong><br><code>GtkWidget *gtk_image_new_from_pixbuf(GdkPixbuf *pixbuf );</code><br>pixbuf：指定好大小的pixbuf<br>返回值：图片控件指针</p><p><strong>图片控件重新设置一张图片(pixbuf)：</strong><br><code>void gtk_image_set_from_pixbuf(GtkImage *image, GdkPixbuf *pixbuf );</code><br>image：图片控件指针<br>pixbuf：指定好大小的pixbuf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span><span class="comment">// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv); <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);    <span class="comment">// 创建窗口</span></span><br><span class="line"></span><br><span class="line">GtkWidget* hbox = gtk_hbox_new(TRUE, <span class="number">5</span>);       <span class="comment">// 创建水平布局容器</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(window), hbox); <span class="comment">// 把水平布局容器放入窗口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建图片控件，这种方法创建以图片默认大小来显示，不能修改</span></span><br><span class="line">GtkWidget* image_one = gtk_image_new_from_file(<span class="string">&quot;./1.jpg&quot;</span>);</span><br><span class="line"><span class="comment">//gtk_container_add(GTK_CONTAINER(hbox), image_one);// 添加到布局里</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面借助GdkPixbuf来修改图片的大小，注意接口以gdk_开头，不属于控件类</span></span><br><span class="line"><span class="comment">// 创建pixbuf，需要占用资源，使用完，需要人为释放</span></span><br><span class="line">GdkPixbuf* src = gdk_pixbuf_new_from_file(<span class="string">&quot;./1.jpg&quot;</span>, <span class="literal">NULL</span>);<span class="comment">// 读取原图片</span></span><br><span class="line">GdkPixbuf* dst = gdk_pixbuf_scale_simple(src,<span class="number">100</span>, <span class="number">100</span>, GDK_INTERP_BILINEAR);<span class="comment">// 修改图片大小(100, 100), 保存在dst</span></span><br><span class="line"></span><br><span class="line">GtkWidget* image_two = gtk_image_new_from_pixbuf(dst);<span class="comment">// 通过pixbuf创建图片控件</span></span><br><span class="line">g_object_unref(src);<span class="comment">// pixbuf使用完，需要人为释放资源</span></span><br><span class="line">g_object_unref(dst);</span><br><span class="line">gtk_container_add(GTK_CONTAINER(hbox), image_two);<span class="comment">// 添加到布局里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取图片控件里的pixbuf，以这个pixbuf又重新创建一个图片控件</span></span><br><span class="line">GdkPixbuf* tmp = gtk_image_get_pixbuf(GTK_IMAGE(image_two));</span><br><span class="line">GtkWidget* image_three = gtk_image_new_from_pixbuf(tmp);</span><br><span class="line">gtk_container_add(GTK_CONTAINER(hbox), image_three);<span class="comment">// 添加到布局里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给创建的图片控件重新设置一张图片</span></span><br><span class="line">GtkWidget* image_four = gtk_image_new_from_file(<span class="string">&quot;./1.jpg&quot;</span>);</span><br><span class="line">src = gdk_pixbuf_new_from_file(<span class="string">&quot;./2.jpg&quot;</span>, <span class="literal">NULL</span>);<span class="comment">// 读取原图片</span></span><br><span class="line">dst = gdk_pixbuf_scale_simple(src,</span><br><span class="line"><span class="number">200</span>, <span class="number">200</span>, GDK_INTERP_BILINEAR);<span class="comment">// 修改图片大小(200, 200), 保存在dst</span></span><br><span class="line">gtk_image_set_from_pixbuf(GTK_IMAGE(image_four), dst);<span class="comment">// 给image_four重新设置一张图片</span></span><br><span class="line">g_object_unref(src);<span class="comment">// pixbuf使用完，需要人为释放资源</span></span><br><span class="line">g_object_unref(dst);</span><br><span class="line">gtk_container_add(GTK_CONTAINER(hbox), image_four);<span class="comment">// 添加到布局里</span></span><br><span class="line"></span><br><span class="line">g_signal_connect(window, <span class="string">&quot;destroy&quot;</span>, G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window);<span class="comment">// 显示窗口控件</span></span><br><span class="line"></span><br><span class="line">gtk_main(); <span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h4><p><strong>进度条的创建：</strong><br><code>GtkWidget *gtk_progress_bar_new(void);</code><br>返回值：进度条指针</p><p><strong>设置进度条显示的进度比例：</strong><br><code>void gtk_progress_bar_set_fraction(GtkProgressBar *pbar, gdouble fraction);</code><br>pbar：需要操作的进度条<br>fraction：0.0到1.0</p><p><strong>获取进度条显示的进度比例：</strong><br><code>gdouble  gtk_progress_bar_get_fraction (GtkProgressBar *pbar);</code><br>pbar：需要操作的进度条<br>返回值：进度比例</p><p><strong>设置滑槽上的文本显示：</strong><br><code>void gtk_progress_bar_set_text(GtkProgressBar *pbar, gchar *text);</code><br>pbar：需要操作的进度条<br>text：设置的文本内容</p><p><strong>设置进度条的移动方向：</strong><br><code>void gtk_progress_bar_set_orientation(GtkProgressBar *pbar, GtkProgressBarOrientation orientation);</code><br>pbar：需要操作的进度条<br>orientation：移动方向，它是一个枚举变量</p><ul><li>GTK_PROGRESS_LEFT_TO_RIGHT：从左向右 </li><li>GTK_PROGRESS_RIGHT_TO_LEFT：从右向左 </li><li>GTK_PROGRESS_BOTTOM_TO_TOP：从下向上 </li><li>GTK_PROGRESS_TOP_TO_BOTTOM：从上向下</li></ul><p><strong>获取进度条的方向：</strong><br><code>GtkProgressBarOrientation  gtk_progress_bar_get_orientation(GtkProgressBar *pbar);</code><br>pbar：需要操作的进度条<br>返回值：进度条的方向，它是一个枚举类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数，切换进度条的移动方向 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">toggle_orientation</span><span class="params">(GtkWidget* widget, gpointer data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// gtk_progress_bar_get_orientation: 获得进度条当前移动的方向</span></span><br><span class="line"><span class="comment">/*switch (gtk_progress_bar_get_orientation(GTK_PROGRESS_BAR(data))) &#123;</span></span><br><span class="line"><span class="comment">case GTK_PROGRESS_LEFT_TO_RIGHT:</span></span><br><span class="line"><span class="comment">gtk_progress_bar_set_orientation(GTK_PROGRESS_BAR(data), GTK_PROGRESS_RIGHT_TO_LEFT);</span></span><br><span class="line"><span class="comment">break;</span></span><br><span class="line"><span class="comment">case GTK_PROGRESS_RIGHT_TO_LEFT:</span></span><br><span class="line"><span class="comment">gtk_progress_bar_set_orientation(GTK_PROGRESS_BAR(data), GTK_PROGRESS_LEFT_TO_RIGHT);</span></span><br><span class="line"><span class="comment">break;</span></span><br><span class="line"><span class="comment">default: // 什么也不做 </span></span><br><span class="line"><span class="comment">break;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新进度条，这样就能够看到进度条的移动</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">callback</span><span class="params">(GtkWidget* widget, gpointer data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 在原来值基础上增加 0.05</span></span><br><span class="line">gdouble new_val = gtk_progress_bar_get_fraction(GTK_PROGRESS_BAR(data)) + <span class="number">0.05</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (new_val &gt; <span class="number">1.0</span>) &#123;<span class="comment">// 越界处理</span></span><br><span class="line">new_val = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置进度条的新值 </span></span><br><span class="line">gtk_progress_bar_set_fraction(GTK_PROGRESS_BAR(data), new_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv);<span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);<span class="comment">// 创建主窗口</span></span><br><span class="line">gtk_window_set_title(GTK_WINDOW(window), <span class="string">&quot;GtkProgressBar&quot;</span>);<span class="comment">// 设置窗口标题</span></span><br><span class="line">gtk_container_set_border_width(GTK_CONTAINER(window), <span class="number">10</span>);<span class="comment">// 设置边框宽度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置窗口的最小大小</span></span><br><span class="line">gtk_widget_set_size_request(window, <span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line"><span class="comment">// 窗口关联 destroy 信号 到 gtk_main_quit</span></span><br><span class="line">g_signal_connect(G_OBJECT(window), <span class="string">&quot;destroy&quot;</span>, G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">GtkWidget* vbox = gtk_vbox_new(FALSE, <span class="number">5</span>); <span class="comment">// 垂直布局容器</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(window), vbox);  <span class="comment">// 容器加入窗口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个进度条</span></span><br><span class="line">GtkWidget* progress = gtk_progress_bar_new();</span><br><span class="line">gtk_container_add(GTK_CONTAINER(vbox), progress);  <span class="comment">// 加入垂直布局容器</span></span><br><span class="line"><span class="comment">// 设置进度条显示的百分比：50%</span></span><br><span class="line">gtk_progress_bar_set_fraction(GTK_PROGRESS_BAR(progress), <span class="number">0.5</span>);</span><br><span class="line"><span class="comment">// 设置在进度条的滑槽上的文本显示 </span></span><br><span class="line">gtk_progress_bar_set_text(GTK_PROGRESS_BAR(progress), <span class="string">&quot;some text&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个按钮，切换移动方向  </span></span><br><span class="line">GtkWidget* button_orientation = gtk_button_new_with_label(<span class="string">&quot;Right to Left&quot;</span>);</span><br><span class="line">g_signal_connect(button_orientation, <span class="string">&quot;clicked&quot;</span>, G_CALLBACK(toggle_orientation), progress);</span><br><span class="line">gtk_container_add(GTK_CONTAINER(vbox), button_orientation);  <span class="comment">// 加入垂直布局容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加进度条进度按钮</span></span><br><span class="line">GtkWidget* button = gtk_button_new_with_label(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">g_signal_connect(button, <span class="string">&quot;clicked&quot;</span>, G_CALLBACK(callback), progress); <span class="comment">// connect</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(vbox), button);  <span class="comment">// 加入垂直布局容器</span></span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window);</span><br><span class="line"></span><br><span class="line">gtk_main();<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该是GTK3.0取消了有关进度条方向操作的原因，在回调函数toggle_orientation里直接全部取消有关操作。</p><h4 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h4><p><strong>空按钮的创建(按钮上没有任何内容)：</strong><br><code>GtkWidget *gtk_button_new(void);</code><br>返回值：按钮指针</p><p><strong>创建带文本内容的按钮：</strong><br><code>GtkWidget *gtk_button_new_with_label (const gchar *label);</code><br>label：文本内容<br>返回值：按钮指针</p><p><strong>设置按钮的文本内容：</strong><br><code>void gtk_button_set_label(GtkButton *button, const gchar *label);</code><br>button：操作的按钮<br>label：要设置的文本内容</p><p><strong>获取按钮的文本内容：</strong><br><code>const gchar *gtk_button_get_label(GtkButton *button);</code><br>button：操作的按钮<br>返回值：获取到的文本内容</p><p><strong>控件使能设置：</strong><br><code>void gtk_widget_set_sensitive(GtkWidget *widget, gboolean sensitive);</code><br>widget：要操作的控件<br>sensitive：FALSE变灰，不允许相应响应；TRUE，正常响应</p><p><strong>给按钮设置一张图片：</strong><br><code>void gtk_button_set_image(GtkButton *button,GtkWidget *image);</code><br>button：按钮<br>image：图片控件</p><p><strong>获取按钮上的图片：</strong><br><code>GtkWidget *gtk_button_set_image(GtkButton *button);</code><br>button：按钮<br>返回值：图片控件</p><p><strong>设置按钮透明背景色：</strong><br><code>void gtk_button_set_relief(GtkButton *button,  newstyle);</code><br>button：按钮<br>newstyle： 枚举变量，GTK_RELIEF_NONE为透明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span><span class="comment">// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv); <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);    <span class="comment">// 创建窗口</span></span><br><span class="line"></span><br><span class="line">GtkWidget* hbox = gtk_hbox_new(TRUE, <span class="number">10</span>); <span class="comment">// 水平布局容器</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(window), hbox); <span class="comment">// 把水平布局容器放入窗口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通按钮</span></span><br><span class="line">GtkWidget* normal_button = gtk_button_new_with_label(<span class="string">&quot;normal button&quot;</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = gtk_button_get_label(GTK_BUTTON(normal_button)); <span class="comment">// 获取按钮的文本内容</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str === %s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">gtk_button_set_label(GTK_BUTTON(normal_button), <span class="string">&quot;change&quot;</span>);<span class="comment">// 设置按钮的文本内容</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(hbox), normal_button);     <span class="comment">// 把按钮放入水平布局容器里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给按钮设置一张图片</span></span><br><span class="line">GtkWidget* button = gtk_button_new(); <span class="comment">// 先创建空按钮</span></span><br><span class="line"><span class="comment">//GtkWidget* image = gtk_image_new_from_file(&quot;./1.jpg&quot;); // 图像控件</span></span><br><span class="line">GdkPixbuf* src = gdk_pixbuf_new_from_file(<span class="string">&quot;./1.jpg&quot;</span>, <span class="literal">NULL</span>);<span class="comment">// </span></span><br><span class="line">GdkPixbuf* dst = gdk_pixbuf_scale_simple(src, <span class="number">100</span>, <span class="number">100</span>, GDK_INTERP_BILINEAR);</span><br><span class="line"></span><br><span class="line">GtkWidget* image = gtk_image_new_from_pixbuf(dst);<span class="comment">// 通过pixbuf创建图片控件</span></span><br><span class="line">g_object_unref(src);<span class="comment">// pixbuf使用完，需要人为释放资源</span></span><br><span class="line">g_object_unref(dst);</span><br><span class="line">gtk_button_set_image(GTK_BUTTON(button), image); <span class="comment">// 给按钮添加图片</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(hbox), button);     <span class="comment">// 把按钮放入水平布局容器里</span></span><br><span class="line">gtk_button_set_relief(GTK_BUTTON(button), GTK_RELIEF_NONE);<span class="comment">// 按钮背景色透明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮使能设置(是否变灰)，默认为使能TRUE，非使能FALSE</span></span><br><span class="line"><span class="comment">//gtk_widget_set_sensitive(button, FALSE);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window);<span class="comment">// 显示窗口控件</span></span><br><span class="line"></span><br><span class="line">gtk_main(); <span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="行编辑"><a href="#行编辑" class="headerlink" title="行编辑"></a>行编辑</h4><p>行编辑，只允许输入一行内容的控件，如密码输入框。</p><p><strong>行编辑的创建：</strong><br><code>GtkWidget *gtk_entry_new(void);</code><br>返回值：行编辑指针</p><p><strong>设置行编辑内容的最大长度：</strong><br><code>void gtk_entry_set_max_length(GtkEntry *entry, gint max);</code><br>entry：行编辑<br>max：长度的最大值，这里填0代表长度不作限制</p><p><strong>设置行编辑的文本内容：</strong><br><code>void gtk_entry_set_text(GtkEntry *entry,const gchar *text);</code><br>entry：行编辑<br>text：文本内容</p><p><strong>获取行编辑的内容：</strong><br><code>const gchar *gtk_entry_get_text(GtkEntry *entry);</code><br>entry：行编辑<br>返回值：获取到的行编辑内容</p><p><strong>设置编辑控件是否允许编辑：</strong><br><code>void gtk_editable_set_editable(GtkEditable *editable,gboolean is_editable);</code><br>editable：需要操作的控件<br>is_editable：TRUE代表能允许编辑，默认属性，FALSE不允许编辑</p><p><strong>设置行编辑的内容是否可视(不能可视相当于密码模式，看不到文本的内容) </strong><br><code>void gtk_entry_set_visibility(GtkEntry *entry,gboolean visible);</code><br>entry：行编辑<br>visible：TRUE可视，FALSE不可视</p><p>常用信号：”activate”<br>当用户在文本输入控件内部按回车键时引发activate信号；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按Enter，获取行编辑的内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_callback</span><span class="params">(GtkWidget* widget, gpointer entry)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> gchar* entry_text;</span><br><span class="line"><span class="comment">// 获得文本内容</span></span><br><span class="line">entry_text = gtk_entry_get_text(GTK_ENTRY(entry));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Entry contents: %s\n&quot;</span>, entry_text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv); <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL); <span class="comment">// 创建窗口</span></span><br><span class="line">g_signal_connect(window, <span class="string">&quot;destroy&quot;</span>, G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line">gtk_widget_set_size_request(window, <span class="number">200</span>, <span class="number">50</span>);<span class="comment">// 设置窗口的大小</span></span><br><span class="line"></span><br><span class="line">GtkWidget* entry = gtk_entry_new();  <span class="comment">// 创建行编辑 </span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(window), entry); <span class="comment">// 表格放入窗口</span></span><br><span class="line">gtk_entry_set_max_length(GTK_ENTRY(entry), <span class="number">100</span>);     <span class="comment">// 设置行编辑显示最大字符的长度</span></span><br><span class="line">gtk_entry_set_text(GTK_ENTRY(entry), <span class="string">&quot;hello word&quot;</span>);  <span class="comment">// 设置内容</span></span><br><span class="line"><span class="comment">//gtk_entry_set_visibility(GTK_ENTRY(entry), FALSE);  // 密码模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果我们想在用户输入文本时进行响应，可以为activate设置回调函数。</span></span><br><span class="line"><span class="comment"> * 当用户在文本输入构件内部按回车键时引发Activate信号；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">g_signal_connect(entry, <span class="string">&quot;activate&quot;</span>, G_CALLBACK(enter_callback), entry);</span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window); <span class="comment">// 显示窗口所有控件</span></span><br><span class="line"></span><br><span class="line">gtk_main(); <span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="笔记本控件"><a href="#笔记本控件" class="headerlink" title="笔记本控件"></a>笔记本控件</h4><p>笔记本控件，可以让用户标签式地切换多个界面。当我们需要多窗口切换时，使用笔记本控件是一个明智的选择。</p><p><img src="/2020/02/18/GTK%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/02/18/GTK%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/20150126154311359" alt="img"></p><p><strong>笔记本控件的创建：</strong><br><code>GtkWidget *gtk_notebook_new(void);</code><br>返回值：笔记本控件指针</p><p><strong>设置页标签的位置：</strong><br><code>void gtk_notebook_set_tab_pos( GtkNotebook *notebook,  GtkPositionType pos );</code><br>notebook：笔记本控件<br>pos取值如下：</p><ul><li>GTK_POS_LEFT：  左</li><li>GTK_POS_RIGHT：  右</li><li>GTK_POS_TOP：   上</li><li>GTK_POS_BOTTOM： 下</li></ul><p><strong>追加页面：</strong><br><code>gint gtk_notebook_append_page(GtkNotebook *notebook, GtkWidget *child, GtkWidget *tab_label );</code><br>notebook： 容纳别的控件的笔记本<br>child：       放在笔记本页面里的子控件<br>tab_label：要添加页面的标题名<br>返回值：成功返回值页面值(从0开始)，失败返回-1</p><p><strong>在指定位置添加页面(从0开始)：</strong><br><code>gint gtk_notebook_insert_page(GtkNotebook *notebook,GtkWidget *child, tkWidget *tab_label,gint position );</code><br>notebook： 容纳别的控件的笔记本<br>child：       放在笔记本页面里的子控件<br>tab_label：要添加页面的标题名<br>position：页面的位置，从0开始，如果-1代表添加到最后<br>返回值：成功返回值页面值(从0开始)，失败返回-1</p><p><strong>设置起始页，从0开始算，相当于设置第几个页面显示：</strong><br><code>void gtk_notebook_set_current_page(GtkNotebook *notebook, gint page_num );</code><br>notebook：要设置的笔记本控件<br>page_num：页面数</p><p>常用信号：”switch-page”<br>当切换页面时，会触发”switch-page”信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;switch-page&quot;信号处理函数，page_num指第几个页面，从0开始</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deal_switch_pape</span><span class="params">(GtkNotebook* notebook, gpointer page,</span></span><br><span class="line"><span class="params">guint page_num, gpointer user_data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This is page %d\n&quot;</span>, page_num + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv); <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL); <span class="comment">// 创建主窗口</span></span><br><span class="line">gtk_widget_set_size_request(window, <span class="number">400</span>, <span class="number">300</span>);<span class="comment">//设置窗口大小</span></span><br><span class="line"></span><br><span class="line">GtkWidget* notebook = gtk_notebook_new(); <span class="comment">// 创建笔记本控件</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(window), notebook); <span class="comment">// 笔记本放进窗口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页标签的位置，可以有四种位置：上、下、左或右。</span></span><br><span class="line">gtk_notebook_set_tab_pos(GTK_NOTEBOOK(notebook), GTK_POS_LEFT);  <span class="comment">//上面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个页面</span></span><br><span class="line">GtkWidget* label = gtk_label_new(<span class="string">&quot;Page one&quot;</span>);<span class="comment">//创建标签</span></span><br><span class="line">GtkWidget* box = gtk_vbox_new(TRUE, <span class="number">5</span>);<span class="comment">// 创建布局</span></span><br><span class="line">GtkWidget* button_one = gtk_button_new_with_label(<span class="string">&quot;I am first page&quot;</span>);</span><br><span class="line">GtkWidget* button_two = gtk_button_new_with_label(<span class="string">&quot;I am first button of first page&quot;</span>);</span><br><span class="line">gtk_container_add(GTK_CONTAINER(box), button_one);</span><br><span class="line">gtk_container_add(GTK_CONTAINER(box), button_two);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gtk_notebook_append_page( GtkNotebook *notebook, GtkWidget *child,</span></span><br><span class="line"><span class="comment"> *                     GtkWidget  *tab_label );</span></span><br><span class="line"><span class="comment"> * 插入页面到笔记本的后端（append）或前端（prepend）来添加页面。</span></span><br><span class="line"><span class="comment"> * child是放在笔记本页面里的子控件，它必须另外创建，一般是容器</span></span><br><span class="line"><span class="comment"> * tab_label是要添加的页面的标签。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">gtk_notebook_append_page(GTK_NOTEBOOK(notebook), box, label);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个页面</span></span><br><span class="line">label = gtk_label_new(<span class="string">&quot;Page two&quot;</span>);<span class="comment">//创建标签</span></span><br><span class="line">box = gtk_hbox_new(TRUE, <span class="number">5</span>);<span class="comment">// 创建布局</span></span><br><span class="line">button_one = gtk_button_new_with_label(<span class="string">&quot;I am second page&quot;</span>);</span><br><span class="line">button_two = gtk_button_new_with_label(<span class="string">&quot;I am first button of second page&quot;</span>);</span><br><span class="line">gtk_container_add(GTK_CONTAINER(box), button_one);</span><br><span class="line">gtk_container_add(GTK_CONTAINER(box), button_two);</span><br><span class="line">gtk_notebook_prepend_page(GTK_NOTEBOOK(notebook), box, label);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个页面，在指定位置添加页面，从0开始</span></span><br><span class="line">button_one = gtk_button_new_with_label(<span class="string">&quot;insert_page&quot;</span>);</span><br><span class="line">label = gtk_label_new(<span class="string">&quot;Page three&quot;</span>);</span><br><span class="line">gtk_notebook_insert_page(GTK_NOTEBOOK(notebook), button_one, label, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理信号，当切换页面时，会触发&quot;switch-page&quot;信号</span></span><br><span class="line">g_signal_connect(notebook, <span class="string">&quot;switch-page&quot;</span>,</span><br><span class="line">G_CALLBACK(deal_switch_pape), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window); <span class="comment">//显示所有控件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置起始页(第2页)，从0开始算，相当于设置第2个页面显示</span></span><br><span class="line">gtk_notebook_set_current_page(GTK_NOTEBOOK(notebook), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">gtk_main(); <span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置窗口背景图"><a href="#设置窗口背景图" class="headerlink" title="设置窗口背景图"></a>设置窗口背景图</h3><p>有问题，暂且存疑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 功能：  设置背景图</span></span><br><span class="line"><span class="comment"> * widget: 主窗口</span></span><br><span class="line"><span class="comment"> * w, h:   图片的大小</span></span><br><span class="line"><span class="comment"> * path：  图片路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">chang_background</span><span class="params">(GtkWidget* widget, <span class="type">int</span> w, <span class="type">int</span> h, <span class="type">const</span> gchar* path)</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_widget_set_app_paintable(widget, TRUE);<span class="comment">//允许窗口可以绘图</span></span><br><span class="line">gtk_widget_realize(widget);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更改背景图时，图片会重叠</span></span><br><span class="line"><span class="comment"> * 这时要手动调用下面的函数，让窗口绘图区域失效，产生窗口重绘制事件（即 expose 事件）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">gtk_widget_queue_draw(widget);</span><br><span class="line"></span><br><span class="line">GdkPixbuf* src_pixbuf = gdk_pixbuf_new_from_file(path, <span class="literal">NULL</span>);<span class="comment">// 创建图片资源对象</span></span><br><span class="line"><span class="comment">// w, h是指定图片的宽度和高度</span></span><br><span class="line">GdkPixbuf* dst_pixbuf = gdk_pixbuf_scale_simple(src_pixbuf, w, h, GDK_INTERP_BILINEAR);</span><br><span class="line"></span><br><span class="line">GdkPixmap* pixmap = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建pixmap图像;</span></span><br><span class="line"><span class="comment"> * NULL：不需要蒙版;</span></span><br><span class="line"><span class="comment"> * 123： 0~255，透明到不透明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">gdk_pixbuf_render_pixmap_and_mask(dst_pixbuf, &amp;pixmap, <span class="literal">NULL</span>, <span class="number">200</span>);</span><br><span class="line"><span class="comment">// 通过pixmap给widget设置一张背景图，最后一个参数必须为: FASLE</span></span><br><span class="line">gdk_window_set_back_pixmap(widget-&gt;window, pixmap, FALSE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">g_object_unref(src_pixbuf);</span><br><span class="line">g_object_unref(dst_pixbuf);</span><br><span class="line">g_object_unref(pixmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">//主窗口操作</span></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line"></span><br><span class="line">gtk_window_set_title(GTK_WINDOW(window), <span class="string">&quot;设置窗口背景图&quot;</span>);</span><br><span class="line">gtk_widget_set_size_request(window, <span class="number">500</span>, <span class="number">450</span>);</span><br><span class="line"></span><br><span class="line">chang_background(window, <span class="number">500</span>, <span class="number">400</span>, <span class="string">&quot;./1.jpg&quot;</span>);<span class="comment">// 设置窗口背景图</span></span><br><span class="line"></span><br><span class="line">GtkWidget* hbox = gtk_hbox_new(TRUE, <span class="number">50</span>); <span class="comment">// 水平布局容器</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(window), hbox); <span class="comment">// 把水平布局容器放入窗口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通按钮</span></span><br><span class="line">GtkWidget* normal_button = gtk_button_new_with_label(<span class="string">&quot;normal button&quot;</span>);</span><br><span class="line">gtk_container_add(GTK_CONTAINER(hbox), normal_button);     <span class="comment">// 把按钮放入水平布局容器里</span></span><br><span class="line">gtk_widget_show_all(window); <span class="comment">// 显示所有部件</span></span><br><span class="line"></span><br><span class="line">gtk_main();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改变控件字体大小"><a href="#改变控件字体大小" class="headerlink" title="改变控件字体大小"></a>改变控件字体大小</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 功能:      设置控件字体大小</span></span><br><span class="line"><span class="comment"> * widget:    需要改变字体的控件</span></span><br><span class="line"><span class="comment"> * size:      字体大小</span></span><br><span class="line"><span class="comment"> * is_button: TRUE代表控件为按钮，FALSE为其它控件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_widget_font_size</span><span class="params">(GtkWidget* widget, <span class="type">int</span> size, gboolean is_button)</span></span><br><span class="line">&#123;</span><br><span class="line">GtkWidget* labelChild;</span><br><span class="line">PangoFontDescription* font;</span><br><span class="line">gint fontSize = size;</span><br><span class="line"></span><br><span class="line">font = pango_font_description_from_string(<span class="string">&quot;Sans&quot;</span>);          <span class="comment">//&quot;Sans&quot;字体名   </span></span><br><span class="line">pango_font_description_set_size(font, fontSize * PANGO_SCALE);<span class="comment">//设置字体大小   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_button) &#123;</span><br><span class="line">labelChild = gtk_bin_get_child(GTK_BIN(widget));<span class="comment">//取出GtkButton里的label  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">labelChild = widget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置label的字体，这样这个GtkButton上面显示的字体就变了</span></span><br><span class="line">gtk_widget_modify_font(GTK_WIDGET(labelChild), font);</span><br><span class="line">pango_font_description_free(font);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">//主窗口操作</span></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line"></span><br><span class="line">gtk_window_set_title(GTK_WINDOW(window), <span class="string">&quot;change &quot;</span>);</span><br><span class="line">gtk_container_set_border_width(GTK_CONTAINER(window), <span class="number">10</span>);</span><br><span class="line">gtk_widget_set_size_request(window, <span class="number">500</span>, <span class="number">450</span>);</span><br><span class="line"></span><br><span class="line">GtkWidget* vbox = gtk_vbox_new(TRUE, <span class="number">5</span>);<span class="comment">// 创建垂直布局</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(window), vbox);<span class="comment">// 把布局放在窗口里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变标签字体大小，参数为 FALSE</span></span><br><span class="line">GtkWidget* label = gtk_label_new(<span class="string">&quot;I am a label&quot;</span>);<span class="comment">// 标签</span></span><br><span class="line">set_widget_font_size(label, <span class="number">50</span>, FALSE);<span class="comment">// 设置标签字体大小</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(vbox), label);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变按钮字体大小，参数为 TRUE</span></span><br><span class="line">GtkWidget* button = gtk_button_new_with_label(<span class="string">&quot;I am a button&quot;</span>);</span><br><span class="line">set_widget_font_size(button, <span class="number">50</span>, TRUE);<span class="comment">// 改变按钮字体大小</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(vbox), button);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window); <span class="comment">// 显示所有部件</span></span><br><span class="line"></span><br><span class="line">gtk_main();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>定时器在应用编程里用得很广，我们手机里的闹钟，幻灯片播放图片等应用都用到定时器。定时器，每隔一段时间干一件事(程序里表现为调用一个函数)，像闹钟，每隔一天响一次。</p><p><strong>定时器的创建：</strong><br><code>guint g_timeout_add(guint interval, GSourceFunc function, gpointer data);</code><br>interval：设置的时间间隔，以毫秒为单位( 1000即为1秒 )<br>function：回调函数的名字<br>data：给回调函数传的参数<br>返回值：定时器id号</p><p>使用实例：<br><code>guint timer = g_timeout_add(500, (GSourceFunc)deal_time, NULL);</code><br>每隔500ms会执行一次deal_time()回调函数。<br>注意：当回调函数返回值为FALSE时，定时器执行一次后便会停止工作，不再循环执行。所以，要想定时器连续工作，循环执行所指定的回调函数，应该返回TRUE。</p><p>定时器的移除：<br><code>gboolean g_source_remove(guint tag);</code><br>tag：定时器id号<br>返回值：TRUE代表成功，FALSE代表失败</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">guint timer;<span class="comment">// 定时器id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 功能: 设置控件字体大小</span></span><br><span class="line"><span class="comment"> * widget: 需要改变字体的控件</span></span><br><span class="line"><span class="comment"> * size: 字体大小</span></span><br><span class="line"><span class="comment"> * is_button: TRUE代表控件为按钮，FALSE为其它控件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_widget_font_size</span><span class="params">(GtkWidget* widget, <span class="type">int</span> size, <span class="type">int</span> is_button)</span></span><br><span class="line">&#123;</span><br><span class="line">GtkWidget* labelChild;</span><br><span class="line">PangoFontDescription* font;</span><br><span class="line">gint fontSize = size;</span><br><span class="line"></span><br><span class="line">font = pango_font_description_from_string(<span class="string">&quot;Sans&quot;</span>);<span class="comment">//&quot;Sans&quot;字体名   </span></span><br><span class="line">pango_font_description_set_size(font, fontSize * PANGO_SCALE);<span class="comment">//设置字体大小   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_button) &#123;</span><br><span class="line">labelChild = gtk_bin_get_child(GTK_BIN(widget));<span class="comment">//取出GtkButton里的label  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">labelChild = widget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置label的字体，这样这个GtkButton上面显示的字体就变了</span></span><br><span class="line">gtk_widget_modify_font(GTK_WIDGET(labelChild), font);</span><br><span class="line">pango_font_description_free(font);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 功能:  定时器处理函数</span></span><br><span class="line"><span class="comment"> * label: 主要用于显示数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">gboolean <span class="title function_">deal_time</span><span class="params">(gpointer* label)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">5</span>] = <span class="string">&quot;Time&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">num--;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line"><span class="comment">//printf(&quot;%s \n&quot;, buf);</span></span><br><span class="line">gtk_label_set_text(GTK_LABEL(label), buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == num) &#123;</span><br><span class="line">num = <span class="number">11</span>;</span><br><span class="line"><span class="comment">//g_source_remove(timer); // 移除定时器 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;<span class="comment">//尽量返回TRUE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////主窗口操作</span></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line">gtk_window_set_title(GTK_WINDOW(window), <span class="string">&quot;timer&quot;</span>);</span><br><span class="line">gtk_container_set_border_width(GTK_CONTAINER(window), <span class="number">0</span>);</span><br><span class="line"><span class="comment">//设置窗口默认大小，设置一个最小大小</span></span><br><span class="line">gtk_window_set_default_size(GTK_WINDOW(window), <span class="number">320</span>, <span class="number">400</span>);</span><br><span class="line"><span class="comment">//设置窗口在显示器中的位置为居中。</span></span><br><span class="line">gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);</span><br><span class="line">g_signal_connect(G_OBJECT(window), <span class="string">&quot;destroy&quot;</span>,</span><br><span class="line">G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>); <span class="comment">//按关闭按钮可以把程序中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 倒计时显示区域</span></span><br><span class="line">GtkWidget* label = gtk_label_new(<span class="string">&quot;10&quot;</span>);<span class="comment">// label的创建</span></span><br><span class="line">set_widget_font_size(label, <span class="number">230</span>, FALSE);<span class="comment">// 设置label的字体大小</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(window), label);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器的创建, label传给回调函数</span></span><br><span class="line">timer = g_timeout_add(<span class="number">1000</span>, (GSourceFunc)deal_time, (gpointer)label);</span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window); <span class="comment">// 显示所有部件</span></span><br><span class="line"></span><br><span class="line">gtk_main();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><p>鼠标事件，可以理解为操作鼠标的动作。对于窗口而言，用户操作鼠标，窗口检测到鼠标的操作( 产生一个信号 )，然后去做相应处理( 调用其规定的回调函数 )，即可认为是鼠标事件，还是信号与回调函数的知识点。</p><p>窗口默认不接收鼠标的操作，需要手动添加让其接收。</p><p><strong>设置控件捕获(接收)相应的事件:</strong><br><code>void gtk_widget_add_events( GtkWidget *widget, gint events );</code><br>widget：控件<br>events：事件类型，它是GdkEventMask的枚举常量，取值列举如下</p><ul><li>GDK_BUTTON_PRESS_MASK：鼠标点击</li><li>GDK_BUTTON_RELEASE_MASK：鼠标释放</li><li>GDK_BUTTON_MOTION_MASK：鼠标移动</li><li>GDK_KEY_PRESS_MASK：键盘按下</li><li>GDK_ENTER_NOTIFY_MASK：进入控件区域</li><li>…… ……</li></ul><p>鼠标点击事件产生的信号：button-press-event<br>鼠标释放事件产生的信号：button-release-event</p><p>其回调函数的定义如下：<br><code>gboolean callback( GtkWidget *widget, GdkEventButton *event, gpointer data )</code><br>event：鼠键事件结构体变量，系统内部的变量，不是用户传参的<br>event-&gt;x，event-&gt;y：得到点击坐标值<br>event-&gt;button： 鼠标哪个键按下<br>event-&gt;type:        是否双击<br>返回值：没有太大意义</p><p>鼠标移动事件产生的信号：motion-notify-event</p><p>其回调函数的定义如下：<br><code>gboolean callback( GtkWidget *widget, GdkEventMotion *event, gpointer data )</code><br>{<br>event-&gt;x，event-&gt;y：得到移动的坐标值<br>}</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span><span class="comment">// 头文件</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 鼠标点击事件处理函数</span></span><br><span class="line">gboolean <span class="title function_">deal_mouse_press</span><span class="params">(GtkWidget *widget, GdkEventButton *event, gpointer data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(event-&gt;button)&#123;<span class="comment">// 判断鼠标点击的类型</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Left Button!!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Middle Button!!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Right Button!!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Unknown Button!!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(event-&gt;type == GDK_2BUTTON_PRESS)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;double click\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获得点击的坐标值，距离窗口左顶点</span></span><br><span class="line">gint i = event-&gt;x;</span><br><span class="line">gint j = event-&gt;y;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;press_x = %d, press_y = %d\n&quot;</span>, i, j);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 鼠标移动事件(点击鼠标任何键)的处理函数</span></span><br><span class="line">gboolean <span class="title function_">deal_motion_notify_event</span><span class="params">(GtkWidget *widget, GdkEventMotion *event, gpointer data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获得移动鼠标的坐标值，距离窗口左顶点</span></span><br><span class="line">gint i = event-&gt;x;</span><br><span class="line">gint j = event-&gt;y;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;motion_x = %d, motion_y = %d\n&quot;</span>, i, j);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc,<span class="type">char</span> *argv[] )</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv);<span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建顶层窗口</span></span><br><span class="line">GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line"><span class="comment">// 设置窗口的标题</span></span><br><span class="line">gtk_window_set_title(GTK_WINDOW(window), <span class="string">&quot;mouse_event&quot;</span>);</span><br><span class="line"><span class="comment">// 设置窗口在显示器中的位置为居中</span></span><br><span class="line">gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);</span><br><span class="line"><span class="comment">// 设置窗口的最小大小</span></span><br><span class="line">gtk_widget_set_size_request(window, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line"><span class="comment">// &quot;destroy&quot; 和 gtk_main_quit 连接</span></span><br><span class="line">g_signal_connect(window, <span class="string">&quot;destroy&quot;</span>, G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 窗口接收鼠标事件</span></span><br><span class="line"><span class="comment">// GDK_BUTTON_PRESS_MASK：鼠标点击事件</span></span><br><span class="line"><span class="comment">// GDK_BUTTON_MOTION_MASK：按住鼠标移动事件</span></span><br><span class="line">gtk_widget_add_events(window, GDK_BUTTON_PRESS_MASK | GDK_BUTTON_MOTION_MASK);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// &quot;button-press-event&quot; 与 deal_mouse_event 连接，鼠标点击事件</span></span><br><span class="line">g_signal_connect(window, <span class="string">&quot;button-press-event&quot;</span>, G_CALLBACK(deal_mouse_press), <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// &quot;motion-notify-event&quot; 与 deal_motion_notify_event 连接，按住鼠标移动事件</span></span><br><span class="line">g_signal_connect(window, <span class="string">&quot;motion-notify-event&quot;</span>, G_CALLBACK(deal_motion_notify_event), <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">gtk_widget_show_all(window);<span class="comment">// 显示窗口全部控件</span></span><br><span class="line"> </span><br><span class="line">gtk_main();<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">​```C</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span><span class="comment">// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标点击事件处理函数</span></span><br><span class="line">gboolean <span class="title function_">deal_mouse_press</span><span class="params">(GtkWidget* widget, GdkEventButton* event, gpointer data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (event-&gt;button) &#123;<span class="comment">// 判断鼠标点击的类型</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Left Button!!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Middle Button!!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Right Button!!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Unknown Button!!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (event-&gt;type == GDK_2BUTTON_PRESS) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;double click\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得点击的坐标值，距离窗口左顶点</span></span><br><span class="line">gint i = event-&gt;x;</span><br><span class="line">gint j = event-&gt;y;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;press_x = %d, press_y = %d\n&quot;</span>, i, j);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标移动事件(点击鼠标任何键)的处理函数</span></span><br><span class="line">gboolean <span class="title function_">deal_motion_notify_event</span><span class="params">(GtkWidget* widget, GdkEventMotion* event, gpointer data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获得移动鼠标的坐标值，距离窗口左顶点</span></span><br><span class="line">gint i = event-&gt;x;</span><br><span class="line">gint j = event-&gt;y;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;motion_x = %d, motion_y = %d\n&quot;</span>, i, j);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv);<span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建顶层窗口</span></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line"><span class="comment">// 设置窗口的标题</span></span><br><span class="line">gtk_window_set_title(GTK_WINDOW(window), <span class="string">&quot;mouse_event&quot;</span>);</span><br><span class="line"><span class="comment">// 设置窗口在显示器中的位置为居中</span></span><br><span class="line">gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);</span><br><span class="line"><span class="comment">// 设置窗口的最小大小</span></span><br><span class="line">gtk_widget_set_size_request(window, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line"><span class="comment">// &quot;destroy&quot; 和 gtk_main_quit 连接</span></span><br><span class="line">g_signal_connect(window, <span class="string">&quot;destroy&quot;</span>, G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口接收鼠标事件</span></span><br><span class="line"><span class="comment">// GDK_BUTTON_PRESS_MASK：鼠标点击事件</span></span><br><span class="line"><span class="comment">// GDK_BUTTON_MOTION_MASK：按住鼠标移动事件</span></span><br><span class="line">gtk_widget_add_events(window, GDK_BUTTON_PRESS_MASK | GDK_BUTTON_MOTION_MASK);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;button-press-event&quot; 与 deal_mouse_event 连接，鼠标点击事件</span></span><br><span class="line">g_signal_connect(window, <span class="string">&quot;button-press-event&quot;</span>, G_CALLBACK(deal_mouse_press), <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// &quot;motion-notify-event&quot; 与 deal_motion_notify_event 连接，按住鼠标移动事件</span></span><br><span class="line">g_signal_connect(window, <span class="string">&quot;motion-notify-event&quot;</span>, G_CALLBACK(deal_motion_notify_event), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window);<span class="comment">// 显示窗口全部控件</span></span><br><span class="line"></span><br><span class="line">gtk_main();<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>键盘事件，可以理解为操作键盘的动作。对于窗口而言，用户操作键盘，窗口检测到键盘的操作( 产生一个信号 )，然后去做相应处理( 调用其规定的回调函数 )，即可认为是键盘事件，还是信号与回调函数的知识点。</p><p>窗口默认就能接收键盘事件，其中的键值定义在 /usr/include/gtk-2.0/gdk/gdkkeysyms.h 文件里</p><p><strong>键盘按下事件产生的信号：key-press-event<br>键盘释放事件产生的信号：key-release-event</strong></p><p>其回调函数的定义如下：<br><code>gboolean callback( GtkWidget *widget, GdkEventKey *event, gpointer data )</code><br>{<br>event：键盘事件结构体变量，系统内部的变量，不是用户传参的<br>event-&gt;keyval：获取按下(释放)键盘键值，每个键值对于一个ASCII码<br>}</p><p>注意：可以在 GtkWidget 里找到相应的事件信号，回调函数如何定义应该查看帮助文档。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span><span class="comment">// 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gdk/gdkkeysyms.h&gt;</span><span class="comment">//键盘头文件，GDK_Up在这声明</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 键盘按下事件处理函数</span></span><br><span class="line">gboolean <span class="title function_">deal_key_press</span><span class="params">(GtkWidget* widget, GdkEventKey* event, gpointer data)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (event-&gt;keyval) &#123;<span class="comment">// 键盘键值类型</span></span><br><span class="line"><span class="keyword">case</span> GDK_KEY_Up:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Up\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> GDK_KEY_Left:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Left\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> GDK_KEY_Right:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Right\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> GDK_KEY_Down:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Down\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> key = event-&gt;keyval; <span class="comment">// 获取键盘键值类型</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;keyval = %d\n&quot;</span>, key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv);<span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建顶层窗口</span></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line"><span class="comment">// 设置窗口的标题</span></span><br><span class="line">gtk_window_set_title(GTK_WINDOW(window), <span class="string">&quot;mouse_event&quot;</span>);</span><br><span class="line"><span class="comment">// 设置窗口在显示器中的位置为居中</span></span><br><span class="line">gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);</span><br><span class="line"><span class="comment">// 设置窗口的最小大小</span></span><br><span class="line">gtk_widget_set_size_request(window, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line"><span class="comment">// &quot;destroy&quot; 和 gtk_main_quit 连接</span></span><br><span class="line">g_signal_connect(window, <span class="string">&quot;destroy&quot;</span>,</span><br><span class="line">G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;key-press-event&quot; 与 deal_key_press 连接</span></span><br><span class="line">g_signal_connect(window, <span class="string">&quot;key-press-event&quot;</span>,</span><br><span class="line">G_CALLBACK(deal_key_press), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window);<span class="comment">// 显示窗口全部控件</span></span><br><span class="line"></span><br><span class="line">gtk_main();<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性改变事件"><a href="#属性改变事件" class="headerlink" title="属性改变事件"></a>属性改变事件</h2><p>当窗口初始化，被移动或拉伸时，会触发属性改变事件。</p><p><strong>属性改变事件产生的信号：configure_event</strong></p><p>其回调函数的定义如下：</p><p><code>gboolean callback( GtkWidget *widget, GdkEventConfigure *event, gpointer data )</code><br>event：属性事件结构体变量，系统内部的变量，不是用户传参的<br>event-&gt;x，event-&gt;y：窗口的起点坐标<br>event-&gt;width，event-&gt;height：窗口的大小</p><p>以下例子为拉伸或移动窗口，能获取窗口的起点坐标以及大小：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span><span class="comment">// 头文件</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line">gboolean <span class="title function_">on_configure_event</span><span class="params">(GtkWidget * widget, </span></span><br><span class="line"><span class="params">GdkEventConfigure * event, </span></span><br><span class="line"><span class="params">gpointer data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 窗口的起点坐标</span></span><br><span class="line">gint x = event-&gt;x;</span><br><span class="line">gint y = event-&gt;y;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d\n&quot;</span>, x, y);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 窗口的宽度和高度</span></span><br><span class="line">gint w = event-&gt;width;</span><br><span class="line">gint h = event-&gt;height;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;w = %d, h = %d\n&quot;</span>, w, h);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv);<span class="comment">// 初始化</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建顶层窗口</span></span><br><span class="line">GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line"><span class="comment">// 设置窗口的标题</span></span><br><span class="line">gtk_window_set_title(GTK_WINDOW(window), <span class="string">&quot;mouse_event&quot;</span>);</span><br><span class="line"><span class="comment">// 设置窗口在显示器中的位置为居中</span></span><br><span class="line">gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);</span><br><span class="line"><span class="comment">// 设置窗口的最小大小</span></span><br><span class="line">gtk_widget_set_size_request(window, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line"><span class="comment">// &quot;destroy&quot; 和 gtk_main_quit 连接</span></span><br><span class="line">g_signal_connect(window, <span class="string">&quot;destroy&quot;</span>, G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// &quot;configure_event&quot; 与 on_configure_event 连接</span></span><br><span class="line">g_signal_connect(window, <span class="string">&quot;configure_event&quot;</span>, G_CALLBACK(on_configure_event), <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">gtk_widget_show_all(window);<span class="comment">// 显示窗口全部控件</span></span><br><span class="line"> </span><br><span class="line">gtk_main();<span class="comment">// 主事件循环</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="事件盒子"><a href="#事件盒子" class="headerlink" title="事件盒子"></a>事件盒子</h2><p>有些控件( 如：标签GtkLabel，图片控件GtkImage 等)，不响应GDK事件，相当于鼠标在其上面点击，它是捕获不到的。用户通过事件盒子可以解决这个问题。</p><p>事件盒子给控件提供一个GDK窗口来捕获事件。我们把控件放在事件盒子里，当我们用鼠标点击这个控件时，这个事件盒子就能捕获到点击的状态。</p><p>事件盒子的创建：</p><p><code>GtkWidget *gtk_event_box_new(void);</code><br>返回值：事件盒子指针</p><p>把控件添加到事件盒子里：<br><code>void gtk_container_add(GtkContainer *container, GtkWidget *widget );</code><br>container：容纳控件的事件盒子<br>widget：要添加的控件</p><p>以下例子为，通过事件盒子实现，双击标签改变其内容：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;button_press_event&quot;信号处理函数</span></span><br><span class="line">gboolean <span class="title function_">button_pressed</span><span class="params">(GtkWidget* eventbox,GdkEventButton* event,GtkLabel* label)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (event-&gt;type == GDK_2BUTTON_PRESS) &#123;<span class="comment">// 双击</span></span><br><span class="line"><span class="type">const</span> gchar* text = gtk_label_get_text(label); <span class="comment">// 获取label内容</span></span><br><span class="line"><span class="keyword">if</span> (text[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">gtk_label_set_text(label, <span class="string">&quot;I Was Double-Clicked!&quot;</span>); <span class="comment">// 修改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">gtk_label_set_text(label, <span class="string">&quot;Double-Click Me Again!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">gtk_init(&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);<span class="comment">// 主窗口</span></span><br><span class="line">gtk_window_set_title(GTK_WINDOW(window), <span class="string">&quot;Event Box&quot;</span>);    <span class="comment">// 标题</span></span><br><span class="line">gtk_container_set_border_width(GTK_CONTAINER(window), <span class="number">10</span>);</span><br><span class="line">gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER); <span class="comment">// 居中显示</span></span><br><span class="line">gtk_widget_set_size_request(window, <span class="number">200</span>, <span class="number">50</span>);     <span class="comment">// 最小大小</span></span><br><span class="line">g_signal_connect(window, <span class="string">&quot;destroy&quot;</span>, G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">GtkWidget* eventbox = gtk_event_box_new();<span class="comment">// 事件盒子的创建</span></span><br><span class="line">gtk_widget_set_events(eventbox, GDK_BUTTON_PRESS_MASK); <span class="comment">// 捕获鼠标点击事件</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(window), eventbox);<span class="comment">// 事件盒子放入窗口</span></span><br><span class="line"></span><br><span class="line">GtkWidget* label = gtk_label_new(<span class="string">&quot;Double-Click Me!&quot;</span>);<span class="comment">// label</span></span><br><span class="line">gtk_container_add(GTK_CONTAINER(eventbox), label);<span class="comment">// label放入事件盒子里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理&quot;button_press_event&quot;信号，把标签label传给回调函数</span></span><br><span class="line">g_signal_connect(eventbox, <span class="string">&quot;button_press_event&quot;</span>,G_CALLBACK(button_pressed), (gpointer)label);</span><br><span class="line"></span><br><span class="line">gtk_widget_show_all(window);<span class="comment">// 显示所有控件</span></span><br><span class="line"></span><br><span class="line">gtk_main();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 添加菜单 menu.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">on_menu_activate</span> <span class="params">(GtkMenuItem* item,gpointer data)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//g_print(&quot;菜单项 %s 被激活\n&quot;,(gchar*)data);</span></span><br><span class="line">   g_print(<span class="string">&quot;Menuitem %s is pressed.\n&quot;</span>,(gchar*)data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">   GtkWidget* window;</span><br><span class="line">   GtkWidget* box;</span><br><span class="line">   GtkWidget* menubar;</span><br><span class="line">   GtkWidget* menu;</span><br><span class="line">   GtkWidget* editmenu;</span><br><span class="line">   GtkWidget* helpmenu;</span><br><span class="line">   GtkWidget* rootmenu;</span><br><span class="line">   GtkWidget* menuitem;</span><br><span class="line">   GtkAccelGroup* accel_group ;</span><br><span class="line"> </span><br><span class="line">   gtk_init(&amp;argc,&amp;argv);</span><br><span class="line"> </span><br><span class="line">   window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line">   gtk_widget_set_size_request(window,<span class="number">400</span>,<span class="number">300</span>); </span><br><span class="line">   gtk_window_set_title(GTK_WINDOW(window),<span class="string">&quot;菜单测试程序&quot;</span>);</span><br><span class="line">   g_signal_connect(G_OBJECT(window),<span class="string">&quot;destroy&quot;</span>,</span><br><span class="line">      G_CALLBACK(gtk_main_quit),<span class="literal">NULL</span>);</span><br><span class="line">   accel_group = gtk_accel_group_new();</span><br><span class="line"> </span><br><span class="line">   gtk_window_add_accel_group(GTK_WINDOW(window),accel_group);<span class="comment">// AccelGroup</span></span><br><span class="line"> </span><br><span class="line">   box = gtk_vbox_new(FALSE,<span class="number">0</span>);</span><br><span class="line">   gtk_container_add(GTK_CONTAINER(window),box);</span><br><span class="line">   menu = gtk_menu_new();<span class="comment">//文件菜单</span></span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_NEW,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(menu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">&quot;activate&quot;</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)(&quot;新建&quot;));</span></span><br><span class="line">      (gpointer)(<span class="string">&quot;New&quot;</span>));</span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_OPEN,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(menu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">&quot;activate&quot;</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)(&quot;打开&quot;));</span></span><br><span class="line">      (gpointer)(<span class="string">&quot;Open&quot;</span>));</span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_SAVE,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(menu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">&quot;activate&quot;</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)(&quot;保存&quot;));</span></span><br><span class="line">      (gpointer)(<span class="string">&quot;Save&quot;</span>));</span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_SAVE_AS,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(menu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">&quot;activate&quot;</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)(&quot;另存为&quot;));</span></span><br><span class="line">      (gpointer)(<span class="string">&quot;Save As&quot;</span>));</span><br><span class="line">   menuitem = gtk_separator_menu_item_new();</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(menu),menuitem);</span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_QUIT,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(menu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">&quot;activate&quot;</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)(&quot;退出&quot;));</span></span><br><span class="line">      (gpointer)(<span class="string">&quot;Exit&quot;</span>));</span><br><span class="line">   rootmenu = gtk_menu_item_new_with_label(<span class="string">&quot; 文件 &quot;</span>);</span><br><span class="line">   gtk_menu_item_set_submenu(GTK_MENU_ITEM(rootmenu),menu);</span><br><span class="line">   menubar = gtk_menu_bar_new();</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(menubar),rootmenu);</span><br><span class="line">   rootmenu = gtk_menu_item_new_with_label(<span class="string">&quot; 编辑 &quot;</span>);</span><br><span class="line">   editmenu = gtk_menu_new();<span class="comment">//编辑菜单</span></span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_CUT,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(editmenu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">&quot;activate&quot;</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)(&quot;剪切&quot;));</span></span><br><span class="line">      (gpointer)(<span class="string">&quot;Cut&quot;</span>));</span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_COPY,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(editmenu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">&quot;activate&quot;</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)(&quot;复制&quot;));</span></span><br><span class="line">      (gpointer)(<span class="string">&quot;Copy&quot;</span>));</span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_PASTE,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(editmenu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">&quot;activate&quot;</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)(&quot;粘贴&quot;));</span></span><br><span class="line">      (gpointer)(<span class="string">&quot;Paste&quot;</span>));</span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_FIND,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(editmenu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">&quot;activate&quot;</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)(&quot;查找&quot;));</span></span><br><span class="line">      (gpointer)(<span class="string">&quot;Search&quot;</span>));</span><br><span class="line">   gtk_menu_item_set_submenu(GTK_MENU_ITEM(rootmenu),editmenu);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(menubar),rootmenu);</span><br><span class="line">   rootmenu = gtk_menu_item_new_with_label(<span class="string">&quot; 帮助 &quot;</span>);</span><br><span class="line">   helpmenu = gtk_menu_new();</span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_HELP,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(helpmenu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">&quot;activate&quot;</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)(&quot;帮助&quot;));</span></span><br><span class="line">      (gpointer)(<span class="string">&quot;Help&quot;</span>));</span><br><span class="line">   menuitem = gtk_menu_item_new_with_label(<span class="string">&quot; 关于... &quot;</span>);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(helpmenu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">&quot;activate&quot;</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)(&quot;关于&quot;));</span></span><br><span class="line">   (gpointer)(<span class="string">&quot;About&quot;</span>));</span><br><span class="line">   gtk_menu_item_set_submenu(GTK_MENU_ITEM(rootmenu),helpmenu);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(menubar),rootmenu);</span><br><span class="line">   gtk_box_pack_start(GTK_BOX(box),menubar,FALSE,FALSE,<span class="number">0</span>);</span><br><span class="line">   gtk_widget_show_all(window);</span><br><span class="line">   gtk_main();</span><br><span class="line">   <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一个简单的空白窗口&quot;&gt;&lt;a href=&quot;#一个简单的空白窗口&quot; class=&quot;headerlink&quot; title=&quot;一个简单的空白窗口&quot;&gt;&lt;/a&gt;一个简单的空白窗口&lt;/h3&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="GTK" scheme="http://yorxika.github.io/tags/GTK/"/>
    
  </entry>
  
  <entry>
    <title>接雨水</title>
    <link href="http://yorxika.github.io/2020/02/18/%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>http://yorxika.github.io/2020/02/18/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</id>
    <published>2020-02-17T16:18:37.000Z</published>
    <updated>2020-04-04T06:29:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第42题接雨水</p><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br><span id="more"></span><br><img src="/2020/02/18/%E6%8E%A5%E9%9B%A8%E6%B0%B4/02/18/%E6%8E%A5%E9%9B%A8%E6%B0%B4/rainwatertrap.png" alt="img"></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 <strong>感谢 Marcos</strong> 贡献此图。</p><p><strong>示例:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">0,1,0,2</span>,<span class="number">1,0,1,3</span>,<span class="number">2,1,2,1</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br></pre></td></tr></table></figure><hr><h3 id="找短板"><a href="#找短板" class="headerlink" title="找短板"></a>找短板</h3><p>对每一个要求的位置，寻找左右两边最高的列，然后取较小的，如果较小列大于当前列，就可以装水。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(height.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; height.length - <span class="number">1</span> ; i++)&#123;</span><br><span class="line">        <span class="comment">//最两端的列不用考虑，因为一定不会有水。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left_max</span> <span class="operator">=</span> <span class="number">0</span>,right_max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找出左边最高的列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            left_max = Math.max(left_max,height[j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; height.length; j++)</span><br><span class="line">            right_max = Math.max(right_max,height[j]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(left_max,right_max);</span><br><span class="line">        <span class="keyword">if</span>(min &gt; height[i])</span><br><span class="line">            sum += min - height[i];  <span class="comment">//只有较小的一段大于当前列的高度才会有水</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/">来源</a></p><p>对于每一列，我们求它左边最高的墙和右边最高的墙，都是重新遍历一遍所有高度，这里我们可以优化一下。</p><p>首先用两个数组，<code>max_left [i]</code>代表第 <code>i</code> 列左边最高的墙的高度，<code>max_right[i]</code> 代表第 <code>i</code> 列右边最高的墙的高度。（一定要注意下，第 i 列左（右）边最高的墙，是不包括自身的，和 leetcode 上边的讲的有些不同）</p><p>对于 <code>max_left</code>我们其实可以这样求。</p><p><code>max_left [i] = Max(max_left [i-1]</code>,<code>height[i-1])</code>。它前边的墙的左边的最高高度和它前边的墙的高度选一个较大的，就是当前列左边最高的墙了。</p><p>对于 max_right我们可以这样求。</p><p><code>max_right[i] = Max(max_right[i+1]</code>,<code>height[i+1])</code> 。它后边的墙的右边的最高高度和它后边的墙的高度选一个较大的，就是当前列右边最高的墙了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] max_left = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];</span><br><span class="line">    <span class="type">int</span>[] max_right = <span class="keyword">new</span> <span class="title class_">int</span>[height.length];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        max_left[i] = Math.max(max_left[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> height.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        max_right[i] = Math.max(max_right[i + <span class="number">1</span>], height[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(max_left[i], max_right[i]);</span><br><span class="line">        <span class="keyword">if</span> (min &gt; height[i]) &#123;</span><br><span class="line">            sum = sum + (min - height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/dong-tai-gui-hua-shuang-zhi-zhen-tu-jie-by-ml-zimi/">来源</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max_left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max_right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length - <span class="number">2</span>; <span class="comment">// 加右指针进去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//从左到右更</span></span><br><span class="line">        <span class="keyword">if</span> (height[left - <span class="number">1</span>] &lt; height[right + <span class="number">1</span>]) &#123;</span><br><span class="line">            max_left = Math.max(max_left, height[left - <span class="number">1</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> max_left;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; height[left]) &#123;</span><br><span class="line">                sum = sum + (min - height[left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        <span class="comment">//从右到左更</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max_right = Math.max(max_right, height[right + <span class="number">1</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> max_right;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; height[right]) &#123;</span><br><span class="line">                sum = sum + (min - height[right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明这里会有积水，我们将墙的高度的下标入栈。</p><p>如果当前高度大于栈顶的墙的高度，说明之前的积水到这里停下，我们可以计算下有多少积水了。计算完，就把当前的墙继续入栈，作为新的积水的墙。</p><p>总体的原则就是，</p><ol><li>当前高度小于等于栈顶高度，入栈，指针后移。</li><li>当前高度大于栈顶高度，出栈，计算出当前墙和栈顶的墙之间水的多少，然后计算当前的高度和新栈的高度的关系，重复第 2 步。直到当前墙的高度不大于栈顶高度或者栈空，然后把当前墙入栈，指针后移。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(height.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> popIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; height.length ; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[stack.peek()] &lt; height[i])&#123;</span><br><span class="line">            <span class="comment">//单调栈</span></span><br><span class="line">            popIndex = stack.pop();</span><br><span class="line">            <span class="comment">//将栈顶元素相等的出栈</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[stack.peek()] == height[popIndex])</span><br><span class="line">                stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">peekIndex</span> <span class="operator">=</span> stack.peek();  <span class="comment">//栈顶</span></span><br><span class="line">                ans += (Math.min(height[stack.peek()],height[i]) - height[popIndex]) * (i - peekIndex - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第42题接雨水&lt;/p&gt;
&lt;p&gt;给定 &lt;em&gt;n&lt;/em&gt; 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="双指针" scheme="http://yorxika.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>K个一组翻转链表</title>
    <link href="http://yorxika.github.io/2020/02/17/K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yorxika.github.io/2020/02/17/K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-17T15:34:33.000Z</published>
    <updated>2020-02-17T16:02:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第25题K个一组翻转链表</p><p>给你一个链表，每 <em>k</em> 个节点一组进行翻转，请你返回翻转后的链表。</p><p><em>k</em> 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 <em>k</em> 的整数倍，那么请将最后剩余的节点保持原有顺序。<br><span id="more"></span><br><strong>示例 :</strong></p><p>给定这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p><p>当 <em>k</em> = 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p><p>当 <em>k</em> = 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p><p><strong>说明 :</strong></p><ul><li>你的算法只能使用常数的额外空间。</li><li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>最简单的思路，把K个结点压入栈中，然后出栈的顺序就是翻转后的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || k == <span class="number">0</span> || k == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">ahead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> ahead,p2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        p2 = head;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="literal">null</span> &amp;&amp; count &lt; k)&#123;</span><br><span class="line">            stack.add(p2);</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count != k)&#123;</span><br><span class="line">            p1.next = head;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            p1.next = stack.pop();</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1.next = p2;</span><br><span class="line">        head = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ahead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pre</span><br><span class="line">tail    head</span><br><span class="line">dummy    <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>     <span class="number">5</span></span><br><span class="line"><span class="comment"># 我们用tail 移到要翻转的部分最后一个元素</span></span><br><span class="line">pre     head       tail</span><br><span class="line">dummy    <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>     <span class="number">5</span></span><br><span class="line">       cur</span><br><span class="line"><span class="comment"># 我们尾插法的意思就是,依次把cur移到tail后面</span></span><br><span class="line">pre          tail  head</span><br><span class="line">dummy    <span class="number">2</span>     <span class="number">3</span>    <span class="number">1</span>     <span class="number">4</span>     <span class="number">5</span></span><br><span class="line">       cur</span><br><span class="line"><span class="comment"># 依次类推</span></span><br><span class="line">pre     tail      head</span><br><span class="line">dummy    <span class="number">3</span>     <span class="number">2</span>    <span class="number">1</span>     <span class="number">4</span>     <span class="number">5</span></span><br><span class="line">cur</span><br><span class="line">....</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || k == <span class="number">0</span> || k == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">ahead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ahead.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> ahead,tail,tmp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        tail = head;</span><br><span class="line">        <span class="keyword">while</span>(tail != <span class="literal">null</span> &amp;&amp; count &lt; k)&#123;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tail == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        tmp = pre.next;</span><br><span class="line">        <span class="keyword">while</span>(pre.next != tail)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;  <span class="comment">// cur = 2</span></span><br><span class="line">            pre.next = cur.next; <span class="comment">//1 -&gt; 3</span></span><br><span class="line">            cur.next = tail.next; <span class="comment">//2 -&gt; k + 1</span></span><br><span class="line">            tail.next = cur;  <span class="comment">//k -&gt; 2</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = tmp;</span><br><span class="line">        tail = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ahead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="keyword">while</span> (end.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="literal">null</span>; i++) end = end.next;</span><br><span class="line">        <span class="keyword">if</span> (end == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> end.next;</span><br><span class="line">        end.next = <span class="literal">null</span>;</span><br><span class="line">        pre.next = reverse(start);</span><br><span class="line">        start.next = next;</span><br><span class="line">        pre = start;</span><br><span class="line">        end = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">        curr.next = pre;</span><br><span class="line">        pre = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第25题K个一组翻转链表&lt;/p&gt;
&lt;p&gt;给你一个链表，每 &lt;em&gt;k&lt;/em&gt; 个节点一组进行翻转，请你返回翻转后的链表。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;k&lt;/em&gt; 是一个正整数，它的值小于或等于链表的长度。&lt;/p&gt;
&lt;p&gt;如果节点总数不是 &lt;em&gt;k&lt;/em&gt; 的整数倍，那么请将最后剩余的节点保持原有顺序。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="链表" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="链表" scheme="http://yorxika.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>缺失的数字</title>
    <link href="http://yorxika.github.io/2020/02/17/%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yorxika.github.io/2020/02/17/%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-02-17T07:40:07.000Z</published>
    <updated>2020-02-17T07:47:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第268题缺失数字</p><p>给定一个包含 <code>0, 1, 2, ..., n</code> 中 <em>n</em> 个数的序列，找出 0 .. <em>n</em> 中没有出现在序列中的那个数。<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [3,0,1]</span></span><br><span class="line"><span class="section">输出: 2</span></span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>利用数组标记各个数字是否出现，最后遍历数组，找到没出现的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n : nums)</span><br><span class="line">        map[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; map.length; i++)</span><br><span class="line">        <span class="keyword">if</span>(map[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> nums.length + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异或位运算"><a href="#异或位运算" class="headerlink" title="异或位运算"></a>异或位运算</h3><p>来自<a href="https://leetcode-cn.com/problems/missing-number/solution/que-shi-shu-zi-by-leetcode/">官方题解</a></p><p>我们知道数组中有 <em>n</em> 个数，并且缺失的数在 [0..n][0..<em>n</em>] 中。因此我们可以先得到 [0..n][0..<em>n</em>] 的异或值，再将结果对数组中的每一个数进行一次异或运算。未缺失的数在 [0..n][0..<em>n</em>] 和数组中各出现一次，因此异或后得到 0。而缺失的数字只在 [0..n][0..<em>n</em>] 中出现了一次，在数组中没有出现，因此最终的异或结果即为这个缺失的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">missing</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            missing ^= i ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> missing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求和公式"><a href="#求和公式" class="headerlink" title="求和公式"></a>求和公式</h3><p>我们可以用 <a href="https://baike.baidu.com/item/高斯求和">高斯求和公式</a> 求出 [0..n][0..<em>n</em>] 的和，减去数组中所有数的和，就得到了缺失的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedSum</span> <span class="operator">=</span> nums.length*(nums.length + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">actualSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) actualSum += num;</span><br><span class="line">        <span class="keyword">return</span> expectedSum - actualSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以遍历一遍数组，在把0-n这n个自然数全加起来的同时也减去nums[i]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        sum -= nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第268题缺失数字&lt;/p&gt;
&lt;p&gt;给定一个包含 &lt;code&gt;0, 1, 2, ..., n&lt;/code&gt; 中 &lt;em&gt;n&lt;/em&gt; 个数的序列，找出 0 .. &lt;em&gt;n&lt;/em&gt; 中没有出现在序列中的那个数。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="位运算" scheme="http://yorxika.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>各位相加</title>
    <link href="http://yorxika.github.io/2020/02/17/%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yorxika.github.io/2020/02/17/%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/</id>
    <published>2020-02-16T16:46:33.000Z</published>
    <updated>2020-02-16T16:57:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第258题</p><p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。<br><span id="more"></span><br><strong>示例:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 38</span><br><span class="line">输出:<span class="number"> 2 </span></span><br><span class="line">解释: 各位相加的过程为：3 +<span class="number"> 8 </span>= 11,<span class="number"> 1 </span>+<span class="number"> 1 </span>= 2。 由于<span class="number"> 2 </span>是一位数，所以返回 2。</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong><br>你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？</p><hr><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>按照题意暴力运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addDigits</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(num/<span class="number">10</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        num = add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        res+=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取余"><a href="#取余" class="headerlink" title="取余"></a>取余</h3><p>X = 100*a + 10*b + c = 99*a + 9*b + (a+b+c)；所以对9取余即可。</p><p>但是要注意当X是9的倍数时，即(a+b+c)也是9的倍数，这时候返回9即可，因为只要是9的倍数，其各位相加一定为9，否则返回X % 9.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addDigits</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num &lt; <span class="number">10</span> ? num : (num % <span class="number">9</span> == <span class="number">0</span> ? <span class="number">9</span> : num % <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大佬的精简代码</p><pre><code class="lang-JAVA">    public int addDigits(int num) &#123;        return (num-1)%9+1;    &#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第258题&lt;/p&gt;
&lt;p&gt;给定一个非负整数 &lt;code&gt;num&lt;/code&gt;，反复将各个位上的数字相加，直到结果为一位数。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>只出现一次的数字III</title>
    <link href="http://yorxika.github.io/2020/02/17/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97III/"/>
    <id>http://yorxika.github.io/2020/02/17/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97III/</id>
    <published>2020-02-16T16:32:01.000Z</published>
    <updated>2020-02-16T16:45:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第260只出现一次的数字III</p><p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，<strong>其余所有元素均出现两次</strong>。 找出只出现一次的那两个元素。<br><span id="more"></span><br><strong>示例 :</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="comment">[1,2,1,3,2,5]</span></span><br><span class="line">输出: <span class="comment">[3,5]</span></span><br></pre></td></tr></table></figure><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>建立一个值到频率的映射关系的哈希表，返回频率为 1 的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addDigits</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//int sum = 0;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(num % <span class="number">10</span>);</span><br><span class="line">            num = num / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!list.isEmpty())&#123;</span><br><span class="line">            num += list.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>来源<a href="https://leetcode-cn.com/problems/single-number-iii/solution/zhi-chu-xian-yi-ci-de-shu-zi-iii-by-leetcode/">官方题解</a></p><p>在做这题时没有注意到题目给出了信息<strong>其余所有元素均出现两次</strong>，这样就好说了。</p><p>首先计算 <code>bitmask ^= x</code>，则 <code>bitmask</code> 不会保留出现两次数字的值，因为相同数字的异或值为 <code>0</code>。但是 <code>bitmask</code> 会保留只出现一次的两个数字（<code>x</code> 和 <code>y</code>）之间的差异。我们通过 <code>bitmask &amp; (-bitmask)</code> 保留 <code>bitmask</code> 最右边的 <code>1</code>，这个 <code>1</code> 要么来自 <code>x</code>，要么来自 <code>y</code>。当我们找到了 <code>x</code>，那么 <code>y = bitmask^x</code>。</p><p>另外一个解释：</p><p>1.对所有数字异或,一样的数字抵消,出现一次的两个数字异或运算后必定不为0;<br>2.这个数字和相反数做与运算得到一个二进制位最右边一位为1的数字;<br>3.mask和数组的每个数字做与运算,等于0的分为一组,等于mask的分为一组,同时也将两个不一样的数字分开;<br>4.完结。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addDigits</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//int sum = 0;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(num % <span class="number">10</span>);</span><br><span class="line">            num = num / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!list.isEmpty())&#123;</span><br><span class="line">            num += list.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] singleNumber(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">xor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums)<span class="comment">// 一样的抵消,不一样的两个数字异或运算结果必定有一位是1</span></span><br><span class="line">        xor ^= i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> xor &amp; (-xor);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; mask) == <span class="number">0</span>)<span class="comment">//== 0、 == mask 两种结果</span></span><br><span class="line">            ans[<span class="number">0</span>] ^= i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans[<span class="number">1</span>] ^= i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第260只出现一次的数字III&lt;/p&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt;，其中恰好有两个元素只出现一次，&lt;strong&gt;其余所有元素均出现两次&lt;/strong&gt;。 找出只出现一次的那两个元素。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="位运算" scheme="http://yorxika.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Nim游戏</title>
    <link href="http://yorxika.github.io/2020/02/15/Nim%E6%B8%B8%E6%88%8F/"/>
    <id>http://yorxika.github.io/2020/02/15/Nim%E6%B8%B8%E6%88%8F/</id>
    <published>2020-02-14T16:17:52.000Z</published>
    <updated>2020-02-16T17:45:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第292题Nim游戏</p><p>你和你的朋友，两个人一起玩 <a href="https://baike.baidu.com/item/Nim游戏/6737105">Nim 游戏</a>：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p><p>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。<br><span id="more"></span><br><strong>示例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: 4</span></span><br><span class="line"><span class="section">输出: false </span></span><br><span class="line"><span class="section">解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；</span></span><br><span class="line">     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</span><br></pre></td></tr></table></figure><hr><p>直觉告诉我是4的倍数就稳输</p><p>以下内容来自<a href="https://leetcode-cn.com/problems/nim-game/solution/nimyou-xi-by-leetcode/">官方题解</a></p><p>让我们考虑一些小例子。显而易见的是，如果石头堆中只有一块、两块、或是三块石头，那么在你的回合，你就可以把全部石子拿走，从而在游戏中取胜。而如果就像题目描述那样，堆中恰好有四块石头，你就会失败。因为在这种情况下不管你取走多少石头，总会为你的对手留下几块，使得他可以在游戏中打败你。因此，要想获胜，在你的回合中，必须避免石头堆中的石子数为 4 的情况。</p><p>同样地，如果有五块、六块、或是七块石头，你可以控制自己拿取的石头数，总是恰好给你的对手留下四块石头，使他输掉这场比赛。但是如果石头堆里有八块石头，你就不可避免地会输掉，因为不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，以确保在再一次轮到你的时候，你会面对四块石头。</p><p>显然，它以相同的模式不断重复 n=4,8,12,16，基本可以看出是 4 的倍数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWinNim</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (n % <span class="number">4</span> != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第292题Nim游戏&lt;/p&gt;
&lt;p&gt;你和你的朋友，两个人一起玩 &lt;a href=&quot;https://baike.baidu.com/item/Nim游戏/6737105&quot;&gt;Nim 游戏&lt;/a&gt;：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。&lt;/p&gt;
&lt;p&gt;你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>长度最小的子数组</title>
    <link href="http://yorxika.github.io/2020/02/13/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yorxika.github.io/2020/02/13/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2020-02-13T15:12:05.000Z</published>
    <updated>2020-02-13T15:21:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第209题长度最小的子数组</p><p>给定一个含有 <strong>n</strong> 个正整数的数组和一个正整数 <strong>s ，</strong>找出该数组中满足其和 <strong>≥ s</strong> 的长度最小的连续子数组<strong>。</strong>如果不存在符合条件的连续子数组，返回 0。<br><span id="more"></span><br><strong>示例:</strong> </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = 7, nums = [2,3,1,2,4,3]</span></span><br><span class="line"><span class="section">输出: 2</span></span><br><span class="line"><span class="section">解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</span></span><br></pre></td></tr></table></figure><p><strong>进阶:</strong></p><p>如果你已经完成了<em>O</em>(<em>n</em>) 时间复杂度的解法, 请尝试 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度的解法。</p><h3 id="丢人写法"><a href="#丢人写法" class="headerlink" title="丢人写法"></a>丢人写法</h3><p>双指针，一开始按照等于做的直接错了，是大于等于，此外还要注意临界条件，当<code>nums[right] &gt;= s</code>时，可以直接返回1；当<code>if(minlen == Integer.MAX_VALUE || right - left == len)</code>时，意味着没满足条件，应当返回0.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minlen</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>,len = nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[right] &gt;= s)&#123;</span><br><span class="line">            <span class="comment">//minlen = 1;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= s)&#123;</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= s &amp;&amp; left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minlen &gt; right - left + <span class="number">1</span>) &#123;</span><br><span class="line">                    minlen = right - left + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                    sum -= nums[left];</span><br><span class="line">                    left++;  <span class="comment">//左指针移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minlen == Integer.MAX_VALUE || right - left == len)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> minlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="精简双指针"><a href="#精简双指针" class="headerlink" title="精简双指针"></a>精简双指针</h3><p>用双指针 left 和 right 表示一个窗口。</p><ol><li>right 向右移增大窗口，直到窗口内的数字和大于等于了 <code>s</code>。进行第 <code>2</code> 步。</li><li>记录此时的长度，left 向右移动，开始减少长度，每减少一次，就更新最小长度。直到当前窗口内的数字和小于了 <code>s</code>，回到第 1 步。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">            min = Math.min(min, right - left);</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="number">0</span> : min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-43/">来自</a></p><p>题目中，我们要寻找连续的数字和大于等于 <code>s</code> 的最小长度。那么，我们可以对这个长度采取二分的方法去寻找吗？</p><p>答案是肯定的，原因就是长度为 <code>1</code> 的所有连续数字中最大的和、长度为 <code>2</code> 的所有连续数字中最大的和、长度为 <code>3</code> 的所有连续数字中最大的和 … 长度为 <code>n</code> 的所有连续数字中最大的和，同样是一个升序数组。</p><p>算法的话就是对长度进行二分，寻求满足条件的最小长度。</p><p>对于长度为 <code>n</code> 的数组，我们先去判断长度为 <code>n/2</code> 的连续数字中最大的和是否大于等于 <code>s</code>。</p><ul><li>如果大于等于 <code>s</code> ，那么我们需要减少长度，继续判断所有长度为 <code>n/4</code> 的连续数字</li><li>如果小于 <code>s</code>，我们需要增加长度，我们继续判断所有长度为 <code>(n/2 + n) / 2</code>，也就是 <code>3n/4</code> 的连续数字。</li></ul><p>可以再结合下边的代码看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> <span class="number">0</span>, maxLen = n;</span><br><span class="line">    <span class="type">int</span> midLen;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (minLen &lt;= maxLen) &#123;</span><br><span class="line">        <span class="comment">//取中间的长度</span></span><br><span class="line">        midLen = (minLen + maxLen) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//判断当前长度的最大和是否大于等于 s</span></span><br><span class="line">        <span class="keyword">if</span> (getMaxSum(midLen, nums) &gt;= s) &#123;</span><br><span class="line">            maxLen = midLen - <span class="number">1</span>; <span class="comment">//减小长度</span></span><br><span class="line">            min = midLen; <span class="comment">//更新最小值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minLen = midLen + <span class="number">1</span>; <span class="comment">//增大长度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min == -<span class="number">1</span> ? <span class="number">0</span> : min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxSum</span><span class="params">(<span class="type">int</span> len, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 达到长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    maxSum = sum; <span class="comment">// 初始化 maxSum</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 加一个数字减一个数字，保持长度不变</span></span><br><span class="line">        sum += nums[i];</span><br><span class="line">        sum = sum - nums[i - len];</span><br><span class="line">        <span class="comment">// 更新 maxSum</span></span><br><span class="line">        maxSum = Math.max(maxSum, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第209题长度最小的子数组&lt;/p&gt;
&lt;p&gt;给定一个含有 &lt;strong&gt;n&lt;/strong&gt; 个正整数的数组和一个正整数 &lt;strong&gt;s ，&lt;/strong&gt;找出该数组中满足其和 &lt;strong&gt;≥ s&lt;/strong&gt; 的长度最小的连续子数组&lt;strong&gt;。&lt;/strong&gt;如果不存在符合条件的连续子数组，返回 0。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="双指针" scheme="http://yorxika.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口中的最大值</title>
    <link href="http://yorxika.github.io/2020/02/13/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://yorxika.github.io/2020/02/13/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2020-02-13T07:04:02.000Z</published>
    <updated>2020-02-13T14:32:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第239题滑动窗口中的最大值</p><p>给定一个数组 <em>nums</em>，有一个大小为 <em>k</em> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <em>k</em> 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。<br><span id="more"></span><br><strong>示例:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,<span class="string">-1</span>,<span class="string">-3</span>,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  <span class="string">-1</span>] <span class="string">-3</span>  5  3  6  7       3</span><br><span class="line"> 1 [3  <span class="string">-1</span>  <span class="string">-3</span>] 5  3  6  7       3</span><br><span class="line"> 1  3 [<span class="string">-1</span>  <span class="string">-3</span>  5] 3  6  7       5</span><br><span class="line"> 1  3  <span class="string">-1</span> [<span class="string">-3</span>  5  3] 6  7       5</span><br><span class="line"> 1  3  <span class="string">-1</span>  <span class="string">-3</span> [5  3  6] 7       6</span><br><span class="line"> 1  3  <span class="string">-1</span>  <span class="string">-3</span>  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>你可以假设 <em>k</em> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><hr><h3 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h3><p>思路同重复元素III，在数组中划定长度为k的滑动窗口，通过2重循环，依次找到每个滑动窗口里的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len * k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> [] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len - k + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - k + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; i + k; j++)</span><br><span class="line">            max = Math.max(max,nums[j]);</span><br><span class="line">        ans[i] = max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/dan-diao-dui-lie-by-labuladong/">来源</a></p><p>「单调队列」的核心思路和「单调栈」类似。单调队列的 push 方法依然在队尾添加元素，但是要把前面比新元素小的元素都删掉.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">deque</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!data.isEmpty() &amp;&amp; data.getLast() &lt; n)</span><br><span class="line">            data.removeLast();</span><br><span class="line">        data.addLast(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!data.isEmpty() &amp;&amp; data.getFirst() ==n)</span><br><span class="line">            data.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">deque</span><span class="params">()</span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len * k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> [] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len - k + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span></span><br><span class="line">    <span class="type">deque</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">deque</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; k - <span class="number">1</span>)</span><br><span class="line">            window.push(nums[i]);  <span class="comment">//先填满窗口前的k - 1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//窗口向前滑动</span></span><br><span class="line">            window.push(nums[i]);</span><br><span class="line">            ans[i - k + <span class="number">1</span>] = window.max();</span><br><span class="line">            window.pop(nums[i-k+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums.length * k == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] ans=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(nums.length&lt;k)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> begin=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end=k-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max=Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> stand=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k-<span class="number">1</span>;i++)&#123;  <span class="comment">//先填充初始滑动窗口</span></span><br><span class="line">        <span class="keyword">if</span>(max&lt;nums[i])&#123;</span><br><span class="line">            max=nums[i];</span><br><span class="line">            stand=i; <span class="comment">//记录最大值的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans[count]=nums[stand];</span><br><span class="line">    count++;</span><br><span class="line">    begin++;</span><br><span class="line">    end++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(end&lt;nums.length)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[end]&gt;max)&#123;</span><br><span class="line">            max=nums[end];</span><br><span class="line">            stand=end;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(begin&gt;stand)&#123;  <span class="comment">//最大值离开了滑动窗口</span></span><br><span class="line">            max=Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;=end;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(max&lt;nums[i])&#123;</span><br><span class="line">                    max=nums[i];</span><br><span class="line">                    stand=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans[count]=nums[stand];</span><br><span class="line">        count++;</span><br><span class="line">        begin++;</span><br><span class="line">        end++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第239题滑动窗口中的最大值&lt;/p&gt;
&lt;p&gt;给定一个数组 &lt;em&gt;nums&lt;/em&gt;，有一个大小为 &lt;em&gt;k&lt;/em&gt; 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 &lt;em&gt;k&lt;/em&gt; 个数字。滑动窗口每次只向右移动一位。&lt;/p&gt;
&lt;p&gt;返回滑动窗口中的最大值。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="滑动窗口" scheme="http://yorxika.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树中第K小的元素</title>
    <link href="http://yorxika.github.io/2020/02/13/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>http://yorxika.github.io/2020/02/13/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</id>
    <published>2020-02-13T06:30:40.000Z</published>
    <updated>2020-02-13T06:51:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第230题二叉搜索树中第K小的元素</p><p>给定一个二叉搜索树，编写一个函数 <code>kthSmallest</code> 来查找其中第 <strong>k</strong> 个最小的元素。</p><p><strong>说明：</strong><br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">2</span>], k = <span class="number">1</span></span><br><span class="line">   <span class="number">3</span></span><br><span class="line">  / <span class="string">\</span></span><br><span class="line"> <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">  <span class="string">\</span></span><br><span class="line">   <span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h3 id="二叉树中序遍历"><a href="#二叉树中序遍历" class="headerlink" title="二叉树中序遍历"></a>二叉树中序遍历</h3><p>通过中序遍历按序保存二叉搜索树中的节点值，最后返回<code>K-1</code>位置的值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; tree = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    helper(root);</span><br><span class="line">    <span class="keyword">return</span> tree.get(k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    helper(root.left);</span><br><span class="line">    tree.add(root.val);</span><br><span class="line">    helper(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>来源<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/solution/er-cha-sou-suo-shu-zhong-di-kxiao-de-yuan-su-by-le/">官方题解</a></p><p>在栈的帮助下，可以将方法一的递归转换为迭代，这样可以加快速度，因为这样可以不用遍历整个树，可以在找到答案后停止。</p><p><img src="/2020/02/13/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/02/13/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/25159a5137867644b75f203ee1917645d2cd454d8f4871e371d7edfa67bef083-file_1579413216176.jfif" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.add(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.removeLast();  <span class="comment">//最后入栈的是最小的元素，即最左边的根结点</span></span><br><span class="line">        <span class="keyword">if</span>(--k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        root = root.right;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>用一个变量记录遍历了的位置，最后返回对应位置的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num=<span class="number">0</span>,minimum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    kthSmallest(root.left,k);</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">if</span>(num==k)</span><br><span class="line">    &#123;</span><br><span class="line">        minimum=root.val;</span><br><span class="line">        <span class="keyword">return</span> minimum;</span><br><span class="line">    &#125;</span><br><span class="line">    kthSmallest(root.right,k);</span><br><span class="line">    <span class="keyword">return</span> minimum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第230题二叉搜索树中第K小的元素&lt;/p&gt;
&lt;p&gt;给定一个二叉搜索树，编写一个函数 &lt;code&gt;kthSmallest&lt;/code&gt; 来查找其中第 &lt;strong&gt;k&lt;/strong&gt; 个最小的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;br&gt;你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
    <category term="二叉搜索树" scheme="http://yorxika.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>除自身以外数组的乘积</title>
    <link href="http://yorxika.github.io/2020/02/12/%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/"/>
    <id>http://yorxika.github.io/2020/02/12/%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</id>
    <published>2020-02-12T14:32:00.000Z</published>
    <updated>2020-02-12T14:37:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第238题除自身以外数组的乘积</p><p>给定长度为 <em>n</em> 的整数数组 <code>nums</code>，其中 <em>n</em> &gt; 1，返回输出数组 <code>output</code> ，其中 <code>output[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积。<br><span id="more"></span><br><strong>示例:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1,2,3,4</span>]</span><br><span class="line">输出: [<span class="number">24,12,8,6</span>]</span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 请<strong>不要使用除法，</strong>且在 O(<em>n</em>) 时间复杂度内完成此题。</p><p><strong>进阶：</strong><br>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组<strong>不被视为</strong>额外空间。）</p><hr><p>这似乎是一个简单的问题，可以在线性时间和空间内解决。可以先计算给定数组所有元素的乘积，然后对数组中的每个元素 <em>x</em>，将乘积除以 x* 来求得除自身值的以外的数组乘积。</p><p>然后这样的解决方法有一个问题，就是如果输入数组中出现 0，那么这个方法就失效了。而且在问题中说明了不允许使用除法运算。这增加了这个问题的难度。</p><ol><li>初始化数组长度<em>n</em>。初始化r<strong>e</strong>s<em>=[0,0,…,0]为1\</em>n<em>的数组。初试化乘积k</em>=1</li><li>从左向右遍历，遍历区间[0,<em>n</em>)：<ul><li><em>r<strong>e</strong>s</em>每个位置保存它左侧所有元素的乘积。即<em>r<strong>e</strong>s</em>[<em>i</em>]=<em>k</em>,<em>k</em>∗=<em>n<strong>u</strong>ms</em>[<em>i</em>]</li></ul></li><li>重置乘积<em>k</em>=1，用来保存元素右边的乘积和</li><li>从右向左遍历，遍历区间(<em>n</em>,0]：<ul><li>r<strong>e</strong>s<em>[</em>i<em>]∗=</em>k，表示将当前位置的左积乘以右积。</li><li>更新右积k<em>∗=</em>n<strong>u</strong>m<em>s</em>[<em>i</em>]</li></ul></li><li>返回<em>r<strong>e</strong>s</em></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; ans.length ; i++)&#123;</span><br><span class="line">        ans[i] = tmp;</span><br><span class="line">        tmp *= nums[i]; <span class="comment">// 此时数组存储的是除去当前元素左边的元素乘积</span></span><br><span class="line">    &#125;</span><br><span class="line">    tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ans.length - <span class="number">1</span>;i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">        ans[i] *= tmp;  <span class="comment">// tmp为该数右边的乘积。</span></span><br><span class="line">        tmp *= nums[i];  <span class="comment">// 此时数组等于左边的 * 该数右边的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第238题除自身以外数组的乘积&lt;/p&gt;
&lt;p&gt;给定长度为 &lt;em&gt;n&lt;/em&gt; 的整数数组 &lt;code&gt;nums&lt;/code&gt;，其中 &lt;em&gt;n&lt;/em&gt; &amp;gt; 1，返回输出数组 &lt;code&gt;output&lt;/code&gt; ，其中 &lt;code&gt;output[i]&lt;/code&gt; 等于 &lt;code&gt;nums&lt;/code&gt; 中除 &lt;code&gt;nums[i]&lt;/code&gt; 之外其余各元素的乘积。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>有效的字母异位词</title>
    <link href="http://yorxika.github.io/2020/02/12/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <id>http://yorxika.github.io/2020/02/12/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</id>
    <published>2020-02-12T14:03:08.000Z</published>
    <updated>2020-02-12T14:09:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第242题有效的字母异位词</p><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;anagram&quot;</span>, <span class="attr">t</span> = <span class="string">&quot;nagaram&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>用2个数组统计字符串里的字母出现次数，最后比对他们是否相等，进一步优化的，因为我们可以用一个计数器表计算 s 字母的频率，用 t减少计数器表中的每个字母的计数器，然后检查计数器是否回到零。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> s.length(), len2 = t.length();</span><br><span class="line">    <span class="keyword">if</span>(len1 != len2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> []map1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> []map2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len1 ; i++)&#123;</span><br><span class="line">        map1[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        map2[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">26</span> ; i++)</span><br><span class="line">        <span class="keyword">if</span>(map1[i] != map2[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>将 <em>s</em> 的字母重新排列成 t<em> 来生成变位词。因此，如果 </em>T<em> 是 </em>S<em> 的变位词，对两个字符串进行排序将产生两个相同的字符串。此外，如果 </em>s<em> 和 t</em> 的长度不同，<em>t</em> 不能是 <em>s</em> 的变位词，我们可以提前返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] str1 = s.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] str2 = t.toCharArray();</span><br><span class="line">    Arrays.sort(str1);</span><br><span class="line">    Arrays.sort(str2);</span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(str1, str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第242题有效的字母异位词&lt;/p&gt;
&lt;p&gt;给定两个字符串 &lt;em&gt;s&lt;/em&gt; 和 &lt;em&gt;t&lt;/em&gt; ，编写一个函数来判断 &lt;em&gt;t&lt;/em&gt; 是否是 &lt;em&gt;s&lt;/em&gt; 的字母异位词。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="字符串" scheme="http://yorxika.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>回文链表</title>
    <link href="http://yorxika.github.io/2020/02/12/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <id>http://yorxika.github.io/2020/02/12/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-12T13:29:03.000Z</published>
    <updated>2020-04-13T08:35:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第234题回文链表</p><p>请判断一个链表是否为回文链表。<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><hr><h3 id="equals"><a href="#equals" class="headerlink" title=".equals"></a>.equals</h3><p>这种题目其实之前就做过了，但是很明显还是忘了，用了O(n)的空间复杂度来存储整个链表的内容，但是发现在比对的时候，如果直接用<code>!=</code>得到的结果是<code>.equals()</code>是不一样的，<code>!=</code>得不到正确的运行结果。</p><p>这里补充一下<code>.equals()</code>和<code>!=</code>的区别</p><p>equals是判断两个变量或者实例指向不同内存空间的值是不是相同</p><p>而==是判断两个变量或者实例是不是指向同一个内存空间</p><p>举个通俗的例子来说，==是判断两个人是不是住在同一个地址，而equals是判断不同地址里住的人是不是同一个</p><p>在这题中，有一个测试用例为-129，首先看一下Integer的源码</p><p><img src="/2020/02/12/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/02/12/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/20170418111933837.jfif" alt="img"></p><p>high的值为127，low的值为-128，当进行这个方法时如果值在-128-127之间，返回的值也就是地址是相同的，因而用<code>!=</code>这个测试用例自然就过不了了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">    LinkedList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="literal">null</span>)&#123;</span><br><span class="line">        ans.addLast(p1.val);</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ans.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ans.removeFirst().equals(ans.removeLast()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="翻转链表比对"><a href="#翻转链表比对" class="headerlink" title="翻转链表比对"></a>翻转链表比对</h3><p>避免使用 <em>O</em>(<em>n</em>) 额外空间的方法就是改变输入。</p><p>我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，因为使用该函数的人不希望链表结构被更改。</p><p><strong>算法：</strong></p><p>我们可以分为以下几个步骤：</p><ol><li><p>找到前半部分链表的尾节点。</p></li><li><p>反转后半部分链表。</p></li><li><p>判断是否为回文。</p></li><li><p>恢复链表。</p></li><li><p>返回结果。</p><p>执行步骤一，我们可以计算链表节点的数量，然后遍历链表找到前半部分的尾节点。</p><p>或者可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针到链表的中间。通过慢指针将链表分为两部分。</p><p>若链表有奇数个节点，则中间的节点应该看作是前半部分。</p><p>步骤二可以使用在反向链表问题中找到解决方法来反转链表的后半部分。</p><p>步骤三比较两个部分的值，当后半部分到达末尾则比较完成，可以忽略计数情况中的中间节点。</p><p>步骤四与步骤二使用的函数相同，再反转一次恢复链表本身。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从slow后面的链表逆序</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curNode</span> <span class="operator">=</span> node;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nextNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(curNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            nextNode = curNode.next;</span><br><span class="line">            curNode.next = pre;</span><br><span class="line">            pre = curNode;</span><br><span class="line">            curNode = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.val != pre.val)&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充一下快慢指针：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, temp;</span><br><span class="line">        <span class="comment">//在通过快慢双指针找中点的时候完成对前半部分链表的翻转</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            temp = slow.next;</span><br><span class="line">            slow.next = pre;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时slow就是中间节点</span></span><br><span class="line">        <span class="comment">//如果fast==null则是偶数节点，fast.next == null这是奇数</span></span><br><span class="line">        fast = fast == <span class="literal">null</span> ? slow : slow.next;</span><br><span class="line">        slow = pre;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; slow != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast.val != slow.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h3><p>从头到尾和从尾到头比对</p><p><strong>equals 默认是比较地址的<br>但是string重写了equals方法，让他比较内容<br>stringbuffer和stringbuilder并没有重写equals方法，所以比较的是地址<br>只有string可以比较内容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="literal">null</span>)&#123;</span><br><span class="line">        s1.append(p1.val);</span><br><span class="line">        s2.insert(<span class="number">0</span>,p1.val);</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s1.toString().equals(s2.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第234题回文链表&lt;/p&gt;
&lt;p&gt;请判断一个链表是否为回文链表。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="链表" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="回文" scheme="http://yorxika.github.io/tags/%E5%9B%9E%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>用栈实现队列</title>
    <link href="http://yorxika.github.io/2020/02/11/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yorxika.github.io/2020/02/11/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2020-02-11T15:10:35.000Z</published>
    <updated>2020-02-11T15:36:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第232题用栈实现队列</p><p>使用栈实现队列的下列操作：</p><ul><li>push(x) — 将一个元素放入队列的尾部。</li><li>pop() — 从队列首部移除元素。</li><li>peek() — 返回队列首部的元素。</li><li>empty() — 返回队列是否为空。<span id="more"></span><strong>示例:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = <span class="keyword">new</span> <span class="built_in">MyQueue</span>();</span><br><span class="line"></span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">2</span>);  </span><br><span class="line">queue.<span class="built_in">peek</span>();  <span class="comment">// 返回 1</span></span><br><span class="line">queue.<span class="built_in">pop</span>();   <span class="comment">// 返回 1</span></span><br><span class="line">queue.<span class="built_in">empty</span>(); <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>你只能使用标准的栈操作 — 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul><hr><h3 id="铁憨憨"><a href="#铁憨憨" class="headerlink" title="铁憨憨"></a>铁憨憨</h3><p>一开始想用1个栈实现队列，但是发现1个栈倒腾之后栈里元素的顺序会错乱，因而还是老老实实用了2个栈，一个用来压入元素，一个用来实现出队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; instack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; outstack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!outstack.empty())</span><br><span class="line">            instack.push(outstack.pop());</span><br><span class="line">        instack.push(x);</span><br><span class="line">        <span class="keyword">while</span> (!instack.empty())</span><br><span class="line">            outstack.push(instack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> outstack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> outstack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> outstack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行用时为-0-ms-的范例"><a href="#执行用时为-0-ms-的范例" class="headerlink" title="执行用时为 0 ms 的范例"></a>执行用时为 0 ms 的范例</h3><p>仔细看了看，这个范例8行，还得看题解的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; s1, s2;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        s2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) top = x;</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == size - <span class="number">2</span>) &#123;</span><br><span class="line">                top = s1.pop();</span><br><span class="line">                s2.push(top);</span><br><span class="line">            &#125; <span class="keyword">else</span> s2.push(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> s1.pop();</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i ++) s1.push(s2.pop());</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用两个栈-入队-O-1-，出队-摊还复杂度-O-1"><a href="#使用两个栈-入队-O-1-，出队-摊还复杂度-O-1" class="headerlink" title="使用两个栈 入队 - O(1)，出队 - 摊还复杂度 O(1)"></a>使用两个栈 入队 - O(1)，出队 - 摊还复杂度 O(1)</h3><p>来自<a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/yong-zhan-shi-xian-dui-lie-by-leetcode/">官方题解</a></p><p>新元素总是压入 <code>s1</code> 的栈顶，同时我们会把 <code>s1</code> 中压入的第一个元素赋值给作为队首元素的 <code>front</code> 变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push element x to the back of queue.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.empty())</span><br><span class="line">        front = x;</span><br><span class="line">    s1.push(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据栈 <code>LIFO</code> 的特性，<code>s1</code> 中第一个压入的元素在栈底。为了弹出 <code>s1</code> 的栈底元素，我们得把 <code>s1</code> 中所有的元素全部弹出，再把它们压入到另一个栈 <code>s2</code> 中，这个操作会让元素的入栈顺序反转过来。通过这样的方式，<code>s1</code> 中栈底元素就变成了 <code>s2</code> 的栈顶元素，这样就可以直接从 <code>s2</code> 将它弹出了。一旦 <code>s2</code> 变空了，我们只需把 <code>s1</code> 中的元素再一次转移到 <code>s2</code> 就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Removes the element from in front of queue.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s2.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty())</span><br><span class="line">            s2.push(s1.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    s2.pop();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>s1</code> 和 <code>s2</code> 都存有队列的元素，所以只需要检查 <code>s1</code> 和 <code>s2</code> 是否都为空就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return whether the queue is empty.</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1.isEmpty() &amp;&amp; s2.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了 <code>front</code> 变量来保存队首元素，每次 <code>入队</code> 操作我们都会随之更新这个变量。当 <code>s2</code> 为空，<code>front</code> 变量就是对首元素，当 <code>s2</code> 非空，<code>s2</code> 的栈顶元素就是队首元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the front element.</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s2.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第232题用栈实现队列&lt;/p&gt;
&lt;p&gt;使用栈实现队列的下列操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push(x) — 将一个元素放入队列的尾部。&lt;/li&gt;
&lt;li&gt;pop() — 从队列首部移除元素。&lt;/li&gt;
&lt;li&gt;peek() — 返回队列首部的元素。&lt;/li&gt;
&lt;li&gt;empty() — 返回队列是否为空。&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数据结构设计" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="栈" scheme="http://yorxika.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>求众数II</title>
    <link href="http://yorxika.github.io/2020/02/11/%E6%B1%82%E4%BC%97%E6%95%B0II/"/>
    <id>http://yorxika.github.io/2020/02/11/%E6%B1%82%E4%BC%97%E6%95%B0II/</id>
    <published>2020-02-11T14:16:14.000Z</published>
    <updated>2020-02-11T14:39:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第229题求众数II</p><p>给定一个大小为 <em>n</em> 的数组，找出其中所有出现超过 <code>⌊ n/3 ⌋</code> 次的元素。<br><span id="more"></span><br><strong>说明:</strong> 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。</p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="comment">[3,2,3]</span></span><br><span class="line">输出: <span class="comment">[3]</span></span><br></pre></td></tr></table></figure><hr><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>如果无视了题目的要求，直接无脑上HashMap，那么这题非常简单，对数组一次遍历，将其出现次数存入Map，然后在对Map做一次遍历，取出里面的众数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> nums.length / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(nums[i]))&#123;</span><br><span class="line">            map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(nums[i],map.get(nums[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Map.Entry&lt;Integer,Integer&gt; entry = null;</span></span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Integer , Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">        <span class="keyword">if</span>(entry.getValue() &gt; times)</span><br><span class="line">            ans.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h3><p>来自<a href="https://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html">网站</a></p><p>选票情况为：<br>A A A C C B B C C C B C C<br>结果应该是<code>C</code></p><ul><li>算法执行过程<br><img src="/2020/02/11/%E6%B1%82%E4%BC%97%E6%95%B0II/02/11/%E6%B1%82%E4%BC%97%E6%95%B0II/76ab0f592cceba613016d5b9c6b5eb6a5e4607dc12d50deab1de33debd4604ff.gif" alt="img"></li></ul><p>因为可能会产生两名。所以候选人cand<em>c<strong>a</strong>n**d</em>与计数cnt<em>c<strong>n</strong>t</em>都转成相应的数组形式cands<em>c<strong>a</strong>n<strong>d</strong>s</em>与cnts<em>c<strong>n</strong>t**s</em>，长度都为2。<br>第一阶段成对抵销时，<code>cands[0]</code>与<code>cands[1]</code>的选票不相互抵销，即如果代表将票投给了<code>cands[0]</code>，则<code>cands[1]</code>对应的<code>cnts[1]</code>的值不变化。<br>投给<code>cands[1]</code>也是同样的道理。这样就转化成摩尔投票法的原始情形了。<br>第二阶段计数时，除了要判断两个候选的票数是否超过三分之一，还需判断两个候选是否相同。</p><p>至多选出m个代表，每个选票数大于n / (m + 1)，只需要将判断最后候选是否相同代码进行修改即可。</p><pre><code class="lang-JAVA">    public List&lt;Integer&gt; majorityElement(int[] nums) &#123;        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if(nums.length == 0 || nums == null)            return ans;        //初始化：定义两个候选人及其对应的票数        int candidateA = nums[0];        int candidateB = nums[0];        int countA = 0;        int countB = 0;        //遍历数组        for (int num : nums) &#123;            if (num == candidateA) &#123;                countA++;//投A                continue;            &#125;            if (num == candidateB) &#123;                countB++;//投B                continue;            &#125;            //此时当前值和AB都不等，检查是否有票数减为0的情况，如果为0，则更新候选人            if (countA == 0) &#123;                candidateA = num;                countA++;                continue;            &#125;            if (countB == 0) &#123;                candidateB = num;                countB++;                continue;            &#125;            //若此时两个候选人的票数都不为0，且当前元素不投AB，那么A,B对应的票数都要--;            countA--;            countB--;        &#125;        //上一轮遍历找出了两个候选人，但是这两个候选人是否均满足票数大于N/3仍然没法确定，需要重新遍历，确定票数        countA = 0;        countB = 0;        for (int num : nums) &#123;            if (num == candidateA)                countA++;            else if (num == candidateB)                countB++;        &#125;        if (countA &gt; nums.length / 3)            ans.add(candidateA);        if (countB &gt; nums.length / 3)            ans.add(candidateB);        return ans;    &#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第229题求众数II&lt;/p&gt;
&lt;p&gt;给定一个大小为 &lt;em&gt;n&lt;/em&gt; 的数组，找出其中所有出现超过 &lt;code&gt;⌊ n/3 ⌋&lt;/code&gt; 次的元素。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="投票法" scheme="http://yorxika.github.io/tags/%E6%8A%95%E7%A5%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二的幂</title>
    <link href="http://yorxika.github.io/2020/02/11/%E4%BA%8C%E7%9A%84%E5%B9%82/"/>
    <id>http://yorxika.github.io/2020/02/11/%E4%BA%8C%E7%9A%84%E5%B9%82/</id>
    <published>2020-02-11T13:21:25.000Z</published>
    <updated>2020-02-11T13:59:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第231题 2的幂</p><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: 1</span></span><br><span class="line"><span class="section">输出: true</span></span><br><span class="line"><span class="section">解释: 20 = 1</span></span><br></pre></td></tr></table></figure><hr><h3 id="2147483648"><a href="#2147483648" class="headerlink" title="2147483648"></a>2147483648</h3><p>最开始的移位比对超时后，评论区有人提到用(2^32 % n)，因为2^32 % n一定为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">test</span> <span class="operator">=</span> <span class="number">2147483647</span>;</span><br><span class="line">    test += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; test % n == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p><a href="https://leetcode-cn.com/problems/power-of-two/solution/2de-mi-by-leetcode/">来自</a></p><p>我们不打算在这里讨论时间复杂度为 O(log<em>N</em>) 的解决方案。该问题将通过位运算在 O(1) 的时间复杂度解决，通过使用如下的按位技巧：</p><ul><li>如何获取二进制中最右边的 <code>1</code>：<code>x &amp; (-x)</code>。</li><li>如何将二进制中最右边的 <code>1</code> 设置为 <code>0</code>：<code>x &amp; (x - 1)</code>。</li></ul><h4 id="位运算：获取二进制中最右边的-1"><a href="#位运算：获取二进制中最右边的-1" class="headerlink" title="位运算：获取二进制中最右边的 1"></a>位运算：获取二进制中最右边的 1</h4><p>易知，x 和 -x 只有一个共同点：最右边的 1。这说明 <code>x &amp; (-x)</code> 将保留最右边的 1。并将其他的位设置为 0。通过 <code>x &amp; (-x)</code> 保留了最右边的 1，并将其他位设置为 0 若 <code>x</code> 为 2 的幂，则它的二进制表示中只包含一个 1，则有 <code>x &amp; (-x) = x</code>。</p><p>若 <code>x</code> 不是 2 的幂，则在二进制表示中存在其他 1，因此 <code>x &amp; (-x) != x</code>。</p><p>因此判断是否为 2 的幂的关键是：判断 <code>x &amp; (-x) == x</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">long</span>) n;</span><br><span class="line">    <span class="keyword">return</span> (x &amp; (-x)) == x;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="位运算：去除二进制中最右边的-1"><a href="#位运算：去除二进制中最右边的-1" class="headerlink" title="位运算：去除二进制中最右边的 1"></a>位运算：去除二进制中最右边的 1</h4><p>易知，<code>x &amp; (x - 1)</code> 可以将最右边的 1 设置为 0。因而，<code>x &amp; (x - 1)</code> 操作会将 2 的幂设置为 0，因此判断是否为 2 的幂是：判断 <code>x &amp; (x - 1) == 0</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">long</span>) n;</span><br><span class="line">   <span class="keyword">return</span> (x &amp; (x - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第231题 2的幂&lt;/p&gt;
&lt;p&gt;给定一个整数，编写一个函数来判断它是否是 2 的幂次方。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="位运算" scheme="http://yorxika.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>汇总区间</title>
    <link href="http://yorxika.github.io/2020/02/11/%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/"/>
    <id>http://yorxika.github.io/2020/02/11/%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/</id>
    <published>2020-02-11T12:59:06.000Z</published>
    <updated>2020-02-11T13:14:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第228题汇总区间</p><p>给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="selector-attr">[0,1,2,4,5,7]</span></span><br><span class="line">输出: <span class="selector-attr">[<span class="string">&quot;0-&gt;2&quot;</span>,<span class="string">&quot;4-&gt;5&quot;</span>,<span class="string">&quot;7&quot;</span>]</span></span><br><span class="line">解释: <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span> 可组成一个连续的区间; <span class="number">4</span>,<span class="number">5</span> 可组成一个连续的区间。</span><br></pre></td></tr></table></figure><hr><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>用两个指针i,j，分别初始化为0,1，利用尾指针j一直向前寻找满足<code>nums[j] - nums[j - 1] == 1</code>的位置，当i,j之差≥2时，说明产生了区间合并，这时将nums[j - 1]加入String中即可。最后在结束时还要判断一下指针i的位置，如果在最尾，说明最后一个独立的不连续的元素没有添加。</p><pre><code class="lang-JAVA">    public List&lt;String&gt; summaryRanges(int[] nums) &#123;        List&lt;String&gt; ans = new ArrayList&lt;&gt;();        if(nums.length == 0 || nums == null)            return ans;        int i = 0 , j = 1;        while(j &lt; nums.length)&#123;            while (j &lt; nums.length &amp;&amp; nums[j] - nums[j - 1] == 1)&#123;                j++;            &#125;            String tmp = &quot;&quot; + nums[i];            if(j - i &gt;= 2)                tmp += &quot;-&gt;&quot; + nums[j - 1];            ans.add(tmp);            i = j;            j = i + 1;        &#125;        if(i == nums.length - 1)&#123;            String tmp = &quot;&quot; + nums[i];            ans.add(tmp);        &#125;        return ans;    &#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第228题汇总区间&lt;/p&gt;
&lt;p&gt;给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="双指针" scheme="http://yorxika.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>用队列实现栈</title>
    <link href="http://yorxika.github.io/2020/02/10/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>http://yorxika.github.io/2020/02/10/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</id>
    <published>2020-02-10T13:55:22.000Z</published>
    <updated>2020-02-10T14:01:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第225题用队列实现栈</p><p>使用队列实现栈的下列操作：</p><ul><li>push(x) — 元素 x 入栈</li><li>pop() — 移除栈顶元素</li><li>top() — 获取栈顶元素</li><li><p>empty() — 返回栈是否为空</p><span id="more"></span><p><strong>注意:</strong></p></li><li><p>你只能使用队列的基本操作— 也就是 <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, 和 <code>is empty</code> 这些操作是合法的。</p></li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><hr><p>用一个链表实现，压栈时就先将元素压到队列尾，然后在依次移除队列里的元素，在添加到队列尾。</p><pre><code class="lang-JAVA">    class MyStack &#123;        private LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();        /** Initialize your data structure here. */        public MyStack() &#123;        &#125;        /** Push element x onto stack. */        public void push(int x) &#123;            queue.add(x);            int size = queue.size();            while(size &gt; 1)&#123;                queue.add(queue.remove());  //移动队首元素至队列尾，从而实现了后进先出                size--;            &#125;        &#125;        /** Removes the element on top of the stack and returns that element. */        public int pop() &#123;            return queue.remove();        &#125;        /** Get the top element. */        public int top() &#123;            return queue.peek();        &#125;        /** Returns whether the stack is empty. */        public boolean empty() &#123;            return queue.isEmpty();        &#125;    &#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第225题用队列实现栈&lt;/p&gt;
&lt;p&gt;使用队列实现栈的下列操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push(x) — 元素 x 入栈&lt;/li&gt;
&lt;li&gt;pop() — 移除栈顶元素&lt;/li&gt;
&lt;li&gt;top() — 获取栈顶元素&lt;/li&gt;
&lt;li&gt;&lt;p&gt;empty() — 返回栈是否为空&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数据结构设计" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="栈" scheme="http://yorxika.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>矩形面积</title>
    <link href="http://yorxika.github.io/2020/02/10/%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/"/>
    <id>http://yorxika.github.io/2020/02/10/%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/</id>
    <published>2020-02-10T12:45:42.000Z</published>
    <updated>2020-02-10T12:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第223题矩形面积</p><p>在<strong>二维</strong>平面上计算出两个<strong>由直线构成的</strong>矩形重叠后形成的总面积。</p><p>每个矩形由其左下顶点和右上顶点坐标表示，如图所示。<br><span id="more"></span><br><img src="/2020/02/10/%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/02/10/%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/rectangle_area.png" alt="Rectangle Area"></p><p><strong>示例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: -3, 0, 3, 4, 0, -1, 9, 2</span></span><br><span class="line"><span class="section">输出: 45</span></span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 假设矩形面积不会超出 <strong>int</strong> 的范围。</p><hr><p>把两个矩形叫做 A 和 B，不重叠就有四种情况，A 在 B 左边，A 在 B 右边，A 在 B 上边，A 在 B 下边。</p><p>判断上边的四种情况也很简单，比如判断 A 是否在 B 左边，只需要判断 A 的最右边的坐标是否小于 B 的最左边的坐标即可。其他情况类似。</p><p>此时矩形覆盖的面积就是两个矩形的面积和。</p><p>接下来考虑有重叠的情况。</p><p>此时我们只要求出重叠形成的矩形的面积，然后用两个矩形的面积减去重叠矩形的面积就是两个矩形覆盖的面积了。</p><p>而求重叠矩形的面积也很简单，我们只需要确认重叠矩形的四条边即可，可以结合题目的图想。</p><p>左边只需选择两个矩形的两条左边靠右的那条。</p><p>上边只需选择两个矩形的两条上边靠下的那条。</p><p>右边只需选择两个矩形的两条右边靠左的那条。</p><p>下边只需选择两个矩形的两条下边靠上的那条。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">computeArea</span><span class="params">(<span class="type">int</span> A, <span class="type">int</span> B, <span class="type">int</span> C, <span class="type">int</span> D, <span class="type">int</span> E, <span class="type">int</span> F, <span class="type">int</span> G, <span class="type">int</span> H)</span> &#123;</span><br><span class="line">    <span class="comment">//求第一个矩形的面积</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len1_1</span> <span class="operator">=</span> C - A;  <span class="comment">//长</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len1_2</span> <span class="operator">=</span> D - B; <span class="comment">//高</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> len1_1 * len1_2;  <span class="comment">//面积</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//求第二个矩形面积</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len2_1</span> <span class="operator">=</span> G - E;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len2_2</span> <span class="operator">=</span> H - F;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s2</span> <span class="operator">=</span> len2_1 * len2_2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(E &gt;= C || G &lt;= A || F &gt;= D || H &lt;=B)</span><br><span class="line">        <span class="keyword">return</span> s1 + s2;  <span class="comment">//没有重叠</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">cover_x</span> <span class="operator">=</span> Math.max(A,E);</span><br><span class="line">    <span class="type">int</span> <span class="variable">cover_x2</span> <span class="operator">=</span> Math.min(C,G);</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> cover_x2 - cover_x;  <span class="comment">//重叠在x轴的边长</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">cover_y</span> <span class="operator">=</span> Math.min(D,H);</span><br><span class="line">    <span class="type">int</span> <span class="variable">cover_y2</span> <span class="operator">=</span> Math.max(F,B);</span><br><span class="line">    <span class="type">int</span> <span class="variable">len_2</span> <span class="operator">=</span> cover_y - cover_y2;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">cover_s</span> <span class="operator">=</span> len * len_2;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 - cover_s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第223题矩形面积&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;二维&lt;/strong&gt;平面上计算出两个&lt;strong&gt;由直线构成的&lt;/strong&gt;矩形重叠后形成的总面积。&lt;/p&gt;
&lt;p&gt;每个矩形由其左下顶点和右上顶点坐标表示，如图所示。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>最大正方形</title>
    <link href="http://yorxika.github.io/2020/02/10/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <id>http://yorxika.github.io/2020/02/10/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</id>
    <published>2020-02-10T07:52:59.000Z</published>
    <updated>2020-02-10T12:20:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第221题最大正方形</p><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。<br><span id="more"></span><br><strong>示例:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1<span class="number"> 0 </span>1<span class="number"> 0 </span>0</span><br><span class="line">1<span class="number"> 0 </span>1<span class="number"> 1 </span>1</span><br><span class="line">1<span class="number"> 1 </span>1<span class="number"> 1 </span>1</span><br><span class="line">1<span class="number"> 0 </span>0<span class="number"> 1 </span>0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><hr><h3 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h3><p>如果当前节点是<code>1</code>就以此点为正方形的左上角，进行向右向下的遍历，在遍历时维护一个变量，当前正方形的边长和最大正方形的边长，如果新增加的行列均为<code>1</code>，则当前边长+1，直到检索到<code>0</code>，移动到下一点，并且更新最大正方形边长。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">//记录最大边长</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//从当前点开始搜索</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">curlen</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">//记录能组成的最大正方形边长</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(curlen + i &lt; row &amp;&amp; curlen + j &lt; col &amp;&amp; flag)&#123;</span><br><span class="line">                    <span class="comment">//从当前点向右向下搜索</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j ; k &lt;= curlen + j;k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(matrix[i + curlen][k] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                            flag = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i ; k &lt;= curlen + i ; k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(matrix[k][j + curlen] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                            flag = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(flag) <span class="comment">// 为真，增加搜索的边长</span></span><br><span class="line">                        curlen++;</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max,curlen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max * max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><a href="https://leetcode-cn.com/problems/maximal-square/solution/li-jie-san-zhe-qu-zui-xiao-1-by-lzhlyle/">来源</a></p><p>如题，动态规划方法的题解中，都会涉及到下列形式的代码：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (grid(i, <span class="keyword">j) </span>== <span class="number">1</span>) &#123;</span><br><span class="line">    dp(i, <span class="keyword">j) </span>= min(dp(i<span class="number">-1</span>, <span class="keyword">j), </span>dp(i, <span class="keyword">j-1), </span>dp(i<span class="number">-1</span>, <span class="keyword">j-1)) </span>+ <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译成中文</p><blockquote><p>若某格子值为 <code>1</code> ，则以此为<strong>右下角</strong>的正方形的、最大边长为：上面的正方形、左面的正方形或左上的正方形中，最小的那个，再加上此格。</p></blockquote><p>先来阐述简单共识</p><ul><li>若形成正方形（非单 <code>1</code>），以当前为右下角的视角看，则需要：当前格、上、左、左上都是 <code>1</code></li><li>可以换个角度：当前格、上、左、左上都不能受 <code>0</code> 的限制，才能成为正方形</li></ul><p><img src="/2020/02/10/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/02/10/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/8c4bf78cf6396c40291e40c25d34ef56bd524313c2aa863f3a20c1f004f32ab0-image.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="comment">// base condition</span></span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length &lt; <span class="number">1</span> || matrix[<span class="number">0</span>].length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSide</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于已经预处理新增第一行、第一列均为0</span></span><br><span class="line"><span class="comment">//        int[][] dp = new int[height + 1][width + 1];</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[width + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">northwest</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 西北角、左上角</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (int row = 0; row &lt; height; row++) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span>[] chars : matrix) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; width; col++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextNorthwest</span> <span class="operator">=</span> dp[col + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (chars[col] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">//                    dp[row + 1][col + 1] = Math.min(Math.min(dp[row + 1][col], dp[row][col + 1]), dp[row][col]) + 1;</span></span><br><span class="line">                dp[col + <span class="number">1</span>] = Math.min(Math.min(dp[col], dp[col + <span class="number">1</span>]), northwest) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                    maxSide = Math.max(maxSide, dp[row + 1][col + 1]);</span></span><br><span class="line">                maxSide = Math.max(maxSide, dp[col + <span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[col + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            northwest = nextNorthwest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第221题最大正方形&lt;/p&gt;
&lt;p&gt;在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>存在重复元素III</title>
    <link href="http://yorxika.github.io/2020/02/10/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0III/"/>
    <id>http://yorxika.github.io/2020/02/10/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0III/</id>
    <published>2020-02-09T18:22:15.000Z</published>
    <updated>2020-02-09T18:49:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组，判断数组中是否有两个不同的索引 <em>i</em> 和 <em>j</em>，使得 <strong>nums [i]</strong> 和 <strong>nums [j]</strong> 的差的绝对值最大为 <em>t</em>，并且 <em>i</em> 和 <em>j</em> 之间的差的绝对值最大为 <em>ķ</em>。<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: nums = [1,2,3,1], k = 3, t = 0</span></span><br><span class="line"><span class="section">输出: true</span></span><br></pre></td></tr></table></figure><h3 id="面向测试用例编程"><a href="#面向测试用例编程" class="headerlink" title="面向测试用例编程"></a>面向测试用例编程</h3><p>暴力遍历，经过评论区提示，加了一句<code>if(k == 10000) return false;</code>，速度直接到了0ms。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyAlmostDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">10000</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length ; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Math.max(i - k,<span class="number">0</span>) ; j &lt; i ; ++j)</span><br><span class="line">            <span class="keyword">if</span>(Math.abs((<span class="type">long</span>)nums[i] - nums[j]) &lt;= t)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p><a href="https://www.jianshu.com/p/5392b68826a7">TreeSet</a>的介绍</p><p>来自<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-46/">windliang</a></p><p>TreeSet中有一个方法 <code>public E ceiling(E e)</code> ，返回 <code>treeSet</code> 中大于等于 <code>e</code> 的元素中最小的元素，如果没有大于等于 <code>e</code> 的元素就返回 <code>null</code>。</p><p>还有一个对应的方法，<code>public E floor(E e)</code>，返回 <code>treeSet</code> 中小于等于 <code>e</code> 的元素中最大的元素，如果没有小于等于 <code>e</code> 的元素就返回 <code>null</code>。</p><p>维护一个滑动窗口，去寻找窗口中是否存在 <code>x - t ~ x + t</code> 的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyAlmostDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    TreeSet&lt;Long&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; k)</span><br><span class="line">            set.remove((<span class="type">long</span>)nums[i - k - <span class="number">1</span>]); <span class="comment">//滑动窗口满，移出最早进入窗口的元素</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">tmp</span> <span class="operator">=</span> set.ceiling((<span class="type">long</span>)nums[i] - t);  <span class="comment">//找到元素在 &gt;= nums[i] - t 的最小元素</span></span><br><span class="line">        <span class="keyword">if</span>(tmp != <span class="literal">null</span> &amp;&amp; tmp &lt;= (<span class="type">long</span>)nums[i] + t)  <span class="comment">//并且确认其 &lt;= nums[i] + t 因为|nums[i] - tmp| &lt;= t -&gt; ,nums[i] - t &lt;= tmp &lt;= nums[i] + t</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//以上不满足继续加入Tree</span></span><br><span class="line">        set.add((<span class="type">long</span>)nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个整数数组，判断数组中是否有两个不同的索引 &lt;em&gt;i&lt;/em&gt; 和 &lt;em&gt;j&lt;/em&gt;，使得 &lt;strong&gt;nums [i]&lt;/strong&gt; 和 &lt;strong&gt;nums [j]&lt;/strong&gt; 的差的绝对值最大为 &lt;em&gt;t&lt;/em&gt;，并且 &lt;em&gt;i&lt;/em&gt; 和 &lt;em&gt;j&lt;/em&gt; 之间的差的绝对值最大为 &lt;em&gt;ķ&lt;/em&gt;。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="二叉搜索树" scheme="http://yorxika.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>打家劫舍II</title>
    <link href="http://yorxika.github.io/2020/02/10/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/"/>
    <id>http://yorxika.github.io/2020/02/10/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/</id>
    <published>2020-02-09T17:51:43.000Z</published>
    <updated>2020-02-09T17:56:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第213题打家劫舍II</p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈，</strong>这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [2,3,2]</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span></span><br></pre></td></tr></table></figure><hr><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>环状排列</strong>意味着第一个房子和最后一个房子中<strong>只能选择一个偷窃</strong>，因此可以把此<strong>环状排列房间</strong>问题约化为两个<strong>单排排列房间</strong>子问题：</p><ol><li>在不偷窃第一个房子的情况下（即 <em>n<strong>u</strong>m</em>s[1:]），最大金额是 <em>p</em>1 ；</li><li>在不偷窃最后一个房子的情况下（即 n<strong>u</strong>ms<em>[:</em>n−1]），最大金额是 p2 。</li></ol><ul><li><strong>综合偷窃最大金额：</strong> 为以上两种情况的较大值，即 m<strong>a</strong>x<em>(</em>p<em>1,</em>p2) 。</li></ul><p>记：</p><blockquote><p><em>f</em>(<em>k</em>) = 从前 <em>k</em> 个房屋中能抢劫到的最大数额，<em>Ai</em> = 第 i 个房屋的钱数。</p></blockquote><p>首先看 <code>n = 1</code> 的情况，显然 <em>f</em>(1) = A1。</p><p>再看 <code>n = 2</code>，<em>f</em>(2) = max(A<em>1, A</em>2)。</p><p>对于 <code>n = 3</code>，有两个选项:</p><ol><li>抢第三个房子，将数额与第一个房子相加。</li><li>不抢第三个房子，保持现有最大数额。</li></ol><p>显然，你想选择数额更大的选项。于是，可以总结出公式：</p><blockquote><p><em>f</em>(<em>k</em>) = max(<em>f</em>(<em>k</em> – 2) + A_k, <em>f</em>(<em>k</em> – 1))</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.max(helper(Arrays.copyOfRange(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>)),helper(Arrays.copyOfRange(nums,<span class="number">1</span>,nums.length)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span> []nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : nums)&#123;</span><br><span class="line">        tmp = cur;</span><br><span class="line">        cur = Math.max(pre + x,cur);</span><br><span class="line">        pre = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第213题打家劫舍II&lt;/p&gt;
&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都&lt;strong&gt;围成一圈，&lt;/strong&gt;这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，&lt;strong&gt;如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;给定一个代表每个房屋存放金额的非负整数数组，计算你&lt;strong&gt;在不触动警报装置的情况下，&lt;/strong&gt;能够偷窃到的最高金额。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>存在重复元素</title>
    <link href="http://yorxika.github.io/2020/02/09/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://yorxika.github.io/2020/02/09/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2020-02-09T13:52:29.000Z</published>
    <updated>2020-02-09T13:57:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第219题存在重复元素II</p><p>给定一个整数数组和一个整数 <em>k</em>，判断数组中是否存在两个不同的索引 <em>i</em> 和 <em>j</em>，使得 <strong>nums [i] = nums [j]</strong>，并且 <em>i</em> 和 <em>j</em> 的差的绝对值最大为 <em>k</em>。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: nums = [1,2,3,1], k = 3</span></span><br><span class="line"><span class="section">输出: true</span></span><br></pre></td></tr></table></figure><hr><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>维护一个哈希表，里面始终最多包含 <code>k</code> 个元素，当出现重复值时则说明在 <code>k</code> 距离内存在重复元素,每次遍历一个元素则将其加入哈希表中，如果哈希表的大小大于 <code>k</code>，则移除最前面的数字</p><pre><code class="lang-JAVA">    public boolean containsNearbyDuplicate(int[] nums, int k) &#123;        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();        for(int i = 0 ; i &lt; nums.length ; ++i)&#123;            if(set.contains(nums[i]))                return true;            set.add(nums[i]);            if(set.size() &gt; k)                set.remove(nums[i - k]);        &#125;        return false;    &#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来自Leetcode第219题存在重复元素II&lt;/p&gt;
&lt;p&gt;给定一个整数数组和一个整数 &lt;em&gt;k&lt;/em&gt;，判断数组中是否存在两个不同的索引 &lt;em&gt;i&lt;/em&gt; 和 &lt;em&gt;j&lt;/em&gt;，使得 &lt;strong&gt;nums [i] = nums [j]&lt;/strong&gt;，</summary>
      
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="哈希" scheme="http://yorxika.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>第K大元素</title>
    <link href="http://yorxika.github.io/2020/02/09/%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://yorxika.github.io/2020/02/09/%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/</id>
    <published>2020-02-09T13:30:11.000Z</published>
    <updated>2020-02-09T13:54:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第215题数组中的第K大元素</p><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [3,2,1,5,6,4] 和 k = 2</span></span><br><span class="line"><span class="section">输出: 5</span></span><br></pre></td></tr></table></figure><hr><h3 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h3><p>利用快速排序里的partition过程实现。<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/">参考</a></p><p>partition（切分）操作，使得：</p><ul><li>对于某个索引 <code>j</code>，<code>nums[j]</code> 已经排定，即 <code>nums[j]</code> 经过 partition（切分）操作以后会放置在它 “最终应该放置的地方”；</li><li><code>nums[left]</code> 到 <code>nums[j - 1]</code> 中的所有元素都不大于 <code>nums[j]</code>；</li><li><code>nums[j + 1]</code> 到 <code>nums[right]</code> 中的所有元素都不小于 <code>nums[j]</code>。</li></ul><p><img src="/2020/02/09/%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/02/09/%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/65ec311c3e9792bb17e9c08cabd4a07f251c9cd65a011b6c5ffb54b46d8e5012-image.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> []nums;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">ran</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(System.currentTimeMillis());</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> len - k;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            index = partition(left,right);</span><br><span class="line">            <span class="keyword">if</span>(index &lt; target)</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index &gt; target)</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">//在区间随机选择一个点作为枢纽</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt; left)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + <span class="number">1</span> + ran.nextInt(right - left);</span><br><span class="line">            swap(left,index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span> ; i &lt;= right ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.nums[i] &lt; pivot)&#123;</span><br><span class="line">                <span class="comment">//小于枢纽的交换位置</span></span><br><span class="line">                j++;</span><br><span class="line">                swap(j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在之前遍历的过程中，满足 [left + 1, j] &lt; pivot，并且 (j, i] &gt;= pivot</span></span><br><span class="line">        <span class="comment">// 交换以后 [left, j - 1] &lt; pivot, nums[j] = pivot, [j + 1, right] &gt;= pivot</span></span><br><span class="line">        swap(j,left);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.nums[left];</span><br><span class="line">        <span class="built_in">this</span>.nums[left] = <span class="built_in">this</span>.nums[right];</span><br><span class="line">        <span class="built_in">this</span>.nums[right] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/">参考</a></p><p>优先队列的思路是很朴素的。因为第 <code>K</code> 大元素，其实就是整个数组排序以后后半部分最小的那个元素。因此，我们可以维护一个有 <code>K</code> 个元素的最小堆：</p><p>1、如果当前堆不满，直接添加；</p><p>2、堆满的时候，如果新读到的数小于等于堆顶，肯定不是我们要找的元素，只有新都到的数大于堆顶的时候，才将堆顶拿出，然后放入新读到的数，进而让堆自己去调整内部结构。</p><p>说明：这里最合适的操作其实是 <code>replace</code>，即直接把新读进来的元素放在堆顶，然后执行下沉（<code>siftDown</code>）操作。Java 当中的 <code>PriorityQueue</code> 没有提供这个操作，只好先 <code>poll()</code> 再 <code>offer()</code>。</p><p>优先队列的写法就很多了，这里例举一下我能想到的（以下的写法大同小异，没有本质差别）。</p><p>假设数组有 <code>len</code> 个元素。</p><p>思路1：把 <code>len</code> 个元素都放入一个最小堆中，然后再 <code>pop()</code> 出 <code>len - k</code> 个元素，此时最小堆只剩下 <code>k</code> 个元素，堆顶元素就是数组中的第 <code>k</code> 个最大元素。</p><p>思路2：把 <code>len</code> 个元素都放入一个最大堆中，然后再 <code>pop()</code> 出 <code>k - 1</code> 个元素，因为前 <code>k - 1</code> 大的元素都被弹出了，此时最大堆的堆顶元素就是数组中的第 <code>k</code> 个最大元素。</p><p>思路 3：只用 <code>k</code> 个容量的优先队列，而不用全部 <code>len</code> 个容量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 使用一个含有 k 个元素的最小堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k, (a, b) -&gt; a - b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            minHeap.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 看一眼，不拿出，因为有可能没有必要替换</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">topEle</span> <span class="operator">=</span> minHeap.peek();</span><br><span class="line">            <span class="comment">// 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; topEle) &#123;</span><br><span class="line">                minHeap.poll();</span><br><span class="line">                minHeap.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第215题数组中的第K大元素&lt;/p&gt;
&lt;p&gt;在未排序的数组中找到第 &lt;strong&gt;k&lt;/strong&gt; 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="优先队列，堆" scheme="http://yorxika.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%8C%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>课程表</title>
    <link href="http://yorxika.github.io/2020/02/08/%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
    <id>http://yorxika.github.io/2020/02/08/%E8%AF%BE%E7%A8%8B%E8%A1%A8/</id>
    <published>2020-02-08T09:26:10.000Z</published>
    <updated>2020-02-08T09:43:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第207题课程表</p><p>现在你总共有 <em>n</em> 门课需要选，记为 <code>0</code> 到 <code>n-1</code>。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: <code>[0,1]</code></p><p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">2</span>, <span class="string">[[1,0]]</span> </span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 总共有 <span class="number">2</span> 门课程。学习课程 <span class="number">1</span> 之前，你需要完成课程 <span class="number">0</span>。所以这是可能的。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">2</span>, <span class="string">[[1,0],[0,1]]</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 总共有 <span class="number">2</span> 门课程。学习课程 <span class="number">1</span> 之前，你需要先完成课程 <span class="number">0</span>；并且学习课程 <span class="number">0</span> 之前，你还应先完成课程 <span class="number">1</span>。这是不可能的。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>输入的先决条件是由<strong>边缘列表</strong>表示的图形，而不是邻接矩阵。详情请参见<a href="http://blog.csdn.net/woaidapaopao/article/details/51732947">图的表示法</a>。</li><li>你可以假定输入的先决条件中没有重复的边。</li></ol><p><strong>提示:</strong></p><ol><li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li><li><a href="https://www.coursera.org/specializations/algorithms">通过 DFS 进行拓扑排序</a> - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。</li><li>拓扑排序也可以通过 <a href="https://baike.baidu.com/item/宽度优先搜索/5224802?fr=aladdin&amp;fromid=2148012&amp;fromtitle=广度优先搜索">BFS</a> 完成。</li></ol><hr><h3 id="BFS拓扑排序"><a href="#BFS拓扑排序" class="headerlink" title="BFS拓扑排序"></a>BFS拓扑排序</h3><p>来源<a href="https://leetcode-cn.com/problems/course-schedule/solution/tuo-bu-pai-xu-by-liweiwei1419/">题解</a></p><ul><li><p>本题可约化为：课程安排图是否是 <strong>有向无环图(DAG)</strong>。即课程间规定了前置条件，但不能构成任何环路，否则课程前置条件将不成立。</p></li><li><p>思路是通过<strong>拓扑排序</strong>判断此课程安排图是否是<strong>有向无环图(DAG)</strong>。</p><ul><li>拓扑排序是对 DAG 的顶点进行排序，使得对每一条有向边 (u, v)(<em>u</em>,<em>v</em>)，均有 u<em>u</em>（在排序记录中）比 v<em>v</em> 先出现。亦可理解为对某点 v<em>v</em> 而言，只有当 v<em>v</em> 的所有源点均出现了，v<em>v</em> 才能出现。</li></ul></li><li><p>通过课程前置条件列表 <code>prerequisites</code> 可以得到课程安排图的 <strong>邻接矩阵</strong> <code>adjacency</code>，以下两种方法都会用到邻接矩阵。</p></li></ul><p>拓扑排序实际上应用的是<strong>贪心算法</strong>。贪心算法简而言之：每一步最优，全局就最优。</p><p>具体到拓扑排序，每一次都从图中删除没有前驱的顶点，这里并不需要真正的做删除操作，我们可以设置一个入度数组，每一轮都输出入度为 0 的结点，并移除它、修改它指向的结点的入度（-1−1即可），依次得到的结点序列就是拓扑排序的结点序列。如果图中还有结点没有被移除，则说明“不能完成所有课程的学习”。</p><p>拓扑排序保证了每个活动（在这题中是“课程”）的所有前驱活动都排在该活动的前面，并且可以完成所有活动。拓扑排序的结果不唯一。拓扑排序还可以用于检测一个有向图是否有环。相关的概念还有 AOV 网，这里就不展开了。</p><p><strong>算法流程</strong>：</p><p>1、在开始排序前，扫描对应的存储空间（使用邻接表），将入度为 0 的结点放入队列。</p><p>2、只要队列非空，就从队首取出入度为 0 的结点，将这个结点输出到结果集中，并且将这个结点的所有邻接结点（它指向的结点）的入度减 1，在减1 以后，如果这个被减 1 的结点的入度为 0 ，就继续入队。</p><p>3、当队列为空的时候，检查结果集中的顶点个数是否和课程数相等即可。</p><p><img src="/2020/02/08/%E8%AF%BE%E7%A8%8B%E8%A1%A8/02/08/%E8%AF%BE%E7%A8%8B%E8%A1%A8/ca22fa351d5278e95c4c8c94aba6da42ae45d465ff3e8e82149777274293e194-0210.gif" alt="0210.gif"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(numCourses &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(prerequisites.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> []indegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    Integer ve;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> [] tmp : prerequisites)</span><br><span class="line">        indegree[tmp[<span class="number">0</span>]]++;  <span class="comment">//记录各节点的入度数</span></span><br><span class="line">    LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; numCourses ; i++)</span><br><span class="line">        <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">            queue.addLast(i);  <span class="comment">//入度为0的点入队尾</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        ve = queue.removeFirst();  <span class="comment">//队首元素出队</span></span><br><span class="line">        numCourses--;  <span class="comment">//对应的课程数减一</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] tmp:prerequisites)&#123;  <span class="comment">//在表里去掉与之有关的边</span></span><br><span class="line">            <span class="keyword">if</span>(tmp[<span class="number">1</span>] != ve) <span class="comment">//如果该边的起点不是出队节点，continue</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(--indegree[tmp[<span class="number">0</span>]] == <span class="number">0</span>)  <span class="comment">//是就删去该边，并且入度数-1</span></span><br><span class="line">                queue.addLast(tmp[<span class="number">0</span>]); <span class="comment">//入度为0入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第207题课程表&lt;/p&gt;
&lt;p&gt;现在你总共有 &lt;em&gt;n&lt;/em&gt; 门课需要选，记为 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: &lt;code&gt;[0,1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="图" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%9B%BE/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="图" scheme="http://yorxika.github.io/tags/%E5%9B%BE/"/>
    
    <category term="拓扑排序" scheme="http://yorxika.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>同构字符串</title>
    <link href="http://yorxika.github.io/2020/02/08/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yorxika.github.io/2020/02/08/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-02-08T08:59:00.000Z</published>
    <updated>2020-02-08T09:12:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第205题同构字符串</p><p>给定两个字符串 <strong><em>s</em></strong> 和 <strong><em>t</em></strong>，判断它们是否是同构的。</p><p>如果 <strong><em>s</em></strong> 中的字符可以被替换得到 <strong><em>t</em></strong> ，那么这两个字符串是同构的。</p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;egg&quot;</span>, <span class="attr">t</span> = <span class="string">&quot;add&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>维护一个HashMap，里面存放2个字符串相对的映射方式，要注意Map里的元素应当是唯一的，如果出现重复，可以直接返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">&quot;&quot;</span>) || s == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">char</span> tmp_t,tmp_s;</span><br><span class="line">    HashMap&lt;Character,Character&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; s.length() ; i++)&#123;</span><br><span class="line">        tmp_s = s.charAt(i);</span><br><span class="line">        tmp_t = t.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(tmp_s))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsValue(tmp_t)) </span><br><span class="line">                map.put(tmp_s,tmp_t);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp_t != map.get(tmp_s))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字母映射成数字"><a href="#字母映射成数字" class="headerlink" title="字母映射成数字"></a>字母映射成数字</h3><p>最开始写的时候是考虑过将字符串add映射成122这种形式，最后比较生成的2个字符串是否一致即可，于是我选择了维护2个HashMap，但是这导致了超时。</p><p>原代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">&quot;&quot;</span>) || s == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>,s2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    HashMap&lt;Character,Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    HashMap&lt;Character,Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; s.length() ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map1.containsKey(s.charAt(i)))&#123;</span><br><span class="line">            map1.put(s.charAt(i),i);</span><br><span class="line">            s1 += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s1 += map1.get(s.charAt(i));</span><br><span class="line">        <span class="keyword">if</span>(!map2.containsKey(t.charAt(i)))&#123;</span><br><span class="line">            map2.put(t.charAt(i),i);</span><br><span class="line">            s2 += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s2 += map2.get(t.charAt(i));</span><br><span class="line">        <span class="keyword">if</span>(!s1.equals(s2))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在参考了<a href="https://leetcode-cn.com/problems/isomorphic-strings/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-42/">windliang</a>的解答后发现可以不用HashMap，可以直接用2个数组处理，但是本质思想是差不多的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">&quot;&quot;</span>) || s == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">char</span> tmp_t,tmp_s;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span>[] map1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span>[] map2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len; i ++)&#123;</span><br><span class="line">        tmp_s = s.charAt(i);</span><br><span class="line">        tmp_t = t.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(map1[tmp_s] != map2[tmp_t])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(map1[tmp_s] == <span class="number">0</span>)&#123;</span><br><span class="line">                map1[tmp_s] = i + <span class="number">1</span>;</span><br><span class="line">                map2[tmp_t] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第205题同构字符串&lt;/p&gt;
&lt;p&gt;给定两个字符串 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;em&gt;t&lt;/em&gt;&lt;/strong&gt;，判断它们是否是同构的。&lt;/p&gt;
&lt;p&gt;如果 &lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt; 中的字符可以被替换得到 &lt;strong&gt;&lt;em&gt;t&lt;/em&gt;&lt;/strong&gt; ，那么这两个字符串是同构的。&lt;/p&gt;
&lt;p&gt;所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="字符串" scheme="http://yorxika.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>计数质数</title>
    <link href="http://yorxika.github.io/2020/02/07/%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/"/>
    <id>http://yorxika.github.io/2020/02/07/%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</id>
    <published>2020-02-07T15:31:23.000Z</published>
    <updated>2020-02-07T15:36:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第204题计数质数</p><p>统计所有小于非负整数 <em>n</em> 的质数的数量。<br><span id="more"></span><br><strong>示例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: 10</span></span><br><span class="line"><span class="section">输出: 4</span></span><br><span class="line"><span class="section">解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span></span><br></pre></td></tr></table></figure><hr><h3 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h3><p>来自<a href="https://leetcode-cn.com/problems/count-primes/solution/ru-he-gao-xiao-pan-ding-shai-xuan-su-shu-by-labula/">labuladong</a></p><p>首先从 2 开始，我们知道 2 是一个素数，那么 2 × 2 = 4, 3 × 2 = 6, 4 × 2 = 8… 都不可能是素数了。</p><p>然后我们发现 3 也是素数，那么 3 × 2 = 6, 3 × 3 = 9, 3 × 4 = 12… 也都不可能是素数了。</p><p>看到这里，你是否有点明白这个排除法的逻辑了呢？先看我们的第一版代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[] isPrim = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    <span class="comment">// 将数组都初始化为 true</span></span><br><span class="line">    Arrays.fill(isPrim, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) </span><br><span class="line">        <span class="keyword">if</span> (isPrim[i]) </span><br><span class="line">            <span class="comment">// i 的倍数不可能是素数了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * i; j &lt; n; j += i) </span><br><span class="line">                    isPrim[j] = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (isPrim[i]) count++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/07/%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/02/07/%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/23d348bef930ca4bb73f749500f664ccffc5e41467aac0ba9787025392ca207b-1.gif" alt="1.gif"></p><p>首先，回想刚才判断一个数是否是素数的 <code>isPrime</code> 函数，由于因子的对称性，其中的 for 循环只需要遍历 <code>[2,sqrt(n)]</code> 就够了。这里也是类似的，我们外层的 for 循环也只需要遍历到 <code>sqrt(n)</code>：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i <span class="operator">=</span> <span class="number">2</span><span class="comment">; i * i &lt; n; i++) </span></span><br><span class="line">    if (isPrim[i]) </span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>除此之外，很难注意到内层的 for 循环也可以优化。我们之前的做法是：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int j <span class="operator">=</span> <span class="number">2</span> * i<span class="comment">; j &lt; n; j += i) </span></span><br><span class="line">    isPrim[j] <span class="operator">=</span> false<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这样可以把 <code>i</code> 的整数倍都标记为 <code>false</code>，但是仍然存在计算冗余。</p><p>比如 <code>n = 25</code>，<code>i = 4</code> 时算法会标记 4 × 2 = 8，4 × 3 = 12 等等数字，但是这两个数字已经被 <code>i = 2</code> 和 <code>i = 3</code> 的 2 × 4 和 3 × 4 标记了。</p><p>我们可以稍微优化一下，让 <code>j</code> 从 <code>i</code> 的平方开始遍历，而不是从 <code>2 * i</code> 开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * i; j &lt; n; j += i) </span><br><span class="line">    isPrim[j] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>这样，素数计数的算法就高效实现了，其实这个算法有一个名字，叫做 Sieve of Eratosthenes。看下完整的最终代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[] isPrim = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    Arrays.fill(isPrim, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt; n; i++) </span><br><span class="line">        <span class="keyword">if</span> (isPrim[i]) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * i; j &lt; n; j += i) </span><br><span class="line">                isPrim[j] = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (isPrim[i]) count++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第204题计数质数&lt;/p&gt;
&lt;p&gt;统计所有小于非负整数 &lt;em&gt;n&lt;/em&gt; 的质数的数量。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>快乐数</title>
    <link href="http://yorxika.github.io/2020/02/07/%E5%BF%AB%E4%B9%90%E4%B9%A6/"/>
    <id>http://yorxika.github.io/2020/02/07/%E5%BF%AB%E4%B9%90%E4%B9%A6/</id>
    <published>2020-02-06T16:37:35.000Z</published>
    <updated>2020-02-06T16:45:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第202题快乐数</p><p>编写一个算法来判断一个数是不是“快乐数”。</p><p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。<br><span id="more"></span><br><strong>示例:</strong> </p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 19</span><br><span class="line">输出: true</span><br><span class="line">解释: </span><br><span class="line">12 +<span class="number"> 92 </span>= 82</span><br><span class="line">82 +<span class="number"> 22 </span>= 68</span><br><span class="line">62 +<span class="number"> 82 </span>= 100</span><br><span class="line">12 +<span class="number"> 02 </span>+<span class="number"> 02 </span>= 1</span><br></pre></td></tr></table></figure><hr><h3 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h3><p>根据在1-9里只有1和7是快乐数，其他的均不是，以此来判断退出循环的条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">7</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">16</span> || n == <span class="number">37</span> || n == <span class="number">58</span> || n == <span class="number">89</span> || n == <span class="number">145</span> || n == <span class="number">42</span> || n == <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            sum = sum + (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>来自<a href="https://leetcode-cn.com/problems/happy-number/solution/shi-yong-kuai-man-zhi-zhen-si-xiang-zhao-chu-xun-h/">题解</a></p><p>方法：使用“快慢指针”思想找出循环：“快指针”每次走两步，“慢指针”每次走一步，当二者相等时，即为一个循环周期。此时，判断是不是因为1引起的循环，是的话就是快乐数，否则不是快乐数。</p><p>注意：此题不建议用集合记录每次的计算结果来判断是否进入循环，因为这个集合可能大到无法存储；另外，也不建议使用递归，同理，如果递归层次较深，会直接导致调用栈崩溃。不要因为这个题目给出的整数是int型而投机取巧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> n, fast = n;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        slow = Square(slow);</span><br><span class="line">        fast = Square(fast);</span><br><span class="line">        fast = Square(fast);</span><br><span class="line">    &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">    <span class="keyword">return</span> slow == <span class="number">1</span> || slow == <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">Square</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        ans += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第202题快乐数&lt;/p&gt;
&lt;p&gt;编写一个算法来判断一个数是不是“快乐数”。&lt;/p&gt;
&lt;p&gt;一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>数字范围按位与</title>
    <link href="http://yorxika.github.io/2020/02/07/%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/"/>
    <id>http://yorxika.github.io/2020/02/07/%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/</id>
    <published>2020-02-06T16:01:58.000Z</published>
    <updated>2020-02-06T16:48:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第201题数字范围按位与</p><p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。<br><span id="more"></span><br><strong>示例 1:</strong> </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [5,7]</span></span><br><span class="line"><span class="section">输出: 4</span></span><br></pre></td></tr></table></figure><hr><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>按顺序执行按位运算，然后有一个测试算例超时了，在运算时排除全0与全1的数，即到了0xFFFF和0x0就可以返回运算结果了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(m == Integer.MAX_VALUE)</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> m++;</span><br><span class="line">    <span class="keyword">while</span>(m &lt;= n) &#123;</span><br><span class="line">        ans &amp;= m;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">0</span> || m == Integer.MAX_VALUE)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制1的个数"><a href="#二进制1的个数" class="headerlink" title="二进制1的个数"></a>二进制1的个数</h3><p>来源<a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/shu-zi-fan-wei-an-wei-yu-qu-qi-gao-wei-wu-bian-hua/">题解</a></p><p>此题其实就是寻找[m,n]范围内二进制数高位（左边）没有变化的数，后面补上0即为所求的结果。</p><p>判断m、n是否相等，如果不相等，m+1会使m的二进制数末位进位，有进位说明m的末位肯定有0的情况，0与任何数相与皆得0，所以结果的末位肯定是0。同理，不断右移1位进行比较，直到最终 m=n 时，说明找到了[m,n]这个范围内高位没有变化的数，左移相同位数得到的结果就是所求的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(m == Integer.MAX_VALUE || m == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span> ; <span class="comment">// 记录移位次数</span></span><br><span class="line">    <span class="keyword">while</span>(m &lt; n)&#123;</span><br><span class="line">        m &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &lt;&lt;= count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制最右边1置0"><a href="#二进制最右边1置0" class="headerlink" title="二进制最右边1置0"></a>二进制最右边1置0</h3><p>有一个方法，可以把最右边的 <code>1</code> 置为 <code>0</code>，举个具体的例子。</p><p>比如十进制的 <code>10</code>，二进制形式是 <code>1010</code>，然后我们只需要把它和 <code>9</code> 进行按位与操作，也就是 <code>10 &amp; 9 = (1010) &amp; (1001) = 1000</code>，也就是把 <code>1010</code> 最右边的 <code>1</code> 置为 <code>0</code>。</p><p>规律就是对于任意一个数 <code>n</code>，然后 <code>n &amp; (n-1)</code> 的结果就是把 <code>n</code> 的最右边的 <code>1</code> 置为 <code>0</code> 。</p><p>也比较好理解，当我们对一个数减 <code>1</code> 的话，比如原来的数是 <code>...1010000</code>，然后减一就会向前借位，直到遇到最右边的第一个 <code>1</code>，变成 <code>...1001111</code>，然后我们把它和原数按位与，就会把从原数最右边 <code>1</code> 开始的位置全部置零了 <code>...10000000</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">zeros</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; m) &#123;</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第201题数字范围按位与&lt;/p&gt;
&lt;p&gt;给定范围 [m, n]，其中 0 &amp;lt;= m &amp;lt;= n &amp;lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="位运算" scheme="http://yorxika.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>岛屿数量</title>
    <link href="http://yorxika.github.io/2020/02/06/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <id>http://yorxika.github.io/2020/02/06/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</id>
    <published>2020-02-05T19:06:56.000Z</published>
    <updated>2020-02-06T15:50:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第200题 岛屿数量</p><p>给定一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line"><span class="section">输出: 1</span></span><br></pre></td></tr></table></figure><hr><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>在初始化并查集的根节点时，记录所有为<code>1</code>的点的数量，同时将为<code>1</code>的点的根节点初始化为自身，对数组进行遍历，如果遍历时当前点为<code>1</code>，并且其上下左右里有点为<code>1</code>，就意味着相连，合并，并将对应的并查集里的岛屿数减1，最后返回并查集里的岛屿数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parents;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        parents = <span class="keyword">new</span> <span class="title class_">int</span>[row * col];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; row; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; col ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    parents[i * col + j] = i * col + j; <span class="comment">//初始化陆地并查集</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并连通区域是通过find来操作的, 即看这两个节点是不是在一个连通区域内.</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> node1, <span class="type">int</span> node2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root1</span> <span class="operator">=</span> find(node1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">root2</span> <span class="operator">=</span> find(node2);</span><br><span class="line">        <span class="keyword">if</span> (root1 != root2) &#123;</span><br><span class="line">            parents[root2] = root1;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (parents[node] != node) &#123;</span><br><span class="line">            <span class="comment">// 当前节点的父节点 指向父节点的父节点.</span></span><br><span class="line">            <span class="comment">// 保证一个连通区域最终的parents只有一个.</span></span><br><span class="line">            parents[node] = parents[parents[node]];</span><br><span class="line">            node = parents[node];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> node1, <span class="type">int</span> node2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(node1) == find(node2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> grid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(grid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; row ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; col ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    uf.union(i * col + j , (i - <span class="number">1</span>) * col + j);</span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">1</span> &lt; row &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    uf.union(i * col + j , (i + <span class="number">1</span>) * col + j);</span><br><span class="line">                <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    uf.union(i * col + j , i* col + j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(j + <span class="number">1</span> &lt; col &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    uf.union(i * col + j , i* col + j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uf.count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>线性扫描整个二维网格，如果一个结点包含 <code>1</code>，则以其为根结点启动深度优先搜索。在深度优先搜索过程中，每个访问过的结点被标记为 <code>0</code>。计数启动深度优先搜索的根结点的数量，即为岛屿的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">nRow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">nColumn</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> row, <span class="type">int</span> column)</span> &#123;</span><br><span class="line">    nRow = grid.length;</span><br><span class="line">    nColumn = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || column &lt; <span class="number">0</span> || row &gt;= nRow || column &gt;= nColumn || grid[row][column] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[row][column] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    dfs(grid, row - <span class="number">1</span>, column);</span><br><span class="line">    dfs(grid, row + <span class="number">1</span>, column);</span><br><span class="line">    dfs(grid, row, column - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, row, column + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nRow = grid.length;</span><br><span class="line">    nColumn = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; nRow; ++r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; nColumn; ++c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                ++num;</span><br><span class="line">                dfs(grid, r, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第200题 岛屿数量&lt;/p&gt;
&lt;p&gt;给定一个由 &lt;code&gt;&amp;#39;1&amp;#39;&lt;/code&gt;（陆地）和 &lt;code&gt;&amp;#39;0&amp;#39;&lt;/code&gt;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="并查集" scheme="http://yorxika.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>被围绕的区域</title>
    <link href="http://yorxika.github.io/2020/02/06/%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/"/>
    <id>http://yorxika.github.io/2020/02/06/%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</id>
    <published>2020-02-05T18:01:21.000Z</published>
    <updated>2020-02-08T09:28:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第130题被围绕的区域</p><p>给定一个二维的矩阵，包含 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code>（<strong>字母 O</strong>）。</p><p>找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。<br><span id="more"></span><br><strong>示例:</strong></p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> O O <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> O <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> O <span class="keyword">X</span> <span class="keyword">X</span></span><br></pre></td></tr></table></figure><p>运行你的函数后，矩阵变为：</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span> <span class="keyword">X</span></span><br><span class="line"><span class="keyword">X</span> O <span class="keyword">X</span> <span class="keyword">X</span></span><br></pre></td></tr></table></figure><p><strong>解释:</strong></p><p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 <code>&#39;O&#39;</code> 都不会被填充为 <code>&#39;X&#39;</code>。 任何不在边界上，或不与边界上的 <code>&#39;O&#39;</code> 相连的 <code>&#39;O&#39;</code> 最终都会被填充为 <code>&#39;X&#39;</code>。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p><hr><h3 id="DFS递归"><a href="#DFS递归" class="headerlink" title="DFS递归"></a>DFS递归</h3><p>从边界出发吧，先把边界上和 <code>O</code> 连通点找到, 把这些变成 <code>#</code>,然后遍历整个 <code>board</code> 把 <code>O</code> 变成 <code>X</code>, 把 <code>#</code> 变成 <code>O</code><br>最上、下或最左、右，且是<code>O</code>的是为边界,在DFS中,已经被置为不能访问标识的无需再DFS最后遍历中，无需再遍历边界条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> board.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt;= row - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt;= col - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isEdge</span> <span class="operator">=</span> i == <span class="number">0</span> || j == <span class="number">0</span> || i == row - <span class="number">1</span> || j == col -<span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span>(isEdge &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                surround(board,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt;= row - <span class="number">1</span> ; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt;= col - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">surround</span><span class="params">(<span class="type">char</span>[][] board , <span class="type">int</span> i , <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= board.length || j &gt;= board[<span class="number">0</span>].length || board[i][j] == <span class="string">&#x27;X&#x27;</span> || board[i][j] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    surround(board,i - <span class="number">1</span>,j);</span><br><span class="line">    surround(board,i + <span class="number">1</span>,j);</span><br><span class="line">    surround(board,i ,j - <span class="number">1</span>);</span><br><span class="line">    surround(board,i , j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>来源<a href="https://leetcode-cn.com/problems/surrounded-regions/solution/bfsdi-gui-dfsfei-di-gui-dfsbing-cha-ji-by-ac_pipe/">题解</a></p><p>并查集常用来解决连通性的问题，即将一个图中连通的部分划分出来。当我们判断图中两个点之间是否存在路径时，就可以根据判断他们是否在一个连通区域。 而这道题我们其实求解的就是和边界的 <em>O</em> 在一个连通区域的的问题。</p><p>并查集的思想就是，同一个连通区域内的所有点的根节点是同一个。将每个点映射成一个数字。先假设每个点的根节点就是他们自己，然后我们以此输入连通的点对，然后将其中一个点的根节点赋成另一个节点的根节点，这样这两个点所在连通区域又相互连通了。<br>并查集的主要操作有：</p><ul><li><code>find(int m)</code>：这是并查集的基本操作，查找 <em>m</em> 的根节点。</li><li><code>isConnected(int m,int n)</code>：判断 m，<em>n</em> 两个点是否在一个连通区域。</li><li><code>union(int m,int n)</code>:合并 m，<em>n</em> 两个点所在的连通区域。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parents;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> totalNodes)</span> &#123;</span><br><span class="line">        parents = <span class="keyword">new</span> <span class="title class_">int</span>[totalNodes];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalNodes; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 合并连通区域是通过find来操作的, 即看这两个节点是不是在一个连通区域内.</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> node1, <span class="type">int</span> node2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root1</span> <span class="operator">=</span> find(node1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">root2</span> <span class="operator">=</span> find(node2);</span><br><span class="line">        <span class="keyword">if</span> (root1 != root2) &#123;</span><br><span class="line">            parents[root2] = root1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (parents[node] != node) &#123;</span><br><span class="line">            <span class="comment">// 当前节点的父节点 指向父节点的父节点.</span></span><br><span class="line">            <span class="comment">// 保证一个连通区域最终的parents只有一个.</span></span><br><span class="line">            parents[node] = parents[parents[node]];</span><br><span class="line">            node = parents[node];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> node1, <span class="type">int</span> node2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(node1) == find(node2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的思路是把所有边界上的 <em>O</em> 看做一个连通区域。遇到 <em>O</em> 就执行并查集合并操作，这样所有的 O 就会被分成两类</p><ul><li>和边界上的 O 在一个连通区域内的。这些 <em>O</em> 我们保留。</li><li>不和边界上的 O 在一个连通区域内的。这些 <em>O</em> 就是被包围的，替换。</li></ul><p>由于并查集我们一般用一维数组来记录，方便查找 <code>parants</code>，所以我们将二维坐标用 <code>node</code> 函数转化为一维坐标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="literal">null</span> || board.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用一个虚拟节点, 边界上的O 的父节点都是这个虚拟节点</span></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(rows * cols + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">dummyNode</span> <span class="operator">=</span> rows * cols;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 遇到O进行并查集操作合并</span></span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || i == rows - <span class="number">1</span> || j == <span class="number">0</span> || j == cols - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 边界上的O,把它和dummyNode 合并成一个连通区域.</span></span><br><span class="line">                        uf.union(node(i, j), dummyNode);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 和上下左右合并成一个连通区域.</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; board[i - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                            uf.union(node(i, j), node(i - <span class="number">1</span>, j));</span><br><span class="line">                        <span class="keyword">if</span> (i &lt; rows - <span class="number">1</span> &amp;&amp; board[i + <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                            uf.union(node(i, j), node(i + <span class="number">1</span>, j));</span><br><span class="line">                        <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; board[i][j - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                            uf.union(node(i, j), node(i, j - <span class="number">1</span>));</span><br><span class="line">                        <span class="keyword">if</span> (j &lt; cols - <span class="number">1</span> &amp;&amp; board[i][j + <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                            uf.union(node(i, j), node(i, j + <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uf.isConnected(node(i, j), dummyNode)) &#123;</span><br><span class="line">                    <span class="comment">// 和dummyNode 在一个连通区域的,那么就是O；</span></span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">node</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i * cols + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="并查集有关补充"><a href="#并查集有关补充" class="headerlink" title="并查集有关补充"></a>并查集有关补充</h3><p>来自<a href="https://blog.csdn.net/liujian20150808/article/details/50848646">文章</a></p><p>首先在地图上给你若干个城镇，这些城镇都可以看作点，然后告诉你哪些对城镇之间是有道路直接相连的。最后要解决的是整幅图的连通性问题。比如随意给你两个点，让你判断它们是否连通，或者问你整幅图一共有几个连通分支，也就是被分成了几个互相独立的块。像畅通工程这题，问还需要修几条路，实质就是求有几个连通分支。如果是1个连通分支，说明整幅图上的点都连起来了，不用再修路了；如果是2个连通分支，则只要再修1条路，从两个分支中各选一个点，把它们连起来，那么所有的点都是连起来的了；如果是3个连通分支，则只要再修两条路……</p><p>以下面这组数据输入数据来说明</p><p>4 2 1 3 4 3</p><p>第一行告诉你，一共有4个点，2条路。下面两行告诉你，1、3之间有条路，4、3之间有条路。那么整幅图就被分成了1-3-4和2两部分。只要再加一条路，把2和其他任意一个点连起来，畅通工程就实现了，那么这个这组数据的输出结果就是1。好了，现在编程实现这个功能吧，城镇有几百个，路有不知道多少条，而且可能有回路。 这可如何是好？</p><p>并查集由一个整数型的数组和两个函数构成。数组pre[]记录了每个点的前导点是什么，函数find是查找，join是合并。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pre[<span class="number">1000</span> ];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>                                       <span class="comment">//查找根节点</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> r=x;</span><br><span class="line">    <span class="keyword">while</span> ( pre[r] != r )                           <span class="comment">//返回根节点 r</span></span><br><span class="line">          r=pre[r];</span><br><span class="line">    <span class="type">int</span> i=x , j ;</span><br><span class="line">    <span class="keyword">while</span>( i != r )                                   <span class="comment">//路径压缩</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">         j = pre[ i ]; <span class="comment">// 在改变上级之前用临时变量  j 记录下他的值 </span></span><br><span class="line">         pre[ i ]= r ; <span class="comment">//把上级改为根节点</span></span><br><span class="line">         i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>                           <span class="comment">//判断x y是否连通，</span></span></span><br><span class="line"><span class="function">                                         <span class="comment">//如果已经连通，就不用管了 如果不连通，就把它们所在的连通分支合并起,</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)</span><br><span class="line">        pre[fx ]=fy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解释并查集的原理，我将举一个更有爱的例子。 话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的群落，通过两两之间的朋友关系串联起来。而不在同一个群落的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？</p><p>我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物，这样，每个圈子就可以这样命名“齐达内朋友之队”“罗纳尔多朋友之队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。</p><p>但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长，要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样一来，队长面子上挂不住了，而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。</p><p><img src="http://hi.csdn.net/attachment/201107/29/0_1311901712oy9f.gif" alt="img"></p><p>下面我们来看并查集的实现。 int pre[1000]; 这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。 find这个函数就是找掌门用的，意义再清楚不过了（路径压缩算法先不论，后面再说）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>                    <span class="comment">//查找我（x）的掌门</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r=x;                      <span class="comment">//委托 r 去找掌门</span></span><br><span class="line">    <span class="keyword">while</span> (pre[r ]!=r)           <span class="comment">//如果r的上级不是r自己（也就是说找到的大侠他不是掌门 = =）</span></span><br><span class="line">    r=pre[r ] ;                 <span class="comment">// r 就接着找他的上级，直到找到掌门为止。</span></span><br><span class="line">    <span class="keyword">return</span>  r ;                <span class="comment">//掌门驾到~~~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看join函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？ 还是举江湖的例子，假设现在武林中的形势如图所示。虚竹小和尚与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”抗议无效，上天安排的，最大。反正谁加入谁效果是一样的，我就随手指定了一个。这段函数的意思很明白了吧？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>          <span class="comment">//我想让虚竹和周芷若做朋友</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);         <span class="comment">//虚竹的老大是玄慈，芷若MM的老大是灭绝</span></span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)                         <span class="comment">//玄慈和灭绝显然不是同一个人</span></span><br><span class="line">    pre[fx ]=fy;                       <span class="comment">//方丈只好委委屈屈地当了师太的手下啦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看路径压缩算法。建立门派的过程是用join函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么胎唇样，我也完全无法预计，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。 设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能揍。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是记己人，西礼西礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位同学请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其习偶们的掌门是曹公公。不如偶们一起及接拜在曹公公手下吧，省得级别太低，以后查找掌门麻环。” “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。路径压缩的代码，看得懂很好，看不懂也没关系，直接抄上用就行了。总之它所实现的功能就是这么个意思。</p><p><img src="http://hi.csdn.net/attachment/201107/29/0_131190167189S8.gif" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第130题被围绕的区域&lt;/p&gt;
&lt;p&gt;给定一个二维的矩阵，包含 &lt;code&gt;&amp;#39;X&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;O&amp;#39;&lt;/code&gt;（&lt;strong&gt;字母 O&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;找到所有被 &lt;code&gt;&amp;#39;X&amp;#39;&lt;/code&gt; 围绕的区域，并将这些区域里所有的 &lt;code&gt;&amp;#39;O&amp;#39;&lt;/code&gt; 用 &lt;code&gt;&amp;#39;X&amp;#39;&lt;/code&gt; 填充。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="深度优先搜索" scheme="http://yorxika.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="并查集" scheme="http://yorxika.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>最大数</title>
    <link href="http://yorxika.github.io/2020/01/24/%E6%9C%80%E5%A4%A7%E6%95%B0/"/>
    <id>http://yorxika.github.io/2020/01/24/%E6%9C%80%E5%A4%A7%E6%95%B0/</id>
    <published>2020-01-24T13:31:53.000Z</published>
    <updated>2020-01-24T13:35:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第179题最大数</p><p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [10,2]</span></span><br><span class="line"><span class="section">输出: 210</span></span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a><span id="more"></span></h2><p>首先，我们将每个整数变成字符串。然后进行排序。</p><pre><code class="lang-JAVA">    public String largestNumber(int[] nums) &#123;        Integer[] n = new Integer[nums.length];        for(int i = 0 ; i &lt; nums.length ; i++)            n[i] = nums[i];        Arrays.sort(n, new Comparator&lt;Integer&gt;() &#123;            @Override            public int compare(Integer o1, Integer o2) &#123;                String s1 = o1 + &quot;&quot; + o2;                String s2 = o2 + &quot;&quot; + o1;                return  s2.compareTo(s1);            &#125;        &#125;);        StringBuilder ans = new StringBuilder();        for(int i = 0 ; i &lt; nums.length ; i++)            ans.append(n[i]);        String res = ans.toString();         return res.charAt(0) == &#39;0&#39; ? &quot;0&quot; : res;    &#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第179题最大数&lt;/p&gt;
&lt;p&gt;给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight makefile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;输入: [10,2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;输出: 210&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h2&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>单词拆分</title>
    <link href="http://yorxika.github.io/2020/01/24/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <id>http://yorxika.github.io/2020/01/24/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</id>
    <published>2020-01-24T09:04:24.000Z</published>
    <updated>2020-01-24T09:46:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第139题单词拆分</p><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。<br><span id="more"></span><br><strong>说明：</strong></p><ul><li>拆分时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;leetcode&quot;</span>, <span class="attr">wordDict</span> = [<span class="string">&quot;leet&quot;</span>, <span class="string">&quot;code&quot;</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 返回 <span class="literal">true</span> 因为 <span class="string">&quot;leetcode&quot;</span> 可以被拆分成 <span class="string">&quot;leet code&quot;</span>。</span><br></pre></td></tr></table></figure><hr><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>最简单的实现方法是用递归和回溯。为了找到解，我们可以检查字典单词中每一个单词的可能前缀，如果在字典中出现过，那么去掉这个前缀后剩余部分回归调用。同时，如果某次函数调用中发现整个字符串都已经被拆分且在字典中出现过了，函数就返回 <code>true</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set ;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">    <span class="keyword">return</span> helper(s,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">helper</span><span class="params">(String s,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == s.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">1</span> ; i &lt;= s.length(); i++)</span><br><span class="line">        <span class="keyword">if</span>(set.contains(s.substring(start,i)) &amp;&amp; helper(s,i))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>题解的看不是很懂，摸了</p><p>在先前的方法中，我们看到许多函数调用都是冗余的，也就是我们会对相同的字符串调用多次回溯函数。为了避免这种情况，我们可以使用记忆化的方法，其中一个 memo<em>m<strong>e</strong>m**o</em> 数组会被用来保存子问题的结果。每当访问到已经访问过的后缀串，直接用 memo<em>m<strong>e</strong>m**o</em> 数组中的值返回而不需要继续调用函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> word_Break(s, <span class="keyword">new</span> <span class="title class_">HashSet</span>(wordDict), <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">Boolean</span>[s.length()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">word_Break</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="type">int</span> start, Boolean[] memo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[start] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(s.substring(start, end)) &amp;&amp; word_Break(s, wordDict, end, memo)) &#123;</span><br><span class="line">                <span class="keyword">return</span> memo[start] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[start] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="宽度优先搜索"><a href="#宽度优先搜索" class="headerlink" title="宽度优先搜索"></a>宽度优先搜索</h3><p>另一个方法是使用宽度优先搜索。将字符串可视化成一棵树，每一个节点是用 end<em>e<strong>n</strong>d</em> 为结尾的前缀字符串。当两个节点之间的所有节点都对应了字典中一个有效字符串时，两个节点可以被连接。</p><p>为了形成这样的一棵树，我们从给定字符串的第一个字符开始（比方说 s<em>s</em> ），将它作为树的根部，开始找所有可行的以该字符为首字符的可行子串。进一步的，将每一个子字符串的结束字符的下标（比方说 i<em>i</em>）放在队列的尾部供宽搜后续使用。</p><p>每次我们从队列最前面弹出一个元素，并考虑字符串 s(i+1,end)<em>s</em>(<em>i</em>+1,<em>e<strong>n</strong>d</em>) 作为原始字符串，并将当前节点作为树的根。这个过程会一直重复，直到队列中没有元素。如果字符串最后的元素可以作为树的一个节点，这意味着初始字符串可以被拆分成多个给定字典中的子字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> [] visit = <span class="keyword">new</span> <span class="title class_">int</span> [s.length()];</span><br><span class="line">    queue.add(<span class="number">0</span>); <span class="comment">//起始位置0入队列</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> queue.remove();  <span class="comment">//队首元素出队</span></span><br><span class="line">        <span class="keyword">if</span>(visit[start] == <span class="number">0</span>)&#123;  <span class="comment">//如果这个点没看过</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">1</span> ; i &lt;= s.length() ; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (set.contains(s.substring(start, i))) &#123;</span><br><span class="line">                    queue.add(i); <span class="comment">// 包含字符串的子串，就加入队列</span></span><br><span class="line">                    <span class="keyword">if</span> (i == s.length())  <span class="comment">//能遍历完，说明完成了拆分</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[start] = <span class="number">1</span>;  <span class="comment">//对遍历点做标记，之后拆分到该点的都可以认为是没有完成拆分的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>这题和算法导论上的解答是差不多的</p><p>这个方法的想法是对于给定的字符串（<em>s</em>）可以被拆分成子问题 <em>s</em>1 和 <em>s</em>2 。如果这些子问题都可以独立地被拆分成符合要求的子问题，那么整个问题 <em>s</em> 也可以满足。也就是，如果 “catsanddog” 可以拆分成两个子字符串 “catsand” 和 “dog” 。子问题 “catsand” 可以进一步拆分成 “cats” 和 “and” ，这两个独立的部分都是字典的一部分，所以 “catsand” 满足题意条件，再往前， “catsand” 和 “dog” 也分别满足条件，所以整个字符串 “catsanddog” 也满足条件。</p><p>现在，我们考虑 dp 数组求解的过程。我们使用 <em>n</em>+1 大小数组的 dp ，其中 <em>n</em> 是给定字符串的长度。我们也使用 2 个下标指针 <em>i</em> 和 <em>j</em> ，其中 <em>i</em> 是当前字符串从头开始的子字符串（<em>s</em>′）的长度， <em>j</em> 是当前子字符串（<em>s</em>′）的拆分位置，拆分成 <em>s</em>′(0,<em>j</em>) 和 <em>s</em>′(<em>j</em>+1,<em>i</em>) 。</p><p>为了求出dp 数组，我们初始化 dp[0] 为 true ，这是因为空字符串总是字典的一部分。dp 数组剩余的元素都初始化为 false 。</p><p>我们用下标 <em>i</em> 来考虑所有从当前字符串开始的可能的子字符串。对于每一个子字符串，我们通过下标 <em>j</em> 将它拆分成 <em>s</em>1′ 和 <em>s</em>2′ （注意 <em>i</em> 现在指向 <em>s</em>2′ 的结尾）。为了将dp[<em>i</em>] 数组求出来，我们依次检查每个 dp[<em>j</em>] 是否为 true ，也就是子字符串 <em>s</em>1′ 是否满足题目要求。如果满足，我们接下来检查 <em>s</em>2′ 是否在字典中。如果包含，我们接下来检查 <em>s</em>2′ 是否在字典中，如果两个字符串都满足要求，我们让 dp[<em>i</em>] 为 true ，否则令其为 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; wordDictSet=<span class="keyword">new</span> <span class="title class_">HashSet</span>(wordDict);</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第139题单词拆分&lt;/p&gt;
&lt;p&gt;给定一个&lt;strong&gt;非空&lt;/strong&gt;字符串 &lt;em&gt;s&lt;/em&gt; 和一个包含&lt;strong&gt;非空&lt;/strong&gt;单词列表的字典 &lt;em&gt;wordDict&lt;/em&gt;，判定 &lt;em&gt;s&lt;/em&gt; 是否可以被空格拆分为一个或多个在字典中出现的单词。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="动态规划" scheme="http://yorxika.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="回溯" scheme="http://yorxika.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>从中序与后序遍历构造二叉树</title>
    <link href="http://yorxika.github.io/2020/01/23/%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yorxika.github.io/2020/01/23/%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-01-23T08:18:54.000Z</published>
    <updated>2020-01-23T08:21:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第106题从中序与后序遍历构造二叉树</p><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。<br><span id="more"></span><br>例如，给出</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中序遍历 inorder = <span class="string">[9,3,15,20,7]</span></span><br><span class="line">后序遍历 postorder = <span class="string">[9,15,7,20,3]</span></span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / <span class="string">\</span></span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  <span class="string">\</span></span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><hr><h3 id="递归构造"><a href="#递归构造" class="headerlink" title="递归构造"></a>递归构造</h3><p>思路同上一题，先确定根节点，然后在中序遍历中找根节点的位置，然后分出左子树和右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> [] inorder,postorder;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; inorder.length ; i++)</span><br><span class="line">        map.put(inorder[i],i);</span><br><span class="line">    <span class="built_in">this</span>.inorder = inorder;</span><br><span class="line">    <span class="built_in">this</span>.postorder = postorder;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>,postorder.length,<span class="number">0</span>,inorder.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span> p_start,<span class="type">int</span> p_end,<span class="type">int</span> i_start,<span class="type">int</span> i_end)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p_start == p_end)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="built_in">this</span>.postorder[p_end - <span class="number">1</span>]);  <span class="comment">//构造根节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i_root_index</span> <span class="operator">=</span> <span class="built_in">this</span>.map.get(<span class="built_in">this</span>.postorder[p_end - <span class="number">1</span>]);  <span class="comment">//得到中序遍历根节点的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i_root_index - i_start;  <span class="comment">//这一块为根节点的左子树</span></span><br><span class="line">    root.left = helper(p_start , p_start + left,i_start,i_root_index);</span><br><span class="line">    root.right = helper(p_start + left,p_end - <span class="number">1</span>,i_root_index + <span class="number">1</span> , i_end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第106题从中序与后序遍历构造二叉树&lt;/p&gt;
&lt;p&gt;根据一棵树的中序遍历与后序遍历构造二叉树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;br&gt;你可以假设树中没有重复的元素。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>从前序与中序遍历构造二叉树</title>
    <link href="http://yorxika.github.io/2020/01/23/%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yorxika.github.io/2020/01/23/%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-01-23T07:51:59.000Z</published>
    <updated>2020-01-23T08:04:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第105题从前序与中序遍历构造二叉树</p><p>根据一棵树的前序遍历与中序遍历构造二叉树。<br><span id="more"></span><br><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder = <span class="string">[3,9,20,15,7]</span></span><br><span class="line">中序遍历 inorder = <span class="string">[9,3,15,20,7]</span></span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / <span class="string">\</span></span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  <span class="string">\</span></span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><hr><h3 id="递归构造"><a href="#递归构造" class="headerlink" title="递归构造"></a>递归构造</h3><p>前序序列的第一个节点为根节点，根据根节点在中序序列里的位置，划分出根节点的左右子树，进一步的递归构造。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">preorder = <span class="comment">[3,9,20,15,7]</span></span><br><span class="line">inorder = <span class="comment">[9,3,15,20,7]</span></span><br><span class="line">首先根据 preorder 找到根节点是 3</span><br><span class="line">    </span><br><span class="line">然后根据根节点将 inorder 分成左子树和右子树</span><br><span class="line">左子树</span><br><span class="line">inorder <span class="comment">[9]</span></span><br><span class="line"></span><br><span class="line">右子树</span><br><span class="line">inorder <span class="comment">[15,20,7]</span></span><br><span class="line"></span><br><span class="line">把相应的前序遍历的数组也加进来</span><br><span class="line">左子树</span><br><span class="line">preorder<span class="comment">[9]</span> </span><br><span class="line">inorder <span class="comment">[9]</span></span><br><span class="line"></span><br><span class="line">右子树</span><br><span class="line">preorder<span class="comment">[20 15 7]</span> </span><br><span class="line">inorder <span class="comment">[15,20,7]</span></span><br><span class="line"></span><br><span class="line">现在我们只需要构造左子树和右子树即可，成功把大问题化成了小问题</span><br><span class="line">然后重复上边的步骤继续划分，直到 preorder 和 inorder 都为空，返回 null 即可</span><br></pre></td></tr></table></figure><p>用一个Map存储中序遍历每一个节点的位置，由此确定对应的左右子树范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> [] preorder,inorder;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; inorder.length ;i++)</span><br><span class="line">        map.put(inorder[i],i);</span><br><span class="line">    <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">    <span class="built_in">this</span>.inorder = inorder;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>,preorder.length ,<span class="number">0</span>,inorder.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span> p_start,<span class="type">int</span> p_end,<span class="type">int</span> i_start,<span class="type">int</span> i_end)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p_start == p_end)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="built_in">this</span>.preorder[p_start]);  <span class="comment">//构造根节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i_root_index</span> <span class="operator">=</span> <span class="built_in">this</span>.map.get(<span class="built_in">this</span>.preorder[p_start]);  <span class="comment">//得到中序遍历根节点的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i_root_index - i_start;  <span class="comment">//这一块为根节点的左子树</span></span><br><span class="line">    root.left = helper(p_start + <span class="number">1</span> , p_start + left + <span class="number">1</span>,i_start,i_root_index);</span><br><span class="line">    root.right = helper(p_start + <span class="number">1</span> + left,p_end,i_root_index + <span class="number">1</span> , i_end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代-栈"><a href="#迭代-栈" class="headerlink" title="迭代 栈"></a>迭代 栈</h3><p>来源<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--22/">题解</a></p><p>我们用一个栈保存已经遍历过的节点，遍历前序遍历的数组，一直作为当前根节点的左子树，直到当前节点和中序遍历的数组的节点相等了，那么我们正序遍历中序遍历的数组，倒着遍历已经遍历过的根节点（用栈的 pop 实现），找到最后一次相等的位置，把它作为该节点的右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; roots = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">in</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//先序遍历第一个值作为根节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">curRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[pre]);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> curRoot;</span><br><span class="line">    roots.push(curRoot);</span><br><span class="line">    pre++;</span><br><span class="line">    <span class="comment">//遍历前序遍历的数组</span></span><br><span class="line">    <span class="keyword">while</span> (pre &lt; preorder.length) &#123;</span><br><span class="line">        <span class="comment">//出现了当前节点的值和中序遍历数组的值相等，寻找是谁的右子树</span></span><br><span class="line">        <span class="keyword">if</span> (curRoot.val == inorder[in]) &#123;</span><br><span class="line">            <span class="comment">//每次进行出栈，实现倒着遍历</span></span><br><span class="line">            <span class="keyword">while</span> (!roots.isEmpty() &amp;&amp; roots.peek().val == inorder[in]) &#123;</span><br><span class="line">                curRoot = roots.peek();</span><br><span class="line">                roots.pop();</span><br><span class="line">                in++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设为当前的右孩子</span></span><br><span class="line">            curRoot.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[pre]);</span><br><span class="line">            <span class="comment">//更新 curRoot</span></span><br><span class="line">            curRoot = curRoot.right;</span><br><span class="line">            roots.push(curRoot);</span><br><span class="line">            pre++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则的话就一直作为左子树</span></span><br><span class="line">            curRoot.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[pre]);</span><br><span class="line">            curRoot = curRoot.left;</span><br><span class="line">            roots.push(curRoot);</span><br><span class="line">            pre++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第105题从前序与中序遍历构造二叉树&lt;/p&gt;
&lt;p&gt;根据一棵树的前序遍历与中序遍历构造二叉树。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记II</title>
    <link href="http://yorxika.github.io/2020/01/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/"/>
    <id>http://yorxika.github.io/2020/01/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/</id>
    <published>2020-01-22T17:42:12.000Z</published>
    <updated>2020-03-20T02:54:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>TBC 269</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;友元&quot;&gt;&lt;a href=&quot;#友元&quot; class=&quot;headerlink&quot; title=&quot;友元&quot;&gt;&lt;/a&gt;友元&lt;/h2&gt;&lt;p&gt;TBC 269&lt;/p&gt;
</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CPP" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/CPP/"/>
    
    
    <category term="CPP" scheme="http://yorxika.github.io/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>阶乘后的零</title>
    <link href="http://yorxika.github.io/2020/01/22/%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/"/>
    <id>http://yorxika.github.io/2020/01/22/%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/</id>
    <published>2020-01-22T15:22:59.000Z</published>
    <updated>2020-01-22T15:29:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第172题阶乘后的零</p><p>给定一个整数 <em>n</em>，返回 <em>n</em>! 结果尾数中零的数量。<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: 3</span></span><br><span class="line"><span class="section">输出: 0</span></span><br><span class="line"><span class="section">解释: 3! = 6, 尾数中没有零。</span></span><br></pre></td></tr></table></figure><hr><p>来源于<a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/q172-factorial-trailing-zeroes-by-ronhou/">题解</a></p><p>计算N的阶乘(<code>N!=1*2*...*N</code>)有多少个后缀0，即计算N!里有多少个10，也就是计算N!里有多少个2和5（<code>数学原理：分解质因数</code>），最后结果即2的个数和5的个数取较小值。因此，得到下面时间复杂度为O(NlogN)的暴力求解的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> nCountTwo = <span class="number">0</span>, nCountFive = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="type">int</span> value = i;</span><br><span class="line"><span class="keyword">while</span> (value % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">++nCountTwo;</span><br><span class="line">value /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (value % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">++nCountFive;</span><br><span class="line">value /= <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">min</span>(nCountTwo, nCountFive);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 不关注其它质因数，用x代替</span><br><span class="line"><span class="number">0</span>! = <span class="number">1</span></span><br><span class="line"><span class="number">1</span>! = <span class="number">1</span></span><br><span class="line"><span class="number">2</span>! = <span class="number">2</span>^<span class="number">1</span> * <span class="number">5</span>^<span class="number">0</span> * <span class="number">1</span></span><br><span class="line"><span class="number">3</span>! = <span class="number">2</span>^<span class="number">1</span> * <span class="number">5</span>^<span class="number">0</span> * <span class="number">3</span></span><br><span class="line"><span class="number">4</span>! = <span class="number">2</span>^<span class="number">3</span> * <span class="number">5</span>^<span class="number">0</span> * <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>! = <span class="number">2</span>^<span class="number">3</span> * <span class="number">5</span>^<span class="number">1</span> * <span class="number">3</span></span><br><span class="line"><span class="number">6</span>! = <span class="number">2</span>^<span class="number">4</span> * <span class="number">5</span>^<span class="number">1</span> * <span class="number">3</span>^<span class="number">2</span></span><br><span class="line"><span class="number">7</span>! = <span class="number">2</span>^<span class="number">4</span> * <span class="number">5</span>^<span class="number">1</span> * x</span><br><span class="line"><span class="number">8</span>! = <span class="number">2</span>^<span class="number">7</span> * <span class="number">5</span>^<span class="number">1</span> * x</span><br><span class="line"><span class="number">9</span>! = <span class="number">2</span>^<span class="number">7</span> * <span class="number">5</span>^<span class="number">1</span> * x</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>! = <span class="number">2</span>^<span class="number">8</span> * <span class="number">5</span>^<span class="number">2</span> * x</span><br><span class="line"><span class="number">11</span>! = <span class="number">2</span>^<span class="number">8</span> * <span class="number">5</span>^<span class="number">2</span> * x</span><br><span class="line"><span class="number">12</span>! = <span class="number">2</span>^<span class="number">10</span> * <span class="number">5</span>^<span class="number">2</span> * x</span><br><span class="line"><span class="number">13</span>! = <span class="number">2</span>^<span class="number">10</span> * <span class="number">5</span>^<span class="number">2</span> * x</span><br><span class="line"><span class="number">14</span>! = <span class="number">2</span>^<span class="number">11</span> * <span class="number">5</span>^<span class="number">2</span> * x</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>! = <span class="number">2</span>^<span class="number">11</span> * <span class="number">5</span>^<span class="number">3</span> * x</span><br><span class="line"><span class="number">16</span>! = <span class="number">2</span>^<span class="number">15</span> * <span class="number">5</span>^<span class="number">3</span> * x</span><br><span class="line"></span><br><span class="line"><span class="number">24</span>! = <span class="number">5</span>^i * x</span><br><span class="line"></span><br><span class="line"><span class="number">25</span>! = <span class="number">5</span>^(i+<span class="number">2</span>) * x</span><br><span class="line"><span class="number">26</span>! = <span class="number">5</span>^(i+<span class="number">2</span>) * x</span><br><span class="line"><span class="number">27</span>! = <span class="number">5</span>^(i+<span class="number">2</span>) * x</span><br><span class="line"><span class="number">28</span>! = <span class="number">5</span>^(i+<span class="number">2</span>) * x</span><br><span class="line"><span class="number">29</span>! = <span class="number">5</span>^(i+<span class="number">2</span>) * x</span><br><span class="line"></span><br><span class="line"><span class="number">30</span>! = <span class="number">5</span>^(i+<span class="number">3</span>) * x</span><br><span class="line"><span class="number">35</span>! = <span class="number">5</span>^(i+<span class="number">4</span>) * x</span><br><span class="line"><span class="number">40</span>! = <span class="number">5</span>^(i+<span class="number">5</span>) * x</span><br><span class="line"><span class="number">45</span>! = <span class="number">5</span>^(i+<span class="number">6</span>) * x</span><br><span class="line"></span><br><span class="line"><span class="number">49</span>! = <span class="number">5</span>^j * x</span><br><span class="line"><span class="number">50</span>! = <span class="number">5</span>^(j+<span class="number">2</span>) * x</span><br><span class="line"><span class="number">51</span>! = <span class="number">5</span>^(j+<span class="number">2</span>) * x</span><br><span class="line"></span><br><span class="line"><span class="number">74</span>! = <span class="number">5</span>^k * x</span><br><span class="line"><span class="number">75</span>! = <span class="number">5</span>^(k+<span class="number">2</span>) * x</span><br><span class="line"><span class="number">76</span>! = <span class="number">5</span>^(k+<span class="number">2</span>) * x</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line"><span class="number">125</span>! = <span class="number">124</span>! * <span class="number">5</span>^<span class="number">3</span></span><br><span class="line"><span class="number">250</span>! = <span class="number">249</span>! * <span class="number">5</span>^<span class="number">3</span> * <span class="number">2</span></span><br><span class="line"><span class="number">375</span>! = <span class="number">374</span>! * <span class="number">5</span>^<span class="number">3</span> * <span class="number">3</span></span><br><span class="line"><span class="number">500</span>! = <span class="number">499</span>! * <span class="number">5</span>^<span class="number">3</span> * <span class="number">4</span></span><br><span class="line"><span class="number">625</span>! = <span class="number">624</span>! * <span class="number">5</span>^<span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的数据我们可以看出以下几点</p><ul><li>N!质因数里2的个数总是要比5的个数多，因此此题就变成了求解<code>N!里有多少个质因数5</code>。这里缺少具体的数学证明，不过解决了这道题，基本就能理解为什么2的个数要比5的个数多了，大致上来说就是<code>每两个数字就会多一个质因数2，而每五个数字才多一个质因数5</code>。</li><li>每5个数字就会多一个质因数5。0~4的阶乘里没有质因数5，5~9的阶乘里有1个质因数5，10~14的阶乘里有2个质因数5，依此类推。</li><li>25!里质因数5的个数要比24!多2个，并不满足上面第3条描述的规律。</li><li>26~49的阶乘仍然满足上面第3条描述的规律；50!里质因数5的个数要比49!多2个，不满足上面第3条描述的规律；51~74的阶乘仍然满足上面第3条描述的规律；依此类推。</li><li>如果上面第3条规律描述成<code>每5个一组，N!里质因数5的个数要比前一组多一个</code>，那么上面两点就可以整理成：<code>每25(5^2)个一组，N!里质因数5的个数要比前一组再多一个</code>；依此类推，还可以继续划分成125(5^3)一组，625(5^4)一组，等等。</li></ul><p>综上</p><ul><li>N!有多少个后缀0，即N!有多少个质因数5。</li><li>N!有多少个质因数5，即N可以划分成多少组5个数字一组，加上划分成多少组25个数字一组，加上划分多少组成125个数字一组，等等。即<code>Ans = N/5 + N/(5^2) + N/(5^3) + ...</code></li><li><code>Ans = N/5 + N/(5^2) + N/(5^3) + ... = ((N / 5) / 5) / 5 /...</code></li><li>最终算法复杂度为O(logN)，代码如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        n /= <span class="number">5</span>;</span><br><span class="line">        cnt += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第172题阶乘后的零&lt;/p&gt;
&lt;p&gt;给定一个整数 &lt;em&gt;n&lt;/em&gt;，返回 &lt;em&gt;n&lt;/em&gt;! 结果尾数中零的数量。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Excel表列序号</title>
    <link href="http://yorxika.github.io/2020/01/22/Excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/"/>
    <id>http://yorxika.github.io/2020/01/22/Excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/</id>
    <published>2020-01-22T15:00:36.000Z</published>
    <updated>2020-01-22T15:08:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第171题Excel表列序号</p><p>给定一个Excel表格中的列名称，返回其相应的列序号。<br><span id="more"></span><br>例如，</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; <span class="number">1</span></span><br><span class="line">B -&gt; <span class="number">2</span></span><br><span class="line">C -&gt; <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Z -&gt; <span class="number">26</span></span><br><span class="line">AA -&gt; <span class="number">27</span></span><br><span class="line">AB -&gt; <span class="number">28</span> </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: &quot;A&quot;</span></span><br><span class="line"><span class="section">输出: 1</span></span><br></pre></td></tr></table></figure><hr><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p>26进制转换思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">titleToNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">null</span> || s.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, len = s.length(),temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">        temp = s.charAt(i) - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        temp *= Math.pow(<span class="number">26</span>,len - i - <span class="number">1</span>);</span><br><span class="line">        sum += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="倒序遍历"><a href="#倒序遍历" class="headerlink" title="倒序遍历"></a>倒序遍历</h3><p>即从字符串的最高位，即进制转换里的最低位开始转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">titleToNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mul</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> c.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        res = res + mul * (c[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">        mul *= <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第171题Excel表列序号&lt;/p&gt;
&lt;p&gt;给定一个Excel表格中的列名称，返回其相应的列序号。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>比较版本号</title>
    <link href="http://yorxika.github.io/2020/01/21/%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    <id>http://yorxika.github.io/2020/01/21/%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/</id>
    <published>2020-01-21T07:52:45.000Z</published>
    <updated>2020-01-21T08:20:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第165题比较版本号</p><p>比较两个版本号 <em>version1</em> 和 <em>version2</em>。<br>如果 <code>*version1* &gt; *version2*</code> 返回 <code>1</code>，如果 <code>*version1* &lt; *version2*</code> 返回 <code>-1</code>， 除此之外返回 <code>0</code>。<br><span id="more"></span><br>你可以假设版本字符串非空，并且只包含数字和 <code>.</code> 字符。</p><p> <code>.</code> 字符不代表小数点，而是用于分隔数字序列。</p><p>例如，<code>2.5</code> 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。</p><p>你可以假设版本号的每一级的默认修订版号为 <code>0</code>。例如，版本号 <code>3.4</code> 的第一级（大版本）和第二级（小版本）修订号分别为 <code>3</code> 和 <code>4</code>。其第三级和第四级修订号均为 <code>0</code>。</p><h3 id="利用split分割"><a href="#利用split分割" class="headerlink" title="利用split分割"></a>利用split分割</h3><p>利用split对字符串进行切割，然后转成Int比较。对于已经遍历完的部分直接赋值为0即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareVersion</span><span class="params">(String version1, String version2)</span> &#123;</span><br><span class="line">    String [] temp1 = version1.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">    String [] temp2 = version2.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span> , p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> v1,v2;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt; temp1.length || p2 &lt; temp2.length)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">num1</span> <span class="operator">=</span> p1 &lt; temp1.length ? temp1[p1] : <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">num2</span> <span class="operator">=</span> p2 &lt; temp2.length ? temp2[p2] : <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        v1 = Integer.parseInt(num1);</span><br><span class="line">        v2 = Integer.parseInt(num2);</span><br><span class="line">        <span class="keyword">if</span> (v1 &gt; v2)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(v1 &lt; v2)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p1++;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分割后字符串比较"><a href="#分割后字符串比较" class="headerlink" title="分割后字符串比较"></a>分割后字符串比较</h3><p>利用Integer.parseInt在一定程度上增加了运行时间并且当数字过大时，可能会溢出，无法比较，因而可以进一步直接用字符串比较。<br>然而提交后还是一样的用时，我傻了。</p><pre><code class="lang-JAVA">    public int compareVersion(String version1, String version2) &#123;        String [] temp1 = version1.split(&quot;\\.&quot;);        String [] temp2 = version2.split(&quot;\\.&quot;);        int p1 = 0 , p2 = 0;        int v1,v2;        while(p1 &lt; temp1.length || p2 &lt; temp2.length)&#123;            String num1 = p1 &lt; temp1.length ? temp1[p1] : &quot;0&quot;;            String num2 = p2 &lt; temp2.length ? temp2[p2] : &quot;0&quot;;            //去掉前导0            v1 = 0;            v2 = 0;            for(int i = 0 ; i &lt; num1.length(); i++)&#123;                if(num1.charAt(i) == &#39;0&#39;)                    v1++;                else                    break;            &#125;            for(int i = 0 ; i &lt; num2.length(); i++)&#123;                if(num2.charAt(i) == &#39;0&#39;)                    v2++;                else                    break;            &#125;            num1 = num1.substring(v1);            num2 = num2.substring(v2);            //开始比较字符串            if(num1.length() &gt; num2.length())                return 1;            else if(num2.length() &gt; num1.length())                return -1;            else            &#123;                for(int i = 0 ; i &lt; num1.length() ; i++)&#123;                    if (num1.charAt(i) - num2.charAt(i) &gt; 0) &#123;                        return 1;                    &#125; else if (num1.charAt(i) - num2.charAt(i) &lt; 0) &#123;                        return -1;                    &#125;                &#125;                p1++;                p2++;            &#125;        &#125;        return 0;    &#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第165题比较版本号&lt;/p&gt;
&lt;p&gt;比较两个版本号 &lt;em&gt;version1&lt;/em&gt; 和 &lt;em&gt;version2&lt;/em&gt;。&lt;br&gt;如果 &lt;code&gt;*version1* &amp;gt; *version2*&lt;/code&gt; 返回 &lt;code&gt;1&lt;/code&gt;，如果 &lt;code&gt;*version1* &amp;lt; *version2*&lt;/code&gt; 返回 &lt;code&gt;-1&lt;/code&gt;， 除此之外返回 &lt;code&gt;0&lt;/code&gt;。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="字符串" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="字符串" scheme="http://yorxika.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>寻找旋转数组中的最小值II</title>
    <link href="http://yorxika.github.io/2020/01/21/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII/"/>
    <id>http://yorxika.github.io/2020/01/21/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII/</id>
    <published>2020-01-21T07:26:26.000Z</published>
    <updated>2020-01-21T07:30:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第154题寻找旋转数组中的最小值II</p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>请找出其中最小的元素。<br><span id="more"></span><br>注意数组中可能存在重复的元素。</p><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [1,3,5]</span></span><br><span class="line"><span class="section">输出: 1</span></span><br></pre></td></tr></table></figure><hr><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>思路同上一题153，只是在判断相等时直接舍弃即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; nums[left] &gt;= nums[right]) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[right])&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right])&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p>可以做一个预处理，保证所有重复数字不在两段里出现即可，再简单化，也就是保证切割的位置不要是重复数字。也就是比较 <code>start</code> 和 <code>end</code> 是否相同，相同的话 <code>end--</code> 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (nums[end] == nums[start] &amp;&amp; end &gt; start) &#123;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[end]) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第154题寻找旋转数组中的最小值II&lt;/p&gt;
&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 &lt;code&gt;[0,1,2,4,5,6,7]&lt;/code&gt; 可能变为 &lt;code&gt;[4,5,6,7,0,1,2]&lt;/code&gt; )。&lt;/p&gt;
&lt;p&gt;请找出其中最小的元素。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="二分查找" scheme="http://yorxika.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>峰值元素</title>
    <link href="http://yorxika.github.io/2020/01/19/%E5%B3%B0%E5%80%BC%E5%85%83%E7%B4%A0/"/>
    <id>http://yorxika.github.io/2020/01/19/%E5%B3%B0%E5%80%BC%E5%85%83%E7%B4%A0/</id>
    <published>2020-01-19T10:19:07.000Z</published>
    <updated>2020-01-21T07:09:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第162题寻找峰值</p><p>峰值元素是指其值大于左右相邻值的元素。</p><p>给定一个输入数组 <code>nums</code>，其中 <code>nums[i] ≠ nums[i+1]</code>，找到峰值元素并返回其索引。</p><p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。<br><span id="more"></span><br>你可以假设 <code>nums[-1] = nums[n] = -∞</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: nums = [1,2,3,1]</span></span><br><span class="line"><span class="section">输出: 2</span></span><br><span class="line"><span class="section">解释: 3 是峰值元素，你的函数应该返回其索引 2。</span></span><br></pre></td></tr></table></figure><hr><h3 id="一次扫描"><a href="#一次扫描" class="headerlink" title="一次扫描"></a>一次扫描</h3><p>因为 <code>nums[-1]</code> 看做负无穷，所以从第 <code>0</code> 个元素开始，它一定是上升的趋势，由于我们要找峰顶，所以当它第一次出现下降，下降前的值就是我们要找的了。</p><p>如果它一直上升到最后一个值，又因为 <code>nums[n]</code> 看做负无穷，所以最后一个值就可以看做一个峰顶。</p><p>题解的解法比我提交时的答案相对的少了很多无谓的判断及比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//第一次下降</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一直上升</span></span><br><span class="line">    <span class="keyword">return</span> nums.length - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>我们可以将 <em>nums</em> 数组中的任何给定序列视为交替的升序和降序序列。通过利用这一点，以及“可以返回任何一个峰作为结果”的要求，我们可以利用二分查找来找到所需的峰值元素。</p><p>在简单的二分查找中，我们处理的是一个有序数列，并通过在每一步减少搜索空间来找到所需要的数字。在本例中，我们对二分查找进行一点修改。首先从数组 nums中找到中间的元素 <em>m<strong>i</strong>d</em>。若该元素恰好位于降序序列或者一个局部下降坡度中（通过将 <em>n<strong>u</strong>m**s</em>[<em>i</em>] 与右侧比较判断)，则说明峰值会在本元素的左边。于是，我们将搜索空间缩小为 <em>m<strong>i</strong>d</em> 的左边(包括其本身)，并在左侧子数组上重复上述过程。</p><p>若该元素恰好位于升序序列或者一个局部上升坡度中（通过将 <em>n<strong>u</strong>m**s</em>[<em>i</em>] 与右侧比较判断)，则说明峰值会在本元素的右边。于是，我们将搜索空间缩小为 <em>m<strong>i</strong>d</em> 的右边，并在右侧子数组上重复上述过程。</p><p>就这样，我们不断地缩小搜索空间，直到搜索空间中只有一个元素，该元素即为峰值元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>])</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第162题寻找峰值&lt;/p&gt;
&lt;p&gt;峰值元素是指其值大于左右相邻值的元素。&lt;/p&gt;
&lt;p&gt;给定一个输入数组 &lt;code&gt;nums&lt;/code&gt;，其中 &lt;code&gt;nums[i] ≠ nums[i+1]&lt;/code&gt;，找到峰值元素并返回其索引。&lt;/p&gt;
&lt;p&gt;数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="二分查找" scheme="http://yorxika.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>相交链表</title>
    <link href="http://yorxika.github.io/2020/01/17/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>http://yorxika.github.io/2020/01/17/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</id>
    <published>2020-01-17T15:50:55.000Z</published>
    <updated>2020-09-02T06:38:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第160题相交链表</p><p>编写一个程序，找到两个单链表相交的起始节点。<br><span id="more"></span><br>如下面的两个链表<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="/2020/01/17/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/01/17/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/160_statement.png" alt="img"></a></p><p>在节点 c1 开始相交。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="/2020/01/17/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/01/17/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/160_example_1.png" alt="img"></a></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = <span class="number">8</span>, listA = [<span class="number">4,1,8,4</span>,<span class="number">5</span>], listB = [<span class="number">5,0,1,8</span>,<span class="number">4</span>,<span class="number">5</span>], skipA = <span class="number">2</span>, skipB = <span class="number">3</span></span><br><span class="line">输出：Reference of the node with value = <span class="number">8</span></span><br><span class="line">输入解释：相交节点的值为 <span class="number">8</span> （注意，如果两个列表相交则不能为 <span class="number">0</span>）。从各自的表头开始算起，链表 <span class="keyword">A</span> 为 [<span class="number">4,1,8,4</span>,<span class="number">5</span>]，链表 B 为 [<span class="number">5,0,1,8</span>,<span class="number">4</span>,<span class="number">5</span>]。在 <span class="keyword">A</span> 中，相交节点前有 <span class="number">2</span> 个节点；在 B 中，相交节点前有 <span class="number">3</span> 个节点。</span><br></pre></td></tr></table></figure><hr><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>遍历链表 <code>A</code> 并将每个结点的地址/引用存储在哈希表中。然后检查链表 <code>B</code> 中的每一个结点 b_i<em>b**i</em> 是否在哈希表中。若在，则 b_i<em>b**i</em> 为相交结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(headA == <span class="literal">null</span> || headB == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA;</span><br><span class="line">    Set&lt;ListNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="literal">null</span>)&#123;</span><br><span class="line">        map.add(p1);</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p1 = headB;</span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.contains(p1))</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        <span class="keyword">else</span> p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><ul><li>创建两个指针 pA 和 pB，分别初始化为链表 <code>A</code> 和 <code>B</code> 的头结点。然后让它们向后逐结点遍历。</li><li>当 pA到达链表的尾部时，将它重定位到链表 <code>B</code> 的头结点 (你没看错，就是链表 <code>B</code>); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 <code>A</code> 的头结点。</li><li>若在某一时刻 pA和 pB 相遇，则 pA/pB为相交结点。</li><li>想弄清楚为什么这样可行, 可以考虑以下两个链表: <code>A=&#123;1,3,5,7,9,11&#125;</code> 和 <code>B=&#123;2,4,9,11&#125;</code>，相交于结点 <code>9</code>。 由于 <code>B.length (=4) &lt; A.length (=6)</code>，pB比 pA少经过 22 个结点，会先到达尾部。将 pB 重定向到 <code>A</code> 的头结点，pA 重定向到 <code>B</code> 的头结点后，pB 要比 pA 多走 <code>2</code> 个结点。因此，它们会同时到达交点。</li><li>如果两个链表存在相交，它们末尾的结点必然相同。因此当 pA/pB 到达链表结尾时，记录下链表 <code>A/B</code> 对应的元素。若最后元素不相同，则两个链表不相交。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(headA == <span class="literal">null</span> || headB == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pa</span> <span class="operator">=</span> headA , pb = headB;</span><br><span class="line">    <span class="keyword">while</span>(pa != pb)&#123;</span><br><span class="line">        pa = pa == <span class="literal">null</span> ? headB : pa.next;</span><br><span class="line">        pb = pb == <span class="literal">null</span> ? headA : pb.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第160题相交链表&lt;/p&gt;
&lt;p&gt;编写一个程序，找到两个单链表相交的起始节点。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="链表" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="链表" scheme="http://yorxika.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>寻找旋转排序数组中的最小值</title>
    <link href="http://yorxika.github.io/2020/01/17/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>http://yorxika.github.io/2020/01/17/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</id>
    <published>2020-01-17T15:42:45.000Z</published>
    <updated>2020-01-17T15:47:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第153题寻找旋转排序数组中的最小值</p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。<br>请找出其中最小的元素。<br>你可以假设数组中不存在重复元素。<br><span id="more"></span><br><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [3,4,5,1,2]</span></span><br><span class="line"><span class="section">输出: 1</span></span><br></pre></td></tr></table></figure><hr><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>由于给定的数组是有序的，我们就可以使用二分搜索。</p><ol><li>找到数组的中间元素 <code>mid</code>。</li><li>如果<code>中间元素 &gt; 数组第一个元素</code>，我们需要在 <code>mid</code> 右边搜索变化点。</li><li>如果<code>中间元素 &lt; 数组第一个元素</code>，我们需要在 <code>mid</code> 做边搜索变化点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left&lt;right &amp;&amp; nums[left] &gt; nums[right]) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid]&gt;=nums[left])&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第153题寻找旋转排序数组中的最小值&lt;/p&gt;
&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;br&gt;( 例如，数组 &lt;code&gt;[0,1,2,4,5,6,7]&lt;/code&gt; 可能变为 &lt;code&gt;[4,5,6,7,0,1,2]&lt;/code&gt; )。&lt;br&gt;请找出其中最小的元素。&lt;br&gt;你可以假设数组中不存在重复元素。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数组" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="二分查找" scheme="http://yorxika.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>颠倒二进制位</title>
    <link href="http://yorxika.github.io/2020/01/16/%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"/>
    <id>http://yorxika.github.io/2020/01/16/%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</id>
    <published>2020-01-16T09:05:50.000Z</published>
    <updated>2020-01-16T09:20:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自Leetcode第190题颠倒二进制位</p><p>颠倒给定的 32 位无符号整数的二进制位。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: 00000010100101000001111010011100</span></span><br><span class="line"><span class="section">输出: 00111001011110000010100101000000</span></span><br><span class="line"><span class="section">解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，</span></span><br><span class="line">      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</span><br></pre></td></tr></table></figure><hr><h3 id="Integer-reverse"><a href="#Integer-reverse" class="headerlink" title="Integer.reverse()"></a>Integer.reverse()</h3><pre><code>public int reverseBits(int n) &#123;    return Integer.reverse(n);&#125;</code></pre><h3 id="错位交换"><a href="#错位交换" class="headerlink" title="错位交换"></a>错位交换</h3><p>其实就是Integer.reverse的源码。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">初始为</span> <span class="string">abcdefghijklmnopqrstuvwxyz012345</span></span><br><span class="line"><span class="string">第一步结果:</span>  <span class="string">qrstuvwxyz012345</span>  <span class="string">abcdefghijklmnop</span>               </span><br><span class="line"><span class="string">第二步结果:</span>  <span class="string">yz012345</span> <span class="string">qrstuvwx</span>   <span class="string">ijklmnop</span> <span class="string">abcdefgh</span>           </span><br><span class="line"><span class="string">第三步结果:</span>  <span class="number">2345 </span><span class="string">yz01</span> <span class="string">uvwx</span> <span class="string">qrst</span>  <span class="string">mnop</span>  <span class="string">ijkl</span> <span class="string">efgh</span> <span class="string">abcd</span> </span><br><span class="line"><span class="string">第四步结果:</span>  <span class="number">45</span> <span class="number">23</span> <span class="number">01</span> <span class="string">yz</span> <span class="string">wx</span> <span class="string">uv</span> <span class="string">st</span> <span class="string">qr</span>  <span class="string">op</span> <span class="string">mn</span> <span class="string">kl</span> <span class="string">ij</span> <span class="string">gh</span> <span class="string">ef</span> <span class="string">cd</span> <span class="string">ab</span> </span><br><span class="line"><span class="string">第五步结果:</span>  <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="string">z</span> <span class="string">y</span> <span class="string">x</span> <span class="string">w</span> <span class="string">v</span> <span class="string">u</span> <span class="string">t</span> <span class="string">s</span> <span class="string">r</span> <span class="string">q</span>  <span class="string">p</span> <span class="string">o</span> <span class="string">n</span> <span class="string">m</span> <span class="string">l</span> <span class="string">k</span> <span class="string">j</span> <span class="string">i</span> <span class="string">h</span> <span class="string">g</span> <span class="string">f</span> <span class="string">e</span> <span class="string">d</span> <span class="string">c</span> <span class="string">b</span> <span class="string">a</span></span><br></pre></td></tr></table></figure><p>这种换法本质是错位法 即创造两个互相错位的数据 这样保证数据不会丢失</p><p>好比两排16个的麻将 一排拿掉后边8个, 再右移8个单位, 另一排拿掉前面8个, 再左移8个单位, 再合并, 那么便得到了一排16个的麻将 但前8和后8的相对位置不变, 但整体位置却前后变换了. 再一排拿掉中间的4个, 右移4位 另一排同理 再合并. 所以这个算法实际上模拟的这个过程. 下面用数字解释:</p><p>如何创造? 先屏蔽 再移位 比如要创造4位错位, 即12345678换位56781234, 那么先屏蔽5678得到12340000, 移位得到00001234, 同理可得56780000, 再加起来得到56781234; 然后再2位错位, 即屏蔽得到56001200, 移位得到00560012, 同理可得78003400, 加起来得到78563412; 再创造一位错位, 即先屏蔽得到70503010,移位得到07050301, 同理可得80604020, 加起来就是最后结果即87654321.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverseBits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    n = ((n &amp; <span class="number">0xffff0000</span>) &gt;&gt;&gt; <span class="number">16</span>) | ((n &amp; <span class="number">0x0000ffff</span>) &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h3><p>用一个变量 <code>res</code> 去存储结果，依次得到要转换数字的低位，然后依次保存到 <code>res</code> 中。<code>res</code> 每得到一位后进行左移腾出位置保存下一位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverseBits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">32</span>) &#123;</span><br><span class="line">        res &lt;&lt;= <span class="number">1</span>;  <span class="comment">//res 左移一位空出位置</span></span><br><span class="line">        res |= (n &amp; <span class="number">1</span>); <span class="comment">//得到的最低位加过来</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;<span class="comment">//原数字右移一位去掉已经处理过的最低位</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自Leetcode第190题颠倒二进制位&lt;/p&gt;
&lt;p&gt;颠倒给定的 32 位无符号整数的二进制位。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="数学" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="位运算" scheme="http://yorxika.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>将有序数组转化为二叉搜索树</title>
    <link href="http://yorxika.github.io/2020/01/16/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yorxika.github.io/2020/01/16/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-01-16T06:58:43.000Z</published>
    <updated>2020-01-16T07:02:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第108题将有序数组转化为二叉搜索树</p><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。<br><span id="more"></span><br><strong>示例:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定有序数组: [<span class="string">-10</span>,<span class="string">-3</span>,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,<span class="string">-3</span>,9,<span class="string">-10</span>,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   <span class="string">-3</span>   9</span><br><span class="line">   /   /</span><br><span class="line"> <span class="string">-10</span>  5</span><br></pre></td></tr></table></figure><h3 id="中点作为根节点"><a href="#中点作为根节点" class="headerlink" title="中点作为根节点"></a>中点作为根节点</h3><p>数组的中点就是根节点，然后将数组截断，以此类推</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> nums.length / <span class="number">2</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">    <span class="keyword">if</span>(mid &gt; <span class="number">0</span>) </span><br><span class="line">        root.left = sortedArrayToBST(Arrays.copyOfRange(nums,<span class="number">0</span>,mid));</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; nums.length - <span class="number">1</span>)</span><br><span class="line">    root.right = sortedArrayToBST(Arrays.copyOfRange(nums,mid + <span class="number">1</span>,nums.length));</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第108题将有序数组转化为二叉搜索树&lt;/p&gt;
&lt;p&gt;将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。&lt;/p&gt;
&lt;p&gt;本题中，一个高度平衡二叉树是指一个二叉树&lt;em&gt;每个节点&lt;/em&gt; 的左右两个子树的高度差的绝对值不超过 1。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="http://yorxika.github.io/2020/01/16/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yorxika.github.io/2020/01/16/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-01-16T06:33:49.000Z</published>
    <updated>2020-01-16T07:04:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第110题平衡二叉树</p><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过1。<br><span id="more"></span><br><strong>示例 1:</strong></p></blockquote><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / <span class="string">\</span></span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  <span class="string">\</span></span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回 <code>true</code> 。</p><h3 id="自底向上的递归"><a href="#自底向上的递归" class="headerlink" title="自底向上的递归"></a>自底向上的递归</h3><p>这道题和求树的高度是一样的，只是在递归求解的时候需要判断树的左右高度是否是平衡的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    hlper(root);</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hlper</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">height_l</span> <span class="operator">=</span> <span class="number">0</span>,height_r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="literal">null</span>)</span><br><span class="line">        height_l = <span class="number">1</span> + hlper(root.left);</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="literal">null</span>)</span><br><span class="line">        height_r = <span class="number">1</span> + hlper(root.right);</span><br><span class="line">    <span class="keyword">if</span>(Math.abs(height_l - height_r) &gt; <span class="number">1</span>)</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(height_l,height_r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分支-限界"><a href="#分支-限界" class="headerlink" title="分支 - 限界"></a>分支 - 限界</h3><p>当递归求解出现左右子树高度相差大于1的情况时，记返回值为-1，这样遇到-1，就可以一路返回上一层，避免了多余的计算。<br>来自<a href="https://leetcode-cn.com/problems/balanced-binary-tree/solution/ti-qian-zu-duan-fa-gei-da-lao-de-xie-fa-xie-zhu-sh/">题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//-1 即为存在层数相差大于1</span></span><br><span class="line"><span class="keyword">return</span> depth(root)!=-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以当前节点为根节点的树的层数</span></span><br><span class="line"><span class="comment"> * 返回-1的话说明 不满足要求不用求了直接 -1 退出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//当前节点不存在其层数为0</span></span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取左节点的层数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> depth(root.left);</span><br><span class="line">        <span class="comment">//如果层数为-1直接截断</span></span><br><span class="line"><span class="keyword">if</span>(left==-<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//获取右节点的层数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> depth(root.right);</span><br><span class="line"><span class="comment">//如果层数为-1直接退出</span></span><br><span class="line">        <span class="keyword">if</span>(right==-<span class="number">1</span>)<span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//如果左右节点层数相差大于1 直接返回-1 否则返回真实层数</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(left-right)&lt;<span class="number">2</span>?Math.max(left,right)+<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第110题平衡二叉树&lt;/p&gt;
&lt;p&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;/p&gt;
&lt;p&gt;本题中，一棵高度平衡二叉树定义为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个二叉树&lt;em&gt;每个节点&lt;/em&gt; 的左右两个子树的高度差的绝对值不超过1。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="树" scheme="http://yorxika.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记I</title>
    <link href="http://yorxika.github.io/2020/01/16/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yorxika.github.io/2020/01/16/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-01-16T03:36:47.000Z</published>
    <updated>2020-03-20T02:54:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。<br><span id="more"></span><br>C++ 引用 vs 指针</p><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><p>引用的好处之一就是在函数调用时在内存中不会生成副本。</p><p>引用总结</p><ul><li>在引用的使用中，单纯给某个变量取个别名是毫无意义的，引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。</li><li>用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过<strong>const</strong>的使用，保证了引用传递的安全性。</li><li>引用与指针的区别是，指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。</li><li>使用引用的时机。流操作符<strong>&lt;&lt;</strong>和<strong>&gt;&gt;</strong>、赋值操作符<strong>=</strong>的返回值、拷贝构造函数的参数、赋值操作符<strong>=</strong>的参数、其它情况都推荐使用引用。</li><li>声明引用时，必须同时对其进行初始化。</li><li>引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。ra=1; 等价于 a=1; </li><li>声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。故：对引用求地址，就是对目标变量求地址。&amp;ra与&amp;a相等。</li><li>不能建立数组的引用。因为数组是一个由若干个元素所成的集合，所以无法建立一个数组的别名。</li><li>不能建立引用的引用，不能建立指向引用的指针。因为引用不是一种数据类型！！所以没有引用的引用，没有引用的指针。<br>引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。</li></ul><p>引用的声明方法：类型标识符<strong>&amp;</strong>引用名=目标变量名；</p><h3 id="引用应用"><a href="#引用应用" class="headerlink" title="引用应用"></a>引用应用</h3><h4 id="引用作为参数"><a href="#引用作为参数" class="headerlink" title="引用作为参数"></a>引用作为参数</h4><p>引用的一个重要作用就是作为函数的参数。以前的C语言中函数参数传递是值传递，如果有大块数据作为参数传递的时候，采用的方案往往是指针，因为这样可以避免将整块数据全部压栈，可以提高程序的效率。但是现在（C++中）又增加了一种同样有效率的选择（在某些特殊情况下又是必须的选择），就是引用。</p><p>递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。</p><p>使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</p><p>使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</p><h4 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h4><p>常引用声明方式：const 类型标识符 &amp;引用名=目标变量名；</p><p>用这种方式声明的引用，不能通过引用对目标变量的值进行修改,从而使引用的目标成为const，达到了引用的安全性。</p><h4 id="引用作为返回值"><a href="#引用作为返回值" class="headerlink" title="引用作为返回值"></a>引用作为返回值</h4><p>要以引用返回函数值，则函数定义时要按以下格式：<br>类型标识符 &amp;函数名（形参列表及类型说明）<br>{函数体}</p><p>说明：<br>（1）以引用返回函数值，定义函数时需要在函数名前加&amp;<br>（2）用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。</p><p>引用作为返回值，必须遵守以下规则：<br>（1）不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了”无所指”的引用，程序会进入未知状态。 </p><p>（2）不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak(内存泄露)。</p><p>（3）可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。</p><p>（4）引用与一些操作符的重载：流操作符&lt;&lt;和&gt;&gt;，这两个操作符常常希望被连续使用，例如：cout &lt;&lt; “hello” &lt;&lt; endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个&lt;&lt;操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用&lt;&lt;操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。 赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。</p><p>（5）在另外的一些操作符中，却千万不能返回引用：+-*/ 四则运算符。它们不能返回引用，Effective C++[1]的Item23详细的讨论了这个问题。主要原因是这四个操作符没有side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个new分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第2、3两个方案都被否决了。静态对象的引用又因为((a+b) == (c+d))会永远为true而导致错误。所以可选的只剩下返回一个对象了。</p><h4 id="引用和多态"><a href="#引用和多态" class="headerlink" title="引用和多态"></a>引用和多态</h4><p>引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。</p><p>【例7】：<br>class 　A;<br>class 　B：public A{……};<br>B 　b;<br>A 　&amp;Ref = b;  // 用派生类对象初始化基类对象的引用<br>Ref 只能用来访问派生类对象中从基类继承下来的成员，是基类引用指向派生类。如果A类中定义有虚函数，并且在B类中重写了这个虚函数，就可以通过Ref产生多态效果。</p><h2 id="顶层const与底层const"><a href="#顶层const与底层const" class="headerlink" title="顶层const与底层const"></a>顶层const与底层const</h2><p>2.4.3.Top-Level const<br>As we’ve seen, a pointer is an object that can point to a different object. As a result,we can talk independently about whether a pointer is const and whether the objects to which it can point are const. We use the term <strong>top-level const</strong> to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer to that const as a <strong>low-level const</strong>.</p><p>指针本身是一个对象，因为，指针实际对应着内存单元的一段存储空间，然而，指针所指向的也是一个数据对象，因此，指针是一个常量与指针所指向的是一个常量是两个完全不同的概念， <strong>顶层 const</strong> 表示的是 <strong>指针本身是一个常量</strong>， <strong>底层 const</strong> 表示的是 <strong>指针所指的对象是一个常量</strong>，更一般情况下， <strong>顶层 const 可以表示任意对象是一个常量</strong>，这对于算术类型、类、指针等任何数据类型都是成立的， <strong>底层 const 则与指针和引用等复合类型的基本类型部分有关</strong> ，比较特殊的是，指针既可以是顶层 const 也可以是底层 const ，这一点与其他类型区别明显。</p><p>顶层和底层的翻译很容易让人误解为就只有两层，实际上当然是不是的。首先我们假设有这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> Const = <span class="type">const</span> T;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> Ptr = T*;</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *** <span class="type">const</span> shit = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>要怎么看呢？很简单，不要用const和*，用Const和Ptr来表达，马上明白：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Const&lt;Ptr&lt;Ptr&lt;Ptr&lt;Const&lt;<span class="type">int</span>&gt;&gt;&gt;&gt;&gt; shit = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>从右向左读，星号读作pointer，没多一层加一个to，然后最前面加上declare就行。比如对const int <em>*</em> const shit;，可以读作：declare shit as const pointer to pointer to pointer to const int。</p><h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><p><code>constexpr</code> 说明符声明可以在编译时求得函数或变量的值。然后这些变量和函数（若给定了合适的函数实参）即可用于仅允许编译时<a href="https://zh.cppreference.com/w/cpp/language/constant_expression">常量表达式</a>之处。用于对象或非静态成员函数 (C++14 前)声明的 constexpr 说明符蕴含 const。用于函数声明的 constexpr 说明符或 <a href="https://zh.cppreference.com/w/cpp/language/static">static</a> 成员变量 (C++17 起)蕴含 inline。若函数或函数模板的任何声明拥有 <code>constexpr</code> 说明符，则每个声明必须都含有该说明符。</p><p><strong>constexpr 变量</strong>必须满足下列要求：</p><ul><li>其类型必须是<a href="https://zh.cppreference.com/w/cpp/named_req/LiteralType"><em>字面类型</em> (<em>LiteralType</em>) </a>。</li><li>它必须被立即初始化</li><li>其初始化的<a href="https://zh.cppreference.com/w/cpp/language/eval_order">全表达式</a>，包括所有隐式转换、构造函数调用等，都必须是<a href="https://zh.cppreference.com/w/cpp/language/constant_expression">常量表达式</a></li></ul><p><strong>constexpr 函数</strong>必须满足下列要求：</p><ul><li>它必须非<a href="https://zh.cppreference.com/w/cpp/language/virtual">虚</a> </li></ul><h2 id="显示强制转换"><a href="#显示强制转换" class="headerlink" title="显示强制转换"></a>显示强制转换</h2><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>用法：static_cast &lt; type-id &gt; ( expression )，</p><p>该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性，它主要有如下几种用法：</p><ol><li>用于基本数据类型之间的转换，如把int转换为char，把int转换成enum，但这种转换的安全性需要开发者自己保证（这可以理解为保证数据的精度，即程序员能不能保证自己想要的程序安全），如在把int转换为char时，如果char没有足够的比特位来存放int的值（int&gt;127或int&lt;-127时），那么static_cast所做的只是简单的截断，及简单地把int的低8位复制到char的8位中，并直接抛弃高位。</li><li>把空指针转换成目标类型的空指针</li><li>把任何类型的表达式类型转换成void类型</li><li>用于类层次结构中父类和子类之间指针和引用的转换。</li></ol><p>对于以上第（4）点，存在两种形式的转换，即上行转换（子类到父类）和下行转换（父类到子类）。对于static_cast，上行转换时安全的，而下行转换时不安全的，为什么呢？因为static_cast的转换时粗暴的，它仅根据类型转换语句中提供的信息（尖括号中的类型）来进行转换，这种转换方式对于上行转换，由于子类总是包含父类的所有数据成员和函数成员，因此从子类转换到父类的指针对象可以没有任何顾虑的访问其（指父类）的成员。而对于下行转换为什么不安全，是因为static_cast只是在编译时进行类型坚持，没有运行时的类型检查，具体原理在dynamic_cast中说明。</p><p><strong>一句话概括：</strong></p><p>仅当类型之间可隐式转换时（除类层次间的下行转换以外），static_cast的转换才是合法的，否则将产生错误。（基类指针或引用转换成子类指针或引用为下行转换）</p><p>类层次间的下行转换不能通过隐式转换完成，但是可以通过static_cast完成，但是由于没有动态类型检查，所以是不安全的。。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d=<span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> i=d;    <span class="comment">//编译器的隐式转换，等价于下面这条语句</span></span><br><span class="line"><span class="type">int</span> i= <span class="keyword">static_cast</span> &lt;<span class="type">int</span>&gt;(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指针之间的转换*/</span></span><br><span class="line"><span class="type">char</span> str[]=<span class="string">&quot;good&quot;</span>;</span><br><span class="line"><span class="type">char</span> *ptr=str;</span><br><span class="line"><span class="type">int</span> *p=<span class="built_in">static_cast</span>&lt;<span class="type">int</span> *&gt;(ptr);<span class="comment">//编译错误，两者之间的转换要显式，如下</span></span><br><span class="line"><span class="type">int</span> *p=(<span class="type">int</span> *)(ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">child</span>:<span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line">  </span><br><span class="line">Base b;</span><br><span class="line">child c;</span><br><span class="line">c=<span class="built_in">static_cast</span>&lt;child *&gt;(b);  <span class="comment">//下行转换，正确；</span></span><br><span class="line">c=b;    <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>只用使用const_cast才能将const性质转换掉。在这种情况下，试图使用其他三种形式的强制转换都会导致编译时的错误。类似地，除了<strong>添加或者删除const特性</strong>，用const_cast符来执行其他任何类型转换，都会引起编译错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> val=<span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> *ptr=<span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*为了使ptr指向val，使用const_cast*/</span></span><br><span class="line">ptr=<span class="built_in">const_cast</span>&lt;<span class="type">double</span> *&gt;(&amp;val);</span><br></pre></td></tr></table></figure><p>在《C++ primer》（第五版）中是这样介绍const_cast的：</p><p>const_cast只能改变运算对象的底层const</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *pc;</span><br><span class="line"><span class="type">char</span> *p=<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pc);<span class="comment">//正确但是通过p写值是未定义的行为</span></span><br></pre></td></tr></table></figure><p>对于将常量对象转换成非常量对象的行为，我们一般称其为“去掉const性质（cast away the const）”。一旦我们去掉了某个对象的const性质，编译器就不再阻止我们对该对象进行写操作了。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果。</p><p>只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。同样的，也不能用const_cast改变表达式的 类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* cp;</span><br><span class="line"><span class="comment">//错误：static_cast不能转换const的性质</span></span><br><span class="line"><span class="type">char</span> *q=<span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(cp);</span><br><span class="line"><span class="built_in">static_cast</span>&lt;string&gt;(cp);<span class="comment">//正确：字符串字面值转换为string类型</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;string&gt;(cp);<span class="comment">//const_cast只改变常量属性</span></span><br></pre></td></tr></table></figure><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>从语法上看，这个操作符仅用于指针类型的转换（返回值是指针）。它用来将一个类型指针转换为另一个类型指针，它只需在编译时重新解释指针的类型。这个操作符基本不考虑转换类型之间是否是相关的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip=<span class="literal">NULL</span>;</span><br><span class="line"><span class="type">char</span> *pc=<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(ip);</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*注：必须牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用</span></span><br><span class="line"><span class="comment">*就可能在运行时发生错误*/</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</p><p>在《C++ Primer（中文 第五版 ）》指出reinterpret_cast很危险，不建议使用。</p><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>该运算符把expression转换成type类型的对象。type必须是类型的指针、类的引用或者void*。type和expression的形式要对应，如果type是指针类型，那么expression也必须是一个指针，如果type是一个引用，那么expression也必须是一个引用。</p><p>static_cast只在编译时进行类型检查，与其他强制类型转换不同，dynamic_cast涉及运行时类型检查。dynamic_cast运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表，故对没有虚函数表的类使用会导致dynamic_cast编译错误。</p><p>所以dynamic_cast主要用于类层次结构中父类和子类之间指针和引用的转换，由于具有运行时类型检查，因此可以保证下行转换的安全性，何为安全性？即转换成功就返回转换后的正确类型指针，如果转换失败，则返回NULL（如果是转换到引用类型的dynamic_cast失败，则抛出bad_cast类型的异常），之所以说static_cast在下行转换时不安全，是因为即使转换失败，它也不返回NULL。</p><p>另外，若绑定到引用或指针的对象类型不是目标类型，则dynamic_cast会失败（这点下面细说）。若转换到指针的失败，dynamic_cast的结果是0值，若转换到引用类型的失败，则抛出一个bad_cast类型的异常。</p><p>dynamic_cast主要符主要用于类层次间的上行转换和下行转换。</p><ol><li>在类层次间上行转换时，dynamic_cast和static_cast的效果一样。因为在公有继承方式（保护继承、私有继承，不能隐式转换）下，派生类的对象/对象指针/对象引用可以赋值给基类的对象/对象指针/对象引用（发生隐式转换），反过来则不行。</li><li>若发生下行转换是安全的，也就是，如果基类指针或者引用的确指向一个派生类对象，这个运算符会传回转型过的指针，若不安全，则会传回空指针。</li></ol><p>针对下行转换，换句话说：向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">Base</span>():<span class="built_in">b</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">     <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">Derived</span>():<span class="built_in">d</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">     <span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Base *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     Derived *pd1=<span class="built_in">static_cast</span>&lt;Derived *&gt;(p);     <span class="comment">//语句1</span></span><br><span class="line">     cout&lt;&lt;pd1-&gt;b&lt;&lt;endl;</span><br><span class="line">     cout&lt;&lt;pd1-&gt;d&lt;&lt;endl;</span><br><span class="line">     Derived *pd2=<span class="built_in">dynamic_cast</span>&lt;Derived *&gt;(p);    <span class="comment">//语句2</span></span><br><span class="line">     cout&lt;&lt;pd2-&gt;b&lt;&lt;endl;</span><br><span class="line">     cout&lt;&lt;pd2-&gt;d&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>若调用函数func的实参p指向一个Derived类型的对象，即<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base *p=<span class="keyword">new</span> Derived;</span><br><span class="line"><span class="built_in">func</span>(p);</span><br></pre></td></tr></table></figure>则pd1和pd2是一样的，并且对这两个指针执行 Derived类的任何操作都是安全的，语句1和2都是输出1、2；</li><li>若p指向的是一个Base类型的对象，即<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base *p=<span class="keyword">new</span> Base;</span><br><span class="line"><span class="built_in">func</span>(p);</span><br></pre></td></tr></table></figure>那么pd1指向Base对象的地址，对它进行Derived类型的操作将是不安全的（如访问d），输出d的值时，将会是一个垃圾值；而pd2将是一个空指针，对空指针进行操作，将会发生异常。</li></ol><h2 id="异常处理-try-catch"><a href="#异常处理-try-catch" class="headerlink" title="异常处理(try catch)"></a>异常处理(try catch)</h2><h3 id="C-异常机制概述"><a href="#C-异常机制概述" class="headerlink" title="C++异常机制概述"></a>C++异常机制概述</h3><p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p><p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p><ul><li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li><li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li><li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li></ul><p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e1 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e2 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName eN )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常事件发生时，程序使用throw关键字抛出异常表达式，抛出点称为异常出现点，由操作系统为程序设置当前异常对象，然后执行程序的当前异常处理代码块，在包含了异常出现点的最内层的<strong>try</strong>块，依次匹配catch语句中的异常对象（只进行类型匹配，catch参数有时在catch语句中并不会使用到）。若匹配成功，则执行catch块内的异常处理语句，然后接着执行<strong>try…catch…</strong>块之后的代码。如果在当前的try…catch…块内找不到<strong>匹配</strong>该异常对象的catch语句,则由更外层的try…catch…块来处理该异常；如果当前函数内所有的try…catch…块都不能匹配该异常，则递归回退到调用栈的上一层去处理该异常。如果一直退到主函数main()都不能处理该异常，则调用系统函数terminate()终止程序。</p><p>执行throw语句时，throw表达式将作为对象被复制构造为一个新的对象，称为异常对象。异常对象放在内存的特殊位置，该位置既不是栈也不是堆，在window上是放在线程信息块TIB中。这个构造出来的新对象与本级的try所对应的catch语句进行<strong>类型匹配</strong>，类型匹配的原则在下面介绍。</p><p><img src="/2020/01/16/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01/16/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/610439-20160117105031678-298323359.png" alt="img"></p><h3 id="异常对象"><a href="#异常对象" class="headerlink" title="异常对象"></a>异常对象</h3><p><strong>异常对象</strong>是一种特殊的对象，编译器依据异常抛出表达式复制构造异常对象，这要求抛出异常表达式不能是一个不完全类型（一个类型在声明之后定义之前为一个不完全类型。不完全类型意味着该类型没有完整的数据与操作描述），而且可以进行复制构造，这就要求异常抛出表达式的复制构造函数（或移动构造函数）、析构函数不能是私有的。</p><p>异常对象不同于函数的局部对象，局部对象在函数调用结束后就被自动销毁，而异常对象将驻留在所有可能被激活的catch语句都能访问到的内存空间中，也即上文所说的TIB。当异常对象与catch语句成功匹配上后，在该catch语句的结束处被自动析构。</p><p>在函数中返回局部变量的引用或指针几乎肯定会造成错误，同样的道理，在throw语句中抛出局部变量的指针或引用也几乎是错误的行为。如果指针所指向的变量在执行catch语句时已经被销毁，对指针进行解引用将发生意想不到的后果。</p><p>throw出一个表达式时，该表达式的静态编译类型将决定异常对象的类型。所以当throw出的是基类指针的解引用，而该指针所指向的实际对象是派生类对象，此时将发生派生类对象切割。</p><p>除了抛出用户自定义的类型外，C++标准库定义了一组类，用户报告标准库函数遇到的问题。这些标准库异常类只定义了几种运算，包括创建或拷贝异常类型对象，以及为异常类型的对象赋值。</p><p>C++ 提供了一系列标准的异常，定义在 <em>**</em> 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：</p><p><img src="/2020/01/16/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01/16/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/exceptions_in_cpp.png" alt="C++ 异常的层次结构"></p><div class="table-container"><table><thead><tr><th>标准异常类</th><th>描述</th><th>头文件</th></tr></thead><tbody><tr><td>exception</td><td>最通用的异常类，只报告异常的发生而不提供任何额外的信息</td><td>exception</td></tr><tr><td>runtime_error</td><td>只有在运行时才能检测出的错误</td><td>stdexcept</td></tr><tr><td>rang_error</td><td>运行时错误：产生了超出有意义值域范围的结果</td><td>stdexcept</td></tr><tr><td>overflow_error</td><td>运行时错误：计算上溢</td><td>stdexcept</td></tr><tr><td>underflow_error</td><td>运行时错误：计算下溢</td><td>stdexcept</td></tr><tr><td>logic_error</td><td>程序逻辑错误</td><td>stdexcept</td></tr><tr><td>domain_error</td><td>逻辑错误：参数对应的结果值不存在</td><td>stdexcept</td></tr><tr><td>invalid_argument</td><td>逻辑错误：无效参数</td><td>stdexcept</td></tr><tr><td>length_error</td><td>逻辑错误：试图创建一个超出该类型最大长度的对象</td><td>stdexcept</td></tr><tr><td>out_of_range</td><td>逻辑错误：使用一个超出有效范围的值</td><td>stdexcept</td></tr><tr><td>bad_alloc</td><td>内存动态分配错误</td><td>new</td></tr><tr><td>bad_cast</td><td>dynamic_cast类型转换出错</td><td>type_info</td></tr><tr><td>bad_exception</td><td>这在处理 C++ 程序中无法预期的异常时非常有用。</td><td>exception</td></tr><tr><td>bad_typeid</td><td>该异常可以通过 <strong>typeid</strong> 抛出。</td><td>typeinfo</td></tr></tbody></table></div><h3 id="catch-关键字"><a href="#catch-关键字" class="headerlink" title="catch 关键字"></a>catch 关键字</h3><p>catch语句匹配被抛出的异常对象。如果catch语句的参数是引用类型，则该参数可直接作用于异常对象，即参数的改变也会改变异常对象，而且在catch中<strong>重新抛出异常</strong>时会继续传递这种改变。如果catch参数是传值的，则复制构函数将依据异常对象来构造catch参数对象。在该catch语句结束的时候，先析构catch参数对象，然后再析构异常对象。</p><p>在进行异常对象的匹配时，编译器不会做任何的隐式类型转换或类型提升。除了以下几种情况外，异常对象的类型必须与catch语句的声明类型完全匹配：</p><ul><li>允许从非常量到常量的类型转换。</li><li>允许派生类到基类的类型转换。</li><li>数组被转换成指向数组（元素）类型的指针。</li><li>函数被转换成指向函数类型的指针。</li></ul><p>寻找catch语句的过程中，匹配上的未必是类型完全匹配那项，而在是最靠前的第一个匹配上的catch语句（我称它为最先匹配原则）。所以，派生类的处理代码catch语句应该放在基类的处理catch语句之前，否则先匹配上的总是参数类型为基类的catch语句，而能够精确匹配的catch语句却不能够被匹配上。</p><p>在catch块中，如果在当前函数内无法解决异常，可以继续向外层抛出异常，让外层catch异常处理块接着处理。此时可以使用不带表达式的throw语句将捕获的异常重新抛出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span>(type x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//做了一部分处理</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被重新抛出的异常对象为保存在TIB中的那个异常对象，与catch的参数对象没有关系，若catch参数对象是引用类型，可能在catch语句内已经对异常对象进行了修改，那么重新抛出的是修改后的异常对象；若catch参数对象是非引用类型，则重新抛出的异常对象并没有受到修改。</p><p>使用catch(…){}可以捕获所有类型的异常，根据最先匹配原则，catch(…){}应该放在所有catch语句的最后面，否则无法让其他可以精确匹配的catch语句得到匹配。通常在catch(…){}语句中执行当前可以做的处理，然后再重新抛出异常。注意，catch中重新抛出的异常只能被外层的catch语句捕获。</p><h3 id="栈展开、RAII"><a href="#栈展开、RAII" class="headerlink" title="栈展开、RAII"></a>栈展开、RAII</h3><p>其实栈展开已经在前面说过，就是从异常抛出点一路向外层函数寻找匹配的catch语句的过程，寻找结束于某个匹配的catch语句或标准库函数terminate。这里重点要说的是栈展开过程中对局部变量的销毁问题。我们知道，在函数调用结束时，函数的局部变量会被系统自动销毁，类似的，throw可能会导致调用链上的语句块提前退出，此时，语句块中的局部变量将按照构成生成顺序的逆序，依次调用析构函数进行对象的销毁。例如下面这个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个没有任何意义的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() :<span class="built_in">a</span>(<span class="number">0</span>)&#123; cout &lt;&lt; <span class="string">&quot;A默认构造函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span>  A&amp; rsh)&#123; cout &lt;&lt; <span class="string">&quot;A复制构造函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123; cout &lt;&lt; <span class="string">&quot;A析构函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>  a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            A a ;</span><br><span class="line">            <span class="keyword">throw</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (A a)</span><br><span class="line">        &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序将输出：<br><img src="/2020/01/16/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01/16/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/610439-20160117104044460-1503720621.png" alt="img"></p><p>定义变量a时调用了默认构造函数，使用a初始化异常变量时调用了复制构造函数，使用异常变量复制构造catch参数对象时同样调用了复制构造函数。三个构造对应三个析构，也即try语句块中局部变量a自动被析构了。然而，如果a是在自由存储区上分配的内存时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        A * a= <span class="keyword">new</span> A;</span><br><span class="line">        <span class="keyword">throw</span> *a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (A a)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果：<br><img src="/2020/01/16/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01/16/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/610439-20160117104140975-1118592832.png" alt="img"></p><p>同样的三次构造，却只调用了两次的析构函数！说明a的内存在发生异常时并没有被释放掉，发生了内存泄漏。<br><strong>RAII机制有助于解决这个问题</strong>，RAII（Resource acquisition is initialization，资源获取即初始化）。它的思想是<strong>以对象管理资源</strong>。为了更为方便、鲁棒地释放已获取的资源，避免资源死锁，一个办法是把资源数据用对象封装起来。程序发生异常，执行栈展开时，封装了资源的对象会被自动调用其析构函数以释放资源。C++中的智能指针便符合RAII。关于这个问题详细可以看<strong>《Effective C++》条款13.</strong></p><h3 id="异常机制与构造函数"><a href="#异常机制与构造函数" class="headerlink" title="异常机制与构造函数"></a>异常机制与构造函数</h3><p>异常机制的一个合理的使用是在构造函数中。构造函数没有返回值，所以应该使用异常机制来报告发生的问题。更重要的是，构造函数抛出异常表明构造函数还没有执行完，其对应的析构函数不会自动被调用，因此析构函数应该先析构所有所有已初始化的基对象，成员对象，再抛出异常。<br>C++类构造函数初始化列表的异常机制，称为function-try block。一般形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">myClass::<span class="built_in">myClass</span>(type1 pa1)</span><br><span class="line">    <span class="keyword">try</span>:  _myClass_val (初始化值)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*构造函数的函数体 */</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="built_in">catch</span> ( exception&amp; err )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 构造函数的异常处理部分 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="异常机制与析构函数"><a href="#异常机制与析构函数" class="headerlink" title="异常机制与析构函数"></a>异常机制与析构函数</h3><p>C++不禁止析构函数向外界抛出异常，但析构函数被期望不向外界函数抛出异常。析构函数中向函数外抛出异常，将直接调用terminator()系统函数终止程序。如果一个析构函数内部抛出了异常，就应该在析构函数的内部捕获并处理该异常，不能让异常被抛出析构函数之外。可以如此处理：</p><ul><li>若析构函数抛出异常，调用std::abort()来终止程序。</li><li>在析构函数中catch捕获异常并作处理。</li></ul><p>关于具体细节，有兴趣可以看《Effective C++》条款08：<strong>别让异常逃离析构函数</strong>。</p><h3 id="noexcept修饰符与noexcept操作符"><a href="#noexcept修饰符与noexcept操作符" class="headerlink" title="noexcept修饰符与noexcept操作符"></a>noexcept修饰符与noexcept操作符</h3><p>noexcept修饰符是C++11新提供的异常说明符，用于声明一个函数不会抛出异常。编译器能够针对不抛出异常的函数进行优化，另一个显而易见的好处是你明确了某个函数不会抛出异常，别人调用你的函数时就知道不用针对这个函数进行异常捕获。在C++98中关于异常处理的程序中你可能会看到这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span> ,<span class="type">double</span> )</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>这是throw作为函数异常说明，前者表示func（）这个函数可能会抛出int或double类型的异常，后者表示func()函数不会抛出异常。事实上前者很少被使用，在C++11这种做法已经被摒弃，而后者则被C++11的noexcept异常声明所代替：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//等价于void func() throw()&#123;...&#125;</span></span><br></pre></td></tr></table></figure><p>在C++11中，编译器并不会在编译期检查函数的noexcept声明，因此，被声明为noexcept的函数若携带异常抛出语句还是可以通过编译的。在函数运行时若抛出了异常，编译器可以选择直接调用terminate()函数来终结程序的运行，因此，noexcept的一个作用是<strong>阻止异常的传播,提高安全性</strong>.</p><p>上面一点提到了，我们不能让异常逃出析构函数，因为那将导致程序的不明确行为或直接终止程序。实际上出于安全的考虑，C++11标准中让类的析构函数默认也是noexcept的。 同样是为了安全性的考虑，经常被析构函数用于释放资源的delete函数，C++11也默认将其设置为noexcept。</p><p>noexcept也可以接受一个常量表达式作为参数，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(常量表达式)</span></span>;</span><br></pre></td></tr></table></figure><p>常量表达式的结果会被转换成bool类型，noexcept(true)表示函数不会抛出异常，noexcept(false)则表示函数有可能会抛出异常。故若你想更改析构函数默认的noexcept声明，可以显式地加上noexcept(false)声明，但这并不会带给你什么好处。</p><h3 id="定义新的异常"><a href="#定义新的异常" class="headerlink" title="定义新的异常"></a>定义新的异常</h3><p>以通过继承和重载 exception 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">what</span> <span class="params">()</span> <span class="type">const</span> <span class="title">throw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;C++ Exception&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(MyException&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyException caught&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(std::exception&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//其他的错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常处理的性能分析"><a href="#异常处理的性能分析" class="headerlink" title="异常处理的性能分析"></a>异常处理的性能分析</h3><p>异常处理机制的主要环节是运行期类型检查。当抛出一个异常时，必须确定异常是不是从try块中抛出。异常处理机制为了完善异常和它的处理器之间的匹配，需要存储每个异常对象的类型信息以及catch语句的额外信息。由于异常对象可以是任何类型（如用户自定义类型），并且也可以是多态的，获取其动态类型必须要使用运行时类型检查（RTTI），此外还需要运行期代码信息和关于每个函数的结构。</p><p>当异常抛出点所在函数无法解决异常时，异常对象沿着调用链被传递出去，程序的控制权也发生了转移。转移的过程中为了将异常对象的信息携带到程序执行处（如对异常对象的复制构造或者catch参数的析构），在时间和空间上都要付出一定的代价，本身也有不安全性，特别是异常对象是个复杂的类的时候。</p><p>异常处理技术在不同平台以及编译器下的实现方式都不同，但都会给程序增加额外的负担，当异常处理被关闭时，额外的数据结构、查找表、一些附加的代码都不会被生成，正是因为如此，对于明确不抛出异常的函数，我们需要使用noexcept进行声明。</p><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><h3 id="自动对象"><a href="#自动对象" class="headerlink" title="自动对象"></a>自动对象</h3><p>默认情况下，局部变量的生命期局限于所在函数的每次执行期间。只有当定义它的函数被调用时才存在的对象称为自动对象。自动对象在每次调用函数时创建和撤销。该类型局部变量存储在栈上，在动态存储区。<br>局部变量所对应的自动对象在函数控制经过变量定义语句时创建。如果在定义时提供了初始化，那么每次创建对象时，对象都会被赋予指定的初值。对于未初始化的内置类型局部变量，其初值不确定。当函数调用时结束，自动对象就会被撤销。<br>形参也是自动对象，其所占存储空间在函数调用时被创建，在函数结束时撤销。</p><h3 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h3><p>静态局部变量的意义：</p><ol><li>分配空间在全局数据栈上</li><li>作用域只局限于当前的函数范围内（局部）</li><li>生命周期为整个程序，不会随着当前的函数结束而结束</li><li>首次初始化时赋值生效，以后的初始化赋值自动跳过</li></ol><h3 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h3><h4 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h4><p>initializer_list是C++11提供的新类型，定义在同名头文件中。<br>用于表示某种特定类型的值的数组，和vector一样，initializer_list也是一种模板类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">initializer_list</span>;</span><br></pre></td></tr></table></figure><p>它提供的操作如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">initializer_list&lt;T&gt; lst; </span><br><span class="line"><span class="comment">//默认初始化；T类型元素的空列表</span></span><br><span class="line">initializer_list&lt;T&gt; lst&#123;a,b,c...&#125;;</span><br><span class="line"><span class="comment">//lst的元素数量和初始值一样多；lst的元素是对应初始值的副本</span></span><br><span class="line"><span class="built_in">lst2</span>(lst)   </span><br><span class="line">lst2=lst  </span><br><span class="line"><span class="comment">//拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本元素共享</span></span><br><span class="line">lst.<span class="built_in">size</span>()  <span class="comment">//列表中的元素数量</span></span><br><span class="line">lst.<span class="built_in">begin</span>()  <span class="comment">//返回指向lst中首元素的指针</span></span><br><span class="line">lst.<span class="built_in">end</span>()   <span class="comment">//返回指向lst中尾元素下一位置的指针</span></span><br></pre></td></tr></table></figure><p>需要注意的是,initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。并且，拷贝或赋值一个initializer_list对象不会拷贝列表中的元素，其实只是引用而已，原始列表和副本共享元素。</p><p>和使用vector一样，我们也可以使用迭代器访问initializer_list里的元素</p><p>如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号内：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//expected和actual是string对象</span></span><br><span class="line"><span class="keyword">if</span>(expected != actual)</span><br><span class="line">   <span class="built_in">error_msg</span>(&#123;<span class="string">&quot;functionX&quot;</span>,expectde,actual&#125;);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">error_msg</span>(&#123;<span class="string">&quot;functionX&quot;</span>,<span class="string">&quot;okay&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><p>而现在c++11添加了initializer_list后，我们可以这样初始化<code>std::vector v = &#123; 1, 2, 3, 4 &#125;;</code>,并且，C++11允许构造函数和其他函数把初始化列表当做参数。</p><h4 id="省略符形参"><a href="#省略符形参" class="headerlink" title="省略符形参"></a>省略符形参</h4><p>省略符形参函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整数求和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span> x, ...)</span><span class="comment">//用...表示后续参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义一个参数列表</span></span><br><span class="line">va_list ap;</span><br><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> var;</span><br><span class="line"><span class="comment">//请看正文介绍va_start()</span></span><br><span class="line"><span class="built_in">va_start</span>(ap, x);</span><br><span class="line"><span class="comment">//请看正文介绍va_arg()</span></span><br><span class="line"><span class="keyword">while</span> (var = <span class="built_in">va_arg</span>(ap, <span class="type">int</span>))</span><br><span class="line">&#123;</span><br><span class="line">result += var;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁列表</span></span><br><span class="line"><span class="built_in">va_end</span>(ap);</span><br><span class="line"><span class="keyword">return</span> result + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>省略符形参 <strong>可以接受不同的参数类型</strong>，但是使用起来相对复杂：</p><p><strong>va_list</strong> 在头文件 <stdarg.h> 或 <cstdarg> 中,它是用来存储实参的。<br><strong>va_arg(ap,int)</strong> 方法用来获取实参列表中的实参，“int”是实参的类型。它从首个实参依次获取，将获取到的结果作为返回值返回。<br><strong>va_start(ap,x)</strong> 就是用来设置首个实参，表示取参数的时候从x的下一个参数开始。（不取x）<br><strong>va_end(ap)</strong> 表示用完ap，即要释放内存。</cstdarg></stdarg.h></p><p>在获取参数列表的时候，va_list并不能判断实参的总个数，所以需要设置结束参数。<br>在上例中，判断取得的参数是否为0，如果为0，表示参数结尾：while (var = va_arg(ap, int)) 。</p><p>所以在使用函数时，需要以0作为结束参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略符形参不需要用&#123;&#125;，但是要以0做结尾：</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">Sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h3><h4 id="返回列表"><a href="#返回列表" class="headerlink" title="返回列表"></a>返回列表</h4><ul><li><p>C++11规定，函数可以返回花括号包围的值的列表</p></li><li><p>如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间</p></li><li><p>如果函数返回的是类类型，由类本身定义初始值如何使用</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    string s2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>&#123; <span class="string">&quot;Info&quot;</span>,s1 ,s2 &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; v= <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="尾置返回类型"><a href="#尾置返回类型" class="headerlink" title="尾置返回类型"></a>尾置返回类型</h4><p>尾置返回类型是在C++11标准中新增的语法，可以用于任何函数定义中，旨在方便复杂函数的定义。尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，需要在本应该出现返回类型的地方放置一个auto关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个返回指向数组的指针的函数</span></span><br><span class="line"><span class="comment">//传统定义</span></span><br><span class="line"><span class="built_in">int</span> (* <span class="built_in">func1</span>(<span class="type">int</span> arr[][<span class="number">3</span>], <span class="type">int</span> n))[<span class="number">3</span>] </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;arr[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用尾置返回类型后</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> arr[][<span class="number">3</span>], <span class="type">int</span> n)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[3] </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;arr[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用decltype声明函数返回值类型"><a href="#使用decltype声明函数返回值类型" class="headerlink" title="使用decltype声明函数返回值类型"></a>使用decltype声明函数返回值类型</h4><p>有时候我们知道函数的返回值是什么类型，就可以使用decltype来简化函数声明</p><p>例如：下面的arrPtr函数返回一个数组指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> odd[] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">int</span> even[] = &#123; <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span>(odd) *<span class="built_in">arrPtr</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%<span class="number">2</span>)? &amp;odd : &amp;even;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*arr)[<span class="number">5</span>] =<span class="built_in">arrPtr</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="built_in">end</span>(*arr) - <span class="built_in">begin</span>(*arr)); ++i)</span><br><span class="line">        cout &lt;&lt; *(*arr + i) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><h3 id="函数指针介绍"><a href="#函数指针介绍" class="headerlink" title="函数指针介绍"></a>函数指针介绍</h3><p>函数指针指向某种特定类型，函数的类型由其参数及返回类型共同决定，与函数名无关。举例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> nLeft,<span class="type">int</span> nRight)</span></span>;<span class="comment">//函数定义 </span></span><br></pre></td></tr></table></figure><p>该函数类型为int(int,int),要想声明一个指向该类函数的指针，只需用指针替换函数名即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*pf)(<span class="type">int</span>,<span class="type">int</span>);<span class="comment">//未初始化  </span></span><br></pre></td></tr></table></figure><p>则pf可指向int(int,int)类型的函数。pf前面有*，说明pf是指针，右侧是形参列表，表示pf指向的是函数，左侧为int，说明pf指向的函数返回值为int。则pf可指向int(int,int)类型的函数。而add类型为int(int,int),则pf可指向add函数。</p><h3 id="标准C函数指针"><a href="#标准C函数指针" class="headerlink" title="标准C函数指针"></a>标准C函数指针</h3><h4 id="函数指针定义"><a href="#函数指针定义" class="headerlink" title="函数指针定义"></a>函数指针定义</h4><p>普通函数指针定义<code>int (*pf)(int,int);</code></p><p>使用typedef定义函数指针类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PF)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;  </span><br><span class="line">PF pf;<span class="comment">//此时，为指向某种类型函数的函数指针类型，而不是具体指针，用它可定义具体指针</span></span><br></pre></td></tr></table></figure><h4 id="函数指针的普通使用"><a href="#函数指针的普通使用" class="headerlink" title="函数指针的普通使用"></a>函数指针的普通使用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pf = add;  </span><br><span class="line"><span class="built_in">pf</span>(<span class="number">100</span>,<span class="number">100</span>);<span class="comment">//与其指向的函数用法无异  </span></span><br><span class="line">(*pf)(<span class="number">100</span>,<span class="number">100</span>);<span class="comment">//此处*pf两端括号必不可少  </span></span><br></pre></td></tr></table></figure><p>注意：add类型必须与pf可指向的函数类型完全匹配</p><h4 id="函数指针作为形参"><a href="#函数指针作为形参" class="headerlink" title="函数指针作为形参"></a>函数指针作为形参</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二个形参为函数类型，会自动转换为指向此类函数的指针  </span></span><br><span class="line"><span class="function">Void <span class="title">fuc</span><span class="params">(<span class="type">int</span> nValue,<span class="type">int</span> pf(<span class="type">int</span>,<span class="type">int</span>))</span></span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//等价的声明，显示的将形参定义为指向函数的指针  </span></span><br><span class="line"><span class="function">Void <span class="title">fuc</span><span class="params">(<span class="type">int</span> nValue,<span class="type">int</span> (*pf)(<span class="type">int</span>,<span class="type">int</span>))</span></span>;  </span><br><span class="line"><span class="function">Void <span class="title">fuc</span><span class="params">(<span class="type">int</span> nValue,PF)</span></span>;  </span><br></pre></td></tr></table></figure><p>形参中有函数指针的函数调用，以fuc为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pf = add;//pf是函数指针  </span><br><span class="line">fuc(1,add);//add自动转换为函数指针  </span><br><span class="line">fuc(1,pf);  </span><br></pre></td></tr></table></figure><h4 id="返回指向函数的指针"><a href="#返回指向函数的指针" class="headerlink" title="返回指向函数的指针"></a>返回指向函数的指针</h4><p>使用typedef定义的函数指针类型作为返回参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PF <span class="title">fuc2</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//PF为函数指针类型  </span></span><br></pre></td></tr></table></figure><p>直接定义函数指针作为返回参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">fuc2</span>(<span class="type">int</span>))(<span class="type">int</span>,<span class="type">int</span>);<span class="comment">//显示定义  </span></span><br></pre></td></tr></table></figure><p>说明：按照有内向外的顺序阅读此声明语句。fuc2有形参列表，则fuc2是一个函数，其形参为fuc2(int),fuc2前面有*，所以fuc2返回一个指针，指针本身也包含形参列表（int，int），因此指针指向函数，该函数的返回值为int.</p><p>总结：fuc2是一个函数，形参为(int),返回一个指向int(int,int)的函数指针。</p><h3 id="C-函数指针"><a href="#C-函数指针" class="headerlink" title="C++函数指针"></a>C++函数指针</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>由于C++完全兼容C，则C中可用的函数指针用法皆可用于C++</p><p>C++其他函数(指针)定义方式及使用</p><p>typedef与decltype组合定义函数类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(add)</span> add2</span>;  </span><br></pre></td></tr></table></figure><p>decltype返回函数类型,add2是与add相同类型的函数，不同的是add2是类型，而非具体函数。</p><p>使用方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add2* pf;<span class="comment">//pf指向add类型的函数指针，未初始化  </span></span><br></pre></td></tr></table></figure><p>typedef与decltype组合定义函数指针类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(add)</span>* PF2</span>;<span class="comment">//PF2与1.1PF意义相同  </span></span><br><span class="line">PF2 pf;<span class="comment">// pf指向int(int,int)类型的函数指针，未初始化</span></span><br></pre></td></tr></table></figure><p>使用推断类型关键字auto定义函数类型和函数指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pf = add;<span class="comment">//pf可认为是add的别名(个人理解)   </span></span><br><span class="line"><span class="keyword">auto</span> *pf = add;<span class="comment">//pf为指向add的指针   </span></span><br></pre></td></tr></table></figure><h4 id="函数指针使用"><a href="#函数指针使用" class="headerlink" title="函数指针使用"></a>函数指针使用</h4><p>函数指针形参</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(add)</span> add2</span>;  </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(add)</span>* PF2</span>;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fuc2</span> <span class="params">(add2 add)</span></span>;<span class="comment">//函数类型形参，调用自动转换为函数指针 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fuc2</span> <span class="params">(PF2 add)</span></span>;<span class="comment">//函数指针类型形参，传入对应函数(指针)即可  </span></span><br></pre></td></tr></table></figure><p>说明：不论形参声明的是函数类型：void fuc2 (add2 add);还是函数指针类型void fuc2 (PF2 add);都可作为函数指针形参声明，在参数传入时，若传入函数名，则将其自动转换为函数指针。</p><p>返回指向函数的指针</p><p>使用auto关键字    </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fuc2</span><span class="params">(<span class="type">int</span>)</span>-&gt; <span class="title">int</span><span class="params">(*)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span> <span class="comment">//fuc2返回函数指针为int(*)(int,int)</span></span></span><br></pre></td></tr></table></figure><p>使用decltype关键字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(add)* <span class="built_in">fuc2</span>(<span class="type">int</span>)<span class="comment">//明确知道返回哪个函数，可用decltype关键字推断其函数类型,  </span></span><br></pre></td></tr></table></figure><h4 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h4><h5 id="普通成员函数指针使用"><a href="#普通成员函数指针使用" class="headerlink" title="普通成员函数指针使用"></a>普通成员函数指针使用</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span><span class="comment">//定义类A  </span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">  </span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> nLeft, <span class="type">int</span> nRight)</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">       </span>&#123;  </span><br><span class="line">              <span class="keyword">return</span> (nLeft + nRight);  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  </span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">fuc</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">       </span>&#123;  </span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;Hello  world\n&quot;</span>);  </span><br><span class="line">             </span><br><span class="line">       &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(A::*PF1)</span><span class="params">()</span></span>;<span class="comment">//指针名前需加上类名限定  </span></span><br><span class="line">  </span><br><span class="line">PF1 pf1 = &amp;A::fuc; <span class="comment">//必须有&amp;  </span></span><br><span class="line">  </span><br><span class="line">A a;<span class="comment">//成员函数地址解引用必须附驻与某个对象地址，所以必须创建一个对象</span></span><br><span class="line">  </span><br><span class="line">(a.*pf1)();<span class="comment">//使用成员函数指针调用函数  </span></span><br></pre></td></tr></table></figure><h5 id="继承中的函数指针使用"><a href="#继承中的函数指针使用" class="headerlink" title="继承中的函数指针使用"></a>继承中的函数指针使用</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">fuc</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">       </span>&#123;  </span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;Hello fuc()\n&quot;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">fuc2</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">       </span>&#123;  </span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;Hello A::fuc2()\n&quot;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fuc2</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">       </span>&#123;  </span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;Hello B::fuc2()\n&quot;</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(A::*PF1)</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(B::*PF2)</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">PF1 pf1 = &amp;A::fuc;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>         </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">       A a;  </span><br><span class="line">       B b;  </span><br><span class="line">       (a.*pf1)();  <span class="comment">//调用A::fuc  </span></span><br><span class="line">       (b.*pf1)();   <span class="comment">//调用A::fuc  </span></span><br><span class="line">  </span><br><span class="line">       pf1 = &amp;A::fuc2;  </span><br><span class="line">       (a.*pf1)();  <span class="comment">//调用A::fuc2  </span></span><br><span class="line">       (b.*pf1)();  <span class="comment">//调用A::fuc2  </span></span><br><span class="line">  </span><br><span class="line">       PF2 pf2 = &amp;A::fuc2;   </span><br><span class="line">       (b.*pf2)(); <span class="comment">//调用A::fuc2  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;p&gt;引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CPP" scheme="http://yorxika.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/CPP/"/>
    
    
    <category term="CPP" scheme="http://yorxika.github.io/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>二叉树展开为链表</title>
    <link href="http://yorxika.github.io/2020/01/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <id>http://yorxika.github.io/2020/01/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</id>
    <published>2020-01-16T01:52:29.000Z</published>
    <updated>2020-01-16T07:05:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>来源Leetcode第114二叉树展开为链表</p><p>给定一个二叉树，<a href="https://baike.baidu.com/item/原地算法/8010757">原地</a>将它展开为链表。</p><p>例如，给定二叉树<br><span id="more"></span><br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / <span class="string">\</span>   <span class="string">\</span></span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>将其展开为：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> <span class="string">\</span></span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   <span class="string">\</span></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     <span class="string">\</span></span><br><span class="line">      <span class="number">4</span></span><br><span class="line">       <span class="string">\</span></span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         <span class="string">\</span></span><br><span class="line">          <span class="number">6</span></span><br></pre></td></tr></table></figure><hr><h3 id="栈的先序遍历"><a href="#栈的先序遍历" class="headerlink" title="栈的先序遍历"></a>栈的先序遍历</h3><p>由题目可知这是一道先序遍历的题目，于是考虑了用栈，通过栈提前保存二叉树的右左子树，然后通过出栈解决。<br>但是与普通的二叉树先序遍历不一样，需要对出栈节点的<strong>左子树赋值为null</strong>，并且保存当前遍历节点。<br>代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(temp != <span class="literal">null</span>)&#123;</span><br><span class="line">            temp.right = tmp;</span><br><span class="line">            temp.left = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.right != <span class="literal">null</span>)</span><br><span class="line">            stack.push(tmp.right);</span><br><span class="line">        <span class="keyword">if</span> (tmp.left != <span class="literal">null</span>)</span><br><span class="line">            stack.push(tmp.left);</span><br><span class="line">        temp = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h3><p>来自<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/">题解</a></p><p>可以发现展开的顺序其实就是二叉树的先序遍历。算法和 94 题中序遍历的 Morris 算法有些神似，我们需要两步完成这道题。</p><ol><li>将左子树插入到右子树的地方</li><li>将原来的右子树接到左子树的最右边节点</li><li>考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null</li></ol><p>可以看图理解下这个过程。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span></span><br><span class="line">   / <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / <span class="string">\</span>   <span class="string">\</span></span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line">//将 <span class="number">1</span> 的左子树插入到右子树的地方</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     <span class="string">\</span></span><br><span class="line">      <span class="number">2</span>         <span class="number">5</span></span><br><span class="line">     / <span class="string">\</span>         <span class="string">\</span></span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>         <span class="number">6</span>        </span><br><span class="line">//将原来的右子树接到左子树的最右边节点</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     <span class="string">\</span></span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">     / <span class="string">\</span>          </span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>  </span><br><span class="line">         <span class="string">\</span></span><br><span class="line">          <span class="number">5</span></span><br><span class="line">           <span class="string">\</span></span><br><span class="line">            <span class="number">6</span></span><br><span class="line">            </span><br><span class="line"> //将 <span class="number">2</span> 的左子树插入到右子树的地方</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     <span class="string">\</span></span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       <span class="string">\</span>          </span><br><span class="line">        <span class="number">3</span>       <span class="number">4</span>  </span><br><span class="line">                 <span class="string">\</span></span><br><span class="line">                  <span class="number">5</span></span><br><span class="line">                   <span class="string">\</span></span><br><span class="line">                    <span class="number">6</span>   </span><br><span class="line">        </span><br><span class="line"> //将原来的右子树接到左子树的最右边节点</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     <span class="string">\</span></span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       <span class="string">\</span>          </span><br><span class="line">        <span class="number">3</span>      </span><br><span class="line">         <span class="string">\</span></span><br><span class="line">          <span class="number">4</span>  </span><br><span class="line">           <span class="string">\</span></span><br><span class="line">            <span class="number">5</span></span><br><span class="line">             <span class="string">\</span></span><br><span class="line">              <span class="number">6</span>         </span><br><span class="line">  </span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>于是相应的，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span>)&#123;</span><br><span class="line">            root = root.right;  <span class="comment">//左子树为空可以直接进行下一层的遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">            <span class="keyword">while</span> (tmp.right != <span class="literal">null</span>)</span><br><span class="line">                tmp = tmp.right;</span><br><span class="line">            tmp.right = root.right;  <span class="comment">//根节点右子树成为左子树最右节点</span></span><br><span class="line">            root.right = root.left;  <span class="comment">//根节点的右子树成为左子树</span></span><br><span class="line">            root.left = <span class="literal">null</span>;  <span class="comment">//根节点左子树赋值为空</span></span><br><span class="line">            root = root.right;  <span class="comment">//进行下一个节点的遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>我们可以逆过来进行。</p><p>我们依次遍历 <code>6 5 4 3 2 1</code>，然后每遍历一个节点就将当前节点的右指针更新为上一个节点。</p><p>遍历到 <code>5</code>，把 <code>5</code> 的右指针指向 <code>6</code>。<code>6 &lt;- 5 4 3 2 1</code>。</p><p>遍历到 <code>4</code>，把 <code>4</code> 的右指针指向 <code>5</code>。<code>6 &lt;- 5 &lt;- 4 3 2 1</code>。</p><p>… …</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / <span class="string">\</span>   <span class="string">\</span></span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure><p>这样就不会有丢失孩子的问题了，因为更新当前的右指针的时候，当前节点的右孩子已经访问过了。</p><p>而 <code>6 5 4 3 2 1</code> 的遍历顺序其实变形的后序遍历，遍历顺序是右子树-&gt;左子树-&gt;根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    flatten(root.right);</span><br><span class="line">    flatten(root.left);</span><br><span class="line">    root.right = pre;</span><br><span class="line">    root.left = <span class="literal">null</span>;</span><br><span class="line">    pre = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源Leetcode第114二叉树展开为链表&lt;/p&gt;
&lt;p&gt;给定一个二叉树，&lt;a href=&quot;https://baike.baidu.com/item/原地算法/8010757&quot;&gt;原地&lt;/a&gt;将它展开为链表。&lt;/p&gt;
&lt;p&gt;例如，给定二叉树&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/"/>
    
    <category term="树" scheme="http://yorxika.github.io/categories/%E7%AE%97%E6%B3%95/Leetcode/%E6%A0%91/"/>
    
    
    <category term="Leetcode" scheme="http://yorxika.github.io/tags/Leetcode/"/>
    
    <category term="二叉树" scheme="http://yorxika.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
