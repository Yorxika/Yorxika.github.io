<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LFU缓存</title>
    <url>/2020/04/06/LFU/</url>
    <content><![CDATA[<p>来源力扣第460题LFU缓存</p>
<p>请你为 <a href="https://baike.baidu.com/item/缓存算法" target="_blank" rel="noopener">最不经常使用（LFU）</a>缓存算法设计并实现数据结构。它应该支持以下操作：<code>get</code> 和 <code>put</code>。</p>
<ul>
<li><code>get(key)</code> - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。</li>
<li><code>put(key, value)</code> - 如果键不存在，请设置或插入值。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近</strong> 最少使用的键。<a id="more"></a>
「项的使用次数」就是自插入该项以来对其调用 <code>get</code> 和 <code>put</code> 函数的次数之和。使用次数会在对应项被移除后置为 0 。</li>
</ul>
<h3 id="两个Map实现"><a href="#两个Map实现" class="headerlink" title="两个Map实现"></a>两个Map实现</h3><p>利用一个Map存放key到value值的映射，一个Map存放key到freq的映射，由于题目要求<code>当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近 最少使用的键</code>，因而采用linkedHashMap实现平局，默认是插入顺序，true为访问顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,Integer&gt; map1;  <span class="comment">//key -&gt; value</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,Integer&gt; map2;  <span class="comment">//key -&gt; freq</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map1 = <span class="keyword">new</span> HashMap&lt;&gt;(capacity);</span><br><span class="line">        <span class="comment">//用linkedHashMap实现平局，默认是插入顺序，true为访问顺序</span></span><br><span class="line">        map2 = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(capacity,<span class="number">0.75F</span>,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map1.containsKey(key))&#123;</span><br><span class="line">            map2.put(key,map2.get(key)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> map1.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(capacity == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(map1.containsKey(key))&#123;</span><br><span class="line">            map1.put(key,value);</span><br><span class="line">            map2.put(key,map2.get(key)+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(map1.size() == capacity)&#123;</span><br><span class="line">                <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">int</span> temp = key;</span><br><span class="line">                <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map2.entrySet())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(min &gt; entry.getValue())&#123;</span><br><span class="line">                        temp = entry.getKey();</span><br><span class="line">                        min = entry.getValue();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                map1.remove(temp);</span><br><span class="line">                map2.remove(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            map1.put(key,value);</span><br><span class="line">            map2.put(key,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>来自<a href="https://leetcode-cn.com/problems/lfu-cache/solution/java-13ms-shuang-100-shuang-xiang-lian-biao-duo-ji/" target="_blank" rel="noopener">sweetiee</a></p>
<p><code>HashMap cache</code> 存缓存的内容; 将写法 1 写法 2 中的 <code>freqMap</code> 不再用 <code>HashMap</code> 来表示，而是直接用双向链表 <code>DoubleLinkedList firstLinkedList; DoubleLinkedList lastLinkedList</code>，省去了一些哈希相关的耗时，也不需要用 min 来存储最小频次了，<code>lastLinkedList.pre</code> 这条 <code>DoubleLinkedList</code> 即为最小频次对应的 Node 双向链表，<code>lastLinkedList.pre.tail.pre</code> 这个 Node 即为最小频次的双向链表中的所有 Node 中最先访问的 Node，即容量满了后要删除的 Node。</p>
<p><img src="/2020/04/06/LFU/909ea661e76e600e49763d06d2fa72b7897e36ebf47d966292636bce1b241734-image.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Node&gt; cache;  <span class="comment">// 存储缓存的内容，Node中除了value值外，还有key、freq、所在DoubleLinkedList、</span></span><br><span class="line">    <span class="comment">// 所在DoubleLinkedList中的postNode、所在DoubleLinkedList中的preNode，具体定义在下方。</span></span><br><span class="line"></span><br><span class="line">    DoubleLinkedList firstLinkedList; <span class="comment">// firstLinkedList.post 是频次最大的双向链表</span></span><br><span class="line">    DoubleLinkedList lastLinkedList;  <span class="comment">// lastLinkedList.pre 是频次最小的双向链表，满了之后</span></span><br><span class="line">    <span class="comment">// 删除 lastLinkedList.pre.tail.pre 这个Node即为频次最小且访问最早的Node</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        cache = <span class="keyword">new</span> HashMap&lt;&gt; (capacity);</span><br><span class="line">        firstLinkedList = <span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line">        lastLinkedList = <span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line">        firstLinkedList.post = lastLinkedList;</span><br><span class="line">        lastLinkedList.pre = firstLinkedList;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该key访问频次+1</span></span><br><span class="line">        freqInc(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node node = cache.get(key);</span><br><span class="line">        <span class="comment">// 若key存在，则更新value，访问频次+1</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            freqInc(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若key不存在</span></span><br><span class="line">            <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果缓存满了，删除lastLinkedList.pre这个链表（即表示最小频次的链表）中的tail.pre这个Node</span></span><br><span class="line">                <span class="comment">// （即最小频次链表中最先访问的Node），如果该链表中的元素删空了，则删掉该链表。</span></span><br><span class="line">                cache.remove(lastLinkedList.pre.tail.pre.key);</span><br><span class="line">                lastLinkedList.removeNode(lastLinkedList.pre.tail.pre);</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (lastLinkedList.pre.head.post == lastLinkedList.pre.tail) &#123;</span><br><span class="line">                    removeDoubleLinkedList(lastLinkedList.pre);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cache中put新Key-Node对儿，并将新node加入表示freq为1的DoubleLinkedList中，</span></span><br><span class="line">            <span class="comment">// 若不存在freq为1的DoubleLinkedList则新建。</span></span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="keyword">if</span> (lastLinkedList.pre.freq != <span class="number">1</span>) &#123;</span><br><span class="line">                DoubleLinkedList newDoublyLinedList = <span class="keyword">new</span> DoubleLinkedList(<span class="number">1</span>);</span><br><span class="line">                addDoubleLinkedList(newDoublyLinedList, lastLinkedList.pre);</span><br><span class="line">                newDoublyLinedList.addNode(newNode);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lastLinkedList.pre.addNode(newNode);</span><br><span class="line">            &#125;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * node的访问频次 + 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">freqInc</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将node从原freq对应的双向链表里移除, 如果链表空了则删除链表。</span></span><br><span class="line">        DoubleLinkedList linkedList = node.DoubleLinkedList;</span><br><span class="line">        DoubleLinkedList preLinkedList = linkedList.pre;</span><br><span class="line">        linkedList.removeNode(node);</span><br><span class="line">        <span class="keyword">if</span> (linkedList.head.post == linkedList.tail) &#123;</span><br><span class="line">            removeDoubleLinkedList(linkedList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将node加入新freq对应的双向链表，若该链表不存在，则先创建该链表。</span></span><br><span class="line">        node.freq++;</span><br><span class="line">        <span class="keyword">if</span> (preLinkedList.freq != node.freq) &#123;</span><br><span class="line">            DoubleLinkedList newDoublyLinedList = <span class="keyword">new</span> DoubleLinkedList(node.freq);</span><br><span class="line">            addDoubleLinkedList(newDoublyLinedList, preLinkedList);</span><br><span class="line">            newDoublyLinedList.addNode(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            preLinkedList.addNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加代表某1频次的双向链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addDoubleLinkedList</span><span class="params">(DoubleLinkedList newDoublyLinedList, DoubleLinkedList preLinkedList)</span> </span>&#123;</span><br><span class="line">        newDoublyLinedList.post = preLinkedList.post;</span><br><span class="line">        newDoublyLinedList.post.pre = newDoublyLinedList;</span><br><span class="line">        newDoublyLinedList.pre = preLinkedList;</span><br><span class="line">        preLinkedList.post = newDoublyLinedList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除代表某1频次的双向链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeDoubleLinkedList</span><span class="params">(DoubleLinkedList DoubleLinkedList)</span> </span>&#123;</span><br><span class="line">        DoubleLinkedList.pre.post = DoubleLinkedList.post;</span><br><span class="line">        DoubleLinkedList.post.pre = DoubleLinkedList.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> freq = <span class="number">1</span>;</span><br><span class="line">    Node pre; <span class="comment">// Node所在频次的双向链表的前继Node</span></span><br><span class="line">    Node post; <span class="comment">// Node所在频次的双向链表的后继Node</span></span><br><span class="line">    DoubleLinkedList DoubleLinkedList;  <span class="comment">// Node所在频次的双向链表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> freq; <span class="comment">// 该双向链表表示的频次</span></span><br><span class="line"></span><br><span class="line">    DoubleLinkedList pre;  <span class="comment">// 该双向链表的前继链表（pre.freq &lt; this.freq）</span></span><br><span class="line">    DoubleLinkedList post; <span class="comment">// 该双向链表的后继链表 (post.freq &gt; this.freq)</span></span><br><span class="line"></span><br><span class="line">    Node head; <span class="comment">// 该双向链表的头节点，新节点从头部加入，表示最近访问</span></span><br><span class="line">    Node tail; <span class="comment">// 该双向链表的尾节点，删除节点从尾部删除，表示最久访问</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node();</span><br><span class="line">        tail = <span class="keyword">new</span> Node();</span><br><span class="line">        head.post = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleLinkedList</span><span class="params">(<span class="keyword">int</span> freq)</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node();</span><br><span class="line">        tail = <span class="keyword">new</span> Node();</span><br><span class="line">        head.post = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">        <span class="keyword">this</span>.freq = freq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        node.pre.post = node.post;</span><br><span class="line">        node.post.pre = node.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        node.post = head.post;</span><br><span class="line">        head.post.pre = node;</span><br><span class="line">        head.post = node;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        node.DoubleLinkedList = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/lfu-cache/solution/ha-xi-biao-shuang-xiang-lian-biao-java-by-liweiwei/" target="_blank" rel="noopener">weiwei</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key 就是题目中的 key</span></span><br><span class="line"><span class="comment">     * value 是结点类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, ListNode&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问次数哈希表，使用 ListNode[] 也可以，不过要占用很多空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DoubleLinkedList&gt; frequentMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 外部传入的容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局最高访问次数，删除最少使用访问次数的结点时会用到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer minFrequent = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(capacity);</span><br><span class="line">        frequentMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get 一次操作，访问次数就增加 1；</span></span><br><span class="line"><span class="comment">     * 从原来的链表调整到访问次数更高的链表的表头</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 测试测出来的，capacity 可能传 0</span></span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 获得结点类</span></span><br><span class="line">            ListNode listNode = removeListNode(key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 挂接到新的访问次数的双向链表的头部</span></span><br><span class="line">            <span class="keyword">int</span> frequent = listNode.frequent;</span><br><span class="line">            addListNode2Head(frequent, listNode);</span><br><span class="line">            <span class="keyword">return</span> listNode.value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 key 存在，就更新访问次数 + 1，更新值</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            ListNode listNode = removeListNode(key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 value</span></span><br><span class="line">            listNode.value = value;</span><br><span class="line">            <span class="keyword">int</span> frequent = listNode.frequent;</span><br><span class="line">            addListNode2Head(frequent, listNode);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 key 不存在</span></span><br><span class="line">        <span class="comment">// 1、如果满了，先删除访问次数最小的的末尾结点，再删除 map 里对应的 key</span></span><br><span class="line">        <span class="keyword">if</span> (map.size() == capacity) &#123;</span><br><span class="line">            <span class="comment">// 1、从双链表里删除结点</span></span><br><span class="line">            DoubleLinkedList doubleLinkedList = frequentMap.get(minFrequent);</span><br><span class="line">            ListNode removeNode = doubleLinkedList.removeTail();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、删除 map 里对应的 key</span></span><br><span class="line">            map.remove(removeNode.key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、再创建新结点放在访问次数为 1 的双向链表的前面</span></span><br><span class="line">        ListNode newListNode = <span class="keyword">new</span> ListNode(key, value);</span><br><span class="line">        addListNode2Head(<span class="number">1</span>, newListNode);</span><br><span class="line">        map.put(key, newListNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【注意】因为这个结点是刚刚创建的，最少访问次数一定为 1</span></span><br><span class="line">        <span class="keyword">this</span>.minFrequent = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下部分主要是结点类和双向链表的操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结点类，是双向链表的组成部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> frequent = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">private</span> ListNode pre;</span><br><span class="line">        <span class="keyword">private</span> ListNode next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双向链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 虚拟头结点，它无前驱结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> ListNode dummyHead;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 虚拟尾结点，它无后继结点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> ListNode dummyTail;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当前双向链表的有效结点数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoubleLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 虚拟头尾结点赋值多少无所谓</span></span><br><span class="line">            <span class="keyword">this</span>.dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.dummyTail = <span class="keyword">new</span> ListNode(-<span class="number">2</span>, -<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            dummyHead.next = dummyTail;</span><br><span class="line">            dummyTail.pre = dummyHead;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 把一个结点类添加到双向链表的开头（头部是最新使用数据）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> addNode</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode2Head</span><span class="params">(ListNode addNode)</span> </span>&#123;</span><br><span class="line">            ListNode oldHead = dummyHead.next;</span><br><span class="line">            <span class="comment">// 两侧结点指向它</span></span><br><span class="line">            dummyHead.next = addNode;</span><br><span class="line">            oldHead.pre = addNode;</span><br><span class="line">            <span class="comment">// 它的前驱和后继指向两侧结点</span></span><br><span class="line">            addNode.pre = dummyHead;</span><br><span class="line">            addNode.next = oldHead;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 把双向链表的末尾结点删除（尾部是最旧的数据，在缓存满的时候淘汰）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ListNode oldTail = dummyTail.pre;</span><br><span class="line">            ListNode newTail = oldTail.pre;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 两侧结点建立连接</span></span><br><span class="line">            newTail.next = dummyTail;</span><br><span class="line">            dummyTail.pre = newTail;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 它的两个属性切断连接</span></span><br><span class="line">            oldTail.pre = <span class="keyword">null</span>;</span><br><span class="line">            oldTail.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重要：删除一个结点，当前双向链表的结点个数少 1</span></span><br><span class="line">            count--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 维护</span></span><br><span class="line">            <span class="keyword">return</span> oldTail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将原来访问次数的结点，从双向链表里脱离出来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">removeListNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得结点类</span></span><br><span class="line">        ListNode deleteNode = map.get(key);</span><br><span class="line"></span><br><span class="line">        ListNode preNode = deleteNode.pre;</span><br><span class="line">        ListNode nextNode = deleteNode.next;</span><br><span class="line">        <span class="comment">// 两侧结点建立连接</span></span><br><span class="line">        preNode.next = nextNode;</span><br><span class="line">        nextNode.pre = preNode;</span><br><span class="line">        <span class="comment">// 删除去原来两侧结点的连接</span></span><br><span class="line">        deleteNode.pre = <span class="keyword">null</span>;</span><br><span class="line">        deleteNode.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 维护双链表结点数</span></span><br><span class="line">        frequentMap.get(deleteNode.frequent).count--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【注意】维护 minFrequent</span></span><br><span class="line">        <span class="comment">// 如果当前结点正好在最小访问次数的链表上，并且移除以后结点数为 0，最小访问次数需要加 1</span></span><br><span class="line">        <span class="keyword">if</span> (deleteNode.frequent == minFrequent &amp;&amp; frequentMap.get(deleteNode.frequent).count == <span class="number">0</span>) &#123;</span><br><span class="line">            minFrequent++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问次数加 1</span></span><br><span class="line">        deleteNode.frequent++;</span><br><span class="line">        <span class="keyword">return</span> deleteNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把结点放在对应访问次数的双向链表的头部</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> frequent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> addNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addListNode2Head</span><span class="params">(<span class="keyword">int</span> frequent, ListNode addNode)</span> </span>&#123;</span><br><span class="line">        DoubleLinkedList doubleLinkedList;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不存在，就初始化</span></span><br><span class="line">        <span class="keyword">if</span> (frequentMap.containsKey(frequent)) &#123;</span><br><span class="line">            doubleLinkedList = frequentMap.get(frequent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doubleLinkedList = <span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加到 DoubleLinkedList 的表头</span></span><br><span class="line">        doubleLinkedList.addNode2Head(addNode);</span><br><span class="line">        frequentMap.put(frequent, doubleLinkedList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数据结构设计</category>
      </categories>
      <tags>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转数组</title>
    <url>/2020/04/06/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>来源力扣189题旋转数组</p>
<p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。<br><a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] 和 k = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">向右旋转 <span class="number">2</span> 步: [<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">向右旋转 <span class="number">3</span> 步: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h3 id="循环旋转"><a href="#循环旋转" class="headerlink" title="循环旋转"></a>循环旋转</h3><p>来自官方题解<br>直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量 temp里面。然后，我们将被替换数字（temp）放到它正确的位置，并继续这个过程 <em>n</em> 次， <em>n</em> 是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果 n%k==0，其中 k=k%n （因为如果 k 大于 n ，移动 k 次实际上相当于移动 k%n次）。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。</p>
<p>把元素看做同学，把下标看做座位，大家换座位。第一个同学离开座位去第k+1个座位，第k+1个座位的同学被挤出去了，他就去坐他后k个座位，如此反复。但是会出现一种情况，就是其中一个同学被挤开之后，坐到了第一个同学的位置（空位置，没人被挤出来），但是此时还有人没有调换位置，这样就顺着让第二个同学换位置。 那么什么时候就可以保证每个同学都换完了呢？n个同学，换n次，所以用一个count来计数即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    k = k % nums.length;</span><br><span class="line">    <span class="keyword">int</span> counts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; counts &lt; nums.length ; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = i;</span><br><span class="line">        <span class="keyword">int</span> pre = nums[i];</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">          <span class="keyword">int</span> next = (cur + k) % nums.length;</span><br><span class="line">          <span class="keyword">int</span> temp = nums[next];</span><br><span class="line">          nums[next] = pre;</span><br><span class="line">          pre = temp;</span><br><span class="line">          cur = next;</span><br><span class="line">          counts++;</span><br><span class="line">        &#125;<span class="keyword">while</span> (i != cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三次翻转"><a href="#三次翻转" class="headerlink" title="三次翻转"></a>三次翻转</h3><p>这个方法基于这个事实：当我们旋转数组 k 次， k<em>%</em>n 个尾部元素会被移动到头部，剩下的元素会被向后移动。</p>
<p>在这个方法中，我们首先将所有元素反转。然后反转前 k 个元素，再反转后面 n-k 个元素，就能得到想要的结果。</p>
<p>假设 n=7 且 k=3 。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">原始数组                  : <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line">反转所有数字后             : <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line">反转前 k 个数字后          : <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line">反转后 n-k 个数字后        : <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> --&gt; 结果</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/04/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>复习一下快速排序</p>
<h3 id="双指针快排"><a href="#双指针快排" class="headerlink" title="双指针快排"></a>双指针快排</h3><a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    quickSort(nums,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = partition(nums,start,end);</span><br><span class="line">    quickSort(nums,start,index-<span class="number">1</span>);</span><br><span class="line">    quickSort(nums,index+<span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//随机选取一个数作为划分点</span></span><br><span class="line">    <span class="keyword">int</span> random = <span class="keyword">new</span> Random().nextInt(end - start + <span class="number">1</span>) + start;</span><br><span class="line">    swap(nums,start,random);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pivot = nums[start];  <span class="comment">//基准值</span></span><br><span class="line">    <span class="keyword">int</span> left = start+<span class="number">1</span>,right = end;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= end &amp;&amp; nums[left] &lt;= pivot)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= right &amp;&amp; nums[right] &gt; pivot)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(nums,left,right);  <span class="comment">//交换左右两个指针</span></span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[start] = nums[right];</span><br><span class="line">    nums[right] = pivot;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">    nums[index1] = nums[index2];</span><br><span class="line">    nums[index2] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三指针"><a href="#三指针" class="headerlink" title="三指针"></a>三指针</h3><p>来源<a href="https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/" target="_blank" rel="noopener">weiwei</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> randomIndex = left + RANDOM.nextInt(right - left + <span class="number">1</span>);</span><br><span class="line">    swap(nums, randomIndex, left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环不变量：</span></span><br><span class="line">    <span class="comment">// all in [left + 1, lt] &lt; pivot</span></span><br><span class="line">    <span class="comment">// all in [lt + 1, i) = pivot</span></span><br><span class="line">    <span class="comment">// all in [gt, right] &gt; pivot</span></span><br><span class="line">    <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">    <span class="keyword">int</span> lt = left;</span><br><span class="line">    <span class="keyword">int</span> gt = right + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; gt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">            lt++;</span><br><span class="line">            swap(nums, i, lt);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            gt--;</span><br><span class="line">            swap(nums, i, gt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, left, lt);</span><br><span class="line">    <span class="comment">// 注意这里，大大减少了两侧分治的区间</span></span><br><span class="line">    quickSort(nums, left, lt - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, gt, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">    nums[index1] = nums[index2];</span><br><span class="line">    nums[index2] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法导论</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>有效括号的嵌套深度</title>
    <url>/2020/04/05/%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p>来源Leetcode第1111题有效括号的嵌套深度</p>
<p><strong>有效括号字符串</strong> 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「<strong>有效括号字符串</strong>」部分。</p>
<p><strong>嵌套深度</strong> <code>depth</code> 定义：即有效括号字符串嵌套的层数，<code>depth(A)</code> 表示有效括号字符串 <code>A</code> 的嵌套深度。详情参见题末「<strong>嵌套深度</strong>」部分。<br><a id="more"></a><br>有效括号字符串类型与对应的嵌套深度计算方法如下图所示：</p>
<p><img src="/2020/04/05/有效括号的嵌套深度/1111.png" alt="img"></p>
<p>给你一个「有效括号字符串」 <code>seq</code>，请你将其分成两个不相交的有效括号字符串，<code>A</code> 和 <code>B</code>，并使这两个字符串的深度最小。</p>
<ul>
<li>不相交：每个 <code>seq[i]</code> 只能分给 <code>A</code> 和 <code>B</code> 二者中的一个，不能既属于 <code>A</code> 也属于 <code>B</code> 。</li>
<li><code>A</code> 或 <code>B</code> 中的元素在原字符串中可以不连续。</li>
<li><code>A.length + B.length = seq.length</code></li>
<li>深度最小：<code>max(depth(A), depth(B))</code> 的可能取值最小。 </li>
</ul>
<p>划分方案用一个长度为 <code>seq.length</code> 的答案数组 <code>answer</code> 表示，编码规则如下：</p>
<ul>
<li><code>answer[i] = 0</code>，<code>seq[i]</code> 分给 <code>A</code> 。</li>
<li><code>answer[i] = 1</code>，<code>seq[i]</code> 分给 <code>B</code> 。</li>
</ul>
<p>如果存在多个满足要求的答案，只需返回其中任意 <strong>一个</strong> 即可。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">输入：seq = <span class="string">"(()())"</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<hr>
<p>题目没读懂，看<a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solution/qian-tao-shen-du-wan-cheng-gua-hao-pi-pei-wen-ti-s/" target="_blank" rel="noopener">weiwei</a>的题解大概懂了一点，目要求我们把输入的整体有效字符串做一个重组，要求是只拆成两个部分 <code>A</code> 和 <code>B</code> ，每个字符要么分到 <code>A</code> 要么分到 <code>B</code>，分到 <code>A</code> 标记为 <code>0</code>，分到 <code>B</code> 标记为 <code>1</code>。而<strong>每个部分的字符又要保持在输入字符串中的顺序不变</strong>。因此输出是一个与原始字符串等长的整数数组，这个整数数组里只有 <code>0</code> 和 <code>1</code>。</p>
<blockquote>
<p>核心思想就是：连续的 <code>(</code>会造成嵌套深度的增加，因此对于这种要把他们分到不同的组中。而连续的标准不仅仅是原始字符串中的左右相邻，应该还包括中间成对的 <code>（）</code>消除后的连续。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxDepthAfterSplit(String seq) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = seq.length();</span><br><span class="line">    <span class="keyword">if</span> (seq == <span class="keyword">null</span> || seq.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">char</span>[] arr = seq.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span> ;  <span class="comment">//模拟栈的深度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == <span class="string">'('</span>)&#123;</span><br><span class="line">            depth++;  <span class="comment">//左括号压栈</span></span><br><span class="line">            ans[i] = depth % <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//右括号出栈</span></span><br><span class="line">            ans[i] = depth % <span class="number">2</span>;</span><br><span class="line">            depth--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Z字型变换</title>
    <url>/2020/04/03/Z%E5%AD%97%E5%9E%8B%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>来自Leetcode第6题Z字型变换</p>
<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 <code>&quot;LEETCODEISHIRING&quot;</code> 行数为 3 时，排列如下：</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">L   C   <span class="literal">I</span>   R</span><br><span class="line">E T O E S <span class="literal">I</span> <span class="literal">I</span> G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>示例 1:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"LEETCODEISHIRING"</span>, <span class="attr">numRows</span> = <span class="number">3</span></span><br><span class="line">输出: <span class="string">"LCIRETOESIIGEDHN"</span></span><br></pre></td></tr></table></figure>
<hr>
<p>模拟从上到下的打印过程。</p>
<pre><code class="lang-JAVA">    public String convert(String s, int numRows) {
        if(numRows &lt; 2 || s == null)
            return s;
        List&lt;StringBuilder&gt; list = new ArrayList&lt;&gt;();
        for(int i = 0 ; i &lt; numRows ; i++)
            list.add(new StringBuilder());
        char[] arr = s.toCharArray();
        int index = 0 , flag = -1;
        for(int i = 0 ; i &lt; arr.length ; ++i){
            list.get(index).append(arr[i]);
            if(index == numRows - 1 || index == 0)
                flag = -flag;
            index += flag;
        }
        StringBuilder stringBuilder = new StringBuilder();
        for(StringBuilder sb : list)
            stringBuilder.append(sb);
        return stringBuilder.toString();
    }
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>单词的压缩编码</title>
    <url>/2020/03/31/%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>来自Leetcode第820题单词的压缩编码</p>
<p>给定一个单词列表，我们将这个列表编码成一个索引字符串 <code>S</code> 与一个索引列表 <code>A</code>。</p>
<p>例如，如果这个列表是 <code>[&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</code>，我们就可以将其表示为 <code>S = &quot;time#bell#&quot;</code> 和 <code>indexes = [0, 2, 5]</code>。</p>
<p>对于每一个索引，我们可以通过从字符串 <code>S</code> 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。</p>
<p>那么成功对给定单词列表进行编码的最小字符串长度是多少呢？<br><a id="more"></a><br><strong>示例：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">words</span> = [<span class="string">"time"</span>, <span class="string">"me"</span>, <span class="string">"bell"</span>]</span><br><span class="line">输出: <span class="number">10</span></span><br><span class="line">说明: <span class="attr">S</span> = <span class="string">"time#bell#"</span> ， <span class="attr">indexes</span> = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>] 。</span><br></pre></td></tr></table></figure>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>题目的意思大概就是将输入里的字符串按某种方式编码，最后返回编码字符串的长度，考虑到字符串S可能是字符串T的后缀，这样的话字符串S就不用加入到编码字符串里了，于是可以考虑先将字符串按长度排序，字符串长的排在前面，如果遍历到的字符串i在包含在原本的字符串里，则不加入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//先按长度倒叙，长的在前面，保证能够框住后面的字符。</span></span><br><span class="line">    Arrays.sort(words, (a1,a2)-&gt; a2.length() - a1.length());</span><br><span class="line"></span><br><span class="line">    StringBuffer result = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    result.append(words[<span class="number">0</span>]+<span class="string">"#"</span>);</span><br><span class="line">    <span class="keyword">int</span> total  = result.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt; words.length;i++)&#123;</span><br><span class="line">        <span class="comment">//如果前面的字符包含了后面的字符，则个数不变，否则加上后面字符长度</span></span><br><span class="line">        <span class="keyword">if</span>(result.indexOf(words[i]+<span class="string">"#"</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            result.append(words[i] + <span class="string">"#"</span>);</span><br><span class="line">            total = total +<span class="number">1</span> + words[i].length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="翻转字符串"><a href="#翻转字符串" class="headerlink" title="翻转字符串"></a>翻转字符串</h3><p>来自<a href="https://leetcode-cn.com/problems/short-encoding-of-words/solution/wu-xu-zi-dian-shu-qing-qing-yi-fan-zhuan-jie-guo-j/" target="_blank" rel="noopener">nettee</a></p>
<p><img src="/2020/03/31/单词的压缩编码/dba07d67627a9ab2e34231359d5079a9c039c306f97f6b0cee8aeccab171a0ba.jpg" alt="string-suffix-tree"></p>
<p>可以看到，字符串 <code>me</code> 的路径已经完全和 <code>time</code> 重合了，而 <code>lime</code> 和 <code>time</code> 只是部分重合。我们只需要把所有<strong>有自己独立起点</strong>的字符串作为编码字符串就可以了。</p>
<p>其实这道题我们的思路很简单：<strong>如果有一对单词 s 和 t，使得 t 是 s 的后缀，例如 <code>me</code> 是 <code>time</code> 的后缀，我们就删掉单词 t。最后剩下来的单词，就是构成索引字符串的单词。</strong></p>
<p>那么，如何找到这些 s 和 t 呢？考虑到 s 和 t 的最后几个字母是一样的，我们可以从单词的最后一个字母向前考虑。先把所有的单词按照最后一个字母分成 26 组，这样 s 和 t 肯定在同一组；再在每一个组中按照倒数第二个字母分成 26 组……</p>
<p>我们发现这样排序太麻烦，不如直接<strong>把所有单词反转</strong>（reverse），让倒的变成正的。Amazing！所有单词反转之后，我们的单词排序规则变成了<strong>字典顺序</strong>，也就是各种语言中比较字符串的默认顺序。</p>
<p>不信你看，假设我们将 <code>[&quot;time&quot;, &quot;me&quot;, &quot;lime&quot;, &quot;sometime&quot;, &quot;hell&quot;, &quot;shell&quot;]</code> 几个单词反转后排序：</p>
<p><img src="/2020/03/31/单词的压缩编码/a175eba7060cddbcf43ebbedf3e838b9a3592923a4a8776ec765e66c391882c8.jpg" alt="process"></p>
<p>我们发现，<strong>如果 t 是 s 的后缀，那么反转之后 t’ 就是 s’ 的前缀。在反转+排序之后，s’ 一定紧跟在 t’ 的后面！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = words.length;</span><br><span class="line">    <span class="comment">//从字符串高位开始遍历排序</span></span><br><span class="line">    Arrays.sort(words, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = o1.length();</span><br><span class="line">            <span class="keyword">int</span> len2 = o2.length();</span><br><span class="line">            <span class="keyword">char</span>[] arry1 = o1.toCharArray();</span><br><span class="line">            <span class="keyword">char</span>[] arry2 = o2.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Math.min(len1,len2);++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> c = Character.compare(arry1[len1 - <span class="number">1</span> - i],arry2[len2 - <span class="number">1</span> - i]);</span><br><span class="line">                <span class="keyword">if</span>(c != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(len1,len2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> &lt; len &amp;&amp; words[i+<span class="number">1</span>].endsWith(words[i])) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans += words[i].length()+<span class="number">1</span>;  <span class="comment">//加上'#'的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><p>见<a href="https://leetcode-cn.com/problems/short-encoding-of-words/solution/99-java-trie-tu-xie-gong-lue-bao-jiao-bao-hui-by-s/" target="_blank" rel="noopener">sweetiee</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>卡牌分组</title>
    <url>/2020/03/31/%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<p>来自Leetcode第914题卡牌分组</p>
<p>给定一副牌，每张牌上都写着一个整数。</p>
<p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p>
<ul>
<li>每组都有 <code>X</code> 张牌。</li>
<li>组内所有的牌上都写着相同的整数。</li>
</ul>
<p>仅当你可选的 <code>X &gt;= 2</code> 时返回 <code>true</code>。<br><a id="more"></a><br><strong>示例 1：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：可行的分组是 [<span class="number">1</span>,<span class="number">1</span>]，[<span class="number">2</span>,<span class="number">2</span>]，[<span class="number">3</span>,<span class="number">3</span>]，[<span class="number">4</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h3 id="求最大公因子"><a href="#求最大公因子" class="headerlink" title="求最大公因子"></a>求最大公因子</h3><p>首先遍历数组，将牌上的整数放入对应的桶中，最后遍历桶，如果桶里的计数有最大公因子，就返回真，否则假。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="keyword">int</span>[] deck)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计数</span></span><br><span class="line">    <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: deck) &#123;</span><br><span class="line">        counter[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求gcd</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cnt: counter) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = gcd(x, cnt);</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辗转相除法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        c = b % a;</span><br><span class="line">        b = c;</span><br><span class="line">        a = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>水壶问题</title>
    <url>/2020/03/22/%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>来自Leetcode第365题水壶问题</p>
<p>有两个容量分别为 <em>x</em>升 和 <em>y</em>升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 <em>z</em>升 的水？</p>
<p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 <em>z升</em> 水。</p>
<p>你允许：</p>
<ul>
<li>装满任意一个水壶</li>
<li>清空任意一个水壶</li>
<li>从一个水壶向另外一个水壶倒水，直到装满或者倒空<a id="more"></a>
<strong>示例 1:</strong> (From the famous <a href="https://www.youtube.com/watch?v=BVtQNK_ZUJg" target="_blank" rel="noopener"><em>“Die Hard”</em> example</a>)</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: x = <span class="number">3</span>, y = <span class="number">5</span>, z = <span class="number">4</span></span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="求最大公因数"><a href="#求最大公因数" class="headerlink" title="求最大公因数"></a>求最大公因数</h3><p>来自<a href="https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>
<p>预备知识：<a href="https://baike.baidu.com/item/裴蜀定理/5186593?fromtitle=贝祖定理&amp;fromid=5185441" target="_blank" rel="noopener">贝祖定理</a></p>
<p>对任何<a href="https://baike.baidu.com/item/整数" target="_blank" rel="noopener">整数</a>a、b和它们的最大公约数d，关于<a href="https://baike.baidu.com/item/未知数" target="_blank" rel="noopener">未知数</a>x和y的线性不定方程（称为裴蜀等式）：若a,b是整数,且gcd(a,b)=d，那么对于任意的整数x,y,ax+by都一定是d的倍数，特别地，一定存在整数x,y，使ax+by=d成立。</p>
<p>它的一个重要推论是：a,b<a href="https://baike.baidu.com/item/互质/577412" target="_blank" rel="noopener">互质</a>的充要条件是存在<a href="https://baike.baidu.com/item/整数" target="_blank" rel="noopener">整数</a>x,y使ax+by=1.</p>
<p>${(\frac{m}{d}(x_0 + \frac{kb}{d}),\frac{m}{d}(y_0 + \frac{ka}{d})) | k \in Z}$</p>
<p>在题目所给的操作下，两个桶不可能同时有水且不满。因为观察题目中的所有操作的结果都至少有一个桶是空的或者满的；</p>
<p>其次，对一个不满的桶加水是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于直接从初始状态给这个桶加满水；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态分别给两个桶加满；</p>
<p>再次，把一个不满的桶里面的水倒掉是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于回到初始状态；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态直接给另一个桶倒满。</p>
<p>因此，我们可以认为每次操作只会给水的总量带来 <code>x</code> 或者 <code>y</code> 的变化量。因此我们的目标可以改写成：找到一对整数 a, b，使得</p>
<p>$ax+by=z$</p>
<p>而只要满足 $z\leq x+y$，且这样的 a, b 存在，那么我们的目标就是可以达成的。这是因为：</p>
<ul>
<li><p>若 $a\geq 0, b\geq 0$，那么显然可以达成目标。</p>
</li>
<li><p>若 $a\lt 0$，那么可以进行以下操作：</p>
<ol>
<li>往 <code>y</code> 壶倒水；</li>
<li>把 <code>y</code> 壶的水倒入 <code>x</code> 壶；</li>
<li>如果 <code>y</code> 壶不为空，那么 <code>x</code> 壶肯定是满的，把 <code>x</code> 壶倒空，然后再把 <code>y</code> 壶的水倒入 <code>x</code> 壶。</li>
</ol>
<p>重复以上操作直至某一步时 <code>x</code> 壶进行了 <em>a</em> 次倒空操作，<code>y</code> 壶进行了 <em>b</em> 次倒水操作。</p>
</li>
<li><p>若 $b\lt 0$，方法同上，<code>x</code> 与 <code>y</code> 互换。</p>
</li>
</ul>
<p>而贝祖定理告诉我们，$ax+by=z$ 有解当且仅当 z 是 x, y的最大公约数的倍数。因此我们只需要找到 x, y的最大公约数并判断 z是否是它的倍数即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x + y &lt; z)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span> || y == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> z == <span class="number">0</span> || x + y == z;</span><br><span class="line">        <span class="keyword">while</span>(y != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = y;</span><br><span class="line">            y = x % y;</span><br><span class="line">            x = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> z % x == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>摘自<a href="https://leetcode-cn.com/problems/water-and-jug-problem/solution/tu-de-yan-du-you-xian-bian-li-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></p>
<p>题目说：</p>
<blockquote>
<p>你允许：</p>
<ul>
<li>装满任意一个水壶</li>
<li>清空任意一个水壶</li>
<li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li>
</ul>
</blockquote>
<p>为了方便说明，我们做如下定义：</p>
<p>装满任意一个水壶，定义为「操作一」，分为：<br>（1）装满 <code>A</code>，包括 <code>A</code> 为空和 <code>A</code> 非空的时候把 <code>A</code> 倒满的情况；<br>（2）装满 <code>B</code>，包括 <code>B</code> 为空和 <code>B</code> 非空的时候把 <code>B</code> 倒满的情况。</p>
<p>清空任意一个水壶，定义为「操作二」，分为<br>（1）清空 <code>A</code>；<br>（2）清空 <code>B</code>。</p>
<p>从一个水壶向另外一个水壶倒水，直到装满或者倒空，定义为「操作三」，其实根据描述「装满」或者「倒空」就知道可以分为 4 种情况：</p>
<p>（1）从 <code>A</code> 到 <code>B</code>，使得 <code>B</code> 满，<code>A</code> 还有剩；<br>（2）从 <code>A</code> 到 <code>B</code>，此时 <code>A</code> 的水太少，<code>A</code> 倒尽，<code>B</code> 没有满；<br>（3）从 <code>B</code> 到 <code>A</code>，使得 <code>A</code> 满，<code>B</code> 还有剩余；<br>（4）从 <code>B</code> 到 <code>A</code>，此时 <code>B</code> 的水太少，<code>B</code> 倒尽，<code>A</code> 没有满。</p>
<p>因此，从当前「状态」最多可以进行 8 种操作，得到 8 个新「状态」，对这 8 个新「状态」，依然可以扩展，一直做下去，直到某一个状态满足题目要求。</p>
<p>建议大家在草稿纸上做一个简单的计算，看一下这 8 种操作怎么写，需要注意哪些边界的情况，相信是一个不错的练习。</p>
<p>然后请大家自己尝试写一下代码，广度优先遍历常见的写法有 2 种，由于这里不用求路径最短的长度，在出队的时候不用读取队列的长度。</p>
<ul>
<li>从当前状态可以扩展出 8 种相邻的状态；</li>
<li>因为状态有重复，因此是一个「有向」且「有环」的图，在遍历的时候，需要判断该结点设置是否访问过；</li>
<li>有序整数对 <code>(a, b)</code> 可以自定义成一个私有的类；</li>
<li>图的遍历，可以使用「深度优先遍历」和「广度优先遍历」，因为状态空间很大，广搜是相对较快；</li>
<li>尽量「剪枝」，跳过不必要的搜索；</li>
<li>当然最快的是数学方法。</li>
</ul>
<p>要重写qeuals和hashcode方法，不然会超时，这和HashSet的判断重复有关。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x + y &lt; z)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> z == <span class="number">0</span> || x + y == z;</span><br><span class="line">    Queue&lt;Pair&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Pair start = <span class="keyword">new</span> Pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    queue.add(start);  <span class="comment">//增加初始状态(0,0)</span></span><br><span class="line">    HashSet&lt;Pair&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    visited.add(start);</span><br><span class="line">    Pair temp;</span><br><span class="line">    <span class="keyword">int</span> curX, curY,tmp;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        temp = queue.poll();</span><br><span class="line">        curX = temp.x;</span><br><span class="line">        curY = temp.y;</span><br><span class="line">        <span class="keyword">if</span> (curX == z || curY == z || curX + curY == z) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curX == <span class="number">0</span>) &#123;  <span class="comment">//转移状态1，将x装满</span></span><br><span class="line">            temp = <span class="keyword">new</span> Pair(x, curY);</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(temp)) &#123;</span><br><span class="line">                visited.add(temp);</span><br><span class="line">                queue.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curY == <span class="number">0</span>) &#123;  <span class="comment">//转移状态1，将y装满</span></span><br><span class="line">            temp = <span class="keyword">new</span> Pair(curX, y);</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(temp)) &#123;</span><br><span class="line">                visited.add(temp);</span><br><span class="line">                queue.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curY &lt; y) &#123; <span class="comment">// 转移状态3，将x倒空</span></span><br><span class="line">            temp = <span class="keyword">new</span> Pair(<span class="number">0</span>, curY);</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(temp)) &#123;</span><br><span class="line">                visited.add(temp);</span><br><span class="line">                queue.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curX &lt; x) &#123; <span class="comment">// 转移状态3，将x倒空</span></span><br><span class="line">            temp = <span class="keyword">new</span> Pair(curX, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(temp)) &#123;</span><br><span class="line">                visited.add(temp);</span><br><span class="line">                queue.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp = Math.min(curX, y - curY);</span><br><span class="line">        <span class="comment">// y - curY是第二个桶还可以再加的水的升数，但是最多只能加curX升水。</span></span><br><span class="line">        temp = <span class="keyword">new</span> Pair(curX - tmp, curY + tmp);</span><br><span class="line">        <span class="keyword">if</span> (!visited.contains(temp)) &#123;</span><br><span class="line">            visited.add(temp);</span><br><span class="line">            queue.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp = Math.min(curY, x - curX);</span><br><span class="line">        <span class="comment">// y - curY是第二个桶还可以再加的水的升数，但是最多只能加curX升水。</span></span><br><span class="line">        temp = <span class="keyword">new</span> Pair(curX + tmp, curY - tmp);</span><br><span class="line">        <span class="keyword">if</span> (!visited.contains(temp)) &#123;</span><br><span class="line">            visited.add(temp);</span><br><span class="line">            queue.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="keyword">null</span> || getClass() != obj.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Pair p = (Pair)obj;</span><br><span class="line">        <span class="keyword">return</span> p.x == <span class="keyword">this</span>.x &amp;&amp; p.y == <span class="keyword">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x * <span class="number">10000</span> + <span class="keyword">this</span>.y / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>最小的k个数</title>
    <url>/2020/03/22/%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>来自面试题40.最小的k个数</p>
<p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。<br><a id="more"></a><br><strong>示例 1：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>] 或者 [<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="快排partition"><a href="#快排partition" class="headerlink" title="快排partition"></a>快排partition</h2><p>利用快排里的partition操作，将第i大的数据固定在第i位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个参数表示我们要找的是下标为k-1的数</span></span><br><span class="line">        <span class="keyword">return</span> quickSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] quickSearch(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(nums, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span></span><br><span class="line">        <span class="keyword">return</span> j &gt; k? quickSearch(nums, lo, j - <span class="number">1</span>, k): quickSearch(nums, j + <span class="number">1</span>, hi, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[lo];</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt;= hi &amp;&amp; nums[i] &lt; v);</span><br><span class="line">            <span class="keyword">while</span> (--j &gt;= lo &amp;&amp; nums[j] &gt; v);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> t = nums[j];</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line">            nums[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[lo] = nums[j];</span><br><span class="line">        nums[j] = v;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>面试相关</title>
    <url>/2020/03/20/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>鹅厂一面有关：</p>
<ol>
<li><p>询问项目经历  与技术相关</p>
</li>
<li><p>equals 和 Hashcode 的关系</p>
</li>
<li><p>== 和 equals</p>
</li>
<li><p>HashMap底层原理 （Node数组+链表/红黑树</p>
<a id="more"></a></li>
<li><p>HashSet 和 HashMap的区别</p>
</li>
<li><p>HashMap 和 HashTable的比较 </p>
</li>
<li><p>对线程安全的理解 </p>
</li>
<li><p>设计模式 具体讲一种（23种工厂模式</p>
</li>
<li><p>GC机制（引用计数器，新生代复制算法忘了没说出来</p>
</li>
<li><p>C 指针和引用的区别</p>
<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
</ul>
<p>引用的好处之一就是在函数调用时在内存中不会生成副本。</p>
</li>
<li><p>讲一下安卓的有关知识</p>
</li>
<li><p>安卓生命周期</p>
</li>
<li><p>如何在线程里实现下载进度提示 </p>
</li>
<li><p>线程间通信方式</p>
</li>
<li><p>问有没有学过一些框架</p>
</li>
<li><p>TCP协议和UDP协议的区别</p>
</li>
<li><p>TCP协议的3次握手和4次握手</p>
</li>
<li><p>HTTP和HTTPS （HTTPS没讲好，像TLS/SSL都没有讲</p>
</li>
<li><p>DNS协议</p>
</li>
<li><p>快速排序原理和时间复杂度</p>
</li>
<li><p>ACM算法有关</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>丑数II</title>
    <url>/2020/03/18/%E4%B8%91%E6%95%B0II/</url>
    <content><![CDATA[<p>来自Leetcode第264题丑数II</p>
<p>编写一个程序，找出第 <code>n</code> 个丑数。</p>
<p>丑数就是只包含质因数 <code>2, 3, 5</code> 的<strong>正整数</strong>。<br><a id="more"></a><br><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: n = <span class="number">10</span></span><br><span class="line">输出: <span class="number">12</span></span><br><span class="line">解释: <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span> 是前 <span class="number">10</span> 个丑数。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>来自<a href="https://leetcode-cn.com/problems/ugly-number-ii/solution/chou-shu-ii-by-leetcode/" target="_blank" rel="noopener">官方题解</a></p>
<p>从堆中包含一个数字开始：1，去计算下一个丑数。将 1 从堆中弹出然后将三个数字添加到堆中：1 * 2，1 * 3和 1 * 5。</p>
<p>现在堆中最小的数字是 2。为了计算下一个丑数，要将 2 从堆中弹出然后添加三个数字：2×2, 2×3，和 2×5。</p>
<p>重复该步骤计算所有丑数。在每个步骤中，弹出堆中最小的丑数 k<em>k</em>，并在堆中添加三个丑数：<em>k</em>×2, k<em>×3，和 k</em>×5。</p>
<ul>
<li>初始化预计算用到的数组 <code>nums</code>，堆 <code>heap</code> 和哈希表 <code>seen</code> 跟踪在堆中出现过的元素，避免重复。<ul>
<li>循环计算丑数，每个步骤：<ul>
<li>弹出堆中最小的数字 <code>k</code> 并添加到数组 <code>nums</code> 中。</li>
<li>若 <code>2k</code>，<code>3k</code>，<code>5k</code> 不存在在哈希表中，则将其添加到栈中并更新哈希表。</li>
</ul>
</li>
</ul>
</li>
<li>返回在数组中预先计算好的丑数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ugly</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1690</span>];</span><br><span class="line">  Ugly() &#123;</span><br><span class="line">    HashSet&lt;Long&gt; seen = <span class="keyword">new</span> HashSet();</span><br><span class="line">    PriorityQueue&lt;Long&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Long&gt;();</span><br><span class="line">    seen.add(<span class="number">1L</span>);</span><br><span class="line">    heap.add(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> currUgly, newUgly;</span><br><span class="line">    <span class="keyword">int</span>[] primes = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1690</span>; ++i) &#123;</span><br><span class="line">      currUgly = heap.poll();</span><br><span class="line">      nums[i] = (<span class="keyword">int</span>)currUgly;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j : primes) &#123;</span><br><span class="line">        newUgly = currUgly * j;</span><br><span class="line">        <span class="keyword">if</span> (!seen.contains(newUgly)) &#123;</span><br><span class="line">          seen.add(newUgly);</span><br><span class="line">          heap.add(newUgly);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Ugly u = <span class="keyword">new</span> Ugly();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u.nums[n - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三指针"><a href="#三指针" class="headerlink" title="三指针"></a>三指针</h3><p>从数组中只包含一个丑数数字 1 开始，使用三个指针 i_2<em>i</em>2, i_3<em>i</em>3 和 i_5<em>i</em>5，标记所指向丑数要乘以的因子。</p>
<p>算法很简单：在 $2 \times \textrm{nums}[i_2]，3 \times \textrm{nums}[i_3] 和 5 \times \textrm{nums}[i_5]$ 选出最小的丑数并添加到数组中。并将该丑数对应的因子指针往前走一步。重复该步骤直到计算完 1690 个丑数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ugly</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1690</span>];</span><br><span class="line">  Ugly() &#123;</span><br><span class="line">    nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ugly, i2 = <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1690</span>; ++i) &#123;</span><br><span class="line">      ugly = Math.min(Math.min(nums[i2] * <span class="number">2</span>, nums[i3] * <span class="number">3</span>), nums[i5] * <span class="number">5</span>);</span><br><span class="line">      nums[i] = ugly;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ugly == nums[i2] * <span class="number">2</span>) ++i2;</span><br><span class="line">      <span class="keyword">if</span> (ugly == nums[i3] * <span class="number">3</span>) ++i3;</span><br><span class="line">      <span class="keyword">if</span> (ugly == nums[i5] * <span class="number">5</span>) ++i5;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Ugly u = <span class="keyword">new</span> Ugly();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u.nums[n - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>三指针</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记整理</title>
    <url>/2020/03/16/JAVA%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><h3 id="float中的32bit中哪些代表符号位，小数位，整数位，指数位？"><a href="#float中的32bit中哪些代表符号位，小数位，整数位，指数位？" class="headerlink" title="float中的32bit中哪些代表符号位，小数位，整数位，指数位？"></a>float中的32bit中哪些代表符号位，小数位，整数位，指数位？</h3><a id="more"></a>
<p>答：float：<br>1bit（符号位） 8bits（指数位） 23bits（尾数位）<br>double：<br>1bit（符号位） 11bits（指数位） 52bits（尾数位）<br>于是，float的指数范围为-128~+127，而double的指数范围为-1024~+1023，并且指数位是按补码的形式来划分的。float的范围为-2^128 ~ +2^127，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1024 ~ +2^1023，也即-1.79E+308 ~ +1.79E+308。</p>
<hr>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>答：事物在运行过程中存在不同的状态。多态的存在有<strong>三个前提</strong>:<br><strong>1.要有继承关系</strong><br><strong>2.子类要重写父类的方法</strong><br><strong>3.父类引用指向子类对</strong><br>多态成员访问的特点：<br><strong>成员变量</strong><br>编译看左边(父类),运行看左边(父类)<br><strong>成员方法</strong><br>编译看左边(父类)，运行看右边(子类)。动态绑定<br><strong>静态方法</strong><br>编译看左边(父类)，运行看左边(父类)。<br>(静态和类相关，算不上重写，所以，访问还是左边的)<br><strong>只有非静态的成员方法,编译看左边,运行看右边</strong><br><strong>多态的弊端，就是：不能使用子类特有的成员属性和子类特有的成员方法。</strong></p>
<hr>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>答：子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<hr>
<h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>1.当子类和父类存在同一个方法，子类重写了父类的方法，程序在运行时调用的是父类的方法还是子类的重写方法呢（尤其是存在向上类型转换的情况）？</p>
<p>2.当一个类中存在方法名相同但参数不同（重载）的方法，程序在执行的时候该如何辨别区分使用哪个方法呢？</p>
<p>答：</p>
<h4 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h4><p>在程序执行以前已经被绑定（即在编译过程中就已经知道这个方法到底是哪个类中的方法）。</p>
<p>java当中的方法只有final、static、private修饰的方法和构造方法是静态绑定的。</p>
<p>private修饰的方法：private修饰的方法是不能被继承的，因此子类无法访问父类中private修饰的方法。所以只能通过父类对象来调用该方法体。因此可以说private方法和定义这个方法的类绑定在了一起。</p>
<p>final修饰的方法：可以被子类继承，但是不能被子类重写（覆盖），所以在子类中调用的实际是父类中定义的final方法。（使用final修饰方法的两个好处：（1）防止方法被覆盖；（2）关闭java中的动态绑定）。</p>
<p>static修饰的方法：可以被子类继承，但是不能被子类重写（覆盖），但是可以被子类隐藏。（这里意思是说如果父类里有一个static方法，它的子类里如果没有对应的方法，那么当子类对象调用这个方法时就会使用父类中的方法，而如果子类中定义了相同的方法，则会调用子类中定义的方法，唯一的不同就是：当子类对象向上类型转换为父类对象时，不论子类中有没有定义这个静态方法，该对象都会使用父类中的静态方法，因此这里说静态方法可以被隐藏而不能被覆盖。这与子类隐藏父类中的成员变量是一样的。隐藏和覆盖的区别在于，子类对象转换成父类对象后，能够访问父类被隐藏的变量和方法，而不能访问父类被覆盖的方法）。</p>
<p>构造方法：构造方法也是不能被继承的（因为子类是通过super方法调用父类的构造函数，或者是jvm自动调用父类的默认构造方法），因此编译时也可以知道这个构造方法方法到底是属于哪个类的。</p>
<p>因此，一个方法被继承，或者是被继承后不能被覆盖，那么这个方法就采用静态绑定</p>
<h4 id="动态绑定-1"><a href="#动态绑定-1" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>在运行时期根据具体对象的类型进行绑定。</p>
<p>若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的，但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。</p>
<p>动态绑定的过程：</p>
<p>1.虚拟机提取对象实际类型的方法表</p>
<p>2.虚拟机搜索方法签名</p>
<p>3.调用方法</p>
<p>java中重载的方法使用静态绑定，重写的方法使用动态绑定。</p>
<hr>
<h3 id="String-stringbuffer-stringbuider区别"><a href="#String-stringbuffer-stringbuider区别" class="headerlink" title="String, stringbuffer, stringbuider区别"></a>String, stringbuffer, stringbuider区别</h3><h4 id="String-字符串常量"><a href="#String-字符串常量" class="headerlink" title="String 字符串常量"></a>String 字符串常量</h4><p>StringBuffer 字符串变量（线程安全）<br>StringBuilder 字符串变量（非线程安全）<br> 简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。<br> 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢。</p>
<h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a><strong>StringBuffer</strong></h4><p>Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。<br>可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。<br>StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。</p>
<h4 id="java-lang-StringBuilder"><a href="#java-lang-StringBuilder" class="headerlink" title="java.lang.StringBuilder"></a><strong>java.lang.StringBuilder</strong></h4><p>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。</p>
<hr>
<h3 id="通过反射是可以修改所谓的“不可变”对象"><a href="#通过反射是可以修改所谓的“不可变”对象" class="headerlink" title="通过反射是可以修改所谓的“不可变”对象"></a><strong>通过反射是可以修改所谓的“不可变”对象</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符串"Hello World"， 并赋给引用s</span></span><br><span class="line">		String s = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"s = "</span> + s); <span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取String类中的value字段</span></span><br><span class="line">		Field valueFieldOfString = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 改变value属性的访问权限</span></span><br><span class="line">		valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取s对象上的value属性的值</span></span><br><span class="line">		<span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 改变value所引用的数组中的第5个字符</span></span><br><span class="line">		value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"s = "</span> + s); <span class="comment">// Hello_World</span></span><br></pre></td></tr></table></figure>
<p>解析：</p>
<p>用反射可以访问私有成员， 然后反射出 String 对象中的 value 属性， 进而改变通过获得的 value 引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p>
<hr>
<h3 id="重写hashcode-是否需要重写equals-不重写会有什么后果"><a href="#重写hashcode-是否需要重写equals-不重写会有什么后果" class="headerlink" title="重写hashcode()是否需要重写equals(),不重写会有什么后果"></a>重写hashcode()是否需要重写equals(),不重写会有什么后果</h3><p>我们先来看一下Object.hashCode的通用约定（摘自《Effective Java》第45页）</p>
<ol>
<li>在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，那么，对该对象调用hashCode方法多次，它必须始终如一地返回 同一个整数。在同一个应用程序的多次执行过程中，这个整数可以不同，即这个应用程序这次执行返回的整数与下一次执行返回的整数可以不一致。</li>
<li>如果两个对象根据equals(Object)方法是相等的，那么调用这两个对象中任一个对象的hashCode方法必须产生同样的整数结果。</li>
<li>如果两个对象根据equals(Object)方法是不相等的，那么调用这两个对象中任一个对象的hashCode方法，不要求必须产生不同的整数结果。然而，程序员应该意识到这样的事实，对于不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能。</li>
</ol>
<p><strong>如果只重写了equals方法而没有重写hashCode方法的话，则会违反约定的第二条：相等的对象必须具有相等的散列码（hashCode）。</strong></p>
<p>   <strong>同时对于HashSet和HashMap这些基于散列值（hash）实现的类。</strong>HashMap的底层处理机制是以数组的方法保存放入的数据的(Node<k,v>[] table)，其中的关键是数组下标的处理。<strong>数组的下标是根据传入的元素hashCode方法的返回值再和特定的值异或决定的。</strong>如果该数组位置上已经有放入的值了，且传入的键值相等则不处理，若不相等则覆盖原来的值，如果数组位置没有条目，则插入，并加入到相应的链表中。检查键是否存在也是根据hashCode值来确定的。所以如果不重写hashCode的话，<strong>可能导致HashSet、HashMap不能正常的运作、</strong></k,v></p>
<p>  如果我们将某个自定义对象存到HashMap或者HashSet及其类似实现类中的时候，<strong>如果该对象的属性参与了hashCode的计算，那么就不能修改该对象参数hashCode计算的属性了。</strong>有可能会移除不了元素，导致内存泄漏。</p>
<p><strong>ArrayList只根据equals()来判断</strong>两个对象是否相等，而不管hashCode是否不相等。<strong>HashSet</strong>判断流程则不一样，①<strong>先判断两个对象的hashCode方法是否一样</strong>；②如果不一样，立即认为两个对象equals不相等，并不调用equals方法；③当hashCode相等时，再根据equals方法判断两个对象是否相等。</p>
<p>当我们所写的类可能用于存放在Hash相关的集合类中时，<strong>在重写equals时，需要重写hashCode，不然会出现与预期不符的结果</strong>。</p>
<hr>
<h3 id="既然有GC-机制，为什么还会有内存泄露的情况"><a href="#既然有GC-机制，为什么还会有内存泄露的情况" class="headerlink" title="既然有GC 机制，为什么还会有内存泄露的情况"></a>既然有GC 机制，为什么还会有内存泄露的情况</h3><p>理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是 Java 被广泛使用于服务器端编程的一个重要原因）。然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被 GC 回收，因此也会导致内存泄露的发生。<br>例如 hibernate 的 Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。<br>下面例子中的代码也会导致内存泄露。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.EmptyStackException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INIT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elements = (T[]) <span class="keyword">new</span> Object[INIT_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T elem)</span> </span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = elem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(elements.length == size) &#123;</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的 pop 方法却存在内存泄露的问题，当我们用 pop 方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsoletereference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发 Disk Paging （物理内存与硬盘的虚拟内存交换数据），甚至造成 OutOfMemoryError。</p>
<hr>
<h3 id="Java-的GC-什么时候回收垃圾"><a href="#Java-的GC-什么时候回收垃圾" class="headerlink" title="Java 的GC 什么时候回收垃圾"></a>Java 的GC 什么时候回收垃圾</h3><p>在面试中经常会碰到这样一个问题：如何判断一个对象已经死去？<br>很容易想到的一个答案是：对一个对象添加引用计数器。每当有地方引用它时，计数器值加1；当引用失效时，计数器值减1.而当计数器的值为0 时这个对象就不会再被使用，判断为已死。是不是简单又直观。然而，很遗憾。这种做法是错误的！为什么是错的呢？事实上，用引用计数法确实在大部分情况下是一个不错的解决方案，而在实际的应用中也有不少案例，但它却无法解决对象之间的循环引用问题。比如对象A 中有一个字段指向了对象B，而对象B 中也有一个字段指向了对象A，而事实上他们俩都不再使用，但计数器的值永远都不可能为0，也就不会被回收，然后就发生了内存泄露。<br>所以，正确的做法应该是怎样呢？<br>在Java，C#等语言中，比较主流的判定一个对象已死的方法是：可达性分析(Reachability Analysis).<br>所有生成的对象都是一个称为”GC Roots”的根的子树。从GC Roots 开始向下搜索，搜索所经过的路径称为引用链(Reference Chain)，当一个对象到GC Roots 没有任何引用链可以到达时，就称这个对象是不可达的（不可引用的），也就是可以被GC 回收了。<br>无论是引用计数器还是可达性分析，判定对象是否存活都与引用有关！那么，如何定义对象的引用呢？<br>我们希望给出这样一类描述：当内存空间还够时，能够保存在内存中；如果进行了垃圾回收之后内存空间仍旧非常紧张，则可以抛弃这些对象。所以根据不同的需求，给出如下四种引用，根据引用类型的不同，GC 回收时也会有不同的操作：<br>1)强引用(Strong Reference):Object obj = new Object();只要强引用还存在，GC 永远不会回收掉被引用的对象。<br>2)软引用(Soft Reference)：描述一些还有用但非必需的对象。在系统将会发生内存溢出之前，会把这些对象列入回收范围进行二次回收（即系统将会发生内存溢出了，才会对他们进行回收。）<br>弱引用(Weak Reference):程度比软引用还要弱一些。这些对象只能生存到下次GC 之前。当GC 工作时，无论内存是否足够都会将其回收（即只要进行GC，就会对他们进行回收。）<br>虚引用(Phantom Reference):一个对象是否存在虚引用，完全不会对其生存时间构成影响。<br>关于方法区中需要回收的是一些废弃的常量和无用的类。<br>1.废弃的常量的回收。这里看引用计数就可以了。没有对象引用该常量就可以放心的回收了。<br>2.无用的类的回收。什么是无用的类呢？<br>A.该类所有的实例都已经被回收。也就是Java 堆中不存在该类的任何实例；<br>B.加载该类的ClassLoader 已经被回收；<br>C.该类对应的java.lang.Class 对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。<br>总而言之:<br>对于堆中的对象，主要用可达性分析判断一个对象是否还存在引用，如果该对象没有任何引用就应该被回收。而根据我们实际对引用的不同需求，又分成了4 中引用，每种引用的回收机制也是不同的。<br>对于方法区中的常量和类，当一个常量没有任何对象引用它，它就可以被回收了。而对于类，如果可以判定它为无用类，就可以被回收了。</p>
<h4 id="新生代与复制算法"><a href="#新生代与复制算法" class="headerlink" title="新生代与复制算法"></a>新生代与复制算法</h4><p>目前大部分JVM的GC对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。一般将新生代划分为一块较大的Eden空间和两个较小的Survivor空间(From Space, To Space)，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor空间中。</p>
<p><img src="/2020/03/16/JAVA笔记整理/image-20200324095521916.png" alt="image-20200324095521916"></p>
<p>复制算法</p>
<p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p><img src="/2020/03/16/JAVA笔记整理/image-20200324100444414.png" alt="image-20200324100444414"></p>
<h4 id="老年代与标记复制算法"><a href="#老年代与标记复制算法" class="headerlink" title="老年代与标记复制算法"></a>老年代与标记复制算法</h4><p>而老年代因为每次只回收少量对象，因而采用Mark-Compact算法。</p>
<ol>
<li>JAVA虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储class类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。</li>
<li>对象的内存分配主要在新生代的Eden Space和Survivor Space的From Space(Survivor目前存放对象的那一块)，少数情况会直接分配到老生代。 </li>
<li>当新生代的Eden Space和From Space空间不足时就会发生一次GC，进行GC后，Eden Space和From Space区的存活对象会被挪到To Space，然后将Eden Space和From Space进行清理。 </li>
<li>如果To Space无法足够存储某个对象，则将这个对象存储到老生代。</li>
<li>在进行GC后，使用的便是Eden Space和To Space了，如此反复循环。 </li>
<li>当对象在Survivor区躲过一次GC后，其年龄就会+1。默认情况下年龄到达15的对象会被移到老生代中。</li>
</ol>
<p>标记-整理算法</p>
<p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="/2020/03/16/JAVA笔记整理/image-20200324100456084.png" alt="image-20200324100456084"></p>
<hr>
<h3 id="HashMap的底层数据结构，局限性与线程安全"><a href="#HashMap的底层数据结构，局限性与线程安全" class="headerlink" title="HashMap的底层数据结构，局限性与线程安全"></a>HashMap的底层数据结构，局限性与线程安全</h3><h4 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h4><p>哈希表结构（链表散列：数组+链表）实现，结合数组和链表的优点。当链表长度超过8时，链表转换为红黑树。</p>
<p> transient Node<k,v>[] table;</k,v></p>
<p><img src="/2020/03/16/JAVA笔记整理/1184092-20190220113622746-1879492177.png" alt="img"></p>
<h4 id="HashMap的工作原理"><a href="#HashMap的工作原理" class="headerlink" title="HashMap的工作原理"></a>HashMap的工作原理</h4><p>A：HashMap底层是hash数组和单向链表实现，数组中的每个元素都是链表，由Node内部类（实现Map.Entry<k,v>接口）实现，HashMap通过put&amp;get方法存储和获取。</k,v></p>
<p><strong>存储对象时，将K/V键值对传给put（）方法；</strong></p>
<p>①、调用hash（K）方法计算K的hash值，然后结合数组长度，计算得数组下标；</p>
<p>②、调整数组大小（当容器中得元素个数大于capacity*loadFactor时，容器会进行resize为2n）</p>
<p>③、</p>
<p>i、如果K的hash值在HashMap不存在，则执行插入；若存在，则发生碰撞；</p>
<p>ii、如果K的hash值在HashMap存在，且它们两者equals返回true，则更新键值对；</p>
<p>iii、如果K的hash值在HashMap存在，且它们两者equals返回false，则插入链表的尾部（尾插法）或者红黑树（树的添加方式）</p>
<p>（JDK1.7 之前使用头插法、JDK 1.8 使用尾插法）</p>
<p>（注意：当碰撞导致链表大于TREEIFY_THRESHOLD = 8时，就把链表转换为红黑树）</p>
<p>（注意：当碰撞导致链表大于TREEIFY_THRESHOLD = 8时，就把链表转换为红黑树）</p>
<p><strong>获取对象时，将K传给get（）方法：</strong></p>
<p>①、调用hash（K）方法（计算K的hash值）从而获取该键值对所在链表的数组下标；</p>
<p>②、顺序遍历链表，equals（）方法查找相同Node链表K值对应的V值</p>
<p>hashCode是定位的，存储位置；</p>
<p>equals是定性的，比较两者是否相等。</p>
<h4 id="当两个对象的hashCode相同会发生什么？"><a href="#当两个对象的hashCode相同会发生什么？" class="headerlink" title="当两个对象的hashCode相同会发生什么？"></a>当两个对象的hashCode相同会发生什么？</h4><p>A：因为hashCode相同，不一定就是相等的（equals方法比较），所以两个对象所在数组下标相同，“碰撞”就此发生。又因为HashMap使用链表存储对象，这个Node会存储到链表下。</p>
<h4 id="你知道hash的实现吗？为什么要这样实现？"><a href="#你知道hash的实现吗？为什么要这样实现？" class="headerlink" title="你知道hash的实现吗？为什么要这样实现？"></a>你知道hash的实现吗？为什么要这样实现？</h4><p>A：JDK1.8中，是通过hashCode（）的高16位异或低16位实现的：（h = k.hashCode()^(h&gt;&gt;&gt;16)）</p>
<p>主要是从速度、功效和质量来考虑的，减少系统的开销，也不会造成因为高位没有参与下标的计算，从而引起的碰撞。</p>
<h4 id="为什么要用异或运算符？"><a href="#为什么要用异或运算符？" class="headerlink" title="为什么要用异或运算符？"></a>为什么要用异或运算符？</h4><p>A：保持了对象的hashCode的32位值只要有一位发生改变，整个hash（）返回值就会改变。尽可能的减少碰撞。</p>
<h4 id="HashMap的table的容量如何确定？loadFactor是什么？该容量如何变化？这种变化会带来什么问题？"><a href="#HashMap的table的容量如何确定？loadFactor是什么？该容量如何变化？这种变化会带来什么问题？" class="headerlink" title="HashMap的table的容量如何确定？loadFactor是什么？该容量如何变化？这种变化会带来什么问题？"></a>HashMap的table的容量如何确定？loadFactor是什么？该容量如何变化？这种变化会带来什么问题？</h4><p>A：</p>
<p>①、table数组大小是由capacity这个参数确定的，默认是16，也可以构造时传入，最大限制为1&lt;&lt;30；</p>
<p>②、loadFactor是负载因子，主要目的是用来确认table数组是否需要动态扩展，默认值是0.75，比如table数组大小为16，装载因子为0.75时，threshold就是12，当table的实际大小超过12时，table就需要动态扩容；</p>
<p>③、扩容时，调用resize（）方法，将table长度变为原来的两倍（注意是table长度，而不是threshold）</p>
<p>④、如果数据很大的情况下，扩展时将会带来性能的损失，在性能要求很高的地方，这种损失很可能很致命。</p>
<h4 id="HashMap、LinkedHashMap、TreeMap有什么区别？"><a href="#HashMap、LinkedHashMap、TreeMap有什么区别？" class="headerlink" title="HashMap、LinkedHashMap、TreeMap有什么区别？"></a>HashMap、LinkedHashMap、TreeMap有什么区别？</h4><p>A：HashMap参考其他问题；</p>
<p>LinkedHashMap保存了记录得插入顺序，用iterator遍历时，先取到得记录肯定是先插入得；遍历比HashMap慢；</p>
<p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以知道排序得比较器）</p>
<h4 id="HashMap和HashTable有什么区别？"><a href="#HashMap和HashTable有什么区别？" class="headerlink" title="HashMap和HashTable有什么区别？"></a>HashMap和HashTable有什么区别？</h4><p>A：</p>
<p>①、HashMap是线程不安全，HashTable是线程安全的；</p>
<p>②、由于线程安全，所以HashTable的效率比不上HashMap；</p>
<p>③、HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而HashTable不允许；</p>
<p>④、HashMao默认初始化数组的大小为16，HashTable为11，前者扩容时，扩大两倍，后者扩大两倍+1；</p>
<p>⑤、HashMap需要重新计算hash值，而HashTable直接使用对象的hashCode。</p>
<h4 id="同样是线程类，ConcurrentHashMap-和-HashTable-在线程同步上有什么不同"><a href="#同样是线程类，ConcurrentHashMap-和-HashTable-在线程同步上有什么不同" class="headerlink" title="同样是线程类，ConcurrentHashMap 和 HashTable 在线程同步上有什么不同"></a>同样是线程类，ConcurrentHashMap 和 HashTable 在线程同步上有什么不同</h4><p>A：ConcurrentHashMap类（是Java并发包java.util.concurrent中提供的一个线程安全且高效的Hash Map实现）</p>
<p>HashTable是使用synchronize关键字加锁的原理（就是对对象加锁）</p>
<p>而针对ConcurrentHashMap，在JDK1.7 中采用分段锁的方式，JDK1.8 中直接采用了CAS（无锁算法）+ synchronized。</p>
<h4 id="HashMap-amp-ConcurrentHashMap-的区别？"><a href="#HashMap-amp-ConcurrentHashMap-的区别？" class="headerlink" title="HashMap &amp; ConcurrentHashMap 的区别？"></a>HashMap &amp; ConcurrentHashMap 的区别？</h4><p> A：除了加锁，原理上无太大区别。</p>
<p>另外，HashMap的键值对允许有null，但是ConcurrentHashMap 都不允许。</p>
<h4 id="为什么-ConcurrentHashMap-比-HashTable-效率要高？"><a href="#为什么-ConcurrentHashMap-比-HashTable-效率要高？" class="headerlink" title="为什么 ConcurrentHashMap 比 HashTable 效率要高？"></a>为什么 ConcurrentHashMap 比 HashTable 效率要高？</h4><p>A：HashTable使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞；</p>
<p>ConcurrentHashMap ：</p>
<p>JDK1.7使用分段锁（ReentrantLock + Segment + HashEntry）相当于把一个HashMap分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：基于Segment，包含多个HashEntry。</p>
<p>JDK1.8使用CAS + synchronized + Node + 红黑树。 锁粒度：Node（首结点）（实现Map.Entry<k,v>）。锁粒度降低了。</k,v></p>
<p>因为多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。</p>
<hr>
<h3 id="Collections-sychronizedMap与ConcurrentHashMap的区别"><a href="#Collections-sychronizedMap与ConcurrentHashMap的区别" class="headerlink" title="Collections.sychronizedMap与ConcurrentHashMap的区别"></a>Collections.sychronizedMap与ConcurrentHashMap的区别</h3><p>Collections.synchronizedMap()与ConcurrentHashMap主要区别是：Collections.synchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步，而ConcurrentHashMap的实现却更加精细，它对map中的所有桶加了锁。所以，只要要有一个线程访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map执行某些操作。这样，ConcurrentHashMap在性能以及安全性方面，明显比Collections.synchronizedMap()更加有优势。同时，同步操作精确控制到桶，所以，即使在遍历map时，其他线程试图对map进行数据修改，也不会抛出ConcurrentModificationException。<br>  但是，细心的朋友可能发现了，上面的例子，即使map=map3时，最后打印的结果可以并没有100行。由于，不论Collections.synchronizedMap()还是ConcurrentHashMap对map同步的原子操作都是作用的map的方法上，map在读取与清空之间，线程间是不同步的。上面代码的不足在于，我们对这些同步的map过于信任，而忽略了混合操作带来的影响。正确的方法是，把map的读取和清空看成一个原子操作，给整个代码块加锁。</p>
<p>还有一个区别是：ConcurrentHashMap从类的命名就能看出，它必然是个HashMap。而Collections.synchronizedMap()可以接收任意Map实例，实现Map的同步。</p>
<hr>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal顾名思义是线程私有的局部变量存储容器，可以理解成每个线程都有自己专属的存储容器，它用来存储线程私有变量，其实它只是一个外壳，内部真正存取是一个Map，后面会仔细讲解。每个线程可以通过<code>set()</code>和<code>get()</code>存取变量，多线程间无法访问各自的局部变量，相当于在每个线程间建立了一个隔板。只要线程处于活动状态，它所对应的ThreadLocal实例就是可访问的，线程被终止后，它的所有实例将被垃圾收集。总之记住一句话：<strong>ThreadLocal存储的变量属于当前线程</strong>。</p>
<p>ThreadLocal ，也叫线程本地变量，可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了所使用的的变量副本。使用起来都是在线程的本地工作内存中操作，并且提供了set和get方法来访问拷贝过来的变量副本。底层也是封装了ThreadLocalMap集合类来绑定当前线程和变量副本的关系，各个线程独立并且访问安全。</p>
<p>set方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">   Thread t = Thread.currentThread();<span class="comment">//1.首先获取当前线程对象</span></span><br><span class="line">       ThreadLocalMap map = getMap(t);<span class="comment">//2.获取该线程对象的ThreadLocalMap</span></span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">           map.set(<span class="keyword">this</span>, value);<span class="comment">//如果map不为空，执行set操作，以当前threadLocal对象为key，实际存储对象为value进行set操作</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           createMap(t, value);<span class="comment">//如果map为空，则为该线程创建ThreadLocalMap</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>(1) ThreadLocal仅仅是个变量访问的入口；</strong></p>
<p><strong>(2) 每一个Thread对象都有一个ThreadLocalMap对象，这个ThreadLocalMap持有对象的引用；</strong></p>
<p><strong>(3) ThreadLocalMap以当前的threadLocal对象为key，以真正的存储对象为value。get()方法时通过threadLocal实例就可以找到绑定在当前线程上的副本对象。</strong></p>
<p>ThreadLocal这样设计有两个目的：</p>
<p>第一：可以保证当前线程结束时，相关对象可以立即被回收；第二：ThreadLocalMap元素会大大减少，因为Map过大容易造成哈希冲突而导致性能降低。</p>
<p>get方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();<span class="comment">//1.首先获取当前线程</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);<span class="comment">//2.获取线程的map对象</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;<span class="comment">//3.如果map不为空，以threadlocal实例为key获取到对应Entry，然后从Entry中取出对象即可。</span></span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> (T)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();<span class="comment">//如果map为空，也就是第一次没有调用set直接get（或者调用过set，又调用了remove）时，为其设定初始值</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ThreadLocal对象通常用于防止对可变的单实例变量或全局变量进行共享。例如：由于JDBC的连接对象不是线程安全的，因此，当多个线程应用程序在没有协同的情况下，使用全局变量时，就是线程不安全的。通过将JDBC的连接对象保存到ThreadLocal中，每个线程都会拥有自己的连接对象副本。</p>
<hr>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><strong><a href="https://baike.baidu.com/item/JAVA反射机制/6015990" target="_blank" rel="noopener">JAVA反射机制</a>是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</strong></p>
<p><strong>静态编译和动态编译</strong></p>
<ul>
<li><strong>静态编译：</strong>在编译时确定类型，绑定对象</li>
<li><p><strong>动态编译：</strong>运行时确定类型，绑定对象</p>
<p>反射机制优缺点</p>
</li>
<li><p><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</p>
</li>
<li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。</li>
</ul>
<p>反射的应用场景</p>
<p><strong>反射是框架设计的灵魂。</strong></p>
<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<p>举例：① 我们在使用 JDBC 连接数据库时使用 <code>Class.forName()</code>通过反射加载数据库的驱动程序；②Spring 框架也用到很多反射机制，最经典的就是 xml 的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java 类里面解析 xml 或 properties 里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的 Class 实例; 4)动态配置实例的属性</p>
<p><strong>推荐阅读：</strong></p>
<ul>
<li><a href="https://segmentfault.com/a/1190000010162647?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">Reflection：Java 反射机制的应用场景</a></li>
<li><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078" target="_blank" rel="noopener">Java 基础之—反射（非常重要）</a></li>
</ul>
<hr>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p><img src="/2020/03/16/JAVA笔记整理/20160421004103005.png" alt="img"></p>
<p>在整个Java.io包中最重要的就是5个类和一个接口。5个类指的是File、OutputStream、InputStream、Writer、Reader；一个接口指的是Serializable.掌握了这些IO的核心操作那么对于Java中的IO体系也就有了一个初步的认识了</p>
<p>Java I/O主要包括如下几个层次，包含三个部分：</p>
<p> <strong>1.流式部分</strong>――IO的主体部分；</p>
<p> <strong>2.非流式部分</strong>――主要包含一些辅助流式部分的类，如：File类、RandomAccessFile类和FileDescriptor等类；</p>
<p> <strong>3.其他类</strong>—文件读取部分的与安全相关的类，如：SerializablePermission类，以及与本地操作系统相关的文件系统的类，如：FileSystem类和Win32FileSystem类和WinNTFileSystem类。</p>
<ol>
<li><p>File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等。</p>
</li>
<li><p>InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。</p>
</li>
<li><p>OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。</p>
</li>
<li><p>Reader（文件格式操作）：抽象类，基于字符的输入操作。</p>
</li>
<li><p>Writer（文件格式操作）：抽象类，基于字符的输出操作。</p>
</li>
<li><p>RandomAccessFile（随机文件操作）：一个独立的类，直接继承至Object.它的功能丰富，<strong>可以从文件的任意位置进行存取（输入输出）操作</strong>。</p>
</li>
</ol>
<p><img src="/2020/03/16/JAVA笔记整理/20160421004203974.png" alt="img"></p>
<p>流：代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象<thinking in java></thinking></p>
<p>流的本质:数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 </p>
<p><strong>流的作用：为数据源和目的地建立一个输送通道。</strong></p>
<p>   Java中将输入输出抽象称为流，就好像水管，将两个容器连接起来。流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流.</p>
<h4 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a><strong>IO流的分类</strong></h4><p>·    根据处理数据类型的不同分为：字符流和字节流</p>
<p>·    根据数据流向不同分为：输入流和输出流</p>
<p>·    按数据来源（去向）分类：</p>
<p>​     1、File（文件）： FileInputStream, FileOutputStream, FileReader, FileWriter<br>​     2、byte[]：ByteArrayInputStream, ByteArrayOutputStream<br>​     3、Char[]: CharArrayReader,CharArrayWriter<br>​     4、String:StringBufferInputStream, StringReader, StringWriter<br>​     5、网络数据流：InputStream,OutputStream, Reader, Writer </p>
<p>字符流和字节流</p>
<p>流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种：</p>
<p> <strong>1)</strong>  <strong>字节流：</strong>数据流中最小的数据单元是字节<br> <strong>2)</strong>  <strong>字符流：</strong>数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节。</p>
<p><strong>字符流的由来：</strong> Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。</p>
<p>输入流和输出流</p>
<p>根据数据的输入、输出方向的不同对而将流分为输入流和输出流。</p>
<p><strong>1) 输入流</strong></p>
<p>   程序从输入流读取数据源。数据源包括外界(键盘、文件、网络…)，即是将数据源读入到程序的通信通道</p>
<p>   <img src="/2020/03/16/JAVA笔记整理/20160421004522335.png" alt="img"></p>
<p>2) 输出流</p>
<p>  程序向输出流写入数据。将程序中的数据输出到外界（显示器、打印机、文件、网络…）的通信通道。</p>
<p>  <img src="/2020/03/16/JAVA笔记整理/20160421004605951.png" alt="img"></p>
<p>​     </p>
<p>采用数据流的目的就是使得输出输入独立于设备。</p>
<p>输入流( Input  Stream )不关心数据源来自何种设备（键盘，文件，网络）。<br>输出流( Output Stream )不关心数据的目的是何种设备（键盘，文件，网络）。</p>
<p><strong>3）特性</strong></p>
<p> 相对于程序来说，输出流是往存储介质或数据通道写入数据，而输入流是从存储介质或数据通道中读取数据，一般来说关于流的特性有下面几点：</p>
<p>1、先进先出，最先写入输出流的数据最先被输入流读取到。</p>
<p>2、顺序存取，可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据。（RandomAccessFile<strong>可以从文件的任意位置进行存取（输入输出）操作</strong>）</p>
<p>3、只读或只写，每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流。</p>
<p>IO流对象</p>
<p><strong>1.输入字节流InputStream</strong></p>
<p> <img src="/2020/03/16/JAVA笔记整理/20160421004733383.png" alt="img"></p>
<p>IO 中输入字节流的继承图可见上图，可以看出：</p>
<ol>
<li><p>InputStream是所有的输入字节流的父类，它是一个抽象类。</p>
</li>
<li><p>ByteArrayInputStream、StringBufferInputStream(上图的StreamBufferInputStream)、FileInputStream是三种基本的介质流，它们分别从Byte数组、StringBuffer、和本地文件中读取数据。</p>
</li>
<li><p>PipedInputStream是从与其它线程共用的管道中读取数据.</p>
</li>
<li><p>ObjectInputStream和所有FilterInputStream的子类都是装饰流（装饰器模式的主角）。</p>
</li>
</ol>
<p><strong>InputStream中的三个基本的读方法</strong><br>   abstract int read() ：读取一个字节数据，并返回读到的数据，如果返回-1，表示读到了输入流的末尾。<br>   intread(byte[]?b) ：将数据读入一个字节数组，同时返回实际读取的字节数。如果返回-1，表示读到了输入流的末尾。<br>   intread(byte[]?b, int?off, int?len) ：将数据读入一个字节数组，同时返回实际读取的字节数。如果返回-1，表示读到了输入流的末尾。off指定在数组b中存放数据的起始偏移位置；len指定读取的最大字节数。</p>
<p>流结束的判断：方法read()的返回值为-1时；readLine()的返回值为null时。</p>
<p><strong>其它方法</strong><br>   long skip(long?n)：在输入流中跳过n个字节，并返回实际跳过的字节数。<br>   int available() ：返回在不发生阻塞的情况下，可读取的字节数。<br>   void close() ：关闭输入流，释放和这个流相关的系统资源。<br>   voidmark(int?readlimit) ：在输入流的当前位置放置一个标记，如果读取的字节数多于readlimit设置的值，则流忽略这个标记。<br>   void reset() ：返回到上一个标记。<br>   booleanmarkSupported() ：测试当前流是否支持mark和reset方法。如果支持，返回true，否则返回false。</p>
<p>输出字节流OutputStream</p>
<p><img src="/2020/03/16/JAVA笔记整理/20160421004936555.png" alt="img"></p>
<p>IO 中输出字节流的继承图可见上图，可以看出：</p>
<ol>
<li><p>OutputStream是所有的输出字节流的父类，它是一个抽象类。</p>
</li>
<li><p>ByteArrayOutputStream、FileOutputStream是两种基本的介质流，它们分别向Byte数组、和本地文件中写入数据。PipedOutputStream是向与其它线程共用的管道中写入数据。</p>
</li>
<li><p>ObjectOutputStream和所有FilterOutputStream的子类都是装饰流。</p>
</li>
</ol>
<p>outputStream中的三个基本的写方法   abstract void write(int?b)：往输出流中写入一个字节。    void write(byte[]?b) ：往输出流中写入数组b中的所有字节。    void write(byte[]?b, int?off, int?len) ：往输出流中写入数组b中从偏移量off开始的len个字节的数据。</p>
<p>其它方法   void flush() ：刷新输出流，强制缓冲区中的输出字节被写出。    void close() ：关闭输出流，释放和这个流相关的系统资源。</p>
<hr>
<h3 id="volatile关键字的含义"><a href="#volatile关键字的含义" class="headerlink" title="volatile关键字的含义"></a>volatile关键字的含义</h3><p>volatile关键字是由JVM提供的最轻量级同步机制。与被滥用的synchronized不同，我们并不习惯使用它。</p>
<p>Java内存模型由Java虚拟机规范定义，用来屏蔽各个平台的硬件差异。简单来说:</p>
<ul>
<li>所有变量储存在主内存。</li>
<li>每条线程拥有自己的工作内存，其中保存了主内存中线程使用到的变量的副本。</li>
<li>线程不能直接读写主内存中的变量，所有操作均在工作内存中完成。</li>
</ul>
<p>线程，主内存，工作内存的交互关系如图。</p>
<p><img src="/2020/03/16/JAVA笔记整理/2018092713195033.png" alt="在这里插入图片描述"></p>
<p>内存间的交互操作有很多，和volatile有关的操作为：</p>
<ul>
<li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>
</ul>
<p>对被volatile修饰的变量进行操作时，需要满足以下规则：</p>
<ul>
<li>规则1：线程对变量执行的前一个动作是load时才能执行use，反之只有后一个动作是use时才能执行load。线程对变量的read，load，use动作关联，必须连续一起出现。——-这保证了线程每次使用变量时都需要从主存拿到最新的值，保证了其他线程修改的变量本线程能看到。</li>
<li>规则2：线程对变量执行的前一个动作是assign时才能执行store，反之只有后一个动作是store时才能执行assign。线程对变量的assign，store，write动作关联，必须连续一起出现。——-这保证了线程每次修改变量后都会立即同步回主内存，保证了本线程修改的变量其他线程能看到。</li>
<li>规则3：有线程T，变量V、变量W。假设动作A是T对V的use或assign动作，P是根据规则2、3与A关联的read或write动作；动作B是T对W的use或assign动作，Q是根据规则2、3与B关联的read或write动作。如果A先与B，那么P先与Q。———这保证了volatile修饰的变量不会被指令重排序优化，代码的执行顺序与程序的顺序相同。</li>
</ul>
<p>1.被volatile修饰的变量保证对所有线程可见。</p>
<p>由上文的规则1、2可知，volatile变量对所有线程是立即可见的，在各个线程中不存在一致性问题。volatile关键字只保证可见性，所以在以下情况中，需要使用锁来保证原子性：</p>
<ul>
<li>运算结果依赖变量的当前值，并且有不止一个线程在修改变量的值。</li>
<li>变量需要与其他状态变量共同参与不变约束</li>
</ul>
<p><strong>2.禁止指令重排序优化。</strong></p>
<p>jvm会把代码中没有依赖赋值的地方打乱执行顺序，由于一些规则限定，我们在单线程内观察不到打乱的现象（线程内表现为串行的语义），但是在并发程序中，从别的线程看另一个线程，操作是无序的。</p>
<p><strong>总结</strong></p>
<p>并发三特征可见性和有序性和原子性中，volatile通过新值立即同步到主内存和每次使用前从主内存刷新机制保证了可见性。<br>通过禁止指令重排序保证了有序性。<br>无法保证原子性。<br>而我们知道，synchronized关键字通过lock和unlock操作保证了原子性，<br>通过对一个变量unlock前，把变量同步回主内存中保证了可见性，<br>通过一个变量在同一时刻只允许一条线程对其进行lock操作保证了有序性。<br>他的“万能”也间接导致了我们对synchronized关键字的滥用，越泛用的控制，对性能的影响也越大，虽然jvm不断的对synchronized关键字进行各种各样的优化，但是我们还是要在合适的时候想起volatile关键字。</p>
<hr>
<h3 id="JAVA-NIO"><a href="#JAVA-NIO" class="headerlink" title="JAVA NIO"></a>JAVA NIO</h3><p>NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p>
<p>NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<p>IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<p>首先说一下Channel，国内大多翻译成“通道”。Channel和IO中的Stream(流)是差不多一个等级的。只不过Stream是单向的，譬如：InputStream, OutputStream.而Channel是双向的，既可以用来进行读操作，又可以用来进行写操作。</p>
<p>NIO中的关键Buffer实现有：ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer，分别对应基本数据类型: byte, char, double, float, int, long, short。当然NIO中还有MappedByteBuffer, HeapByteBuffer, DirectByteBuffer等这里先不进行陈述。</p>
<p>Selector运行单线程处理多个Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用Selector就会很方便。例如在一个聊天服务器中。要使用Selector, 得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收等。</p>
<hr>
<h3 id="String-不可变"><a href="#String-不可变" class="headerlink" title="String 不可变"></a>String 不可变</h3><p>String 底层实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//other codes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String 的底层实现是依靠 char[] 数组，既然依靠的是基础类型变量，那么他一定是可变的， String 之所以不可变，是因为 Java 的开发者通过技术实现，隔绝了使用者对 String 的底层数据的操作。但是，我们可以同反射的机制，操作 String 的底层，检验其不可变的猜想。</p>
<p><strong>为什么会将 String 设计为不可变</strong></p>
<ul>
<li>安全<ul>
<li>引发安全问题，譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞</li>
<li>保证线程安全，在并发场景下，多个线程同时读写资源时，会引竞态条件，由于 String 是不可变的，不会引发线程的问题而保证了线程</li>
<li>HashCode，当 String 被创建出来的时候，hashcode也会随之被缓存，hashcode的计算与value有关，若 String 可变，那么 hashcode 也会随之变化，针对于 Map、Set 等容器，他们的键值需要保证唯一性和一致性，因此，String 的不可变性使其比其他对象更适合当容器的键值。</li>
</ul>
</li>
<li>性能<ul>
<li>当字符串是不可变时，字符串常量池才有意义。字符串常量池的出现，可以减少创建相同字面量的字符串，让不同的引用指向池中同一个字符串，为运行时节约很多的堆内存。若字符串可变，字符串常量池失去意义，基于常量池的String.intern()方法也失效，每次创建新的 String 将在堆内开辟出新的空间，占据更多的内存</li>
</ul>
</li>
</ul>
<hr>
<h3 id="jre-jdk-jvm-的关系"><a href="#jre-jdk-jvm-的关系" class="headerlink" title="jre , jdk , jvm 的关系"></a>jre , jdk , jvm 的关系</h3><p><strong>JVM</strong> ：英文名称（Java Virtual Machine），就是我们耳熟能详的 Java 虚拟机。它只认识 xxx.class 这种类型的文件，它能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。所以说，jvm 是 Java 能够跨平台的核心，具体的下文会详细说明。</p>
<p><strong>什么是字节码?采用字节码的好处是什么?</strong></p>
<blockquote>
<p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
</blockquote>
<p><strong>Java 程序从源代码到运行一般有下面 3 步：</strong></p>
<p><img src="/2020/03/16/JAVA笔记整理/TIM截图20200401215950.jpg" alt="TIM截图20200401215950"></p>
<p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p>
<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p>
<p><strong>总结：</strong></p>
<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
<p><strong>JRE</strong> ：英文名称（Java Runtime Environment），我们叫它：Java 运行时环境。它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。</p>
<p><strong>JDK</strong> ：英文名称（Java Development Kit），Java 开发工具包。jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。例如：javac.exe，java.exe，jar.exe 等。</p>
<p>显然，这三者的关系是：一层层的嵌套关系。<strong>JDK&gt;JRE&gt;JVM</strong>。</p>
<hr>
<h3 id="什么是字节码？采用字节码的最大好处是什么？"><a href="#什么是字节码？采用字节码的最大好处是什么？" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么？"></a>什么是字节码？采用字节码的最大好处是什么？</h3><p><strong>先看下 java 中的编译器和解释器：</strong></p>
<p>Java 中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在 Java 中，这种供虚拟机理解的代码叫做<code>字节码</code>（即扩展名为<code>.class</code>的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了 Java 的编译与解释并存的特点。</p>
<p>Java 源代码——&gt;编译器——&gt;jvm 可执行的 Java 字节码(即虚拟指令)——&gt;jvm——&gt;jvm 中解释器——-&gt;机器可执行的二进制机器码——&gt;程序运行。</p>
<p><strong>采用字节码的好处：</strong></p>
<p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同的计算机上运行。</p>
<hr>
<h3 id="接口和抽象类的区别是什么"><a href="#接口和抽象类的区别是什么" class="headerlink" title="接口和抽象类的区别是什么?"></a>接口和抽象类的区别是什么?</h3><ol>
<li>接口的方法默认是 public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法</li>
<li>接口中的实例变量默认是 final 类型的，而抽象类中则不一定</li>
<li>一个类可以实现多个接口，但最多只能实现一个抽象类</li>
<li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</li>
<li>接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li>
</ol>
<p>注意：Java8 后接口可以有默认实现( default )。</p>
<p>重载和重写的区别</p>
<p>重载</p>
<p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p>重写</p>
<p>重写是子类对父类的允许访问的方法的实现过程进行重新编写,发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。另外，如果父类方法访问修饰符为 private 则子类就不能重写该方法。<strong>也就是说方法提供的行为改变，而方法的外貌并没有改变。</strong></p>
<hr>
<h3 id="Java-面向对象编程三大特性-封装-继承-多态"><a href="#Java-面向对象编程三大特性-封装-继承-多态" class="headerlink" title="Java 面向对象编程三大特性: 封装 继承 多态"></a>Java 面向对象编程三大特性: 封装 继承 多态</h3><p>封装</p>
<p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<p>继承</p>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<p>多态</p>
<p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<hr>
<h3 id="什么是线程和进程"><a href="#什么是线程和进程" class="headerlink" title="什么是线程和进程?"></a>什么是线程和进程?</h3><h4 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a>何为进程?</h4><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p>
<h4 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程?"></a>何为线程?</h4><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p><strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行</strong>。</p>
<hr>
<h3 id="请简要描述线程与进程的关系-区别及优缺点？"><a href="#请简要描述线程与进程的关系-区别及优缺点？" class="headerlink" title="请简要描述线程与进程的关系,区别及优缺点？"></a>请简要描述线程与进程的关系,区别及优缺点？</h3><h4 id="从-JVM-角度说进程和线程之间的关系"><a href="#从-JVM-角度说进程和线程之间的关系" class="headerlink" title="从 JVM 角度说进程和线程之间的关系"></a><strong>从 JVM 角度说进程和线程之间的关系</strong></h4><p>图解进程和线程的关系</p>
<p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。如果你对 Java 内存区域 (运行时数据区) 这部分知识不太了解的话可以阅读一下这篇文章：<a href="https://github.com/Snailclimb/JavaGuide/blob/3965c02cc0f294b0bd3580df4868d5e396959e2e/Java相关/可能是把Java内存区域讲的最清楚的一篇文章.md" target="_blank" rel="noopener">《可能是把 Java 内存区域讲的最清楚的一篇文章》</a></p>
<p><img src="https://camo.githubusercontent.com/a66819fd82c6adfa69b368edf3c52b1fa9cdc89d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67" alt="img"></p>
<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>
<p><strong>总结：</strong> 线程 是 进程 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反</p>
<p>下面是该知识点的扩展内容！</p>
<p>下面来思考这样一个问题：为什么<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是线程私有的呢？为什么堆和方法区是线程共享的呢？</p>
<p>程序计数器为什么是私有的?</p>
<p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<p>虚拟机栈和本地方法栈为什么是私有的?</p>
<ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<p>一句话简单了解堆和方法区</p>
<p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<hr>
<h3 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h3><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p>
<p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
<hr>
<h3 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h3><h4 id="认识线程死锁"><a href="#认识线程死锁" class="headerlink" title="认识线程死锁"></a>认识线程死锁</h4><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<h4 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁?"></a>如何避免线程死锁?</h4><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p>
<p><strong>破坏互斥条件</strong></p>
<p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p>
<p><strong>破坏请求与保持条件</strong></p>
<p>一次性申请所有的资源。</p>
<p><strong>破坏不剥夺条件</strong></p>
<p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p>
<p><strong>破坏循环等待条件</strong></p>
<p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>
<hr>
<h3 id="Object-类有哪些方法"><a href="#Object-类有哪些方法" class="headerlink" title="Object 类有哪些方法?"></a>Object 类有哪些方法?</h3><p>这个问题，面试中经常出现。我觉得不论是出于应付面试还是说更好地掌握 Java 这门编程语言，大家都要掌握！</p>
<h4 id="Object-类的常见方法总结"><a href="#Object-类的常见方法总结" class="headerlink" title="Object 类的常见方法总结"></a>Object 类的常见方法总结</h4><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>问完上面这个问题之后，面试官很可能紧接着就会问你“hashCode 与 equals”相关的问题。</p>
</blockquote>
<h4 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode 与 equals"></a>hashCode 与 equals</h4><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？”</p>
<h4 id="hashCode-介绍"><a href="#hashCode-介绍" class="headerlink" title="hashCode()介绍"></a>hashCode()介绍</h4><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<h4 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h4><p><strong>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong></p>
<p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head fist java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<p>hashCode()与 equals()的相关规定</p>
<ol>
<li>如果两个对象相等，则 hashcode 一定也是相同的</li>
<li>两个对象相等，对两个对象分别调用 equals 方法都返回 true</li>
<li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li>
<li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<h4 id="为什么两个对象有相同的-hashcode-值-它们也不一定是相等的"><a href="#为什么两个对象有相同的-hashcode-值-它们也不一定是相等的" class="headerlink" title="为什么两个对象有相同的 hashcode 值,它们也不一定是相等的?"></a>为什么两个对象有相同的 hashcode 值,它们也不一定是相等的?</h4><p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p>
<p>因为 hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。</p>
<p>我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。</p>
<hr>
<h3 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h3><p><strong>① 两者都是可重入锁</strong></p>
<p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p>
<p><strong>② synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></p>
<p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<p><strong>③ ReentrantLock 比 synchronized 增加了一些高级功能</strong></p>
<p>相比 synchronized，ReentrantLock 增加了一些高级功能。主要来说主要有三点：<strong>① 等待可中断；② 可实现公平锁；③ 可实现选择性通知（锁可以绑定多个条件）</strong></p>
<ul>
<li><strong>ReentrantLock 提供了一种能够中断等待锁的线程的机制</strong>，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>ReentrantLock 可以指定是公平锁还是非公平锁。而 synchronized 只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReentrantLock 默认情况是非公平的，可以通过 ReentrantLock 类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li>synchronized 关键字与 wait()和 notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock 类当然也可以实现，但是需要借助于 Condition 接口与 newCondition() 方法。Condition 是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个 Lock 对象中可以创建多个 Condition 实例（即对象监视器），<strong>线程对象可以注册在指定的 Condition 中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用 notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用 ReentrantLock 类结合 Condition 实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。而 synchronized 关键字就相当于整个 Lock 对象中只有一个 Condition 实例，所有的线程都注册在它一个身上。如果执行 notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而 Condition 实例的 signalAll()方法 只会唤醒注册在该 Condition 实例中的所有等待线程。</li>
</ul>
<p>如果你想使用上述功能，那么选择 ReentrantLock 是一个不错的选择。</p>
<p><strong>④ 两者的性能已经相差无几</strong></p>
<p>在 JDK1.6 之前，synchronized 的性能是比 ReentrantLock 差很多。具体表示为：synchronized 关键字吞吐量随线程数的增加，下降得非常严重。而 ReentrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。JDK1.6 之后，synchronized 和 ReentrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReentrantLock 的文章都是错的！JDK1.6 之后，性能已经不是选择 synchronized 和 ReentrantLock 的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的 synchronized，所以还是提倡在 synchronized 能满足你的需求的情况下，优先考虑使用 synchronized 关键字来进行同步！优化后的 synchronized 和 ReentrantLock 一样，在很多地方都是用到了 CAS 操作。</p>
<hr>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池?"></a>为什么要用线程池?</h4><p>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p>
<p>这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：</p>
<ul>
<li><strong>降低资源消耗。</strong> 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度。</strong> 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性。</strong> 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h4 id="Java-提供了哪几种线程池-他们各自的使用场景是什么"><a href="#Java-提供了哪几种线程池-他们各自的使用场景是什么" class="headerlink" title="Java 提供了哪几种线程池?他们各自的使用场景是什么?"></a>Java 提供了哪几种线程池?他们各自的使用场景是什么?</h4><h5 id="Java-主要提供了下面-4-种线程池"><a href="#Java-主要提供了下面-4-种线程池" class="headerlink" title="Java 主要提供了下面 4 种线程池"></a>Java 主要提供了下面 4 种线程池</h5><ul>
<li><strong>FixedThreadPool：</strong> 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
<li><strong>ScheduledThreadPoolExecutor：</strong> 主要用来在给定的延迟后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor 又分为：ScheduledThreadPoolExecutor（包含多个线程）和 SingleThreadScheduledExecutor （只包含一个线程）两种。</li>
</ul>
<h5 id="各种线程池的适用场景介绍"><a href="#各种线程池的适用场景介绍" class="headerlink" title="各种线程池的适用场景介绍"></a>各种线程池的适用场景介绍</h5><ul>
<li><strong>FixedThreadPool：</strong> 适用于为了满足资源管理需求，而需要限制当前线程数量的应用场景。它适用于负载比较重的服务器；</li>
<li><strong>SingleThreadExecutor：</strong> 适用于需要保证顺序地执行各个任务并且在任意时间点，不会有多个线程是活动的应用场景；</li>
<li><strong>CachedThreadPool：</strong> 适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器；</li>
<li><strong>ScheduledThreadPoolExecutor：</strong> 适用于需要多个后台执行周期任务，同时为了满足资源管理需求而需要限制后台线程的数量的应用场景；</li>
<li><strong>SingleThreadScheduledExecutor：</strong> 适用于需要单个后台线程执行周期任务，同时保证顺序地执行各个任务的应用场景。</li>
</ul>
<h4 id="创建的线程池的方式"><a href="#创建的线程池的方式" class="headerlink" title="创建的线程池的方式"></a>创建的线程池的方式</h4><p><strong>（1） 使用 Executors 创建</strong></p>
<p>我们上面刚刚提到了 Java 提供的几种线程池，通过 Executors 工具类我们可以很轻松的创建我们上面说的几种线程池。但是实际上我们一般都不是直接使用 Java 提供好的线程池，另外在《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Executors 返回线程池对象的弊端如下：</span><br><span class="line"></span><br><span class="line">FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</span><br><span class="line">CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</span><br></pre></td></tr></table></figure>
<p><strong>（2） ThreadPoolExecutor 的构造函数创建</strong></p>
<p>我们可以自己直接调用 ThreadPoolExecutor 的构造函数来自己创建线程池。在创建的同时，给 BlockQueue 指定容量就可以了。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">13</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">13</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, // <span class="number">1</span></span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,  // <span class="number">2</span></span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,  // <span class="number">3</span></span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,  // <span class="number">4</span></span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue, // <span class="number">5</span></span></span></span><br><span class="line"><span class="function"><span class="params">                             ThreadFactory threadFactory,  // <span class="number">6</span></span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler )</span> </span>&#123; <span class="comment">//7</span></span><br><span class="line">       <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">           keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">       <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">       <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">       <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">       <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">       <span class="keyword">this</span>.handler = handler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>corePoolSize</td>
<td>int</td>
<td>核心线程池大小</td>
</tr>
<tr>
<td>2</td>
<td>maximumPoolSize</td>
<td>int</td>
<td>最大线程池大小</td>
</tr>
<tr>
<td>3</td>
<td>keepAliveTime</td>
<td>long</td>
<td>线程最大空闲时间</td>
</tr>
<tr>
<td>4</td>
<td>unit</td>
<td>TimeUnit</td>
<td>时间单位</td>
</tr>
<tr>
<td>5</td>
<td>workQueue</td>
<td>BlockingQueue<runnable></runnable></td>
<td>线程等待队列</td>
</tr>
<tr>
<td>6</td>
<td>threadFactory</td>
<td>ThreadFactory</td>
<td>线程创建工厂</td>
</tr>
<tr>
<td>7</td>
<td>handler</td>
<td>RejectedExecutionHandler</td>
<td>拒绝策略</td>
</tr>
</tbody>
</table>
</div>
<p>这种情况下，一旦提交的线程数超过当前可用线程数时，就会抛出 java.util.concurrent.RejectedExecutionException，这是因为当前线程池使用的队列是有边界队列，队列已经满了便无法继续处理新的请求。但是异常（Exception）总比发生错误（Error）要好。</p>
<p><strong>（3） 使用开源类库</strong></p>
<p>Hollis 大佬之前在他的文章中也提到了：“除了自己定义 ThreadPoolExecutor 外。还有其他方法。这个时候第一时间就应该想到开源类库，如 apache 和 guava 等。”他推荐使用 guava 提供的 ThreadFactoryBuilder 来创建线程池。下面是参考他的代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">        .setNameFormat(<span class="string">"demo-pool-%d"</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>,</span><br><span class="line">        <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> SubThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述方式创建线程时，不仅可以避免 OOM 的问题，还可以自定义线程名称，更加方便的出错的时候溯源。</p>
<h4 id="workQueue任务队列"><a href="#workQueue任务队列" class="headerlink" title="workQueue任务队列"></a><strong>workQueue任务队列</strong></h4><p><strong>它一般分为直接提交队列、有界任务队列、无界任务队列、优先任务队列；</strong></p>
<p>1、<strong>直接提交队列</strong>：设置为SynchronousQueue队列，SynchronousQueue是一个特殊的BlockingQueue，它没有容量，没执行一个插入操作就会阻塞，需要再执行一个删除操作才会被唤醒，反之每一个删除操作也都要等待对应的插入操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//maximumPoolSize设置为2 ，拒绝策略为AbortPolic策略，直接抛出异常</span></span><br><span class="line">        pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),Executors.defaultThreadFactory(),<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> ThreadTask());</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*pool-1-thread-1</span></span><br><span class="line"><span class="comment">pool-1-thread-2</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task com.hhxx.test.ThreadTask@55f96302 rejected from java.util.concurrent.ThreadPoolExecutor@3d4eac69[Running, pool size = 2, active threads = 0, queued tasks = 0, completed tasks = 2]</span></span><br><span class="line"><span class="comment">    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(Unknown Source)</span></span><br><span class="line"><span class="comment">    at java.util.concurrent.ThreadPoolExecutor.reject(Unknown Source)</span></span><br><span class="line"><span class="comment">    at java.util.concurrent.ThreadPoolExecutor.execute(Unknown Source)</span></span><br><span class="line"><span class="comment">    at com.hhxx.test.ThreadPool.main(ThreadPool.java:17)*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，当任务队列为SynchronousQueue，创建的线程数大于maximumPoolSize时，直接执行了拒绝策略抛出异常。</p>
<p>使用SynchronousQueue队列，提交的任务不会被保存，总是会马上提交执行。如果用于执行任务的线程数量小于maximumPoolSize，则尝试创建新的进程，如果达到maximumPoolSize设置的最大值，则根据你设置的handler执行拒绝策略。因此这种方式你提交的任务不会被缓存起来，而是会被马上执行，在这种情况下，你需要对你程序的并发量有个准确的评估，才能设置合适的maximumPoolSize数量，否则很容易就会执行拒绝策略；</p>
<p>2、<strong>有界的任务队列</strong>：有界的任务队列可以使用ArrayBlockingQueue实现，如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>),Executors.defaultThreadFactory(),<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br></pre></td></tr></table></figure>
<p>使用ArrayBlockingQueue有界任务队列，若有新的任务需要执行时，线程池会创建新的线程，直到创建的线程数量达到corePoolSize时，则会将新的任务加入到等待队列中。若等待队列已满，即超过ArrayBlockingQueue初始化的容量，则继续创建线程，直到线程数量达到maximumPoolSize设置的最大线程数量，若大于maximumPoolSize，则执行拒绝策略。在这种情况下，线程数量的上限与有界任务队列的状态有直接关系，如果有界队列初始容量较大或者没有达到超负荷的状态，线程数将一直维持在corePoolSize以下，反之当任务队列已满时，则会以maximumPoolSize为最大线程数上限。</p>
<p>3、<strong>无界的任务队列</strong>：有界任务队列可以使用LinkedBlockingQueue实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),Executors.defaultThreadFactory(),<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br></pre></td></tr></table></figure>
<p>使用无界任务队列，线程池的任务队列可以无限制的添加新的任务，而线程池创建的最大线程数量就是你corePoolSize设置的数量，也就是说在这种情况下maximumPoolSize这个参数是无效的，哪怕你的任务队列中缓存了很多未执行的任务，当线程池的线程数达到corePoolSize后，就不会再增加了；若后续有新的任务加入，则直接进入队列等待，当使用这种任务队列模式时，一定要注意你任务提交与处理之间的协调与控制，不然会出现队列中的任务由于无法及时处理导致一直增长，直到最后资源耗尽的问题。</p>
<p>4<strong>、优先任务队列：</strong>优先任务队列通过PriorityBlockingQueue实现，下面我们通过一个例子演示下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//优先任务队列</span></span><br><span class="line">        pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> PriorityBlockingQueue&lt;Runnable&gt;(),Executors.defaultThreadFactory(),<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> ThreadTask(i));</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span>,<span class="title">Comparable</span>&lt;<span class="title">ThreadTask</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTask</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前对象和其他对象做比较，当前优先级大就返回-1，优先级小就返回1,值越小优先级越高</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ThreadTask o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span>  <span class="keyword">this</span>.priority&gt;o.priority?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//让线程阻塞，使后续任务进入缓存队列</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"priority:"</span>+<span class="keyword">this</span>.priority+<span class="string">",ThreadName:"</span>+Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">priority:0,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">priority:9,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">priority:8,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">priority:7,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">priority:6,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">priority:5,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">priority:4,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">priority:3,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">priority:2,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">priority:1,ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到除了第一个任务直接创建线程执行外，其他的任务都被放入了优先任务队列，按优先级进行了重新排列执行，且线程池的线程数一直为corePoolSize，也就是只有一个。</p>
<p>通过运行的代码我们可以看出PriorityBlockingQueue它其实是一个特殊的无界队列，它其中无论添加了多少个任务，线程池创建的线程数也不会超过corePoolSize的数量，只不过其他队列一般是按照先进先出的规则处理任务，而PriorityBlockingQueue队列可以自定义规则根据任务的优先级顺序先后执行。</p>
<h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a><strong>拒绝策略</strong></h4><p>一般我们创建线程池时，为防止资源被耗尽，任务队列都会选择创建有界任务队列，但种模式下如果出现任务队列已满且线程池创建的线程数达到你设置的最大线程数时，这时就需要你指定ThreadPoolExecutor的RejectedExecutionHandler参数即合理的拒绝策略，来处理线程池”超载”的情况。ThreadPoolExecutor自带的拒绝策略如下：</p>
<p><strong>1、AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作；</strong></p>
<p><strong>2、CallerRunsPolicy策略：如果线程池的线程数量达到上限，该策略会把任务队列中的任务放在调用者线程当中运行；</strong></p>
<p><strong>3、DiscardOledestPolicy策略：该策略会丢弃任务队列中最老的一个任务，也就是当前任务队列中最先被添加进去的，马上要被执行的那个任务，并尝试再次提交；</strong></p>
<p><strong>4、DiscardPolicy策略：该策略会默默丢弃无法处理的任务，不予任何处理。当然使用此策略，业务场景中需允许任务的丢失；</strong></p>
<p>以上内置的策略均实现了RejectedExecutionHandler接口，当然你也可以自己扩展RejectedExecutionHandler接口，定义自己的拒绝策略，我们看下示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//自定义拒绝策略</span></span><br><span class="line">        pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>),</span><br><span class="line">                Executors.defaultThreadFactory(), <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">                System.out.println(r.toString()+<span class="string">"执行了拒绝策略"</span>);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> ThreadTask());</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//让线程阻塞，使后续任务进入缓存队列</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"ThreadName:"</span>+Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">com.hhxx.test.ThreadTask@33909752执行了拒绝策略</span></span><br><span class="line"><span class="comment">com.hhxx.test.ThreadTask@55f96302执行了拒绝策略</span></span><br><span class="line"><span class="comment">com.hhxx.test.ThreadTask@3d4eac69执行了拒绝策略</span></span><br><span class="line"><span class="comment">ThreadName:pool-1-thread-2</span></span><br><span class="line"><span class="comment">ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">ThreadName:pool-1-thread-2</span></span><br><span class="line"><span class="comment">ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">ThreadName:pool-1-thread-2</span></span><br><span class="line"><span class="comment">ThreadName:pool-1-thread-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到由于任务加了休眠阻塞，执行需要花费一定时间，导致会有一定的任务被丢弃，从而执行自定义的拒绝策略；</p>
<h4 id="ThreadFactory自定义线程创建"><a href="#ThreadFactory自定义线程创建" class="headerlink" title="ThreadFactory自定义线程创建"></a><strong>ThreadFactory自定义线程创建</strong></h4><p> 线程池中线程就是通过ThreadPoolExecutor中的ThreadFactory，线程工厂创建的。那么通过自定义ThreadFactory，可以按需要对线程池中创建的线程进行一些特殊的设置，如命名、优先级等，下面代码我们通过ThreadFactory对线程池中创建的线程进行记录与命名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//自定义线程工厂</span></span><br><span class="line">        pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>),</span><br><span class="line">                <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+r.hashCode()+<span class="string">"创建"</span>);</span><br><span class="line">                <span class="comment">//线程命名</span></span><br><span class="line">                Thread th = <span class="keyword">new</span> Thread(r,<span class="string">"threadPool"</span>+r.hashCode());</span><br><span class="line">                <span class="keyword">return</span> th;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> ThreadTask());</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//输出执行线程的名称</span></span><br><span class="line">        System.out.println(<span class="string">"ThreadName:"</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程118352462创建</span></span><br><span class="line"><span class="comment">线程1550089733创建</span></span><br><span class="line"><span class="comment">线程865113938创建</span></span><br><span class="line"><span class="comment">ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">ThreadName:threadPool118352462</span></span><br><span class="line"><span class="comment">线程1442407170创建</span></span><br><span class="line"><span class="comment">ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">ThreadName:threadPool865113938</span></span><br><span class="line"><span class="comment">ThreadName:threadPool865113938</span></span><br><span class="line"><span class="comment">ThreadName:threadPool118352462</span></span><br><span class="line"><span class="comment">ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">ThreadName:threadPool1442407170</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="ThreadPoolExecutor扩展"><a href="#ThreadPoolExecutor扩展" class="headerlink" title="ThreadPoolExecutor扩展"></a><strong>ThreadPoolExecutor扩展</strong></h4><p>ThreadPoolExecutor扩展主要是围绕beforeExecute()、afterExecute()和terminated()三个接口实现的，</p>
<p><strong>1、beforeExecute：线程池中任务运行前执行</strong></p>
<p><strong>2、afterExecute：线程池中任务运行完毕后执行</strong></p>
<p><strong>3、terminated：线程池退出后执行</strong></p>
<p>通过这三个接口我们可以监控每个任务的开始和结束时间，或者其他一些功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//实现自定义接口</span></span><br><span class="line">        pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>),</span><br><span class="line">                <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+r.hashCode()+<span class="string">"创建"</span>);</span><br><span class="line">                <span class="comment">//线程命名</span></span><br><span class="line">                Thread th = <span class="keyword">new</span> Thread(r,<span class="string">"threadPool"</span>+r.hashCode());</span><br><span class="line">                <span class="keyword">return</span> th;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy()) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t,Runnable r)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"准备执行："</span>+ ((ThreadTask)r).getTaskName());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r,Throwable t)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"执行完毕："</span>+((ThreadTask)r).getTaskName());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程池退出"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> ThreadTask(<span class="string">"Task"</span>+i));</span><br><span class="line">        &#125;    </span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> String taskName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTaskName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> taskName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTaskName</span><span class="params">(String taskName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskName = taskName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setTaskName(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//输出执行线程的名称</span></span><br><span class="line">        System.out.println(<span class="string">"TaskName"</span>+<span class="keyword">this</span>.getTaskName()+<span class="string">"---ThreadName:"</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程118352462创建</span></span><br><span class="line"><span class="comment">线程1550089733创建</span></span><br><span class="line"><span class="comment">准备执行：Task0</span></span><br><span class="line"><span class="comment">准备执行：Task1</span></span><br><span class="line"><span class="comment">TaskNameTask0---ThreadName:threadPool118352462</span></span><br><span class="line"><span class="comment">线程865113938创建</span></span><br><span class="line"><span class="comment">执行完毕：Task0</span></span><br><span class="line"><span class="comment">TaskNameTask1---ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">执行完毕：Task1</span></span><br><span class="line"><span class="comment">准备执行：Task3</span></span><br><span class="line"><span class="comment">TaskNameTask3---ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">执行完毕：Task3</span></span><br><span class="line"><span class="comment">准备执行：Task2</span></span><br><span class="line"><span class="comment">准备执行：Task4</span></span><br><span class="line"><span class="comment">TaskNameTask4---ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">执行完毕：Task4</span></span><br><span class="line"><span class="comment">准备执行：Task5</span></span><br><span class="line"><span class="comment">TaskNameTask5---ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">执行完毕：Task5</span></span><br><span class="line"><span class="comment">准备执行：Task6</span></span><br><span class="line"><span class="comment">TaskNameTask6---ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">执行完毕：Task6</span></span><br><span class="line"><span class="comment">准备执行：Task8</span></span><br><span class="line"><span class="comment">TaskNameTask8---ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">执行完毕：Task8</span></span><br><span class="line"><span class="comment">准备执行：Task9</span></span><br><span class="line"><span class="comment">TaskNameTask9---ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">准备执行：Task7</span></span><br><span class="line"><span class="comment">执行完毕：Task9</span></span><br><span class="line"><span class="comment">TaskNameTask2---ThreadName:threadPool118352462</span></span><br><span class="line"><span class="comment">TaskNameTask7---ThreadName:threadPool865113938</span></span><br><span class="line"><span class="comment">执行完毕：Task7</span></span><br><span class="line"><span class="comment">执行完毕：Task2</span></span><br><span class="line"><span class="comment">线程池退出</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到通过对beforeExecute()、afterExecute()和terminated()的实现，我们对线程池中线程的运行状态进行了监控，在其执行前后输出了相关打印信息。另外使用shutdown方法可以比较安全的关闭线程池， 当线程池调用该方法后，线程池中不再接受后续添加的任务。但是，此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。</p>
<hr>
<h3 id="抽象类-abstract-class-和接口-interface-有什么异同？"><a href="#抽象类-abstract-class-和接口-interface-有什么异同？" class="headerlink" title="抽象类(abstract class)和接口(interface)有什么异同？"></a>抽象类(abstract class)和接口(interface)有什么异同？</h3><p>不同：<br>抽象类：<br>1.抽象类中可以定义构造器<br>2.可以有抽象方法和具体方法<br>3.接口中的成员全都是public 的<br>4.抽象类中可以定义成员变量<br>5.有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法<br>6.抽象类中可以包含静态方法<br>7.一个类只能继承一个抽象类<br>接口：<br>1.接口中不能定义构造器<br>2.方法全部都是抽象方法<br>3.抽象类中的成员可以是 private、默认、protected、public<br>4.接口中定义的成员变量实际上都是常量<br>5.接口中不能有静态方法<br>6.一个类可以实现多个接口<br>相同：<br>1.不能够实例化<br>2.可以将抽象类和接口类型作为引用类型<br>3.一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要<br>被声明为抽象类</p>
<hr>
<h3 id="sleep-方法和-wait-方法区别和共同点"><a href="#sleep-方法和-wait-方法区别和共同点" class="headerlink" title="sleep() 方法和 wait() 方法区别和共同点"></a>sleep() 方法和 wait() 方法区别和共同点</h3><ul>
<li>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong> 。</li>
<li>两者都可以暂停线程的执行。</li>
<li>Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</li>
<li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。</li>
</ul>
<hr>
<h3 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h3><p>这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>
<p>new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p>
<hr>
<h3 id="Java-为什么能跨平台，实现一次编写，多处运行？"><a href="#Java-为什么能跨平台，实现一次编写，多处运行？" class="headerlink" title="Java 为什么能跨平台，实现一次编写，多处运行？"></a><strong>Java 为什么能跨平台，实现一次编写，多处运行？</strong></h3><p>Java 能够跨平台运行的核心在于 JVM 。不是 Java 能够跨平台，而是它的 jvm 能够跨平台。我们知道，不同的操作系统向上的 API 肯定是不同的，那么如果我们想要写一段代码调用系统的声音设备，就需要针对不同系统的 API 写出不同的代码来完成动作。</p>
<p>而 Java 引入了字节码的概念，jvm 只能认识字节码，并将它们解释到系统的 API 调用。针对不同的系统有不同的 jvm 实现，有 Linux 版本的 jvm 实现，也有 Windows 版本的 jvm 实现，但是同一段代码在编译后的字节码是一样的。引用上面的例子，在 Java API 层面，我们调用系统声音设备的代码是唯一的，和系统无关，编译生成的字节码也是唯一的。但是同一段字节码，在不同的 jvm 实现上会映射到不同系统的 API 调用，从而实现代码的不加修改即可跨平台运行。</p>
<hr>
<h3 id="jvm-的内容模型"><a href="#jvm-的内容模型" class="headerlink" title="jvm 的内容模型"></a>jvm 的内容模型</h3><p><img src="/2020/03/16/JAVA笔记整理/300854081661499.jpg" alt="img"></p>
<p><strong>其实JVM内部不仅仅只有栈和堆</strong><br><strong>包括 程序计数器 、 Java 虚拟机栈 、本地方法栈、Java 堆、方法区等</strong></p>
<p><strong>1. 程序计数器</strong></p>
<p>线程私有，较小的内存空间，如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。</p>
<p><strong>2. Java 虚拟机栈（栈区）</strong><br>线程私有，每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p><strong>3.本地方法栈</strong><br>与虚拟机栈所发挥的作用是非常相似的，区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务，有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError。</p>
<p><strong>4.Java 堆（堆区）</strong><br><strong>线程共享</strong>，此内存区域的唯一目的就是创建并存放对象实例，也是GC区。分代收集算法：内存区大概分为新生代，老年代，永久代。<br>新生代从Eden区创建，复制到Survivor区（2个 from 和 to）。 GC分为minor GC 和 Full GC 。<br><strong>minor GC：</strong> Eden满了就触发minor GC，minorGC会将Eden区仍然存活的会复制到ToSurvivor，FromSurvivor一部分复制到老年代，一部分复制ToSurvivor，此时原Eden和From的数据清空,from和to互换，这样的过程直到To被填满，复制到老年代。<br><strong>FullGC：</strong>(1)年老代内存不足;(2)持久代内存不足;(3)统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间（4）调用System.gc()方法的时候，</p>
<p><strong>5. 方法区（类级/静态）</strong><br><strong>线程共享</strong>,存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它别名叫做Non-Heap（非堆）即“永久代”,不进行GC，只是针对常量池的回收和对类型的卸载 。<br><strong>运行时常量池：</strong>是方法区的一部分，Class常量池存放编译期生成的各种字面量和符号引用，运行时常量池相对于Class 文件常量池的另外一个重要特征是具备动态性，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String 类的intern() 方法（这个方法会首先检查字符串池中是有”ab”这个字符串，如果存在则返回这个字符串的引用，否则就将这个字符串添加到字符串常量池中，然会返回这个字符串的引用，这可以实现字符串的”= =”比较。new String 不进入常量池，直接赋值会进入常量池）。</p>
<hr>
<h3 id="new-一个对象的过程和-clone-一个对象的过程区别"><a href="#new-一个对象的过程和-clone-一个对象的过程区别" class="headerlink" title="new 一个对象的过程和 clone 一个对象的过程区别"></a>new 一个对象的过程和 clone 一个对象的过程区别</h3><p>new 操作符的本意是分配内存。程序执行到 new 操作符时，首先去看 new 操作符后面的类型，因为知道了类型， 才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对 象。 clone 在第一步是和 new 相似的，都是分配内存，调用 clone 方法时，分配的内存和原对象（即调用 clone 方法 的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域，填充完成之后，clone 方法返回，一个新的相同 的对象被创建，同样可以把这个新对象的引用发布到外部。</p>
<hr>
<h3 id="为什么-Java-中只有值传递"><a href="#为什么-Java-中只有值传递" class="headerlink" title="为什么 Java 中只有值传递"></a>为什么 Java 中只有值传递</h3><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是 Java)中方法参数传递方式。</p>
<p>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</p>
<p>Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按 值传递的。</p>
<p>下面再总结一下 Java 中方法参数的使用情况：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ul>
<hr>
<h3 id="与-equals"><a href="#与-equals" class="headerlink" title="==与 equals"></a>==与 equals</h3><p>== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)</p>
<p>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<ul>
<li>情况 1：类没有覆盖 equals()方法。则通过 equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>
<li>情况 2：类覆盖了 equals()方法。一般，我们都覆盖 equals()方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<p>说明：</p>
<ul>
<li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li>
<li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li>
</ul>
<hr>
<h3 id="hashCode-与-equals-1"><a href="#hashCode-与-equals-1" class="headerlink" title="hashCode 与 equals"></a>hashCode 与 equals</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p>
<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<p><strong>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong><br>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head fist java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<p><strong>hashCode（）与 equals（）的相关规定</strong></p>
<ol>
<li>如果两个对象相等，则 hashcode 一定也是相同的</li>
<li>两个对象相等,对两个对象分别调用 equals 方法都返回 true</li>
<li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li>
<li>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<hr>
<h3 id="双亲委托模型"><a href="#双亲委托模型" class="headerlink" title="双亲委托模型"></a>双亲委托模型</h3><p><a href="https://blog.csdn.net/xuemengrui12/article/details/82707473" target="_blank" rel="noopener">类加载过程</a></p>
<p>当Java程序需要使用某个类时，如果该类还未被加载到内存中，JVM会通过加载、连接(验证、准备和解析)、初始化三个步骤来对该类进行初始化。</p>
<p>类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备(为静态变量分配内存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤。最后JVM对类进行初始化，包括：</p>
<p>1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类;</p>
<p>2)如果类中存在初始化语句，就依次执行这些初始化语句。</p>
<p><a href="https://www.jianshu.com/p/46d3668b357a" target="_blank" rel="noopener">Java类加载器(ClassLoader)</a></p>
<p>类加载器就是寻找类或接口字节码文件进行解析并构造JVM内部对象表示的组件，在java中类装载器把一个类装入JVM，经过以下步骤：</p>
<p>1、加载：查找和导入Class文件</p>
<p>2、链接：其中解析步骤是可以选择的 （a）检查：检查载入的class文件数据的正确性 （b）准备：给类的静态变量分配存储空间 （c）解析：将符号引用转成直接引用</p>
<p>3、初始化：对静态变量，静态代码块执行初始化工作</p>
<p>双亲委派模式要求<strong>除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器</strong>，请注意双亲委派模式中的父子关系并非通常所说的类继承关系，而是<strong>采用组合关系来复用父类加载器的相关代码</strong>，类加载器间的关系如下：</p>
<p><img src="/2020/03/16/JAVA笔记整理/5982616-aad63782162c9ae5.webp" alt="img"></p>
<p>双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就<strong>成功返回</strong>，倘若父类加载器无法完成此加载任务，<strong>子加载器才会尝试自己去加载</strong>，这就是双亲委派模式</p>
<p>双亲委派模式优势</p>
<ul>
<li>采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种<strong>带有优先级的层次关系</strong>，通过这种层级关可以<strong>避免类的重复加载</strong>，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</li>
<li>其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以<strong>防止核心API库被随意篡改</strong>。</li>
</ul>
<hr>
<h3 id="为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？"><a href="#为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？" class="headerlink" title="为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？"></a><strong>为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</strong></h3><p>因为 hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。</p>
<p>我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。</p>
<hr>
<h3 id="闭包和回调区别"><a href="#闭包和回调区别" class="headerlink" title="闭包和回调区别"></a>闭包和回调区别</h3><ul>
<li><strong>闭包</strong>是指可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。 —《百度百科》</li>
<li>是引用了自由变量的函数。这个函数通常被定义在另一个外部函数中，并且引用了外部函数中的变量。 – &lt;&gt;</li>
<li>是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。– &lt;</li>
</ul>
<p><strong>闭包</strong>能够将一个<strong>方法</strong>作为一个<strong>变量</strong>去存储，这个方法有能力去访问所在类的<strong>自由变量</strong>。</p>
<p>闭包的价值在于可以作为函数对象或者匿名函数，持有上下文数据，作为第一级对象进行传递和保存。闭包广泛用于回调函数、函数式编程中。</p>
<p>在Java中，闭包是 通过“接口与内部类实现的”</p>
<p>通过这种仿闭包的非静态内部类，可以很方便地实现回调功能，回调就是某个方法一旦获得了内部类对象的引用后，就可以在合适时候反过来调用外部类的方法。所谓回调，就是允许客户类通过内部类引用来调用其外部类的方法，这是一种非常灵活的功能。</p>
<hr>
<h3 id="回调和观察者的区别"><a href="#回调和观察者的区别" class="headerlink" title="回调和观察者的区别"></a>回调和观察者的区别</h3><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。观察者模式完美的将观察者和被观察的对象分离开，一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。<br>回调函数其实也算是一种观察者模式的实现方式，回调函数实现的观察者和被观察者往往是一对一的依赖关系。<br>所以最明显的区别是观察者模式是一种设计思路，而回调函数式一种具体的实现方式；另一明显区别是一对多还是多对多的依赖关系方面。</p>
<hr>
<h3 id="MVP和MVC模式差别"><a href="#MVP和MVC模式差别" class="headerlink" title="MVP和MVC模式差别"></a>MVP和MVC模式差别</h3><p><img src="/2020/03/16/JAVA笔记整理/20180322204213875" alt="img"></p>
<p>MVC</p>
<p>View：布局的xml文件，或者纯Java写的布局，可以把页面显示的逻辑直接放在View中。</p>
<p>Model：数据处理层，可以直接和View进行交互。</p>
<p>Controller：把特定的功能逻辑抽离出来，作为控制层，保证View层和Model层的功能单一性，便于维护。</p>
<p>MVP</p>
<p>View：Activity作为显示层。</p>
<p>Presenter：逻辑层，从Activity中抽离出功能逻辑，简化Activity的代码。</p>
<p>Model：数据处理层，主要负责网络请求，本地数据加载等操作，进一步简化Activity的代码</p>
<p>1、Presenter与Controller都扮演了逻辑层的角色，但是Presenter层的功能相对更复杂，因为他负责和View的双向交互，Controller只是单向的中介。因为Presenter是从View层抽离出来的，通常和View是一对一的关系，而Controller是面向业务的，往往是单例模式或者提供静态方法。</p>
<p>2、MVP中View和Model是不能进行通信的，虽然加重了P层的负担，但是有利于维护View层和Model层，如果条件允许，我们还可以对Presenter进一步拆分，来弥补Presenter负担过重的问题。</p>
<ol>
<li><p>MVC中View和Model层可以直接交互，虽然方便了两者之间的交互，但是耦合性相对较高。</p>
</li>
<li><p><strong>Activity职责不同</strong>，Activity在MVP中是View层，在MVC中是Controller层，这是MVC和MVP很主要的一个区别，可以说Android从MVC转向MVP开发也主要是优化Activity的代码，避免Activity的代码臃肿庞大。</p>
</li>
<li><strong>View层不同</strong>，MVC的View层指的是XML布局文件或者是用Java自定义的View，MVP的View层是Activity或者Fragment。使用传统的MVC，其中的View，对应的是各种Layout布局文件，但是这些布局文件中并不像Web端那样强大，能做的事情非常有限。MVP的View层Activity在实际项目中，随着逻辑的复杂度越来越大，Activity臃肿的缺点仍然体现出来了，因为Activity中还是充满了大量与View层无关的代码，比如各种事件的处理派发，就如MVC中的那样View层和Controller代码耦合在一起无法自拔。</li>
<li><strong>控制层不同</strong>，MVC的控制层是Activity，或者是Fragment，Controller对应的是Activity，而Activity中却又具有操作UI的功能，我们在实际的项目中也会有很多UI操作在这一层，也做了很多View中应该做的事情，当然Controller层Activity中也包含Controller应该做的事情，比如各种事件的派发回调，而且在一层中我们会根据事件再去调用Model层操作数据，所以这种MVC的方式在实际项目中，Activity所在的Controller是非常重的，各层次之间的耦合情况也比较严重，不方便单元测试。MVP的控制层是Presenter，里面没有很多的实际东西，主要是做Model和View层的交互。</li>
<li><strong>关系链不同</strong>，MVP中Model层与View是没有关系的，彼此不会通讯和操作，Model与View的通讯都是Presenter层来传达的。但是在MVC中，Model层和View是曾在交互的。比如我们自定义的View控件里面肯定是要使用Model的数据的，View也要根据不同的Model数据做出不同的展现！这点尤其是体现在自定义的View中，自定义View需要设置数据，用户操作了自定义控件需要改变数据，View要操作Model怎么办？有人说把Controller传到自定义的View啊，现实是不可能没一个自定义View都去持有Controller的引用，其实在MVP中就不会这么尴尬，接口就可以完成。</li>
<li><strong>适用范围不同</strong>，在Android中，MVP和MVC都用自己的适用情况，使用MVP可以更好的解耦三大模块，模块之间比较清晰，也很方便使用MVP来组件化架构整体项目。但是MVC也是有用武之地的，在组件化的Module或者中间件我们可以使用MVC来做，Module或者中间件不会存在很复杂的View层，使用MVC可以更加方便我们实现功能。</li>
<li><strong>交互方式不同</strong>，MVP中通讯交互基本都是通过接口的，MVC中的通讯交互很多时候都是实打实的调用对象的方法，简单粗暴！</li>
<li><strong>实现方法不同</strong> ，MVC和MVP的Model几乎一样的，都是处理数据，只要不在Activity或者Fragment中请求数据，其他的所有控制都放在Activity或者Fragment中，这样写就基本是MVC的模式，这样写不麻烦，但是很容易把Activity写出上万行代码。用MVP的时候我们需要写很多View和Presenter接口来实现模块之间的通讯，会增加很多类。</li>
</ol>
<p><strong>（1）相同点：</strong><br><strong>优点：</strong><br>1.降低耦合度<br>2.模块职责划分明显<br>3.利于测试驱动开发<br>4.代码复用<br>5.隐藏数据<br>6.代码灵活性<br><strong>缺点：</strong><br>额外的代码复杂度及学习成本。</p>
<p><strong>（2）不同点：</strong><br><strong>MVP模式：</strong><br>1.View不直接与Model交互，而是通过与Presenter交互来与Model间接交互<br>2.Presenter与View的交互是通过接口来进行的，更有利于添加单元测试<br>3.通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑，业务相似的时候也可以多同个View共享一个Presenter。<br><strong>MVC模式：</strong><br>1.View可以与Model直接交互<br>2.Controller是基于行为的，并且可以被多个View共享<br>3.Controller可以负责决定显示哪个View</p>
<hr>
<h3 id="4种引用"><a href="#4种引用" class="headerlink" title="4种引用"></a>4种引用</h3><p><a href="https://www.jianshu.com/p/825cca41d962" target="_blank" rel="noopener">https://www.jianshu.com/p/825cca41d962</a></p>
<hr>
<h3 id="线程同步方法"><a href="#线程同步方法" class="headerlink" title="线程同步方法"></a>线程同步方法</h3><p>volatile、synchronized、Concurrent包中的BlockingQueue、Semaphore。</p>
<p>然后展开讲了一下volatile的原理、底层实现内存屏障、应用、synchronized底层的WaitSet、onDeck、Owner、BlockingQueue。</p>
<p>然后讲了一下BlockingQueue的两种常用形式利用信号量帮助编程人员更轻松使用BlockingQueue。</p>
<hr>
<h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><ul>
<li><strong>序列化：将对象写入到IO流中</strong></li>
<li><strong>反序列化：从IO流中恢复对象</strong></li>
<li><strong>意义：序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。</strong></li>
<li><strong>使用场景：所有可在网络上传输的对象都必须是可序列化的，</strong>比如RMI（remote method invoke,即远程方法调用），传入的参数或返回的对象都是可序列化的，否则会出错；<strong>所有需要保存到磁盘的java对象都必须是可序列化的。通常建议：程序创建的每个JavaBean类都实现Serializeable接口。</strong></li>
</ul>
<p>如果需要将某个对象保存到磁盘上或者通过网络传输，那么这个类应该实现<strong>Serializable</strong>接口或者<strong>Externalizable</strong>接口之一。</p>
<h4 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h4><p>Serializable接口是一个标记接口，不用实现任何方法。一旦实现了此接口，该类的对象就是可序列化的。</p>
<ol>
<li><strong>序列化步骤：</strong></li>
</ol>
<ul>
<li><strong>步骤一：创建一个ObjectOutputStream输出流；</strong></li>
<li><strong>步骤二：调用ObjectOutputStream对象的writeObject输出可序列化对象。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写到二进制文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> out :输出流对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        out.writeObject(docIdToDocPathMapping);</span><br><span class="line">        out.writeObject(termToPostingListMapping);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * 从索引文件里加载已经构建好的索引.内部调用FileSerializable接口方法readObject即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file ：索引文件</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ObjectInputStream输入流；</span></span><br><span class="line">        <span class="comment">//调用ObjectInputStream对象的readObject()得到序列化的对象。</span></span><br><span class="line">        ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        readObject(inputStream);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>反序列化步骤：</strong></li>
</ol>
<ul>
<li><strong>步骤一：创建一个ObjectInputStream输入流；</strong></li>
<li><strong>步骤二：调用ObjectInputStream对象的readObject()得到序列化的对象。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从二进制文件读</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> in ：输入流对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        docIdToDocPathMapping = (Map&lt;Integer, String&gt;) in.readObject();</span><br><span class="line">        termToPostingListMapping = (Map&lt;AbstractTerm, AbstractPostingList&gt;) in.readObject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * 从索引文件里加载已经构建好的索引.内部调用FileSerializable接口方法readObject即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file ：索引文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ObjectInputStream输入流；</span></span><br><span class="line">        <span class="comment">//调用ObjectInputStream对象的readObject()得到序列化的对象。</span></span><br><span class="line">        ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        readObject(inputStream);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Java序列化同一对象，并不会将此对象序列化多次得到多个对象。</strong></p>
<ul>
<li><strong>Java序列化算法</strong></li>
</ul>
<ol>
<li><strong>所有保存到磁盘的对象都有一个序列化编码号</strong></li>
<li><strong>当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。</strong></li>
<li><strong>如果此对象已经序列化过，则直接输出编号即可。</strong></li>
</ol>
<p>由于java序利化算法不会重复序列化同一个对象，只会记录已序列化对象的编号。<strong>如果序列化一个可变对象（对象内的内容可更改）后，更改了对象内容，再次序列化，并不会再次将此对象转换为字节序列，而只是保存序列化编号。</strong></p>
<p>有些时候，我们有这样的需求，某些属性不需要序列化。<strong>使用transient关键字选择不需要序列化的字段。</strong></p>
<p><strong>使用transient修饰的属性，java序列化时，会忽略掉此字段，所以反序列化出的对象，被transient修饰的属性是默认值。对于引用类型，值是null；基本类型，值是0；boolean类型，值是false。</strong></p>
<p>使用transient虽然简单，但将此属性完全隔离在了序列化之外。java提供了<strong>可选的自定义序列化。</strong>可以进行控制序列化的方式，或者对序列化数据进行编码加密等。通过重写writeObject与readObject方法，可以自己选择哪些属性需要序列化， 哪些属性不需要。如果writeObject使用某种规则序列化，则相应的readObject需要相反的规则反序列化，以便能正确反序列化出对象。</p>
<h4 id="Externalizable：强制自定义序列化"><a href="#Externalizable：强制自定义序列化" class="headerlink" title="Externalizable：强制自定义序列化"></a>Externalizable：强制自定义序列化</h4><p>通过实现Externalizable接口，必须实现writeExternal、readExternal方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Externalizable</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExPerson</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//注意，必须加上pulic 无参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExPerson</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//将name反转后写入二进制流</span></span><br><span class="line">        StringBuffer reverse = <span class="keyword">new</span> StringBuffer(name).reverse();</span><br><span class="line">        System.out.println(reverse.toString());</span><br><span class="line">        out.writeObject(reverse);</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//将读取的字符串反转后赋值给name实例变量</span></span><br><span class="line">        <span class="keyword">this</span>.name = ((StringBuffer) in.readObject()).reverse().toString();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">this</span>.age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"ExPerson.txt"</span>));</span><br><span class="line">             ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"ExPerson.txt"</span>))) &#123;</span><br><span class="line">            oos.writeObject(<span class="keyword">new</span> ExPerson(<span class="string">"brady"</span>, <span class="number">23</span>));</span><br><span class="line">            ExPerson ep = (ExPerson) ois.readObject();</span><br><span class="line">            System.out.println(ep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//ydarb</span></span><br><span class="line"><span class="comment">//brady</span></span><br><span class="line"><span class="comment">//ExPerson&#123;name='brady', age=23&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：Externalizable接口不同于Serializable接口，实现此接口必须实现接口中的两个方法实现自定义序列化，这是强制性的；特别之处是必须提供pulic的无参构造器，因为在反序列化的时候需要反射创建对象。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">实现Serializable接口</th>
<th style="text-align:left">实现Externalizable接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">系统自动存储必要的信息</td>
<td style="text-align:left">程序员决定存储哪些信息</td>
</tr>
<tr>
<td style="text-align:left">Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持</td>
<td style="text-align:left">必须实现接口内的两个方法</td>
</tr>
<tr>
<td style="text-align:left">性能略差</td>
<td style="text-align:left">性能略好</td>
</tr>
</tbody>
</table>
</div>
<p><strong>虽然Externalizable接口带来了一定的性能提升，但变成复杂度也提高了，所以一般通过实现Serializable接口进行序列化。</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>所有需要网络传输的对象都需要实现序列化接口，通过建议所有的javaBean都实现Serializable接口。</li>
<li>对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、transient实例变量都不会被序列化。</li>
<li>如果想让某个变量不被序列化，使用transient修饰。</li>
<li>序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错。</li>
<li>反序列化时必须有序列化对象的class文件。</li>
<li>当通过文件、网络来读取序列化后的对象时，必须按照实际写入的顺序读取。</li>
<li>单例类序列化，需要重写readResolve()方法；否则会破坏单例原则。</li>
<li>同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化。</li>
<li>建议所有可序列化的类加上serialVersionUID 版本号，方便项目升级。</li>
</ol>
<hr>
<h3 id="JAVA中各种锁机制"><a href="#JAVA中各种锁机制" class="headerlink" title="JAVA中各种锁机制"></a>JAVA中各种锁机制</h3><p><a href="https://www.cnblogs.com/jyroy/p/11365935.html" target="_blank" rel="noopener">https://www.cnblogs.com/jyroy/p/11365935.html</a></p>
<hr>
<h3 id="JAVA异常机制"><a href="#JAVA异常机制" class="headerlink" title="JAVA异常机制"></a>JAVA异常机制</h3><p><a href="https://www.cnblogs.com/yc211/p/9910949.html" target="_blank" rel="noopener">https://www.cnblogs.com/yc211/p/9910949.html</a></p>
<hr>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><h3 id="Activty生命周期"><a href="#Activty生命周期" class="headerlink" title="Activty生命周期"></a>Activty生命周期</h3><p>活动在系统中被活动堆栈管理。当一个新的活动开始时，将会强加于堆栈的顶端并成为运行活动状态。而之前的活动总是被放置在这个活动下面的堆栈中，并且不会被移动到前台直到新的活动退出为止。<br>   活动从开始到结束经历各种状态。从一个状态到另一个状态的转变，从无到有再到无，这样一个过程中所经历的各个状态就叫做生命周期。Activity拥有自己的生命周期，而它的意义就在于，当我们对当前的界面进行展示的过程中，本身也会经历各个阶段去准备和处理当前的activity，然后展示给用户，而开发者为了界面上一些炫酷的效果与功能，做一些特殊处理时，就离不开这些生命周期。</p>
<p>关于activity的四个状态：<br><strong>running-poused-stopped-killed</strong></p>
<ol>
<li>running-&gt;当前显示在屏幕的activity(位于任务栈的顶部)，用户可见状态。</li>
<li>poused-&gt;依旧在用户可见状态，但是界面焦点已经失去，此Activity无法与用户进行交互。</li>
<li>stopped-&gt;用户看不到当前界面,也无法与用户进行交互 完全被覆盖.</li>
<li>killed-&gt;当前界面被销毁，等待这系统被回收</li>
</ol>
<p><img src="/2020/03/16/JAVA笔记整理/20140810102151522.png" alt="4个的状态"></p>
<p>由上图我们得知：<br>Starting ——–&gt;Running 所执行的生命周期顺序 onCreate()-&gt;onstart()-&gt;onResume()</p>
<blockquote>
<p>当前称为活动状态（Running），此activity所处于任务栈的top中，可以与用户进行交互。</p>
</blockquote>
<p>Running ——&gt;Paused 所执行Activity生命周期中的onPause（）</p>
<blockquote>
<p>当前称为暂停状态（Paused），该Activity已失去了焦点但仍然是可见的状态(包括部分可见)。</p>
</blockquote>
<p>Paused ——&gt;Running所执行的生命周期为:OnResume()</p>
<blockquote>
<p>当前重新回到活动状态(Running),此情况用户操作home键，然后重新回到当前activity界面发生。</p>
</blockquote>
<p>Paused ——&gt;Stoped所执行的生命周期为:onStop()</p>
<blockquote>
<p>该Activity被另一个Activity完全覆盖的状态,该Activity变得不可见，所以系统经常会由于内存不足而将该Activity强行结束。</p>
</blockquote>
<p>Stoped——&gt;killed所执行的生命周期为:onDestroy()</p>
<blockquote>
<p>该Activity被系统销毁。当一个Activity处于暂停状态或停止状态时就随处可能进入死亡状态，因为系统可能因内存不足而强行结束该Activity。</p>
</blockquote>
<p>注：还有一种情况由于系统内存不足可能在Paused状态中直接被系统杀死达到killed状态。</p>
<p>activity的<strong>生命周期</strong></p>
<p><strong>oncreate()-&gt;onstart()-&gt;onResume()-&gt;onRestart()-&gt;onPouse()-&gt;onStop()-&gt;onDestory()</strong></p>
<p><img src="/2020/03/16/JAVA笔记整理/12239817-57bb34bbf201853d.webp" alt="img"></p>
<p>onCreate():<br>当我们点击activity的时候，系统会调用activity的oncreate()方法，在这个方法中我们会初始化当前布局setContentLayout（）方法。<br>onStart():<br>onCreate()方法完成后，此时activity进入onStart()方法,当前activity是用户可见状态，但没有焦点，与用户不能交互，一般可在当前方法做一些动画的初始化操作。<br>onResume():<br>onStart()方法完成之后，此时activity进入onResume()方法中，当前activity状态属于运行状态 (Running)，可与用户进行交互。<br>onPause()<br>当另外一个activity覆盖当前的acitivty时，此时当前activity会进入到onPause()方法中，当前activity是可见的，但不能与用户交互状态。<br>onStop()<br>onPouse()方法完成之后，此时activity进入onStop()方法，此时activity对用户是不可见的，在系统内存紧张的情况下，有可能会被系统进行回收。所以一般在当前方法可做资源回收。<br>onDestory()<br>onStop()方法完成之后，此时activity进入到onDestory()方法中，结束当前activity。<br>onRestart()<br>onRestart()方法在用户按下home()之后，再次进入到当前activity的时候调用。调用顺序onPouse()-&gt;onStop()-&gt;onRestart()-&gt;onStart()-&gt;onResume().</p>
<p><strong>onSaveInstanceState(Bundle outState):</strong></p>
<blockquote>
<p>onSaveInstanceState函数在Activity生命周期中执行。<br>outState 参数作用 :<br>数据保存 : Activity 声明周期结束的时候, 需要保存 Activity 状态的时候, 会将要保存的数据使用键值对的形式 保存在 Bundle 对象中;</p>
<hr>
<p>调用时机 :<br>Activity 被销毁的时候调用, 也可能没有销毁就调用了;<br>按下Home键 : Activity 进入了后台, 此时会调用该方法;<br>按下电源键 : 屏幕关闭, Activity 进入后台;<br>启动其它 Activity : Activity 被压入了任务栈的栈底;<br>横竖屏切换 : 会销毁当前 Activity 并重新创建；</p>
<hr>
<p>onSaveInstanceState方法调用注意事项 :<br>用户主动销毁不会调用 : 当用户点击回退键 或者 调用了 finish() 方法, 不会调用该方法;<br>调用时机不固定 : 该方法一定是在 onStop() 方法之前调用, 但是不确定是在 onPause() 方法之前 还是 之后调用;<br>布局中组件状态存储 : 每个组件都 实现了 onSaveInstance() 方法, 在调用函数的时候, 会自动保存组件的状态, 注意, 只有有 id 的组件才会保存;<br>关于默认的 super.onSaveInstanceState(outState) : 该默认的方法是实现 组件状态保存的;</p>
</blockquote>
<p><strong>onRestoreInstanceState(Bundle outState):</strong></p>
<blockquote>
<p>方法回调时机 : 在 Activity 被系统销毁之后 恢复 Activity 时被调用, 只有销毁了之后重建的时候才调用, 如果内存充足, 系统没有销毁这个 Activity, 就不需要调用;<br>– Bundle 对象传递 : 该方法保存的 Bundle 对象在 Activity 恢复的时候也会通过参数传递到 onCreate() 方法中;</p>
</blockquote>
<p><strong>activity的进程优先级。</strong></p>
<blockquote>
<p>前台进程&gt;可见进程&gt;service进程&gt;后台进程&gt;空进程</p>
</blockquote>
<hr>
<h3 id="fragmengt生命周期"><a href="#fragmengt生命周期" class="headerlink" title="fragmengt生命周期"></a>fragmengt生命周期</h3><p>Fragment是可以让你的app纵享丝滑的设计，如果你的app想在现在基础上性能大幅度提高，并且<strong>占用内存降低</strong>，同样的界面Activity占用内存比Fragment要多，响应速度Fragment比Activty在中低端手机上快了很多，甚至能达到好几倍！如果你的app当前或以后有<strong>移植平板</strong>等平台时，可以让你节省大量时间和精力。</p>
<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fapp%2FFragment.html" target="_blank" rel="noopener">Fragment</a>表示 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fapp%2FActivity.html" target="_blank" rel="noopener">Activity</a> 中的行为或用户界面部分。您可以将多个片段(片段就是指 Fragment )组合在一个 Activity 中来构建多窗格 UI，以及在多个 Activity 中重复使用某个片段。您可以将片段视为 Activity 的模块化组成部分，它具有自己的生命周期，能接收自己的输入事件，并且您可以在 Activity 运行时添加或移除片段（有点像您可以在不同 Activity 中重复使用的“子 Activity”）。</p>
<p>片段必须始终嵌入在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。 例如，当 Activity 暂停时，其中的所有片段也会暂停；当 Activity 被销毁时，所有片段也会被销毁。</p>
<p>当您将片段作为 Activity 布局的一部分添加时，它存在于 Activity 视图层次结构的某个 ViewGroup 内部，并且片段会定义其自己的视图布局。您可以通过在 Activity 的布局文件中声明片段，将其作为 `` 元素插入您的 Activity 布局中，即静态添加。或者通过将其添加到某个现有 ViewGroup，利用应用代码进行动态插入。不过，片段并非必须成为 Activity 布局的一部分；您还可以将没有自己 UI 的片段用作 Activity 的不可见工作线程。</p>
<p>下图是文档中给出的一个Fragment分别对应手机与平板间不同情况的处理图：</p>
<p><img src="/2020/03/16/JAVA笔记整理/7508328-dea3e88fded20350.webp" alt="img"></p>
<p>Fragment 生命周期</p>
<p><img src="/2020/03/16/JAVA笔记整理/1688279-0424d62f50035b43.webp" alt="img"></p>
<p>可以看到 Fragment 的生命周期和 Activity 很相似，只是多了一下几个方法：<br><strong>onAttach()</strong> 在Fragment 和 Activity 建立关联是调用（Activity 传递到此方法内）<br><strong>onCreateView()</strong> 当Fragment 创建视图时调用<br><strong>onActivityCreated()</strong> 在相关联的 Activity 的 onCreate() 方法已返回时调用。<br><strong>onDestroyView()</strong> 当Fragment中的视图被移除时调用<br><strong>onDetach()</strong> 当Fragment 和 Activity 取消关联时调用。</p>
<p>可以看下几种操作情况下Fragment 的生命周期变化</p>
<p><img src="/2020/03/16/JAVA笔记整理/1688279-e34d09c9351c7084.webp" alt="img"></p>
<p>管理 Fragment 生命周期和 Activity 生命周期很相似，同时 Activity 的生命周期对 Fragment 的生命周期也有一定的影响，如下图所示</p>
<p><img src="/2020/03/16/JAVA笔记整理/1688279-e513845a80659860.webp" alt="img"></p>
<p>用下图（<a href="https://www.jianshu.com/p/184f0c8857d6" target="_blank" rel="noopener">来源</a>）来表示 Activity 和 Fragment 的生命周期变化的先后过程是:</p>
<p><img src="/2020/03/16/JAVA笔记整理/1688279-020ad51ed5443cce.webp" alt="img"></p>
<p>Activity 和 Fragment 生命周期执行过程</p>
<p>Fragment 生命周期与 Activity 生命周期的一个关键区别就在于，Fragment 的生命周期方法是由托管Activity而不是操作系统调用的。Activity 中生命周期方法都是 protected，而 Fragment 都是 public，也能印证了这一点，因为 Activity 需要调用 Fragment 那些方法并管理它。</p>
<p><strong>加载 Fragment</strong></p>
<ul>
<li>静态加载</li>
<li>动态加载</li>
</ul>
<ol>
<li><p>静态加载 在 Activity 的布局文件内声明片段，其中 fragment 中的 android:name 属性要指定 fragment 对应的具体包名路径，当系统创建此 Activity 布局时，会实例化在布局中指定的每个 fragment，并为每个 fragment 调用 onCreateView()方法，以检索每个 fragment 的布局。系统会直接插入 fragment 返回的 View 来替代 fragment 元素。</p>
<p>并且在 Activity 活动里可以直接使用 findViewById() 方法获取 fragment 对应布局里的控件。同样在 fragment 里可以直接使用 getActivity()方法获得绑定的主 Activity 实例，并调用 Activity 里的方法或其他 fragment 实例。</p>
</li>
<li><p>动态加载 通过编程方式将 fragment 添加到某个activity布局里现有的 <strong>ViewGroup</strong> （例如 LinearLayout 或 FrameLayout）里。<br>要想在 Avtivity 中执行 Fragment 事务 (如添加、删除或替换 Fragment)，必须使用 FragmentTransaction 中的 API。可以使用下面这样从 Activity 中获取一个 FragmentTransaction。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FragmentManager  fragmentManager = getFragmentManager();</span><br><span class="line">FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</span><br></pre></td></tr></table></figure>
<p>然后可以使用 add()方法添加一个 fragment ，指定要添加的 fragment 和插入到哪个视图。例如</p>
</li>
</ol>
   <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ExampleFragment  exampleFragment = <span class="keyword">new</span> ExampleFragment();</span><br><span class="line">fragmentTransaction.<span class="keyword">add</span>(R.id.frame_layout,exampleFragment);</span><br><span class="line">fragmentTransaction.commit();</span><br></pre></td></tr></table></figure>
<p>   add 方法中第一个参数是一个activity 对应布局文件中的 ViewGroup，即应该放置 fragment 的位置，由资源 ID 指定，第二个参数是加入的 fragment ，一旦通过 fragmentTransaction 做了更改，最后必须使用 commit 方法以使更改生效。</p>
<p>   在 Activity 中使用 Fragment 可以很方便的进行添加 add、替换 replace、移除 remove 等操作，这样提交给 Activity 的每组更改都可以称为<strong>事务</strong>。像上边动态添加 fragment 那样，使用 FragmentTransaction 里的 API 就可以执行一项事务。同时也可以将此事务保存到 Activity 管理的返回栈中，从而用户可以回退到 fragment 改变之前的状态（类似于 activity 回退到上一个页面）。</p>
<p><strong>Fragment 与 Activity 通信</strong></p>
<p>上边说过，在 fragment 中可以调用 getActivity() 获取 activity 的实例并调用 activity 里的方法和布局，同样在 activity 里也可以通过 findFragmentById()（对于在 activity 提供 fragment 布局的） 或 findFragmentByTag() （对于在 activity 提供或者不提供 fragment 布局的）方法获取 fragment 的实例，例如在 activity 中从 FragmentManager 获取对 Fragment 的引用来调用 fragment 中的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fragment fragment = getFragmentManager.findFragmentById(R.id.fragment_container);</span><br></pre></td></tr></table></figure>
<p>使用 FragmentManager 还可以执行的操作包括：</p>
<ul>
<li>通过 findFragmentById 或 findFragmentByTag 获取 activity 中存在的 fragment 的实例</li>
<li>通过 popBackStack （<em>模拟用户点击返回按钮操作</em>）将 fragment 从返回栈中弹出</li>
<li>通过 addOnBackStackChangedListener() 注册一个监听返回栈改变的监听器</li>
<li>像上边生成 fragmentTransaction 的方法，可以使用 fragmentManager 生成一个 fragmentTransaction 来执行某些事务，比如添加、替换、移除、addToBackStack（）等。</li>
</ul>
<hr>
<h3 id="Activity中View的生命周期方法回调"><a href="#Activity中View的生命周期方法回调" class="headerlink" title="Activity中View的生命周期方法回调"></a>Activity中View的生命周期方法回调</h3><p>Activity有生命周期，同样的，View从添加到界面到从界面中移除也有一个生命周期，在<a href="https://link.jianshu.com/?t=https://developer.android.google.cn/reference/android/view/View.html" target="_blank" rel="noopener">官方文档</a>中介绍了自定义View需要重写的一些方法，可以认为这些方法就是View的生命周期方法。</p>
<p><img src="/2020/03/16/JAVA笔记整理/2083810-82ee9f1ceb9c6b95.webp" alt="img"></p>
<p>从Activity启动到退出，这个View 的过程是这样的。</p>
<p><img src="/2020/03/16/JAVA笔记整理/2083810-e496916704fa4dfa.webp" alt="img"></p>
<p><strong>在Activity的onCreate()方法中调用setContentView方法，Activity显示到界面时的View的回调</strong></p>
<ol>
<li>构造方法，这是肯定的，View也是一个Java类。</li>
<li>onFinishInflate，这个一般是通过LayoutInflater进行填充的时候会走这个方法。如果我们是直接在代码中new出来的View进行添加，是不会走这个方法的。</li>
<li>onAttachedToWindow，这个方法表明现在这个View已经跟它对应的Window已经绑定了</li>
<li>onWindowVisibilitChanged(int visibility) ，这个值等于 View.VISIBLE，代表View所在的Window已经可见了。</li>
<li>onMeasure，开始测量。我们发现，这个measure过程是在Window可见的情况下才会去调用了，仔细想想这个也不难理解，如果你都不准备显示，我何必去花精力测量你呢。这个测量过程可能会多次调用。</li>
<li>onSizeChanged ，测量之后会回调这个方法。onSizeChanged，顾名思义就是当尺寸发生变化的时候会调用。一般是第一次测量之后调用，后面再测量，如果尺寸没变化就不会再去调用了。</li>
<li>onLayout，测量时候就进行布局，这个时候如果是View的话一般不用去管，因为具体放在哪个位置是由父控件去控制的，如果是ViewGroup，就需要去确定子View的位置。</li>
<li>onDraw，确定完位置和宽高，就可以进行绘制了。</li>
<li>onWindowFocusChanged(boolean hasWindowFocus)，为true这个说明View所绑定的Window开始获取焦点</li>
</ol>
<p><strong>当按back键退出当前Activity后，走下面几个方法</strong></p>
<ol>
<li>onWindowVisibilitChanged(int visibility) ，这个值等于 View.GONE，此时Window已经不可见了</li>
<li>onWindowFocusChanged(boolean hasWindowFocus)，这个也变为false，说明已经没有焦点了。有一点比较奇怪，为什么是先不可见才是没有焦点的呢？</li>
<li>onDetachedFromWindow， 当前View与它对应的Window解除绑定。</li>
</ol>
<p><strong>结合与Activity的启动过程可以看到</strong></p>
<ol>
<li><strong>Activity</strong> 调用onCreate方法，这个时候我们setContentView加载了带View的布局</li>
<li><strong>Activity</strong> 调用onWindowAttributesChanged 方法，而且这个方法连续调用多次</li>
<li><code>View</code> 调用构造方法</li>
<li><code>View</code> 调用onFinishInflate方法，说明这个时候View已经填充完毕，但是这个时候还没开始触发绘制过程</li>
<li><strong>Activity</strong> 调用onstart方法</li>
<li><strong>Activity</strong> 再次调用 onWindowAttributesChanged 方法，说明这个方法在onResume之前会多次调用</li>
<li><strong>Activity</strong> 调用onResume，我们一般认为当Activity调用onResume的时候，整个Activit已经可以和用户进行交互了，但事实上可能并不是这样，后面解释原因。</li>
<li><strong>Activity</strong> 调用onAttachedToWindow，说明跟Window进行了绑定。发现了吗，Activity在onResume之后才跟Window进行了绑定。</li>
<li><code>View</code> 调用onAttachedToWindow，View开始跟Window进行绑定，这个过程肯定是在Activity绑定之后才进行的。</li>
<li><code>View</code> 调用 onWindowVisibilityChanged(int visibility)，参数变为 <code>View.VISIABLE</code>，说明Window已经可见了，这个时候我们发现一个问题就是其实onResume的时候似乎并不代表Activity中的View已经可见了。</li>
<li><code>View</code> 调用onMeasure，开始测量</li>
<li><code>View</code> 调用onSizeChanged，表示测量完成，尺寸发生了变化</li>
<li><code>View</code> 调用onLayout，开始摆放位置</li>
<li><code>View</code> 调用 onDraw，开始绘制</li>
<li><strong>Activity</strong> 调用onWindowFocusChanged(boolean hasFocus)，此时为true，代表窗体已经获取了焦点</li>
<li><code>View</code> 调用 onWindowFocusChanged(boolean hasWindowFocus)，此时为true，代表当前的控件获取了Window焦点，当调用这个方法后说明当前Activity中的View才是真正的可见了。</li>
</ol>
<p><strong>当退出当前的Activity的时候</strong></p>
<ol>
<li><strong>Activity</strong> 调用 onPause</li>
<li><code>View</code> 调用 onWindowVisibilityChanged(int visibility)，参数变为 <code>View.GONE</code>，View中对应的Window隐藏</li>
<li><strong>Activity</strong> 调用onWindowFocusChanged(boolean hasFocus)，此时为false，说明Actvity所在的Window已经失去焦点</li>
<li><strong>Activity</strong> 调用 onStop，此时Activity已经切换到后台</li>
<li><strong>Activity</strong> 调用 onDestory，此时Activity开始准备销毁，实际上调用onDestory并不代表Activity已经销毁了。</li>
<li><code>View</code> 调用 onDetachedFromWindow，此时View 与Window解除绑定</li>
<li><strong>Activity</strong> 调用 onDetathedFromWindow ，此时Activity 与Window 解除绑定</li>
</ol>
<p>当View进行与Window解除绑定之后，View即将被销毁。我们可以在 View 的 <code>onDetachedFromWindow</code> 方法中可以做一些资源的释放，防止内存泄漏。</p>
<hr>
<h3 id="android进程间通信"><a href="#android进程间通信" class="headerlink" title="android进程间通信"></a>android进程间通信</h3><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bundle</td>
<td>简单易用</td>
<td>只能传输Bundle支持的数据类型</td>
<td>四大组件间的进程间通信</td>
</tr>
<tr>
<td>文件共享</td>
<td>简单易用</td>
<td>不适用高并发场景，并且无法做到进程间即时通信</td>
<td>适用于无关发的情况下，交换简单的数据，对实时性要求不高的场景。</td>
</tr>
<tr>
<td>AIDL</td>
<td>功能强大，支持一对多实时并发通信</td>
<td>使用稍复杂，需要处理好线程间的关系</td>
<td>一对多通信且有RPC需求</td>
</tr>
<tr>
<td>Messenger</td>
<td>功能一般，支持一对多串行通信，支持实时通信</td>
<td>不能很好地处理高并发的情形，不支持RPC，由于数据通过Message传输，因此只能传输Bundle支持的数据类型</td>
<td>低并发的一对多实时通信，无RPC需求，或者无需要返回结果的RPC需求</td>
</tr>
<tr>
<td>ContentProvider</td>
<td>支持一对多的实时并发通信，在数据源共享方面功能强大，可通过Call方法扩展其它操作</td>
<td>可以理解为受约束的AIDL，主要提供对数据源的CRUD操作</td>
<td>一对多的进程间数据共享</td>
</tr>
<tr>
<td>BroadcastReceiver</td>
<td>操作简单，对持一对多实时通信</td>
<td>只支持数据单向传递，效率低且安全性不高</td>
<td>一对多的低频率单向通信</td>
</tr>
<tr>
<td>Socket</td>
<td>功能强大，可通过网络传输字节流，支持一对多实时并发通信</td>
<td>实现细节步骤稍繁琐，不支持直接的RPC</td>
<td>网络间的数据交换</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="Android中PX、DP、SP的区别"><a href="#Android中PX、DP、SP的区别" class="headerlink" title="Android中PX、DP、SP的区别"></a>Android中PX、DP、SP的区别</h3><p><strong>px ： 其实就是像素单位，比如我们通常说的手机分辨列表800*400都是px的单位</strong><br><strong>sp ： 同dp相似，还会根据用户的字体大小偏好来缩放</strong><br><strong>dp ： 虚拟像素，在不同的像素密度的设备上会自动适配</strong><br><strong>dip： 同dp</strong></p>
<hr>
<h3 id="点击应用图标以后的流程"><a href="#点击应用图标以后的流程" class="headerlink" title="点击应用图标以后的流程"></a>点击应用图标以后的流程</h3><p><img src="/2020/03/16/JAVA笔记整理/20180429164552531.jfif" alt="这里写图片描述"></p>
<p><strong>Instrumentation</strong>: 监控应用与系统相关的交互行为。<br><strong>ActivityManagerService（AMS）</strong>：组件管理调度中心，什么都不干，但是什么都管。<br><strong>ActivityStarter</strong>：Activity启动的控制器，处理Intent与Flag对Activity启动的影响，具体说来有：1 寻找符合启动条件的Activity，如果有多个，让用户选择；2 校验启动参数的合法性；3 返回int参数，代表Activity是否启动成功。<br><strong>ActivityStackSupervisior</strong>：这个类的作用你从它的名字就可以看出来，它用来管理任务栈。<br><strong>ActivityStack</strong>：用来管理任务栈里的Activity。<br><strong>ActivityThread</strong>：在Android中它就代表了Android的主线程，注意是代表而不是说它就是一个Thread类，它是创建完新进程之后（肯定是在<br>一个线程中啊），main函数被加载，然后执行一个loop的循环使当前线程进入消息循环，并且作为主线程。<br><strong>ApplicationThread</strong>：最终干活的人，是ActivityThread的内部类，也是一个Binder对象。在此处它是作为IApplicationThread对象的server端等待client端的请求然后进行处理，最大的client就是AMS.Activity、Service、BroadcastReceiver的启动、切换、调度等各种操作都在这个类里完成。</p>
<p>注意：这里单独提一下ActivityStackSupervisior，这是高版本才有的类，它用来管理多个ActivityStack，早期的版本只有一个ActivityStack对应着手机屏幕，后来高版本支持多屏以后，就有了多个ActivityStack，于是就引入了ActivityStackSupervisior用来管理多个ActivityStack。</p>
<p>整个流程主要涉及四个进程：</p>
<ol>
<li>调用者进程，如果是在桌面启动应用就是Launcher应用进程。</li>
<li>ActivityManagerService等所在的System Server进程，该进程主要运行着系统服务组件。</li>
<li>Zygote进程，该进程主要用来fork新进程。</li>
<li>新启动的应用进程，该进程就是用来承载应用运行的进程了，它也是应用的主线程（新创建的进程就是主线程），处理组件生命周期、界面绘制等相关事情。</li>
</ol>
<p>整个流程如下</p>
<ol>
<li>点击桌面应用图标，Launcher进程将启动Activity（MainActivity）的请求以Binder的方式发送给了AMS。</li>
<li>AMS接收到启动请求后，交付ActivityStarter处理Intent和Flag等信息，然后再交给ActivityStackSupervisior/ActivityStack处理Activity进栈相关流程。同时以Socket方式请求Zygote进程fork新进程。</li>
<li>Zygote接收到新进程创建请求后fork出新进程。</li>
<li>在新进程里创建ActivityThread对象，新创建的进程就是应用的主线程，在主线程里开启Looper消息循环，开始处理创建Activity。ActivityThread利用ClassLoader去加载Activity、创建Activity实例，并回调Activity的onCreate()方法。这样便完成了Activity的启动。</li>
</ol>
<hr>
<h3 id="AMS"><a href="#AMS" class="headerlink" title="AMS"></a>AMS</h3><p><a href="https://www.cnblogs.com/ganchuanpu/p/8384471.html" target="_blank" rel="noopener">https://www.cnblogs.com/ganchuanpu/p/8384471.html</a></p>
<hr>
<h3 id="activity与service通信"><a href="#activity与service通信" class="headerlink" title="activity与service通信"></a>activity与service通信</h3><p><strong>为何要进行Secvice和Activity的通信</strong>？</p>
<p>常用的服务一般是普通服务，即是不可交互的后台服务，该服务在活动中启动，但是启动之后，活动基本就和服务没有什么关系了。确实如此，我们在普通服务里是用startService()方法来启动Service这个服务的，之后服务会一直处于运行状态，但具体运行的是什么逻辑，活动控制不了，活动并不知道服务到底做了什么，完成的如何。</p>
<p>但是在很多场景下，活动是需要和服务进行交互的，比如<strong>音乐播放界面</strong>，用户可以根据播放进度条掌握播放的<strong>进度</strong>，用户也可以自己根据歌词的进度选择调整整首歌的进度。</p>
<p>要实现上面所示的功能，就要选择服务的另外一种类型——<strong>*可交互的后台服务</strong>。以最常见的后台下载，前台显示的操作为例。实现这个功能的思路是创建一个专门的<strong>Binder类</strong>来对下载进行管理。</p>
<p><a href="https://blog.csdn.net/weixin_41101173/article/details/79718718" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41101173/article/details/79718718</a></p>
<hr>
<h3 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h3><p>WebView是android中一个非常重要的控件，它的作用是用来展示一个web页面。它使用的内核是<code>webkit</code>引擎，4.4版本之后，直接使用Chrome作为内置网页浏览器。</p>
<p>作用：</p>
<ol>
<li>显示和渲染网页；</li>
<li>可与页面JavaScript交互，实现混合开发。</li>
</ol>
<p>加载页面一般有以下几种形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：加载一个网页</span></span><br><span class="line">webView.loadUrl(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：加载应用资源文件内的网页</span></span><br><span class="line">webView.loadUrl(<span class="string">"file:///android_asset/test.html"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三：加载一段代码</span></span><br><span class="line">webView.loadData(String data,String mimeType, String encoding);</span><br></pre></td></tr></table></figure>
<p>其中，方式一和方式二比较好理解，方式三可能有些朋友不明白，我在这里解释一下。</p>
<p><code>WebView.loadData()</code>和<code>WebView.loadDataWithBaseURL()</code>是表示加载某一段代码，其中，<code>WebView.loadDataWithBaseURL()</code>兼容性更好，适用场景更多，因此，我着重介绍一下这个方法。</p>
<p><code>WebView.loadDataWithBaseURL(String baseUrl, String data, String mimeType, String encoding, String historyUrl))</code>的五个参数：<code>baseUrl</code>表示基础的网页，<code>data</code>表示要加载的内容，<code>mimeType</code>表示加载网页的类型，<code>encoding</code>表示编码格式，<code>historyUrl</code>表示可用历史记录，可以为<code>null</code>值。<br>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String body = <span class="string">"示例：这里有个img标签，地址是相对路径&lt;img src='/uploads/allimg/130923/1FP02V7-0.png' /&gt;"</span>;</span><br><span class="line">webView.loadDataWithBaseURL(<span class="string">"http://www.jcodecraeer.com"</span>, body, <span class="string">"text/html"</span>, <span class="string">"utf-8"</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/16/JAVA笔记整理/12359382-84191a7b9aee861e.webp" alt="img"></p>
<p>WebView的生命周期一般跟随Activity：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    <span class="comment">//恢复webview的状态（不靠谱）</span></span><br><span class="line">    webView.resumeTimers();</span><br><span class="line">    <span class="comment">//激活webView的状态，能正常加载网页</span></span><br><span class="line">    webView.onResume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    <span class="comment">//当页面被失去焦点被切换到后台不可见状态，需要执行onPause</span></span><br><span class="line">    <span class="comment">//通过onPause动作通知内核暂停所有的动作，比如DOM的解析、plugin的执行、JavaScript执行。</span></span><br><span class="line">    webView.onPause();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当应用程序(存在webview)被切换到后台时，这个方法不仅仅针对当前的webview而是全局的全应用程序的webview</span></span><br><span class="line">    <span class="comment">//它会暂停所有webview的layout，parsing，javascripttimer。降低CPU功耗。（不靠谱）</span></span><br><span class="line">    webView.pauseTimers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在关闭了Activity时，如果Webview的音乐或视频，还在播放。就必须销毁Webview</span></span><br><span class="line"><span class="comment">//但是注意：webview调用destory时,webview仍绑定在Activity上</span></span><br><span class="line"><span class="comment">//这是由于自定义webview构建时传入了该Activity的context对象</span></span><br><span class="line"><span class="comment">//因此需要先从父容器中移除webview,然后再销毁webview:</span></span><br><span class="line">ViewGroup parent = findViewById(R.id.container);</span><br><span class="line">parent.removeView(webView);</span><br><span class="line">webView.destroy();</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/3e0136c9e748" target="_blank" rel="noopener">https://www.jianshu.com/p/3e0136c9e748</a></p>
<hr>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p><a href="https://blog.csdn.net/weixin_41101173/article/details/79684183" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41101173/article/details/79684183</a></p>
<hr>
<h3 id="Activity启动模式"><a href="#Activity启动模式" class="headerlink" title="Activity启动模式"></a>Activity启动模式</h3><p>在实际的项目中我们应该根据特定的需求为每个活动指定恰当的启动模式。<br>启动模式一共有4种。<strong>standard、singleTop、singleTask</strong>和<strong>singleInstance</strong><br>通过在AndroidManifest.xml中给<activity>标签指定<code>android:launchMode</code>属性来选择启动模式。</activity></p>
<h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p>默认模式，可以不用写配置。在这个模式下，都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。</p>
<p>在该模式下，每当启动一个新活动，它就会在返回栈中入栈，并处于栈顶的位置，并且，不管此活动是否已经存在于返回栈中，每次启动都会创建该活动的一个新实例。</p>
<p>例如：</p>
<p>若我有一个Activity名为A1, 上面有一个按钮可跳转到A1。那么如果我点击按钮，便会新启一个Activity A1叠在刚才的A1之上，再点击，又会再新启一个在它之上……</p>
<p>点back键会依照栈顺序依次退出。</p>
<p><img src="/2020/03/16/JAVA笔记整理/1674835-cbec07958657c4a8.webp" alt="img"></p>
<h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p>可以有多个实例，但是不允许多个相同Activity叠加。即，如果Activity在栈顶的时候，启动相同的Activity，不会创建新的实例，而会调用其onNewIntent方法。不过当FirstActivity并未处于栈顶时，若再启动FirstActivity还是会创建新的实例。</p>
<p>例如：</p>
<p>若我有两个Activity名为B1,B2,两个Activity内容功能完全相同，都有两个按钮可以跳到B1或者B2，唯一不同的是B1为standard，B2为singleTop。</p>
<p>若我意图打开的顺序为B1-&gt;B2-&gt;B2，则实际打开的顺序为B1-&gt;B2（后一次意图打开B2，实际只调用了前一个的onNewIntent方法）</p>
<p>若我意图打开的顺序为B1-&gt;B2-&gt;B1-&gt;B2，则实际打开的顺序与意图的一致，为B1-&gt;B2-&gt;B1-&gt;B2。</p>
<p><img src="/2020/03/16/JAVA笔记整理/1674835-7e2417de609e171e.webp" alt="img"></p>
<h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p>使用 single Top模式可以很好地解决重复创建栈顶活动的问题，但是如你在上一节所看到的，如果该活动并没有处于栈顶的位置，还是可能会创建多个活动实例的。那么有没有什么办法可以让某个活动在整个应用程序的上下文中只存在一个实例呢?这就要借助 singleTask模式来实现了。当活动的启动模式指定为 singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。</p>
<p>只有一个实例。在同一个应用程序中启动他的时候，若Activity不存在，则会在当前task创建一个新的实例，若存在，则会把task中在其之上的其它Activity destory掉并调用它的onNewIntent方法。</p>
<p>如果是在别的应用程序中启动它，则会新建一个task，并在该task中启动这个Activity，singleTask允许别的Activity与其在一个task中共存，也就是说，如果我在这个singleTask的实例中再打开新的Activity，这个新的Activity还是会在singleTask的实例的task中。</p>
<p>例如：</p>
<p>若我的应用程序中有三个Activity,C1,C2,C3，三个Activity可互相启动，其中C2为singleTask模式，那么，无论我在这个程序中如何点击启动，如：C1-&gt;C2-&gt;C3-&gt;C2-&gt;C3-&gt;C1-C2，C1,C3可能存在多个实例，但是C2只会存在一个，并且这三个Activity都在同一个task里面。</p>
<p>但是C1-&gt;C2-&gt;C3-&gt;C2-&gt;C3-&gt;C1-C2，这样的操作过程实际应该是如下这样的，因为singleTask会把task中在其之上的其它Activity destory掉。</p>
<p>操作：C1-&gt;C2     C1-&gt;C2-&gt;C3     C1-&gt;C2-&gt;C3-&gt;C2      C1-&gt;C2-&gt;C3-&gt;C2-&gt;C3-&gt;C1      C1-&gt;C2-&gt;C3-&gt;C2-&gt;C3-&gt;C1-C2</p>
<p>实际：C1-&gt;C2     C1-&gt;C2-&gt;C3     C1-&gt;C2               C1-&gt;C2-&gt;C3-&gt;C1               C1-&gt;C2</p>
<p>若是别的应用程序打开C2，则会新启一个task。</p>
<p>如别的应用Other中有一个activity，taskId为200，从它打开C2，则C2的taskIdI不会为200，例如C2的taskId为201，那么再从C2打开C1、C3，则C2、C3的taskId仍为201。</p>
<p>注意：如果此时你点击home，然后再打开Other，发现这时显示的肯定会是Other应用中的内容，而不会是我们应用中的C1 C2 C3中的其中一个。</p>
<p><img src="/2020/03/16/JAVA笔记整理/1674835-dcef4bb069cc5d6f.webp" alt="img"></p>
<h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p>singleInstance模式算是4种启动模式中最复杂的一个了，不同于以上三种模式，该模式下活动会启用一个新的返回栈来管理这个活动(其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈)。</p>
<p>那么这样做有什么意义呢?想象以下场景，假设我们的程序中有一个活动是允许其他程序调用的，如果我们想实现其他程序和我们的程序可以共享这个活动的实例，应该如何实现呢?使用前面3种启动模式肯定是做不到的，因为每个应用程序都会有自己的返回栈，同一个活动在不同的返回栈中入栈时必然是创建了新的实例。而使用singlelnstance模式就可以解决这个问题，在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了共享活动实例的问题。</p>
<p>只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。</p>
<p>例如：</p>
<p>程序有三个ActivityD1,D2,D3，三个Activity可互相启动，其中D2为singleInstance模式。那么程序从D1开始运行，假设D1的taskId为200，那么从D1启动D2时，D2会新启动一个task，即D2与D1不在一个task中运行。假设D2的taskId为201，再从D2启动D3时，D3的taskId为200，也就是说它被压到了D1启动的任务栈中。</p>
<p>若是在别的应用程序打开D2，假设Other的taskId为200，打开D2，D2会新建一个task运行，假设它的taskId为201，那么如果这时再从D2启动D1或者D3，则又会再创建一个task，因此，若操作步骤为other-&gt;D2-&gt;D1，这过程就涉及到了3个task了。</p>
<p><img src="/2020/03/16/JAVA笔记整理/1674835-7cf53bd4d1af899b.webp" alt="img"></p>
<hr>
<h3 id="触摸事件分发机制"><a href="#触摸事件分发机制" class="headerlink" title="触摸事件分发机制"></a>触摸事件分发机制</h3><p><a href="https://blog.csdn.net/qq_43652500/article/details/100186032" target="_blank" rel="noopener">见【Android】 触摸事件分发机制</a></p>
<ol>
<li>Android中的控件都是直接或者间接继承View的，Viewgroup也是继承View的，ViewGroup中可以包含View，也可以包含ViewGroup，我们平时接触的譬如说LinearLayout啊、RelativeLayout就是ViewGroup的子类。</li>
<li>Android的事件分发机制我有看过它的源码，总的来说就是Android中触摸事件的传递都是先传递到ViewGroup，再传递到View的。我就举Button点击这个例子来讲解一下Android中触摸事件分发的大致流程吧。</li>
<li>当点击Button的时候，会调用这个控件所在布局的dispatchTouchEvent()，然后在这个布局中dispatchTouchEvent()方法中找到被点击控件的dispatchTouchEvent()方法。</li>
<li>在调用被点击控件的dispatchTouchEvent()方法之前会有一次触摸事件的拦截判断，如果触摸事件被拦截了，就不会再去执行被点击控件的dispatchTouchEvent函数了，也就不会再执行onClick点击事件了。而是执行ViewGroup控件中的dispatchTouchEvent()的onTouch触摸事件然后返回。</li>
<li>如果触摸事件没被拦截的话又是怎么做呢，就会ViewGroup中dispatchTouchEvent()方法中被点击控件的dispatchTouchEvent()方法，就不会执行ViewGroup中的onTouch方法了。</li>
<li>以上只是阐述了touch事件在ViewGroup中和View中的事件分发过程，但是具体得在一个View中的touch事件分发机制又是怎么样的呢，我们继续往下看</li>
<li>android里面当触摸到任何一个控件的时候就一定会调用这个控件的dispatchTouchEvent方法。dispatchTouchEvent方法中的源码首先会调用onTouch方法，不过这个方法要执行的话也需要有两个前提条件，一个是这个控件注册了触摸监听、第二个是这个控件的状态要是enabled的。</li>
<li>执行完onTouch方法之后，会有一个返回值，如果返回这为true的话代表这个点击事件不继续往下传递了，为false的话就表示点击事件继续往下传递，就会执行onTouchEvent方法，onClick方法就是在onTouchEvent中被调用的。</li>
<li>这样的话一个控件的触摸事件在ViewGroup以及View中的分发过程就完成了。</li>
</ol>
<hr>
<h3 id="handler机制，多个handler怎么确定哪个handler处理哪个Message"><a href="#handler机制，多个handler怎么确定哪个handler处理哪个Message" class="headerlink" title="handler机制，多个handler怎么确定哪个handler处理哪个Message"></a>handler机制，多个handler怎么确定哪个handler处理哪个Message</h3><p><strong>一、Handler是什么？</strong></p>
<p>Handler在我们android开发中是一项非常重要的机制，那Handler是什么呢？Handler是android提供用于更新UI的一套机制，也是消息处理机制。</p>
<p><strong><em>Handler</em>的主要作用有两个：</strong></p>
<p>​    <strong><em>(1).</em>在新启动的线程中发送消息</strong></p>
<p>​           <strong>(2).在主线程中获取，处理消息。</strong></p>
<p>解释：(1) 当应用程序启动时，Android首先会开启一个主线程 (也就是UI线程) ， 主线程为管理界面中的UI控件， 进行事件分发， 比如说， 你要是点击一个 Button ，Android会分发事件到Button上，来响应你的操作。 主线程（UI线程）就是android程序从启动运行到最后的程序。</p>
<p>(2) 如果此时需要一个耗时的操作，例如: 联网读取数据，或者读取本地较大的一个文件的时候，你不能把这些操作放在主线程中，如果你放在主线程中的话，界面会出现假死现象， 如果5秒钟还没有完成的话，会收到Android系统的一个错误提示 “强制关闭”。</p>
<p>(3)这个时候我们需要把这些耗时的操作，放在一个子线程中，因为子线程涉及到UI更新，Android主线程是线程不安全的， 也就是说，更新UI只能在主线程中更新，子线程中操作是危险的。</p>
<p>(4)这个时候，Handler就出现了。来解决这个复杂的问题 ，由于Handler运行在主线程中(UI线程中)， 它与子线程可以通过Message对象来传递数据， 这个时候，Handler就承担着接受子线程传过来的(子线程用sendMessage()方法传递)Message对象(里面包含数据) ， 把这些消息放入主线程队列中，配合主线程进行更新UI。</p>
<p><strong>二、为什么要用Handler</strong></p>
<p>如果我们不用Handler去发送消息，更新UI可以吗？</p>
<p>答案是不行的。 <strong>Android</strong>在设计的时候，就封装了一套消息创建，传递，处理机制，如果不遵循这样的机制，就没有办法更新UI信息的，就会抛出异常信息。</p>
<p>抛出异常的描述：不能在非UI线程中去更新UI</p>
<p><strong>三、</strong> <strong>Handler</strong>怎么用</p>
<p> handler可以分发Message对象和Runnable对象到主线程中，每个Handler实例，都会绑定到创建他的线程中(一般是位于主程)，它有两个作用：</p>
<p>   (1)合理调度安排消息和runnable对象，使它们在将来的某个点被执行</p>
<p>​    (2)安排一个动作在不同的线程中执行</p>
<p><strong>Handler中开启线程和分发消息的一些方法:</strong></p>
<p>   <strong>post(Runnable)</strong>直接开启Runnable线程</p>
<p>   <strong>postAtTime(Runnable，long)</strong>在指定的时间long，开始启动线程</p>
<p>   <strong>postDelayed(Runnable long)</strong>在延迟long时间后，启动Runnable线程</p>
<p>   <strong>sendEmptyMessage(int)</strong> 发送指定的消息，通过参数<em>int**来区分不同的消息</em></p>
<p>   <strong>sendMessage(Message)</strong>发送消息到UI线程中</p>
<p>   sendMessageAtTime(Message，long)   这个long代表的是系统时间，不推荐用</p>
<p>  sendMessageDelayed(Message,long)  此方法long代表调用后几秒后执行。</p>
<p>  sendMessage类方法， 允许你安排一个带数据的Message对象到队列中，等待更新.</p>
<p><strong>handler基本使用：</strong> 1)在主线程中，使用handler很简单，new一个Handler对象实现其handleMessage方法，在 handleMessage 中提供收到消息后相应的处理方法即可。（接收消息，并且更新UI）</p>
<p>​           2)在新启动的线程中发送消息</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            tv.setText(<span class="string">"msg.arg1:"</span>+msg.arg1+<span class="string">"--msg.arg2:"</span>+msg.arg2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> TextView tv;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_handler);</span><br><span class="line">        initView();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Message msg = <span class="keyword">new</span> Message();<span class="comment">//实例化消息对象</span></span><br><span class="line">                msg.arg1 = <span class="number">99</span>;<span class="comment">//携带参数</span></span><br><span class="line">                msg.arg2 = <span class="number">100</span>;<span class="comment">//携带参数</span></span><br><span class="line">                Object str = <span class="keyword">new</span> Object();<span class="comment">//实例化对象</span></span><br><span class="line">                msg.obj = str; <span class="comment">//携带参数为实体类对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tv = (TextView) findViewById(R.id.tv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>handler运行机制：</strong></p>
<p><strong><img src="/2020/03/16/JAVA笔记整理/20180818235134804.png" alt="img"></strong> </p>
<p> Handler机制也可叫异步消息机制，它主要由4个部分组成：<strong>Message,Handler,MessageQueue,Looper</strong>,在上面图中我们已经有了大致印象,接下来我们对4个成员进行着重的了解：</p>
<p><strong>1.Message</strong><br>  Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。使用Message的arg1和arg2便可携带int数据，使用obj便可携带Object类型数据。</p>
<p><strong>2.Handler</strong><br>  Handler顾名思义就是处理者的意思，它只要用于在子线程发送消息对象Message,在UI线程处理消息对象Message，在子线程调用sendMessage方法发送消息对象Message，而发送的消息经过一系列地辗转之后最终会被传递到Handler的handleMessage方法中,最终在handleMessage方法中消息对象Message被处理。</p>
<p><strong>3.MessageQueue</strong><br>  MessageQueue就是消息队列的意思,它只要用于存放所有通过Handler发送过来的消息。这部分消息会一直存放于消息队列当中，等待被处理。每个线程中只会有一个MessageQueue对象，请牢记这句话。其实从字面上就可以看出，MessageQueue底层数据结构是队列，而且这个队列只存放Message对象。</p>
<p><strong>4.Looper</strong><br>  Looper是每个线程中的MessageQueue的管家，调用Looper的loop()方法后，就会进入到一个无限循环当中，然后每当MesssageQueue中存在一条消息，Looper就会将这条消息取出，并将它传递到Handler的handleMessage()方法中。每个线程只有一个Looper对象。</p>
<p>  了解了上述Handler机制的4个成员后，我们再来把思路理一遍：<strong>首先在UI线程我们创建了一个Handler实例对象，无论是匿名内部类还是自定义类生成的Handler实例对象，我们都需要对handleMessage方法进行重写，在handleMessage方法中我们可以通过参数msg来写接受消息过后UIi线程的逻辑处理，接着我们创建子线程，在子线程中需要更新UI的时候，新建一个Message对象，并且将消息的数据记录在这个消息对象Message的内部，比如arg1,arg2,obj等，然后通过前面的Handler实例对象调用sendMessge方法把这个Message实例对象发送出去，之后这个消息会被存放于MessageQueue中等待被处理，此时MessageQueue的管家Looper正在不停的把MessageQueue存在的消息取出来，通过回调dispatchMessage方法将消息传递给Handler的handleMessage方法，最终前面提到的消息会被Looper从MessageQueue中取出来传递给handleMessage方法，最终得到处理。这就是Handler机制整个的工作流程。</strong></p>
<hr>
<h3 id="避免ANR"><a href="#避免ANR" class="headerlink" title="避免ANR"></a>避免ANR</h3><p>ANR(Application Not Responding)定义</p>
<p>在Android上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，这个对话框称作应用程序无响应（ANR：Application Not Responding）对话框。用户可以选择“等待”而让程序继续运行，也可以选择“强制关闭”。所以一个流畅的合理的应用程序中不能出现anr，而让用户每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要，这样系统不会显示ANR给用户。默认情况下，在android中Activity的最长执行时间是5秒，BroadcastReceiver的最长执行时间则是10秒。</p>
<p>Android应用程序通常是运行在一个单独的线程（例如，main）里。这意味着你的应用程序所做的事情如果在<a href="https://baike.baidu.com/item/主线程" target="_blank" rel="noopener">主线程</a>里占用了太长的时间的话，就会引发ANR对话框，因为你的应用程序并没有给自己机会来处理输入事件或者Intent广播。</p>
<p>因此，运行在主线程里的任何方法都尽可能少做事情。特别是，Activity应该在它的关键生命周期方法（如onCreate()和onResume()）里尽可能少的去做创建操作。潜在的耗时操作，例如网络或数据库操作，或者高耗时的计算如改变位图尺寸，应该在子线程里（或者以数据库操作为例，通过异步请求的方式）来完成。然而，不是说你的<a href="https://baike.baidu.com/item/主线程" target="_blank" rel="noopener">主线程</a>阻塞在那里等待子线程的完成——也不是调用Thread.wait()或是Thread.sleep()。替代的方法是，主线程应该为子线程提供一个Handler，以便完成时能够提交给主线程。以这种方式设计你的应用程序，将能保证你的主线程保持对输入的响应性并能避免由于5秒输入事件的超时引发的ANR对话框。这种做法应该在其它显示UI的线程里效仿，因为它们都受相同的超时影响。</p>
<p>IntentReceiver执行时间的特殊限制意味着它应该做：在后台里做小的、琐碎的工作如保存设定或者注册一个Notification。和在<a href="https://baike.baidu.com/item/主线程" target="_blank" rel="noopener">主线程</a>里调用的其它方法一样，应用程序应该避免在BroadcastReceiver里做耗时的操作或计算。但不再是在子线程里做这些任务（因为BroadcastReceiver的生命周期短），替代的是，如果响应Intent广播需要执行一个耗时的动作的话，应用程序应该启动一个Service。顺便提及一句，你也应该避免在Intent Receiver里启动一个Activity，因为它会创建一个新的画面，并从当前用户正在运行的程序上抢夺焦点。如果你的应用程序在响应Intent广播时需要向用户展示什么，你应该使用Notification Manager来实现。</p>
<p>一般来说，在应用程序里，100到200ms是用户能感知阻滞的时间阈值。因此，这里有一些额外的技巧来避免ANR，并有助于让你的应用程序看起来有响应性。</p>
<p>如果你的应用程序为响应用户输入正在后台工作的话，可以显示工作的进度（ProgressBar和ProgressDialog对这种情况来说很有用）。</p>
<p>特别是游戏，在子线程里做移动的计算。</p>
<p>如果你的应用程序有一个耗时的初始化过程的话，考虑可以显示一个Splash Screen或者快速显示主画面并异步来填充这些信息。在这两种情况下，你都应该显示正在进行的进度，以免用户认为应用程序被冻结了。</p>
<p>ThreadLocal-&gt;Looper-&gt;MessageQueue-&gt;Message-&gt;target-&gt;handler</p>
<p><a href="https://blog.csdn.net/zl18603543572/article/details/89196436?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">见</a></p>
<p>不会，一句话谁发送的消息，谁处理，为什么，因为每个Message消息都会绑定一个target来指定这个消息由谁来处理。</p>
<p>Message消息在被发送时会被绑定Handler</p>
<p>追溯源码发现，无论使用Handler的哪个方法来发送消息，最终都会调用到下面方法来发送，在这里 msg对象会被绑定target，而这里的值为this，正是发送消息的Handler的本身，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Message消息在被处理的时候</p>
<p>追溯源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">       <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">       <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">       Binder.clearCallingIdentity();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">           <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">           Printer logging = me.mLogging;</span><br><span class="line">           <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">               logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                       msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           msg.target.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">               logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">           <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">           <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">               Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                       + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                       + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                       + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                       + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           msg.recycleUnchecked();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>msg.target.dispatchMessage(msg); 关键的这一句，msg调用了自身绑定的target的dispatchMessage方法来处理消息，而这里的target正是msg在被发送的时候所绑定的handler.</p>
<hr>
<h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><p>AIDL是Android中<strong>IPC（Inter-Process Communication）</strong>方式中的一种，AIDL是<strong>Android Interface definition language</strong>的缩写，对于小白来说，AIDL的作用是让你可以在自己的APP里绑定一个其他APP的service，这样你的APP可以和其他APP交互。</p>
<hr>
<h3 id="线程通信方式"><a href="#线程通信方式" class="headerlink" title="线程通信方式"></a>线程通信方式</h3><p><a href="https://blog.csdn.net/liuxingyuzaixian/article/details/78893392" target="_blank" rel="noopener">https://blog.csdn.net/liuxingyuzaixian/article/details/78893392</a></p>
<hr>
<h3 id="Intent显示跳转与隐式跳转"><a href="#Intent显示跳转与隐式跳转" class="headerlink" title="Intent显示跳转与隐式跳转"></a>Intent显示跳转与隐式跳转</h3><p><a href="https://blog.csdn.net/sinat_22949049/article/details/80064261" target="_blank" rel="noopener">https://blog.csdn.net/sinat_22949049/article/details/80064261</a></p>
<hr>
<h3 id="apk编译-apk安装过程"><a href="#apk编译-apk安装过程" class="headerlink" title="apk编译,apk安装过程"></a>apk编译,apk安装过程</h3><p><img src="/2020/03/16/JAVA笔记整理/20180710175536508.png" alt="这里写图片描述"></p>
<ol>
<li>Android通过<code>AAPT工具</code>将.xml资源文件编译成R.java的二进制文件，除了assets、raw目录下的文件；</li>
<li>将java文件编译成.class文件；</li>
<li>通过dex工具将.class文件转换成.dex文件</li>
<li>优化dex文件 ： Davlik模式下使用 <code>dexopt</code>工具将.dex文件优化得到<code>.odex</code>文件 ; Art模式下使用<code>dexoat</code>工具将.dex文件优化得到<code>.oat</code>文件;</li>
<li><code>apkbuilder</code>会将.dex文件和未被编译的文件编译成apk;</li>
<li><code>apkSinger</code>对apk签名；</li>
<li><code>zipalign</code>对签名后的apk进行优化</li>
</ol>
<p><img src="/2020/03/16/JAVA笔记整理/20180710175548750.png" alt="这里写图片描述"></p>
<p>Android 安装的apk文件实际上是以.zip结尾的压缩文件，解压后的文件内容如上图所示</p>
<ul>
<li>AndroidManifest.xml对应源代码中的AndroidManifest.xml, 但这里是编译过的，文件内容已经不同了；</li>
<li>assets对应源代码的assets目录， 是直接复制过来的；</li>
<li>classes.dex（classes2.dex、classes3.dex等等）是包含所有Java文件对应的字节码，其中<code>classes.dex</code>是程序主包;</li>
<li>lib目录对应源代码中的libs目录，包含so文件；</li>
<li>META-INF目录包含CERT.RSA、CERT.SF、MANIFEST.MF等， 保存了各个资源文件的SHA1值，用于校验资源文件是否被篡改，从而防止二次打包时资源文件被替换；</li>
<li>res目录对应源码的res目录， 包含各种图片、xml等；</li>
<li>resources.arsc包含了各个资源文件的映射， 可以理解为索引， 通过该文件能找到对应的资源文件信息。</li>
</ul>
<hr>
<h3 id="androidManifest文件的作用"><a href="#androidManifest文件的作用" class="headerlink" title="androidManifest文件的作用"></a>androidManifest文件的作用</h3><p>AndroidManifest.xml是Android应用的入口文件，它描述了package中暴露的组件（activities, services, 等等），他们各自的实现类，各种能被处理的数据和启动位置。 除了能声明程序中的Activities, ContentProviders, Services, 和Intent Receivers,还能指定permissions和instrumentation（安全控制和测试）。 </p>
<p><a href="https://blog.csdn.net/weixin_41729259/article/details/87910512" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41729259/article/details/87910512</a></p>
<hr>
<h3 id="ProGuard"><a href="#ProGuard" class="headerlink" title="ProGuard"></a>ProGuard</h3><p>ProGuard 是一款免费的Java类文件压缩器、优化器和混淆器。它能发现并删除无用类、字段（field）、方法和属性值（attribute）。它也能优化字节码 并删除无用的指令。最后，它使用简单无意义的名字来重命名你的类名、字段名和方法名。经过以上操作的jar文件会变得更小，并很难进行逆向工程。这里提到 了ProGuard的主要功能是压缩、优化和混淆，下面我就先介绍一下这些概念，然后再介绍ProGuard的基本使用方法。</p>
<p>ProGuard支持那些种类的优化：</p>
<p>除了在压缩操作删除的无用类，字段和方法外，ProGuard也能在字节码级提供性能优化，内部方法有：</p>
<p>² 常量表达式求值</p>
<p>² 删除不必要的字段存取</p>
<p>² 删除不必要的方法调用</p>
<p>² 删除不必要的分支</p>
<p>² 删除不必要的比较和instanceof验证</p>
<p>² 删除未使用的代码</p>
<p>² 删除只写字段</p>
<p>² 删除未使用的方法参数</p>
<p>² 像push/pop简化一样的各种各样的peephole优化</p>
<p>² 在可能的情况下为类添加static和final修饰符</p>
<p>² 在可能的情况下为方法添加private, static和final修饰符</p>
<p>² 在可能的情况下使get/set方法成为内联的</p>
<p>² 当接口只有一个实现类的时候，就取代它</p>
<p>² 选择性的删除日志代码</p>
<hr>
<h3 id="Service的onBind和onStart差别"><a href="#Service的onBind和onStart差别" class="headerlink" title="Service的onBind和onStart差别"></a>Service的onBind和onStart差别</h3><p>Service的生命周期方法比Activity少一些，只有onCreate, onStart, onDestroy<br>　　我们有两种方式启动一个Service,他们对Service生命周期的影响是不一样的。</p>
<p>　　1 通过startService<br>　　Service会经历 onCreate —&gt; onStart<br>　　stopService的时候直接onDestroy</p>
<p>　　如果是 调用者 直接退出而没有调用stopService的话，Service会一直在后台运行。<br>　　下次调用者再起来仍然可以stopService。</p>
<p>　　2 通过bindService<br>　　Service只会运行onCreate， 这个时候 调用者和Service绑定在一起</p>
<p>　　调用者退出了，Srevice就会调用onUnbind—&gt;onDestroyed<br>　　所谓绑定在一起就共存亡了。</p>
<p>　　注意：Service的onCreate的方法只会被调用一次，<br>　　就是你无论多少次的startService又 bindService，Service只被创建一次。<br>　　如果先是bind了，那么start的时候就直接运行Service的onStart方法，<br>　　如果先是start，那么bind的时候就直接运行onBind方法。如果你先bind上了，就stop不掉了，<br>　　只能先UnbindService, 再StopService,所以是先start还是先bind行为是有区别的。</p>
<p>　　Android中的服务和windows中的服务是类似的东西，服务一般没有用户操作界面，它运行于系统中不容易被用户发觉，可以使用它开发如监控之类的程序。</p>
<p>　　服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。<br>　　这两个方法都可以启动Service，但是它们的使用场合有所不同。使用startService()方法启用服务，调用者与服务之间没有关连，<br>　　即使调用者退出了，服务仍然运行。使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。</p>
<p>　　如果打算采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，<br>　　接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次创建服务，<br>　　但会导致多次调用onStart()方法。采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。</p>
<p>　　如果打算采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，<br>　　接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，<br>　　接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，<br>　　多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。<br>　　如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()—&gt;onDestroy()方法.</p>
<p>　　onBind将返回给客户端一个IBind接口实例，IBind允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。这个时候调用者会和Service绑定在一起,但onBind只能一次，不可多次绑定。<br>　　在Service每一次的开启关闭过程中，只有onStart可被多次调用(通过多次startService调用)，其他onCreate，onBind，onUnbind，onDestory在一个生命周期中只能被调用一次。</p>
<p>　　由于Android 中的Service使用了onBind 的方法去绑定服务，返回一个I<a href="https://www.baidu.com/s?wd=binder&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">binder</a>对象进行操作，而我们要获取具体的Service方法的内容的时候，我们需要I<a href="https://www.baidu.com/s?wd=binder&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">binder</a>对象返回具体的Service对象才能操作，所以说具体的Service对象必须首先实现<a href="https://www.baidu.com/s?wd=Binder&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">Binder</a>对象，这个样子的话我们才能利用bindService的方法对Service进行绑定，获取Binder对象之后获取具体的Service对象，然后才获取Service中的方法等等。</p>
<p>　　与采用Context.startService()方法启动服务有关的生命周期方法<br>　　onCreate() —onStart() —onDestroy()<br>　　onCreate()该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，服务也只被创建一次。<br>　　onStart() 只有采用Context.startService()方法启动服务时才会回调该方法。该方法在服务开始运行时被调用。多次调用startService()方法尽管不会多次创建服务，但onStart() 方法会被多次调用。<br>　　onDestroy()该方法在服务被终止时调用。</p>
<p>　　与采用Context.bindService()方法启动服务有关的生命周期方法<br>　　onCreate()— onBind() — onUnbind() — onDestroy()<br>　　onBind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务绑定时被调用，当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。</p>
<hr>
<h3 id="View的绘制过程"><a href="#View的绘制过程" class="headerlink" title="View的绘制过程"></a>View的绘制过程</h3><p><a href="https://www.jianshu.com/p/c151efe22d0d" target="_blank" rel="noopener">https://www.jianshu.com/p/c151efe22d0d</a></p>
<hr>
<h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p><a href="https://www.jianshu.com/p/4920c7781afe" target="_blank" rel="noopener">https://www.jianshu.com/p/4920c7781afe</a></p>
<hr>
<h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><h3 id="三次握手四次挥手使用哪个协议"><a href="#三次握手四次挥手使用哪个协议" class="headerlink" title="三次握手四次挥手使用哪个协议"></a>三次握手四次挥手使用哪个协议</h3><p>建立TCP需要三次握手才能建立，而断开连接则需要四次握手。首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p>
<p>在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。</p>
<p><strong>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong><br>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<p>第三次失败会怎么样</p>
<p>当客户端收到服务端的SYN+ACK应答后，其状态变为ESTABLISHED，并会发送ACK包给服务端，准备发送数据了。如果此时ACK在网络中丢失，过了超时计时器后，那么Server端会重新发送SYN+ACK包，重传次数根据/proc/sys/net/ipv4/tcp_synack_retries来指定，默认是5次。如果重传指定次数到了后，仍然未收到ACK应答，那么一段时间后，Server自动关闭这个连接。但是Client认为这个连接已经建立，如果Client端向Server写数据，Server端将以RST包响应，方能感知到Server的错误。</p>
<p>当失败时服务器并不会重传ack报文，而是直接发送RTS报文段，进入CLOSED状态。这样做的目的是为了防止SYN洪泛攻击。</p>
<hr>
<h3 id="TCP和UDP区别，工作在哪一层，这一层的主要功能，数据在TCP下有什么变化；（增加tcp头部，udp头部）"><a href="#TCP和UDP区别，工作在哪一层，这一层的主要功能，数据在TCP下有什么变化；（增加tcp头部，udp头部）" class="headerlink" title="TCP和UDP区别，工作在哪一层，这一层的主要功能，数据在TCP下有什么变化；（增加tcp头部，udp头部）"></a>TCP和UDP区别，工作在哪一层，这一层的主要功能，数据在TCP下有什么变化；（增加tcp头部，udp头部）</h3><p>TCP和<a href="https://www.baidu.com/s?wd=UDP协议&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">UDP协议</a>都是传输层的协议。</p>
<p>TCP与UDP基本区别<br> 1.基于连接与无连接<br> 2.TCP要求系统资源较多，UDP较少；<br> 3.UDP程序结构较简单<br> 4.流模式（TCP）与数据报模式(UDP);<br> 5.TCP保证数据正确性，UDP可能丢包<br> 6.TCP保证数据顺序，UDP不保证 </p>
<p>UDP应用场景：<br> 1.面向数据报方式<br> 2.网络数据大多为短消息<br> 3.拥有大量Client<br> 4.对数据安全性无特殊要求<br> 5.网络负担非常重，但对响应速度要求高</p>
<p>TCP编程的服务器端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt(); * 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();<br>　　4、开启监听，用函数listen()；<br>　　5、接收客户端上来的连接，用函数accept()；<br>　　6、收发数据，用函数send()和recv()，或者read()和write();<br>　　7、关闭网络连接；<br>　　8、关闭监听； </p>
<p>TCP编程的客户端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();<em> 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();</em> 可选<br>　　4、设置要连接的对方的IP地址和端口等属性；<br>　　5、连接服务器，用函数connect()；<br>　　6、收发数据，用函数send()和recv()，或者read()和write();<br>　　7、关闭网络连接；</p>
<p><strong><em>\</em>UDP:**</strong><br>与之对应的UDP编程步骤要简单许多，分别如下：<br>　　UDP编程的服务器端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();* 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();<br>　　4、循环接收数据，用函数recvfrom();<br>　　5、关闭网络连接； </p>
<p>UDP编程的客户端一般步骤是：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();<em> 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();</em> 可选<br>　　4、设置对方的IP地址和端口等属性;<br>　　5、发送数据，用函数sendto();<br>　　6、关闭网络连接；</p>
<p>TCP补充：<br> TCP充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p>
<p>TCP与UDP区别总结：<br>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保  证可靠交付<br>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br> UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p>
<p>TCP头部</p>
<p>/<em>TCP头定义，共20个字节</em>/<br>typedef struct _TCP_HEADER<br>{<br> short m_sSourPort;    　　　　　　// 源端口号16bit<br> short m_sDestPort;    　　　　　 // 目的端口号16bit<br> unsigned int m_uiSequNum;    　// 序列号32bit<br> unsigned int m_uiAcknowledgeNum; // 确认号32bit<br> short m_sHeaderLenAndFlag;   　　// 前4位：TCP头长度；中6位：保留；后6位：标志位<br> short m_sWindowSize;    　　　　// 窗口大小16bit<br> short m_sCheckSum;    　　　　　 // 检验和16bit<br> short m_surgentPointer;   　　　　 // 紧急数据偏移量16bit<br>}<strong>attribute</strong>((packed))TCP_HEADER, *PTCP_HEADER;</p>
<ol>
<li><p>TCP layer 没有IP地址的概念，那个是IP 层的，所以前4个字节是<strong>源端口和目的端口</strong></p>
</li>
<li><p>Sequence Number：传输数据过程中，为每一个封包分配一个序号，<strong>保证网络传输数据的顺序性</strong></p>
</li>
<li><p>Acknowledgment Number：用来确认确实有收到相关封包，内容表示期望收到下一个报文的序列号，<strong>用来解决丢包的问题</strong></p>
</li>
<li><p>TCP Flags：这部分主要标志数据包的属性，比如SYN，RST，FIN等，操控TCP的状态机</p>
</li>
<li><p>Window：滑动窗口，主要用于解决流控拥塞的问题</p>
</li>
<li><p>Checksum：校验值</p>
</li>
<li><p>Urgent Pointer：紧急指针，可以告知紧急的数据位置，需要和Flag的U flag 配合使用</p>
</li>
<li><p>TCP Options：一般包含在三次握手中，有Option的选项！</p>
</li>
</ol>
<p><strong>UDP头结构的定义</strong></p>
<p>/<em>UDP头定义，共8个字节</em>/</p>
<p>typedef struct _UDP_HEADER<br>{<br> unsigned short m_usSourPort;  　　　// 源端口号16bit<br> unsigned short m_usDestPort;  　　　// 目的端口号16bit<br> unsigned short m_usLength;  　　　　// 数据包长度16bit<br> unsigned short m_usCheckSum;  　　// 校验和16bit<br>}<strong>attribute</strong>((packed))UDP_HEADER, *PUDP_HEADER;</p>
<hr>
<h3 id="http使用了哪些技术？Get-post区别"><a href="#http使用了哪些技术？Get-post区别" class="headerlink" title="http使用了哪些技术？Get,post区别"></a>http使用了哪些技术？Get,post区别</h3><ol>
<li><p>GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以？分割URL和传输数据，参数之间以&amp;相连，如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母或数字，则原样发送；如果是空格，转换为+；如果是中文或其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII码值。而与之对应的，POST把提交的数据放置在HTTP包的包体中，文章最下面将会有代码示例。</p>
</li>
<li><p>POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为：(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击（CSRF,跨站请求伪造，也被称为：one click attack/session riding）。</p>
</li>
</ol>
<p>HTTP 协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议 TLS/SSL 具有身份验证、信息加密和完整性校验的功能，可以避免此类问题。<br>TLS/SSL 全称安全传输层协议 Transport Layer Security, 是介于 TCP 和 HTTP 之间的一层安全协议，不影响原有的 TCP 协议和 HTTP 协议，所以使用 HTTPS 基本上不需要对 HTTP 页面进行太多的改造。</p>
<p>HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，本节分析安全协议的实现原理。</p>
<p>TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。<img src="/2020/03/16/JAVA笔记整理/2snzFs9.gif" alt="img"></p>
<p><img src="/2020/03/16/JAVA笔记整理/1260476-20171116160813812-635766483.png" alt="img"></p>
<ul>
<li>在使用HTTPS是需要保证服务端配置正确了对应的安全证书</li>
<li>客户端发送请求到服务端</li>
<li>服务端返回公钥和证书到客户端</li>
<li>客户端接收后会验证证书的安全性,如果通过则会随机生成一个随机数,用公钥对其加密,发送到服务端</li>
<li>服务端接受到这个加密后的随机数后会用私钥对其解密得到真正的随机数,随后用这个随机数当做私钥对需要发送的数据进行对称加密</li>
<li>客户端在接收到加密后的数据使用私钥(即生成的随机值)对数据进行解密并且解析数据呈现结果给客户</li>
<li>SSL加密建立</li>
</ul>
<hr>
<h3 id="如何实现UDP的可靠传输"><a href="#如何实现UDP的可靠传输" class="headerlink" title="如何实现UDP的可靠传输"></a>如何实现UDP的可靠传输</h3><p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<p>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p>
<ul>
<li>1、添加seq/ack机制，确保数据发送到对端</li>
<li>2、添加发送和接收缓冲区，主要是用户超时重传。</li>
<li>3、添加超时重传机制。</li>
</ul>
<p>详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p>
<hr>
<h3 id="TIME-WAIT状态处在哪一方以及为什么需要它"><a href="#TIME-WAIT状态处在哪一方以及为什么需要它" class="headerlink" title="TIME_WAIT状态处在哪一方以及为什么需要它"></a>TIME_WAIT状态处在哪一方以及为什么需要它</h3><p><img src="/2020/03/16/JAVA笔记整理/3971776-9550b64ff16dbb0b.webp" alt="img"></p>
<p>在TCP连接中四次挥手关闭连接时，主动关闭连接的一方（上图中时Client）会在发送最后一条ACK报文后维持一段时长2MSL（MSL指的是数据包在网络中的最大生存时间）的等待时间后才会真正关闭连接到CLOSED状态，该时间段内主动关闭方的状态为TIME_WAIT。即在TIME_WAIT状态时，定义这个连接的四元组（源/目的IP、源/目的端口）不能被使用。</p>
<p>为实现TCP连接的可靠释放</p>
<ol>
<li><p>若主动断开连接方（上图中Client）最后一次ACK报文丢失了，会触发被动方（上图中Server）的超时重传机制，Server再次向Client发送FIN+ACK报文，如果Client在发送完最后一次ACK后立即断开连接（没有TIME_WAIT状态），则Server会收到RST=1的报文响应，表示连接建立异常，而此时并非异常，只是正常的关闭连接过程，进而导致Server端不能正常关闭连接。因此，Client必须维护2MSL的等待时间，确保在Server端第二次发送的FIN+ACK被Client正常接收，收到后Client立即发送ACK给Server，并重新启动2MSL计时器。（因为极端情况涉及两次报文传输（Client向Server的ACK，Server向Client的FIN+ACK），所以等待时间为2MSL）</p>
</li>
<li><p>为使旧的重复数据包在网络中因过期而消失</p>
<p>可能存在一些数据包在传输过程中出现异常而导致严重推迟，而在它到来之前发送方已经重发了该报文，并完成其任务。如果在被推迟的报文未抵达前接收方断开了连接，随后又建立了一个与之前相同IP、Port的连接，而之前被推迟的报文在这时恰好到达，而此时此新连接非彼连接，从而会发生数据错乱，进而导致无法预知的情况。因此必须维持一段等待时间，使迟到的报文在网络中完全消失，并且在等待时间内，因为连接并未关闭，所以不能建立相同四元组的新连接，就不会出现数据错乱。</p>
</li>
</ol>
<p>在高并发短连接的TCP服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于TIME_WAIT状态，服务器维护每一个连接需要一个socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些连接失败。</p>
<p>可设置套接字选项为SO_REUSEADDR，该选项的意思是，告诉操作系统，如果端口忙，但占用该端口TCP连接处于TIME_WAIT状态，并且套接字选项为SO_REUSEADDR，则该端口可被重用。如果TCP连接处于其他状态，依然返回端口被占用。该选项对服务程序重启非常有用。</p>
<hr>
<h3 id="HTTPs的握手过程"><a href="#HTTPs的握手过程" class="headerlink" title="HTTPs的握手过程"></a>HTTPs的握手过程</h3><p><img src="/2020/03/16/JAVA笔记整理/555379-20160210231313448-2027205313.png" alt="img"></p>
<ol>
<li><p>客户端发起HTTPS请求</p>
</li>
<li><p>服务端的配置</p>
</li>
</ol>
<p>采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。</p>
<ol>
<li>传送证书</li>
</ol>
<p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。</p>
<ol>
<li>客户端解析证书</li>
</ol>
<p>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。</p>
<ol>
<li>传送加密信息</li>
</ol>
<p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p>
<ol>
<li>服务段解密信息</li>
</ol>
<p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p>
<ol>
<li>传输加密后的信息</li>
</ol>
<p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p>
<ol>
<li>客户端解密信息</li>
</ol>
<p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。</p>
<p>PS: 整个握手过程第三方即使监听到了数据，也束手无策。</p>
<p>总结</p>
<p>为什么HTTPS是安全的？</p>
<p>在HTTPS握手的第四步中，如果站点的证书是不受信任的，会显示出现下面确认界面，确认了网站的真实性。另外第六和八步，使用客户端私钥加密解密，保证了数据传输的安全。</p>
<p>HTTPS和HTTP的区别</p>
<ol>
<li><p>https协议需要到ca申请证书或自制证书。</p>
</li>
<li><p>http的信息是明文传输，https则是具有安全性的ssl加密。</p>
</li>
<li><p>http是直接与TCP进行数据传输，而https是经过一层SSL（OSI表示层），用的端口也不一样，前者是80（需要国内备案），后者是443。</p>
</li>
<li><p>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
</li>
</ol>
<p>注意https加密是在传输层 </p>
<p>https报文在被包装成tcp报文的时候完成加密的过程，无论是https的header域也好，body域也罢都是会被加密的。</p>
<p>当使用tcpdump或者wireshark之类的tcp层工具抓包，获取是加密的内容，而如果用应用层抓包，使用Charels(Mac)、Fildder(Windows)抓包工具，那当然看到是明文的。</p>
<hr>
<h3 id="为什么数据传输不用非对称加密"><a href="#为什么数据传输不用非对称加密" class="headerlink" title="为什么数据传输不用非对称加密"></a>为什么数据传输不用非对称加密</h3><p>因为非对称加密加密解密算法效率较低，不适合客户端和服务器端这样高频率的通信过程，在某些极端情况下，甚至能比非对称加密慢上1000倍。</p>
<p>非对称加密的优势在于它可以很好帮助完成秘钥的交换，所以前期交换秘钥必须使用非对称加密算法。</p>
<p>对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；为什么叫对称加密？</p>
<p>一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文。他们之间的关系如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">明文 <span class="tag">&lt;<span class="name">-</span>&gt;</span> 密钥 <span class="tag">&lt;<span class="name">-</span>&gt;</span> 密文</span><br></pre></td></tr></table></figure>
<p>常见的对称加密算法：DES，AES，3DES等等。</p>
<p>而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</p>
<p>非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p>
<p><img src="/2020/03/16/JAVA笔记整理/20190314090627135.png" alt="img"></p>
<p>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。<br>但是此时交换的两个公钥不一定正确</p>
<p>常见的非对称加密算法：RSA，ECC</p>
<hr>
<h3 id="转发和重定向的区别"><a href="#转发和重定向的区别" class="headerlink" title="转发和重定向的区别"></a>转发和重定向的区别</h3><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p>
<p><strong>转发（Forword）</strong> 通过 RequestDispatcher 对象的<code>forward（HttpServletRequest request,HttpServletResponse response）</code>方法实现的。<code>RequestDispatcher</code> 可以通过<code>HttpServletRequest</code> 的 <code>getRequestDispatcher()</code>方法获得。例如下面的代码就是跳转到 login_success.jsp 页面。</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">request</span>.getRequestDispatcher(<span class="string">"login_success.jsp"</span>).forward(<span class="built_in">request</span>, <span class="built_in">response</span>);</span><br></pre></td></tr></table></figure>
<p><strong>重定向（Redirect）</strong> 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 HttpServletRequestResponse 的 setStatus(int status)方法设置状态码。如果服务器返回 301 或者 302，则浏览器会到新的网址重新请求该资源。</p>
<ol>
<li><strong>从地址栏显示来说</strong>：forward 是服务器请求资源，服务器直接访问目标地址的 URL，把那个 URL 的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址。redirect 是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址。所以地址栏显示的是新的 URL。</li>
<li><strong>从数据共享来说</strong>：forward：转发页面和转发到的页面可以共享 request 里面的数据。redirect：不能共享数据。</li>
<li><strong>从运用地方来说</strong>：forward：一般用于用户登陆的时候，根据角色转发到相应的模块。redirect：一般用于用户注销登陆时返回主页面和跳转到其它的网站等。</li>
<li><strong>从效率来说</strong>：forward：高。redirect：低。</li>
</ol>
<hr>
<h3 id="在浏览器中输入-url-地址到显示主页的过程-整个过程会使用哪些协议"><a href="#在浏览器中输入-url-地址到显示主页的过程-整个过程会使用哪些协议" class="headerlink" title="在浏览器中输入 url 地址到显示主页的过程,整个过程会使用哪些协议"></a>在浏览器中输入 url 地址到显示主页的过程,整个过程会使用哪些协议</h3><p><img src="https://camo.githubusercontent.com/c6bda910351aff0fc39247088fde335ab5bbf3c8/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f2545352539302538342545372541372538442545372542442539312545372542422539432545382541462542372545362542312538322545372539342541382545352538382542302545372539412538342545352538442538462545382541452541452e6a7067" alt="各种网络请求用到的协议"></p>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>具体可以参考下面这篇文章：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006879700</a></li>
</ul>
<hr>
<h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><h3 id="线程和进程区别-线程可以脱离进程单独运行吗"><a href="#线程和进程区别-线程可以脱离进程单独运行吗" class="headerlink" title="线程和进程区别,线程可以脱离进程单独运行吗?"></a>线程和进程区别,线程可以脱离进程单独运行吗?</h3><p><strong>1.定义</strong></p>
<p>进程:具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</p>
<p>线程:进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<p><strong>2.关系</strong></p>
<p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p>
<p>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的<strong>栈空间</strong>，拥有独立的<strong>执行序列</strong>。</p>
<p><strong>3.区别</strong></p>
<p>　　进程和线程的主要差别在于它们是<strong>不同的操作系统资源管理方式</strong>。进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。<strong>但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</strong></p>
<p><strong>1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</strong></p>
<p>2) 线程的划分尺度小于进程，使得多线程程序的并发性高。</p>
<p>3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
<p>4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。<strong>但是线程不能够独立执行，</strong>必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<p>5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。</p>
<p>6)体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。</p>
<p>7)属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符。而不同过的进程相互独立。</p>
<p>8)线程又称为轻量级进程，进程有进程控制块，线程有线程控制块。</p>
<p>9)线程必定也只能属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程。</p>
<hr>
<h3 id="死锁概念-他的四个必要条件-什么是资源独占"><a href="#死锁概念-他的四个必要条件-什么是资源独占" class="headerlink" title="死锁概念,他的四个必要条件,什么是资源独占"></a>死锁概念,他的四个必要条件,什么是资源独占</h3><ul>
<li>互斥条件：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。</li>
<li>不可剥夺条件：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。</li>
<li>请求和保持条件：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。</li>
<li>循环等待条件：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源。<br>以上给出了导致死锁的四个必要条件，只要系统发生死锁则以上四个条件至少有一个成立。事实上<strong>循环等待</strong>的成立蕴含了前三个条件的成立，似乎没有必要列出然而考虑这些条件对死锁的预防是有利的，因为可以通过破坏四个条件中的任何一个来预防死锁的发生。</li>
</ul>
<p>1.临界资源：我们将一次只允许一个进程使用的资源成为临界资源，临界资源又名 独占资源。</p>
<p>2.临界区：进程中访问临界资源的那段代码，称为临界区，又名 临界段。</p>
<hr>
<h3 id="什么是僵尸进程"><a href="#什么是僵尸进程" class="headerlink" title="什么是僵尸进程"></a>什么是僵尸进程</h3><p>我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。</p>
<p>　　<strong>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p>
<p>　　<strong>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</strong></p>
<p>由于子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程 到底什么时候结束. 那么会不会因为父进程太忙来不及wait子进程，或者说不知道 子进程什么时候结束，而丢失子进程结束时的状态信息呢? 不会。因为UNⅨ提供了一种机制可以保证只要<a href="https://baike.baidu.com/item/父进程" target="_blank" rel="noopener">父进程</a>想知道子进程结束时的状态信息， 就可以得到。这种机制就是： 在每个进程退出的时候，<a href="https://baike.baidu.com/item/内核" target="_blank" rel="noopener">内核</a>释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息（包括进程号the process ID，退出状态the termination status of the process，运行时间the amount of CPU time taken by the process等）。直到<a href="https://baike.baidu.com/item/父进程" target="_blank" rel="noopener">父进程</a>通过wait / waitpid来取时才释放. 但这样就导致了问题，如果进程不调用wait / waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生<a href="https://baike.baidu.com/item/僵尸进程" target="_blank" rel="noopener">僵尸进程</a>，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</p>
<p><strong>孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上</strong>，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。<strong>因此孤儿进程并不会有什么危害。</strong></p>
<p>　　<strong>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。</strong>这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p>
<p><strong>僵尸进程的避免</strong></p>
<p>⒈父进程通过wait和waitpid等函数等待子进程结束，这会导致父进程挂起。</p>
<p>⒉ 如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler，因为子进程结束后， 父进程会收到该信号，可以在handler中调用wait回收。</p>
<p>⒊ 如果<a href="https://baike.baidu.com/item/父进程" target="_blank" rel="noopener">父进程</a>不关心子进程什么时候结束，那么可以用signal（SIGCHLD,SIG_IGN） 通知<a href="https://baike.baidu.com/item/内核" target="_blank" rel="noopener">内核</a>，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收， 并不再给父进程发送信号。</p>
<p>⒋ 还有一些技巧，就是fork两次，父进程fork一个子进程，然后继续工作，子进程fork一 个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收 还要自己做。</p>
<hr>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p><strong>协程是一种用户态的轻量级线程，</strong>协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<p>1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。</p>
<p>2) 线程进程都是同步机制，而协程则是异步</p>
<p>3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</p>
<p>协程的特点：</p>
<ol>
<li>线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换。</li>
<li>线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程。</li>
<li>由于在同一个线程上，因此可以避免竞争关系而使用锁。</li>
</ol>
<p>协程是怎么来处理的呢，就是对于一个阻塞的业务操作，我们不是用线程来处理，而是用用协程，这样当出现IO阻塞的时候，并且你还没运行完时间片，你不会让CPU跑掉，而是调起你的另一个协程任务，让他继续进行计算。而通常我们知道，代码纯计算执行是非常快的，5ms可能跑了N个方法了，因此这样充分的利用时间片，并且减少CPU切换的时间。</p>
<hr>
<h3 id="多线程和线程池"><a href="#多线程和线程池" class="headerlink" title="多线程和线程池"></a>多线程和线程池</h3><p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的<a href="https://baike.baidu.com/item/堆栈/1682032" target="_blank" rel="noopener">堆栈</a>大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在<a href="https://baike.baidu.com/item/托管代码/2886980" target="_blank" rel="noopener">托管代码</a>中空闲（如正在等待某个事件）,则线程池将插入另一个<a href="https://baike.baidu.com/item/辅助线程/4746601" target="_blank" rel="noopener">辅助线程</a>来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p>
<p>线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。 例如，线程数一般取cpu数量+2比较合适，线程数过多会导致额外的线程切换开销。</p>
<p>任务调度以执行线程的常见方法是使用同步队列，称作任务队列。池中的线程等待队列中的任务，并把执行完的任务放入完成队列中。</p>
<p>线程池模式一般分为两种：HS/HA半同步/半异步模式、L/F领导者与跟随者模式。</p>
<ul>
<li>半同步/半异步模式又称为生产者消费者模式，是比较常见的实现方式，比较简单。分为同步层、队列层、异步层三层。同步层的主线程处理工作任务并存入工作队列，工作线程从工作队列取出任务进行处理，如果工作队列为空，则取不到任务的工作线程进入挂起状态。由于线程间有数据通信，因此不适于大数据量交换的场合。</li>
<li>领导者跟随者模式，在线程池中的线程可处在3种状态之一：领导者leader、追随者follower或工作者processor。任何时刻线程池只有一个领导者线程。事件到达时，领导者线程负责消息分离，并从处于追随者线程中选出一个来当继任领导者，然后将自身设置为工作者状态去处置该事件。处理完毕后工作者线程将自身的状态置为追随者。这一模式实现复杂，但避免了线程间交换任务数据，提高了CPU cache相似性。在<a href="https://baike.baidu.com/item/ACE" target="_blank" rel="noopener">ACE</a>(Adaptive Communication Environment)中，提供了领导者跟随者模式实现。</li>
</ul>
<p>线程池的<a href="https://baike.baidu.com/item/伸缩性" target="_blank" rel="noopener">伸缩性</a>对性能有较大的影响。</p>
<ul>
<li>创建太多线程，将会浪费一定的资源，有些线程未被充分使用。</li>
<li>销毁太多线程，将导致之后浪费时间再次创建它们。</li>
<li>创建线程太慢，将会导致长时间的等待，性能变差。</li>
<li>销毁线程太慢，导致其它线程<a href="https://baike.baidu.com/item/资源" target="_blank" rel="noopener">资源</a>饥饿。 </li>
</ul>
<hr>
<h3 id="进程间有什么通讯方式"><a href="#进程间有什么通讯方式" class="headerlink" title="进程间有什么通讯方式"></a>进程间有什么通讯方式</h3><p>1、管道</p>
<p>我们来看一条 Linux 的语句</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">netstat -tulnp <span class="string">| grep 8080</span></span><br></pre></td></tr></table></figure>
<p>学过 Linux 命名的估计都懂这条语句的含义，其中”|“是<strong>管道</strong>的意思，它的作用就是把前一条命令的输出作为后一条命令的输入。在这里就是把 netstat -tulnp 的输出结果作为 grep 8080 这条命令的输入。如果两个进程要进行通信的话，就可以用这种<strong>管道</strong>来进行通信了，并且我们可以知道这条<strong>竖线</strong>是没有名字的，所以我们把这种通信方式称之为<strong>匿名管道</strong>。</p>
<p>并且这种通信方式是<strong>单向</strong>的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道。</p>
<p>居然有匿名管道，那也意味着有<strong>命名</strong>管道，下面我们来创建一个命名管道。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfifo  <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>这条命令创建了一个名字为 test 的命名管道。</p>
<p>接下来我们用一个进程向这个管道里面写数据，然后有另外一个进程把里面的数据读出来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"this is a pipe"</span> &gt; <span class="built_in">test</span>   // 写数据</span><br></pre></td></tr></table></figure>
<p>这个时候管道的内容没有被读出的话，那么这个命令就会一直停在这里，只有当另外一个进程把 test 里面的内容读出来的时候这条命令才会结束。接下来我们用另外一个进程来读取</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cat</span> &lt; <span class="keyword">test</span>  <span class="comment">// 读数据</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，test 里面的数据被读取出来了。上一条命令也执行结束了。</p>
<p>从上面的例子可以看出，管道的通知机制类似于<strong>缓存</strong>，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，并且是管道是<strong>单向传输的。</strong></p>
<p>这种通信方式有什么缺点呢？显然，这种通信方式<strong>效率低下</strong>，你看，a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回。</p>
<p>所以管道不适合频繁通信的进程。当然，他也有它的优点，例如比较简单，能够保证我们的数据已经真的被其他进程拿走了。我们平时用 Linux 的时候，也算是经常用。</p>
<p>2、消息队列</p>
<p>那我们能不能把进程的数据放在某个内存之后就马上让进程返回呢？无需等待其他进程来取就返回呢？</p>
<p>答是可以的，我们可以用<strong>消息队列</strong>的通信模式来解决这个问题，例如 a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的<br>消息队列里取出来。同理，b 进程要个 a 进程发送消息也是一样。这种通信方式也类似于<strong>缓存</strong>吧。</p>
<p>这种通信方式有缺点吗？答是有的，如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了。因为 a 发送的数据很大的话，意味<strong>发送消息（拷贝）</strong>这个过程需要花很多时间来读内存。</p>
<p>哪有没有什么解决方案呢？答是有的，请继续往下看。</p>
<p>3、共享内存</p>
<p><strong>共享内存</strong>这个通信方式就可以很好着解决<strong>拷贝</strong>所消耗的时间了。</p>
<p>这个可能有人会问了，每个进程不是有自己的独立内存吗？两个进程怎么就可以共享一块内存了？</p>
<p>我们都知道，系统加载一个进程的时候，分配给进程的内存并不是<strong>实际物理内存</strong>，而是<strong>虚拟内存空间</strong>。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了<strong>内存共享</strong>机制了。</p>
<p>4、信号量</p>
<p>共享内存最大的问题是什么？没错，就是多进程竞争内存的问题，就像类似于我们平时说的<strong>线程安全</strong>问题。如何解决这个问题？这个时候我们的<strong>信号量</strong>就上场了。</p>
<p>信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问<strong>内存1</strong>的时候，我们就把信号量的值设为 0，然后进程b 也要来访问<strong>内存1</strong>的时候，看到信号量的值为 0 就知道已经有进程在访问<strong>内存1</strong>了，这个时候进程 b 就会访问不了<strong>内存1</strong>。所以说，信号量也是进程之间的一种通信方式。</p>
<p>5、Socket</p>
<p>上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？</p>
<p>答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。</p>
<p>总结</p>
<p>所以，进程之间的通信方式有：</p>
<p>1、管道</p>
<p>2、消息队列</p>
<p>3、共享内存</p>
<p>4、信号量</p>
<p>5、Socket</p>
<hr>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="B-树与红黑树的区别"><a href="#B-树与红黑树的区别" class="headerlink" title="B+树与红黑树的区别"></a>B+树与红黑树的区别</h3><p><strong>红黑树：带有平衡性的二叉搜索树增强版</strong></p>
<p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:</p>
<p>　　性质1. 节点是红色或黑色。</p>
<p>　　性质2. 根节点是黑色。</p>
<p>　　性质3 每个叶节点是黑色的。</p>
<p>　　性质4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p>
<p>　　性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
<p>这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。</p>
<p>要知道为什么这些特性确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</p>
<p>考虑一棵黑色高度为3的红黑树：从根结点到叶结点的最短路径长度显然是2(黑-黑-黑)，最长路径为4(黑-红-黑-红-黑)。由于性质4，不可能在最长路经中加入更多的黑色 结点， 此外根据性质3，红色结点的子结点必须是黑色的，因此在同一简单路径中不允许有两个连续的红色结点。综上，我们能够建立的最长路经将是一个红黑交替的路径。</p>
<p>由此我们可以得出结论：<strong>对于给定的黑色高度为n的红黑树，从根到叶结点的简单路径的最短长度为n-1，最大长度为2(n-1)。</strong></p>
<p><strong>B, B-, B+树总结：</strong></p>
<p>B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</p>
<p>B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；<strong>（关键字可以在非叶子节点和叶子节点）M指的是树的阶数</strong></p>
<p>B+树：在B-树基础上，为叶子结点增加链表指针，<strong>所有关键字都在叶子结点中出现</strong>，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p>
<p> B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</p>
<p>性能比较：</p>
<p>性能相当，都等价于在关键字全集做一次二分查找；</p>
<p>B-树 改善了B树的平衡问题，</p>
<p>B+树比 B-树 更适合文件索引系统(结构上的改善)，</p>
<p>B*树比B+树改善了空间利用率。</p>
<p>红黑树：</p>
<p>(1)并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树能够以O(log2 n) 的时间复杂度进行搜索、插入、删除操作。</p>
<p>(2)此外，由于它的设计，任何不平衡都会在三次旋转之内解决。红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高。</p>
<p>B树</p>
<p>二叉排序树（Binary Sort Tree）又称二叉查找（二路搜索）树，也叫B树。　　它或者是一棵空树；或者是具有下列性质的二叉树：　　</p>
<p>(1)若左子树不空，则左子树上所有结点的值均小于左子树所在树的根结点的值；　　</p>
<p>(2)若右子树不空，则右子树上所有结点的值均大于右子树所在树的根结点的值；</p>
<p>(3)左、右子树也分别为二叉排序树；</p>
<p>B树的特点：</p>
<p>1.所有非叶子结点至多拥有两个儿子（Left和Right）；</p>
<p>2.所有结点存储一个关键字；</p>
<p>3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</p>
<p>B树的搜索：从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；如果B树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么B树的搜索性能逼近二分查找</p>
<p>B-树</p>
<p>B-树是一种平衡的<strong>多路查找树</strong>，在文件系统中有所应用。<strong>主要用作文件的索引</strong>。</p>
<p>B-树是一种多路搜索树（并不是二叉的）：</p>
<p>​    1.定义任意非叶子结点最多只有M个儿子；且M&gt;2；</p>
<p>​    2.根结点的儿子数为[2, M]；</p>
<p>​    3.除根结点以外的非叶子结点的儿子数为[M/2, M]；</p>
<p>​    4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</p>
<p>​    5.非叶子结点的关键字个数=指向儿子的指针个数-1；</p>
<p>​    6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</p>
<p>​    7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</p>
<p>​    8.所有叶子结点位于同一层；如：（M=3）</p>
<p> B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；</p>
<p>B-树的特性： </p>
<p>​      1.<strong>关键字集合分布在整颗树中；</strong></p>
<p>​      2.任何一个关键字出现且只出现在一个结点中；</p>
<p>​      3.搜索有可能在非叶子结点结束；</p>
<p>​      4.其搜索性能等价于在关键字全集内做一次二分查找；</p>
<p>​      5.自动层次控制；</p>
<p>B+树</p>
<p>B+树是应文件系统所需而出的一种B-树的变型树。</p>
<p>B+树是B-树的变体，也是一种多路搜索树：</p>
<p>​             1.其定义基本与B-树同，除了：</p>
<p>​            2<strong>.非叶子结点的子树指针与关键字个数相同；</strong></p>
<p>​            3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</p>
<p>​           4.为所有叶子结点增加一个链指针；</p>
<p>​           5.<strong>所有关键字都在叶子结点出现；</strong></p>
<p>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p>
<p>B+的特性： 1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</p>
<p>​             2.不可能在非叶子结点命中；</p>
<p>​             3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</p>
<p>​            4.更适合文件索引系统；</p>
<p><strong>B树和B+树的区别</strong></p>
<p>B/B+树用在磁盘文件组织、数据索引和数据库索引中。其中B+树比B 树更适合实际应用中操作系统的文件索引和数据库索引，因为：</p>
<p>1、B+树的磁盘读写代价更低</p>
<p>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>
<p>2、B+-tree的查询效率更加稳定</p>
<p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<p>3、B树在元素遍历的时候效率较低</p>
<p>B+树只要遍历叶子节点就可以实现整棵树的遍历。在数据库中基于范围的查询相对频繁，所以此时B+树优于B树。</p>
<p>??一言而知就是树的深度较高，在磁盘I/O方面的表现不如B树。</p>
<p>??要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定。</p>
<p>??所以，在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。在这方面，B树表现相对优异，B树可以有多个子女，从几十到上千，可以降低树的高度。</p>
<hr>
<h3 id="共享内存与Socket的优缺点与性能比较"><a href="#共享内存与Socket的优缺点与性能比较" class="headerlink" title="共享内存与Socket的优缺点与性能比较"></a>共享内存与Socket的优缺点与性能比较</h3><p>要使用一块共享内存，进程必须首先分配它。随后需要访问这个共享内存块的每一个进程都必须将这个共享内存绑定到自己的地址空间中。当完成通信之后，所有进程都将脱离共享内存，并且由一个进程释放该共享内存块。理解 Linux 系统内存模型可以有助于解释这个绑定的过程。在 Linux 系统中，每个进程的虚拟内存是被分为许多页面的。这些内存页面中包含了实际的数据。每个进程都会维护一个从内存地址到虚拟内存页面之间的映射关系。尽管每个进程都有自己的内存地址，不同的进程可以同时将同一个内存页面映射到自己的地址空间中，从而达到共享内存的目的。分配一个新的共享内存块会创建新的内存页面。因为所有进程都希望共享对同一块内存的访问，只应由一个进程创建一块新的共享内存。再次分配一块已经存在的内存块不会创建新的页面，而只是会返回一个标识该内存块的标识符。一个进程如需使用这个共享内存块，则首先需要将它绑定到自己的地址空间中。这样会创建一个从进程本身虚拟地址到共享页面的映射关系。当对共享内存的使用结束之后，这个映射关系将被删除。当再也没有进程需要使用这个共享内存块的时候，必须有一个（且只能是一个）进程负责释放这个被共享的内存页面。</p>
<p>共享内存号称是最快的进程间通信方式，她在系统内存中开辟一块内存区，分别映射到各个进程的虚拟地址空间中，任何一个进程操作了内存区都会反映到其他进程中，各个进程之间的通信并没有像copy数据一样从内核到用户，再从用户到内核的拷贝。这种方式可以像访问自己的私有空间一样访问共享内存区，但是这事这种特性加大了共享内存的编程难度，对于数据的同步问题是一个难点，没有一定的经验很 容易造成数据的混乱。但是我们可以使用一个折中的方法，我们可以结合它和管道来使用。</p>
<p>这样就不会因为，多个进程同时鞋一块内存造成数据的混乱了，看起来是不是有点像管道，其实就是管道的机制，但是不同的是，她的速度要比管道快的多，他的数据大小没有限制（当然不能超过系统的内存大小），当然也不会有阻塞问题。但是这种方式也有明显的缺点，它只适合点对点的通信，如果要多个进程间通信，内存区的数量会呈线性增长，会造成数据的冗余，并且管理起来也会变得困难,如果你的进程数量在各位数着中方式是一个好的选择，否则就要采用一块共享内存，同时做好数据的同步了。</p>
<p>它是基于内存的，所以他只能在同一主机上使用，如果我们要做分布式应用或者跨物理机通信，那么socket就是我们唯一的选择了。</p>
<p>共享内存通信(SHARED MEMORY)<br>   针对消息缓冲需要占用CPU进行消息复制的缺点．OS提供了一种进程间直接进行数据交换的通信方式一共享内存 顾名思义．这种通信方式允许多个进程在外部通信协议或同步，互斥机制的支持下使用同一个内存段(作为中间介质)进行通信．它是一种最有效的数据通信方式，其特点是没有中间环节．直接将共享的内存页面通过附接．映射到相互通信的进程各自的虚拟地址空间中．从而使多个进程可以直接访问同一个物理内存页面．如同访问自己的私有空间一样(但实质上不是私有的而是共享的)。因此这种进程间通信方式是在同一个计算机系统中的诸进程间实现通信的最快捷的方法．而它的局限性也在于此．即共享内存的诸进程必须共处同一个计算机系统．有物理内存可以共享才行。</p>
<p>共享内存针对消息缓冲的缺点改而利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。但是共享内存的通信方式是通过将共享的内存缓冲区直接附加到进程的虚拟地址空间中来实现的．因此，这些进程之间的读写操作的同步问题操作系统无法实现。必须由各进程利用其他同步工具解决。另外，由于内存实体存在于计算机系统中．所以只能由处于同一个计算机系统中的诸进程共享。不方便网络通信。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="帧率，比特率，分辨率"><a href="#帧率，比特率，分辨率" class="headerlink" title="帧率，比特率，分辨率"></a>帧率，比特率，分辨率</h3><p><strong>帧速率</strong></p>
<p>帧速率也称为FPS(Frames PerSecond)的缩写——帧/秒。是指每秒钟刷新的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次。越高的帧速率可以得到更流畅、更逼真的动画。每秒钟帧数(FPS)越多，所显示的动作就会越流畅。</p>
<p><strong>比特率</strong></p>
<p>比特率是指每秒传送的比特(bit)数。单位为bps(Bit Per Second)，比特率越高，传送的数据越大。在视频领域,比特率常翻译为码率 !!!</p>
<p>比特率表示经过编码（压缩）后的音、视频数据每秒钟需要用多少个比特来表示，而比特就是二进制里面最小的单位，要么是0，要么是1。比特率与音、视频压缩的关系，简单的说就是比特率越高，音、视频的质量就越好，但编码后的文件就越大；如果比特率越少则情况刚好相反。</p>
<p>比特率是指将数字声音、视频由模拟格式转化成数字格式的采样率，采样率越高，还原后的音质、画质就越好。</p>
<p>常见编码模式：</p>
<p>VBR（Variable Bitrate）动态比特率 也就是没有固定的比特率，压缩软件在压缩时根据音频数据即时确定使用什么比特率，这是以质量为前提兼顾文件大小的方式，推荐编码模式；</p>
<p>ABR（Average Bitrate）平均比特率 是VBR的一种插值参数。LAME针对CBR不佳的文件体积比和VBR生成文件大小不定的特点独创了这种编码模式。ABR在指定的文件大小内，以每50帧（30帧约1秒）为一段，低频和不敏感频率使用相对低的流量，高频和大动态表现时使用高流量，可以做为VBR和CBR的一种折衷选择。</p>
<p>CBR（Constant Bitrate），常数比特率 指文件从头到尾都是一种位速率。相对于VBR和ABR来讲，它压缩出来的文件体积很大，而且音质相对于VBR和ABR不会有明显的提高。</p>
<p><strong>分辨率</strong> </p>
<p>就是帧大小每一帧就是一副图像。</p>
<p>720p对应的分辨率为像素1280*720=92w像素</p>
<p>1080p对应的分辨率为1920*1080=207w像素</p>
<p>640*480分辨率的视频，建议视频的码速率设置在700以上，音频采样率44100就行了</p>
<p>一个音频编码率为128Kbps，视频编码率为800Kbps的文件，其总编码率为928Kbps，意思是经过编码后的数据每秒钟需要用928K比特来表示。</p>
<p>计算输出文件大小公式：<br>（音频编码率（KBit为单位）/8 +视频编码率（KBit为单位）/8）×影片总长度（秒为单位）=文件大小（MB为单位）</p>
<p>电影一般是24帧的，24帧的视频就能满足人眼，然后大家墨守成规，同时为了音画同步，大家就都统一使用24帧的画面。即便是在数字时代，更高的帧数依然需要高昂的成本，24帧依然是主流。当然也有一些例外，如《霍比特人》使用了48帧技术，《比利林恩的中场故事》使用了120帧技术。更高的帧数会有什么效果呢？可以在b站就可以找到很多60帧视频。李安使用4K加取120 帧技术绝对是一项技术革命，从光源，到播放技术，到演员的表演，因为在这种清晰度下真的是毫发毕现，但是这也造成了一种电视剧感，因为我们理解的电影就因为是有一种距离感，一种old school的美学。为什么帧率越高越清晰呢？电影不是连续曝光，24帧是在一秒内拍摄了24张照片，但是不是说每一张照片的曝光时间就是1/24秒，曝光时间应该是1/48秒。曝光时间是通过叫做叶子板的半圆形装置进行的，通过改变开角就可以调整曝光时间，可以理解为快门。只要快门时间不为0，理论上就会造成残影。更高的帧率就代表了每一张照片的曝光时间更短，对比于30帧的视频，60帧的视频中每一幅画面的快门时间更短，造成的模糊效应更小，所以虽然分辨率没有改变，但是视频更加清晰。</p>
<p>电视剧等电视节目与电影除了美学方面的区别，还有很多技术方面的区别：电视的显像管的扫描方式是隔行扫描，而即便是胶片电影，其形成的数字中间片是逐行扫描的；在帧率方面，PAL和SECAM制式是25fps，在美国等一些国家使用的电视扫描频率是59.94Hz，帧率是29.97fps。</p>
<p>我国和大多数欧洲国家使用的交流电是50Hz，由于采用隔行扫描，在PAL或者SECAM视频标准中播放是25 frames per second(fps)，PAL标准中为电视节目录制的电影也是25 frames per second，所以对于每一个film frame，捕获得到一个video frame。但是对于最初以24frames/s拍摄的电影，在播放时要加快1/24来匹配，这样就会导致声音不同步，需要使用音高变换器进行校正。使用pulldown方法可以避免加速的过程。为了适应mismatch，需要将24电影帧分配在50个PAL fields中。</p>
<p>NTSC制下交流电频率信号是60Hz，而如果采用间隔扫描下，其实每秒是30张图片，就是30fps，为了把信号和载波区分开，频率降低千分之一，变成了29.97fps。而在电影上播放时，要变成24帧，问题是你不能随便删掉开头的6帧或者结尾的6帧，这样画面会变得很不连续，所以就想出一个方法，叫做2：3pulldown，硬是把5帧的内容缩成了4帧第一个电影帧显示两次，第二帧显示3次，第三帧又显示两次，按照这个规律循环，这样29.97*4/5就是23.976fps了。</p>
<p><strong>隔行扫描</strong></p>
<p>　　每一帧被分割为两场，每一场包含了一帧中所有的奇数扫描行或者偶数扫描行，通常是先扫描奇数行得到第一场，然后扫描偶数行得到第二场。</p>
<p>　　无论是逐行扫描还是隔行扫描，都有视频文件、传输和显像三个概念，这三个概念相通但不相同。最早出现的是隔行扫描显像，同时就配套产生了隔行传输。而隔行扫描视频文件是到数字视频时代才出现的，其目的是为了兼容原有的隔行扫描体系(隔行扫描还依然在广泛应用)。</p>
<p>　　通常显示器分“隔行扫描” 和 “逐行扫描”两种扫描方式。逐行扫描相对于隔行扫描是一种先进的扫描方式，它是指显示屏显示图像进行扫描时，从屏幕左上角的第一行开始逐行进行，整个图像扫描一次完成。因此图像显示画面闪烁小，显示效果好。先进的显示器大都采用逐行扫描方式。</p>
<p>　　隔行扫描情况下，由于视觉暂留效应，人眼将会看到平滑的运动而不是闪动的半帧半帧的图像。但是这种方法造成了两幅图像显示的时间间隔比较大，从而导致图像画面闪烁较大。 因此该种扫描方式较为落后，通常用在早期的显示产品中。</p>
<p>每一帧图像由电子束顺序地一行接着一行连续扫描而成，这种扫描方式称为逐行扫描。把每一帧图像通过两场扫描完成则是隔行扫描，两场扫描中，第一场(奇数场)只扫描奇数行，依次扫描1、3、5…行，而第二场(偶数场)只扫描偶数行，依次扫描2、4、6…行。隔行扫描技术在传送信号带宽不够的情况下起了很大作用，逐行扫描和隔行扫描的显示效果主要区别在稳定性上面，隔行扫描的行间闪烁比较明显，逐行扫描克服了隔行扫描的缺点，画面平滑自然无闪烁。</p>
<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>零钱兑换</title>
    <url>/2020/03/13/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<p>来自Leetcode第322题零钱兑换</p>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。<br><a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>从面额最大的货币开始找零，并遍历完当前硬币数组，当剩余金额为0时返回上层搜索，当目前已用总数大于已知最小硬币数时也返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] coin;</span><br><span class="line">    <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line">        <span class="keyword">this</span>.coin = coins;</span><br><span class="line">        dfs(coin.length-<span class="number">1</span>,amount,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> amount,<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> rest,tmp_count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = amount /coin[index];i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            rest = amount - i * coin[index];</span><br><span class="line">            tmp_count = count + i;</span><br><span class="line">            <span class="keyword">if</span>(rest == <span class="number">0</span>)&#123;</span><br><span class="line">                ans = Math.min(ans,tmp_count);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp_count + <span class="number">1</span> &gt;= ans)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            dfs(index-<span class="number">1</span>,rest,tmp_count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>来自<a href="https://leetcode-cn.com/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>
<p>仍定义 F(i) 为组成金额 <em>i</em> 所需最少的硬币数量，假设在计算 <em>F</em>(<em>i</em>) 之前，我们已经计算出 <em>F</em>(0)−<em>F</em>(<em>i</em>−1) 的答案。 则 <em>F</em>(<em>i</em>) 对应的转移方程应为</p>
<script type="math/tex; mode=display">
F(i)=\min_{j=0 \ldots n-1}{F(i -c_j)} + 1</script><p>其中 $c_j$代表的是第 <em>j</em> 枚硬币的面值，即我们枚举最后一枚硬币面额是 $c_j$，那么需要从 $i-c_j$ 这个金额的状态 $F(i-c_j)$转移过来，再算上枚举的这枚硬币数量 1 的贡献，由于要硬币数量最少，所以 $F(i$)为前面能转移过来的状态的最小值加上枚举的硬币数量 1 。</p>
<p>例子1：假设</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>则，当 $i==0$ 时无法用硬币组成，为 0 。当 $i&lt;0$时，忽略 $F(i)$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>F(i)</th>
<th>最小硬币数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>F(0)</td>
<td>0 //金额为0不能由硬币组成</td>
</tr>
<tr>
<td>F(1)</td>
<td>1 //$F(1)=min(F(1-1),F(1-2),F(1-5))+1=1$</td>
</tr>
<tr>
<td>F(2)</td>
<td>1 //$F(2)=min(F(2-1),F(2-2),F(2-5))+1=1$</td>
</tr>
<tr>
<td>F(3)</td>
<td>2 //$F(3)=min(F(3-1),F(3-2),F(3-5))+1=2$</td>
</tr>
<tr>
<td>F(4)</td>
<td>2 /$/F(4)=min(F(4-1),F(4-2),F(4-5))+1=2$</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>F(11)</td>
<td>3 //$F(11)=min(F(11-1),F(11-2),F(11-5))+1=3$</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = amount + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, max);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">          dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串最大公因子</title>
    <url>/2020/03/13/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/</url>
    <content><![CDATA[<p>来自Leetcode第1071题字符串最大公因子</p>
<p>对于字符串 <code>S</code> 和 <code>T</code>，只有在 <code>S = T + ... + T</code>（<code>T</code> 与自身连接 1 次或多次）时，我们才认定 “<code>T</code> 能除尽 <code>S</code>”。</p>
<p>返回最长字符串 <code>X</code>，要求满足 <code>X</code> 能除尽 <code>str1</code> 且 <code>X</code> 能除尽 <code>str2</code>。<br><a id="more"></a></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">输入：<span class="keyword">str1 </span>= <span class="string">"ABCABC"</span>, <span class="keyword">str2 </span>= <span class="string">"ABC"</span></span><br><span class="line">输出：<span class="string">"ABC"</span></span><br></pre></td></tr></table></figure>
<h3 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h3><p>如果它们有公因子 <code>abc</code>，那么 <code>str1</code> 就是 <em>m</em> 个 <code>abc</code> 的重复，<code>str2</code> 是 <em>n</em> 个 <code>abc</code> 的重复，连起来就是 <em>m</em>+<em>n</em> 个 <code>abc</code>，好像 <em>m</em>+<em>n</em> 个 <code>abc</code> 跟 <em>n</em>+<em>m</em> 个 <code>abc</code> 是一样的。</p>
<p>所以如果 <code>str1 + str2 === str2 + str1</code> 就意味着有解。</p>
<p>我们也很容易想到 <code>str1 + str2 !== str2 + str1</code> 也是无解的<strong>充要条件</strong>。</p>
<p>当确定有解的情况下，最优解是长度为 <code>gcd(str1.length, str2.length)</code> 的字符串。</p>
<pre><code class="lang-JAVA">    public String gcdOfStrings(String str1, String str2) {
        // 假设str1是N个x，str2是M个x，那么str1+str2肯定是等于str2+str1的。
        if (!(str1 + str2).equals(str2 + str1)) {
            return &quot;&quot;;
        }
        // 辗转相除法求gcd。
        return str1.substring(0, gcd(str1.length(), str2.length()));
    }

    private int gcd(int a, int b) {
        return b == 0? a: gcd(b, a % b);
    }
</code></pre>
<p>迭代形式的gdc</p>
<pre><code class="lang-JAVA">private int gcd(int a, int b){
       while(b != 0){
           int tmp = b;
           b = a%b;
           a = tmp;
       }
       return a;
   }
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>和为s的连续整数序列</title>
    <url>/2020/03/08/%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>来自Leetcode面试题57-II 和为s的连续整数序列</p>
<p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。<br><a id="more"></a><br><strong>示例 1：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：target = <span class="number">9</span></span><br><span class="line">输出：[[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><ul>
<li>当窗口的和小于 <code>target</code> 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动</li>
<li>当窗口的和大于 <code>target</code> 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动</li>
<li>当窗口的和恰好等于 <code>target</code> 的时候，我们需要记录此时的结果。设此时的窗口为 [i, j)，那么我们已经找到了一个 i 开头的序列，也是唯一一个 i 开头的序列，接下来需要找 i+1开头的序列，所以窗口的左边界要向右移动</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>; <span class="comment">// 滑动窗口的左边界</span></span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">1</span>; <span class="comment">// 滑动窗口的右边界</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 滑动窗口中数字的和</span></span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= target / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 右边界向右移动</span></span><br><span class="line">            sum += right;</span><br><span class="line">            right++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 左边界向右移动</span></span><br><span class="line">            sum -= left;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 记录结果</span></span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[right-left];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt; right; k++) &#123;</span><br><span class="line">                arr[k-left] = k;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(arr);</span><br><span class="line">            <span class="comment">// 左边界向右移动</span></span><br><span class="line">            sum -= left;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>分糖果II</title>
    <url>/2020/03/08/%E5%88%86%E7%B3%96%E6%9E%9C/</url>
    <content><![CDATA[<p>来自Leetcode第1103题分糖果II</p>
<p>排排坐，分糖果。</p>
<p>我们买了一些糖果 <code>candies</code>，打算把它们分给排好队的 <strong><code>n = num_people</code></strong> 个小朋友。</p>
<p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 <code>n</code> 颗糖果。</p>
<p>然后，我们再回到队伍的起点，给第一个小朋友 <code>n + 1</code> 颗糖果，第二个小朋友 <code>n + 2</code> 颗，依此类推，直到给最后一个小朋友 <code>2 * n</code> 颗糖果。</p>
<p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p>
<p>返回一个长度为 <code>num_people</code>、元素之和为 <code>candies</code> 的数组，以表示糖果的最终分发情况（即 <code>ans[i]</code> 表示第 <code>i</code> 个小朋友分到的糖果数）。<br><a id="more"></a></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：candies = <span class="number">7</span>, num_people = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">解释：</span><br><span class="line">第一次，ans[<span class="number">0</span>] += <span class="number">1</span>，数组变为 [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]。</span><br><span class="line">第二次，ans[<span class="number">1</span>] += <span class="number">2</span>，数组变为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]。</span><br><span class="line">第三次，ans[<span class="number">2</span>] += <span class="number">3</span>，数组变为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>]。</span><br><span class="line">第四次，ans[<span class="number">3</span>] += <span class="number">1</span>（因为此时只剩下 <span class="number">1</span> 颗糖果），最终数组变为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>不断地遍历数组，如果还有糖就一直分，直到没有糖为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] distributeCandies(<span class="keyword">int</span> candies, <span class="keyword">int</span> num_people) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[num_people];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (candies != <span class="number">0</span>) &#123;</span><br><span class="line">        ans[i % num_people] += Math.min(candies, i + <span class="number">1</span>);</span><br><span class="line">        candies -= Math.min(candies, i + <span class="number">1</span>);</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h3><p>来自<a href="https://leetcode-cn.com/problems/distribute-candies-to-people/solution/xiang-xi-jie-shi-shu-xue-fang-fa-zen-yao-zuo-gao-z/" target="_blank" rel="noopener">题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] distributeCandies(<span class="keyword">int</span> candies, <span class="keyword">int</span> num_people) &#123;</span><br><span class="line">  <span class="keyword">int</span> n = num_people;</span><br><span class="line">  <span class="comment">// how many people received complete gifts</span></span><br><span class="line">  <span class="keyword">int</span> p = (<span class="keyword">int</span>)(Math.sqrt(<span class="number">2</span> * candies + <span class="number">0.25</span>) - <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">int</span> remaining = (<span class="keyword">int</span>)(candies - (p + <span class="number">1</span>) * p * <span class="number">0.5</span>);</span><br><span class="line">  <span class="keyword">int</span> rows = p / n, cols = p % n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// complete rows</span></span><br><span class="line">    d[i] = (i + <span class="number">1</span>) * rows + (<span class="keyword">int</span>)(rows * (rows - <span class="number">1</span>) * <span class="number">0.5</span>) * n;</span><br><span class="line">    <span class="comment">// cols in the last row</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; cols) d[i] += i + <span class="number">1</span> + rows * n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// remaining candies        </span></span><br><span class="line">  d[cols] += remaining;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>腐烂的橘子</title>
    <url>/2020/03/08/%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</url>
    <content><![CDATA[<p>来自Leetcode第994题腐烂的橘子</p>
<p>在给定的网格中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 <code>0</code> 代表空单元格；</li>
<li>值 <code>1</code> 代表新鲜橘子；</li>
<li>值 <code>2</code> 代表腐烂的橘子。</li>
</ul>
<p>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p>
<p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code>。<br><a id="more"></a></p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="/2020/03/08/腐烂的橘子/oranges.png" alt="img"></strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="BFS-I"><a href="#BFS-I" class="headerlink" title="BFS I"></a>BFS I</h3><p>来自<a href="https://leetcode-cn.com/problems/rotting-oranges/solution/fu-lan-de-ju-zi-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>
<p>观察到对于所有的腐烂橘子，其实它们<strong>在广度优先搜索上是等价于同一层的节点的</strong>。</p>
<p>假设这些腐烂橘子刚开始是新鲜的，而有一个腐烂橘子(<strong>我们令其为超级源点</strong>)会在下一秒把这些橘子都变腐烂，而这个腐烂橘子刚开始在的时间是 -1−1 ，那么按照广度优先搜索的算法，下一分钟也就是第 00 分钟的时候，这个腐烂橘子会把它们都变成腐烂橘子，然后继续向外拓展，所以其实这些腐烂橘子是同一层的节点。那么在广度优先搜索的时候，我们将这些腐烂橘子都放进队列里进行广度优先搜索即可，最后每个新鲜橘子被腐烂的最短时间 dis[x][y]<em>d<strong>i</strong>s</em>[<em>x</em>][<em>y</em>] 其实是以这个超级源点的腐烂橘子为起点的广度优先搜索得到的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dr,dc 配合使用得到 grid[r][c] 上grid[r-1][c]左grid[r][c-1]下grid[r+1][c]右grid[r][c+1]的元素</span></span><br><span class="line">        <span class="keyword">int</span>[] dr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dc = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 获取二维数组的行数row 和 列数 column</span></span><br><span class="line">            <span class="keyword">int</span> R = grid.length, C = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// queue : all starting cells with rotten oranges</span></span><br><span class="line">            Queue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayDeque();</span><br><span class="line">            Map&lt;Integer, Integer&gt; depth = <span class="keyword">new</span> HashMap();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; ++r)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; ++c)</span><br><span class="line">                    <span class="keyword">if</span> (grid[r][c] == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> code = r * C + c;  <span class="comment">// 转化为索引唯一的一维数组</span></span><br><span class="line">                        queue.add(code); <span class="comment">//存储腐烂橘子</span></span><br><span class="line">                        depth.put(code, <span class="number">0</span>); <span class="comment">//存储橘子变为腐烂时的时间,key为橘子的一维数组下标，value为变腐烂的时间</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">int</span> code = queue.remove();</span><br><span class="line">                <span class="keyword">int</span> r = code / C, c = code % C;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nr = r + dr[k];</span><br><span class="line">                    <span class="keyword">int</span> nc = c + dc[k];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &lt;= nr &amp;&amp; nr &lt; R &amp;&amp; <span class="number">0</span> &lt;= nc &amp;&amp; nc &lt; C &amp;&amp; grid[nr][nc] == <span class="number">1</span>) &#123;</span><br><span class="line">                        grid[nr][nc] = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">int</span> ncode = nr * C + nc;</span><br><span class="line">                        queue.add(ncode);</span><br><span class="line">                        <span class="comment">// 计次的关键 元素 grid[r][c] 的上左下右元素得腐烂时间应该一致</span></span><br><span class="line">                        depth.put(ncode, depth.get(code) + <span class="number">1</span>);</span><br><span class="line">                        ans = depth.get(ncode);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//检查grid，此时的grid能被感染已经都腐烂了，此时还新鲜的橘子无法被感染</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] row: grid)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> v: row)</span><br><span class="line">                    <span class="keyword">if</span> (v == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="BFS-II"><a href="#BFS-II" class="headerlink" title="BFS II"></a>BFS II</h3><p>首先遍历一遍数组，将腐烂橘子入队列，新鲜橘子计数；接下来开始计时，从-1时刻开始遍历队列，将腐烂橘子出队，判断周围是否会有新鲜的橘子，如果有就入队，并且计时+1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>)</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    e++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty() &amp;&amp; e &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty() &amp;&amp; e == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dis = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span>[] p = queue.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = p[<span class="number">0</span>] + dis[i][<span class="number">0</span>], ny = p[<span class="number">1</span>] + dis[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (check(grid, nx, ny)) &#123;</span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nx, ny&#125;);</span><br><span class="line">                        grid[nx][ny] = <span class="number">2</span>;</span><br><span class="line">                        e--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e == <span class="number">0</span> ? count : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x &lt; grid.length &amp;&amp; x &gt;= <span class="number">0</span> &amp;&amp; y &lt; grid[<span class="number">0</span>].length &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; grid[x][y] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索二维矩阵II</title>
    <url>/2020/03/03/%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II/</url>
    <content><![CDATA[<p>来自Leetcode第240题搜索二维矩阵II</p>
<p>编写一个高效的算法来搜索 <em>m</em> x <em>n</em> 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。<a id="more"></a>
<strong>示例:</strong></li>
</ul>
<p>现有矩阵 matrix 如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">4</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],</span><br><span class="line">  [<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>],</span><br><span class="line">  [<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>],</span><br><span class="line">  [<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>给定 target = <code>5</code>，返回 <code>true</code>。</p>
<p>给定 target = <code>20</code>，返回 <code>false</code>。</p>
<hr>
<h3 id="左下-右上遍历"><a href="#左下-右上遍历" class="headerlink" title="左下/右上遍历"></a>左下/右上遍历</h3><p>数组从左到右和从上到下都是升序的，如果从右上角出发开始遍历呢？</p>
<p>会发现每次都是向左数字会变小，向下数字会变大，有点和二分查找树相似。二分查找树的话，是向左数字变小，向右数字变大。</p>
<p>所以我们可以把 <code>target</code> 和当前值比较。</p>
<ul>
<li>如果 <code>target</code> 的值大于当前值，那么就向下走。</li>
<li>如果 <code>target</code> 的值小于当前值，那么就向左走。</li>
<li>如果相等的话，直接返回 <code>true</code> 。</li>
</ul>
<p>也可以换个角度思考。</p>
<p>如果 <code>target</code> 的值小于当前值，也就意味着当前值所在的列肯定不会存在 <code>target</code> 了，可以把当前列去掉，从新的右上角的值开始遍历。</p>
<p>同理，如果 <code>target</code> 的值大于当前值，也就意味着当前值所在的行肯定不会存在 <code>target</code> 了，可以把当前行去掉，从新的右上角的值开始遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//从右上角开始，比较target与右上角的数据的大小，如果大于target，就可以往左进一列，如果小于target，就可以往下走一行</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;m &amp;&amp; j&gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] &gt; target)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历二分"><a href="#遍历二分" class="headerlink" title="遍历二分"></a>遍历二分</h3><p>对每一行都做一次二分查找，<a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-5-4/" target="_blank" rel="noopener">来自</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][matrix[i].length - <span class="number">1</span>] &lt; target)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> col = binarySearch(matrix[i], target);</span><br><span class="line">        <span class="keyword">if</span> (col != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树最近的公共祖先</title>
    <url>/2020/03/03/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E8%BF%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<p>来自Leetcode第235题二叉搜索树最近的公共祖先</p>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin" target="_blank" rel="noopener">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”<br><a id="more"></a><br>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="/2020/03/03/二叉搜索树最近的公共祖先/binarysearchtree_improved.png" alt="img"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: root = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">5</span>], p = <span class="number">2</span>, q = <span class="number">8</span></span><br><span class="line">输出: <span class="number">6</span> </span><br><span class="line">解释: 节点 <span class="number">2</span> 和节点 <span class="number">8</span> 的最近公共祖先是 <span class="number">6</span>。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ol>
<li>从根节点开始遍历树</li>
<li>如果节点 p<em>p</em> 和节点 q<em>q</em> 都在右子树上，那么以右孩子为根节点继续 1 的操作</li>
<li>如果节点 p<em>p</em> 和节点 q<em>q</em> 都在左子树上，那么以左孩子为根节点继续 1 的操作</li>
<li>如果条件 2 和条件 3 都不成立，这就意味着我们已经找到节 p<em>p</em> 和节点 q<em>q</em> 的 LCA 了</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pval = p.val;</span><br><span class="line">    <span class="keyword">int</span> qval = q.val;</span><br><span class="line">    <span class="keyword">int</span> rval = root.val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pval &gt; rval &amp;&amp; qval &gt; rval)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pval &lt; rval &amp;&amp; qval &lt; rval)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>思路同上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pval = p.val;</span><br><span class="line">    <span class="keyword">int</span> qval = q.val;</span><br><span class="line">    <span class="keyword">int</span> rval = root.val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        rval = root.val;</span><br><span class="line">        <span class="keyword">if</span> (pval &gt; rval &amp;&amp; qval &gt; rval)</span><br><span class="line">            <span class="comment">//return lowestCommonAncestor(root.right, p, q);</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pval &lt; rval &amp;&amp; qval &lt; rval)</span><br><span class="line">            <span class="comment">//return lowestCommonAncestor(root.left, p, q);</span></span><br><span class="line">            root = root.left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树最近的公共祖先</title>
    <url>/2020/03/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E8%BF%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<p>来自Leetcode第236题二叉树最近的公共祖先</p>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin" target="_blank" rel="noopener">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”<br><a id="more"></a><br>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="/2020/03/02/二叉树最近的公共祖先/binarytree.png" alt="img"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: root = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">4</span>], p = <span class="number">5</span>, q = <span class="number">1</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 节点 <span class="number">5</span> 和节点 <span class="number">1</span> 的最近公共祖先是节点 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul>
<li>在左、右子树中分别查找是否包含p或q：</li>
<li>如果以下两种情况（左子树包含p，右子树包含q/左子树包含q，右子树包含p），<strong>那么此时的根节点就是最近公共祖先</strong></li>
<li>如果左子树包含p和q，那么到root-&gt;left中继续查找，最近公共祖先在左子树里面</li>
<li>如果右子树包含p和q，那么到root-&gt;right中继续查找，最近公共祖先在右子树里面</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q)</span><br><span class="line">         <span class="keyword">return</span> root;</span><br><span class="line">     TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">     TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">     <span class="keyword">if</span>(left == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> right;</span><br><span class="line">     <span class="keyword">if</span>(right == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> left;</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>来自<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetcod/" target="_blank" rel="noopener">官方题解</a>的解答</p>
<p>先深度遍历改树。当你遇到节点 <code>p</code> 或 <code>q</code> 时，返回一些布尔标记。该标志有助于确定是否在任何路径中找到了所需的节点。最不常见的祖先将是两个子树递归都返回真标志的节点。它也可以是一个节点，它本身是<code>p</code>或<code>q</code>中的一个，对于这个节点,子树递归返回一个真标志。</p>
<p><strong>算法：</strong></p>
<ol>
<li>从根节点开始遍历树。</li>
<li>如果当前节点本身是 <code>p</code> 或 <code>q</code> 中的一个，我们会将变量 <code>mid</code> 标记为 <code>true</code>，并继续搜索左右分支中的另一个节点。</li>
<li>如果左分支或右分支中的任何一个返回 <code>true</code>，则表示在下面找到了两个节点中的一个。</li>
<li>如果在遍历的任何点上，左、右或中三个标志中的任意两个变为 <code>true</code>，这意味着我们找到了节点 <code>p</code> 和 <code>q</code> 的最近公共祖先。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Variable to store LCA node.</span></span><br><span class="line">        <span class="keyword">this</span>.ans = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recurseTree</span><span class="params">(TreeNode currentNode, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If reached the end of a branch, return false.</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Left Recursion. If left recursion returns true, set left = 1 else 0</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="keyword">this</span>.recurseTree(currentNode.left, p, q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Right Recursion</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="keyword">this</span>.recurseTree(currentNode.right, p, q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the current node is one of p or q</span></span><br><span class="line">        <span class="keyword">int</span> mid = (currentNode == p || currentNode == q) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If any two of the flags left, right or mid become True</span></span><br><span class="line">        <span class="keyword">if</span> (mid + left + right &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.ans = currentNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return true if any one of the three bool values is True.</span></span><br><span class="line">        <span class="keyword">return</span> (mid + left + right &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Traverse the tree</span></span><br><span class="line">        <span class="keyword">this</span>.recurseTree(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用父指针迭代"><a href="#使用父指针迭代" class="headerlink" title="使用父指针迭代"></a>使用父指针迭代</h3><p>还是来自官方题解</p>
<p>如果每个节点都有父指针，那么我们可以从 <code>p</code> 和 <code>q</code> 返回以获取它们的祖先。在这个遍历过程中，我们得到的第一个公共节点是 LCA 节点。我们可以在遍历树时将父指针保存在字典中。</p>
<p><strong>算法：</strong></p>
<ol>
<li>从根节点开始遍历树。</li>
<li>在找到 <code>p</code> 和 <code>q</code> 之前，将父指针存储在字典中。</li>
<li>一旦我们找到了 <code>p</code> 和 <code>q</code>，我们就可以使用父亲字典获得 <code>p</code> 的所有祖先，并添加到一个称为祖先的集合中。</li>
<li>同样，我们遍历节点 <code>q</code> 的祖先。如果祖先存在于为 <code>p</code> 设置的祖先中，这意味着这是 <code>p</code> 和 <code>q</code> 之间的第一个共同祖先（同时向上遍历），因此这是 LCA 节点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    HashMap&lt;TreeNode, TreeNode&gt; parent = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    parent.put(root, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//将遍历过程中每个节点的父节点保存起来</span></span><br><span class="line">    <span class="keyword">while</span> (!parent.containsKey(p) || !parent.containsKey(q)) &#123;</span><br><span class="line">        TreeNode cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur.left);</span><br><span class="line">            parent.put(cur.left, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur.right);</span><br><span class="line">            parent.put(cur.right, cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    HashSet&lt;TreeNode&gt; path = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 倒着还原 p 的路径，并将每个节点加入到 set 中</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        path.add(p);</span><br><span class="line">        p = parent.get(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倒着遍历 q 的路径，判断是否在 p 的路径中</span></span><br><span class="line">    <span class="keyword">while</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.contains(q)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q = parent.get(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>组合综合III</title>
    <url>/2020/03/01/%E7%BB%84%E5%90%88%E7%BB%BC%E5%90%88III/</url>
    <content><![CDATA[<p>来源Leetcode第216题组合综合III</p>
<p>找出所有相加之和为 <strong><em>n</em></strong> 的 <strong><em>k\</em></strong> 个数的组合<strong><em>。\</em></strong>组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p><strong>说明：</strong></p>
<ul>
<li><p>所有数字都是正整数。</p>
</li>
<li><p>解集不能包含重复的组合。</p>
<a id="more"></a>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: k = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">//List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();</span></span><br><span class="line">    backtrack(<span class="number">1</span>,n,k,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> target ,<span class="keyword">int</span> k,List&lt;Integer&gt; tmp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp.size() &gt; k || target &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; tmp.size() == k) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; start)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        tmp.add(i);</span><br><span class="line">        backtrack(i+<span class="number">1</span>,target-i,k,tmp);</span><br><span class="line">        tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>完全二叉树的结点个数</title>
    <url>/2020/03/01/%E2%80%9C%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0%E2%80%9D/</url>
    <content><![CDATA[<p>来源Leetcode第222题完全二叉树的结点个数</p>
<p>给出一个<strong>完全二叉树</strong>，求出该树的节点个数。</p>
<p><strong>说明：</strong></p>
<p><a href="https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin" target="_blank" rel="noopener">完全二叉树</a>的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。<br><a id="more"></a><br><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> / \  /</span><br><span class="line"><span class="number">4</span>  <span class="number">5</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">6</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>最简单的递归遍历完所有结点，返回所有结点数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用定义"><a href="#利用定义" class="headerlink" title="利用定义"></a>利用定义</h3><p><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/solution/chang-gui-jie-fa-he-ji-bai-100de-javajie-fa-by-xia/" target="_blank" rel="noopener">来源</a></p>
<p>首先需要明确完全二叉树的定义：<strong>它是一棵空树或者它的叶子节点只出在最后两层，若最后一层不满则叶子节点只在最左侧。</strong></p>
<p>再来回顾一下满二叉的节点个数怎么计算，如果满二叉树的层数为h，则总节点数为：2^h - 1.<br>那么我们来对root节点的左右子树进行高度统计，分别记为left和right,有以下两种结果：</p>
<ol>
<li>left == right。这说明，左子树一定是满二叉树，因为节点已经填充到右子树了，左子树必定已经填满了。所以左子树的节点总数我们可以直接得到，是2^left - 1，加上当前这个root节点，则正好是2^left。再对右子树进行递归统计。</li>
<li>left != right。说明此时最后一层不满，但倒数第二层已经满了，可以直接得到右子树的节点个数。同理，右子树节点+root节点，总数为2^right。再对左子树进行递归查找。</li>
</ol>
<p>关于如何计算二叉树的层数，可以利用下面的递归来算，当然对于完全二叉树，可以利用其特点，不用递归直接算，具体请参考最后的完整代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> left = countLevel(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = countLevel(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> countNodes(root.right) + (<span class="number">1</span>&lt;&lt;left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> countNodes(root.left) + (<span class="number">1</span>&lt;&lt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countLevel</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            level++;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>填充每个结点的下一个右侧节点</title>
    <url>/2020/02/28/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>来源Leetcode第116题填充每个结点的下一个右侧节点</p>
<p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">struct <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">  int</span> val;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*left</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*right</span>;</span><br><span class="line">  <span class="keyword">Node</span> <span class="title">*next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。<br><a id="more"></a></p>
<p><strong>示例：</strong></p>
<p><img src="/2020/02/28/填充每个结点的下一个右侧节点/116_sample.png" alt="img"></p>
<p><strong>提示：</strong></p>
<ul>
<li>你只能使用常量级额外空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
</ul>
<hr>
<h3 id="常规BFS"><a href="#常规BFS" class="headerlink" title="常规BFS"></a>常规BFS</h3><p>创建一个队列，按层序遍历实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        Node tmp;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            size = queue.size();</span><br><span class="line">            tmp = queue.peek();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size ; ++i)&#123;  <span class="comment">//串联队列里的结点</span></span><br><span class="line">                tmp.next = queue.get(i);</span><br><span class="line">                tmp = queue.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; ++i)&#123;</span><br><span class="line">                tmp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(tmp.left);</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(tmp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用已有的next结点"><a href="#利用已有的next结点" class="headerlink" title="利用已有的next结点"></a>利用已有的next结点</h3><p>如果不为一层的尾结点，那么其<code>next</code>指针只想的就是根节点的右孩子，或者更结点兄弟的右孩子，根节点的兄弟在上一轮递归中已经用<code>root.next</code>实现了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        root.left.next = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        root.right.next = root.next == <span class="keyword">null</span> ? <span class="keyword">null</span> : root.next.left;</span><br><span class="line">    &#125;</span><br><span class="line">    connect(root.left);</span><br><span class="line">    connect(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>宽度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>有序链表转化二叉搜索树</title>
    <url>/2020/02/27/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E5%8C%96%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p>来源Leetcode第109题有序链表转化二叉搜索树</p>
<p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。<br><a id="more"></a><br><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">给定的有序链表： [<span class="number">-10</span>, <span class="number">-3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[<span class="number">0</span>, <span class="number">-3</span>, <span class="number">9</span>, <span class="number">-10</span>, <span class="literal">null</span>, <span class="number">5</span>], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      <span class="number">0</span></span><br><span class="line">     / \</span><br><span class="line">   <span class="number">-3</span>   <span class="number">9</span></span><br><span class="line">   /   /</span><br><span class="line"> <span class="number">-10</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="链表转数组"><a href="#链表转数组" class="headerlink" title="链表转数组"></a>链表转数组</h3><p>将链表转化成数组，在套用第108题的代码即可，注意在<code>Arrays.copyOfRange()</code>方法中，复制的区间是左闭又开，即[left,right)，所以右侧区间要+1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(Integer[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = nums.length / <span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    <span class="keyword">if</span>(mid &gt; <span class="number">0</span>)</span><br><span class="line">        root.left = sortedArrayToBST(Arrays.copyOfRange(nums,<span class="number">0</span>,mid));</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; nums.length - <span class="number">1</span>)</span><br><span class="line">    root.right = sortedArrayToBST(Arrays.copyOfRange(nums,mid + <span class="number">1</span>,nums.length));</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; num = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        num.add(head.val);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println();</span></span><br><span class="line">    Integer[] nums = num.toArray(<span class="keyword">new</span> Integer[num.size()]);</span><br><span class="line">    <span class="keyword">return</span> sortedArrayToBST(nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.<span class="keyword"> public</span> class <span class="class">ListNode &#123; int val;</span> <span class="class">ListNode next;</span> ListNode(int</span><br><span class="line"> * x) &#123; val = x; &#125; &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.<span class="keyword"> public</span> class TreeNode &#123;<span class="built_in"> int </span>val; TreeNode left; TreeNode</span><br><span class="line"> * right; TreeNode(int x) &#123; val = x; &#125; &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword"> private</span> <span class="class">List&lt;Integer&gt; values;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword"> public</span> Solution() &#123;</span><br><span class="line">    this.values =<span class="built_in"> new </span>ArrayList&lt;Integer&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword"> private</span> void mapListToValues(ListNode head) &#123;</span><br><span class="line">    while (head != null) &#123;</span><br><span class="line">      this.values.add(head.val);</span><br><span class="line">      head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword"> private</span> TreeNode convertListToBST(int left,<span class="built_in"> int </span>right) &#123;</span><br><span class="line">    // Invalid case</span><br><span class="line">   <span class="built_in"> if </span>(left &gt; right) &#123;</span><br><span class="line">     <span class="built_in"> return </span>null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Middle element forms the root.</span><br><span class="line">   <span class="built_in"> int </span>mid = (left + right) / 2;</span><br><span class="line">    TreeNode node =<span class="built_in"> new </span>TreeNode(this.values.get(mid));</span><br><span class="line"></span><br><span class="line">    // Base case for when there is only one element left in the array</span><br><span class="line">   <span class="built_in"> if </span>(left == right) &#123;</span><br><span class="line">     <span class="built_in"> return </span>node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Recursively form BST on the two halves</span><br><span class="line">    node.left = convertListToBST(left, mid - 1);</span><br><span class="line">    node.right = convertListToBST(mid + 1, right);</span><br><span class="line">   <span class="built_in"> return </span>node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword"> public</span> TreeNode sortedListToBST(ListNode head) &#123;</span><br><span class="line"></span><br><span class="line">    // Form an<span class="built_in"> array </span>out of the given linked list<span class="built_in"> and </span>then</span><br><span class="line">    // use the<span class="built_in"> array </span>to form the BST.</span><br><span class="line">    this.mapListToValues(head);</span><br><span class="line"></span><br><span class="line">    // Convert the<span class="built_in"> array </span>to</span><br><span class="line">   <span class="built_in"> return </span>convertListToBST(0, this.values.size() - 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>来源<a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-by-/" target="_blank" rel="noopener">题解</a></p>
<ol>
<li>由于我们得到的是一个有序链表而不是数组，我们不能直接使用下标来访问元素。我们需要知道链表中的中间元素。</li>
<li>我们可以利用两个指针来访问链表中的中间元素。假设我们有两个指针 <code>slow_ptr</code> 和 <code>fast_ptr</code>。<code>slow_ptr</code> 每次向后移动一个节点而 <code>fast_ptr</code> 每次移动两个节点。当 <code>fast_ptr</code> 到链表的末尾时 <code>slow_ptr</code> 就访问到链表的中间元素。对于一个偶数长度的数组，中间两个元素都可用来作二叉搜索树的根。</li>
<li>当找到链表中的中间元素后，我们将链表从中间元素的左侧断开，做法是使用一个 <code>prev_ptr</code> 的指针记录 <code>slow_ptr</code> 之前的元素，也就是满足 <code>prev_ptr.next</code> = <code>slow_ptr</code>。断开左侧部分就是让 <code>prev_ptr.next = None</code>。</li>
<li>我们只需要将链表的头指针传递给转换函数，进行高度平衡二叉搜索树的转换。所以递归调用的时候，左半部分我们传递原始的头指针；右半部分传递 <code>slow_ptr.next</code> 作为头指针。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list. public class ListNode &#123; int val; ListNode next; ListNode(int</span></span><br><span class="line"><span class="comment"> * x) &#123; val = x; &#125; &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node. public class TreeNode &#123; int val; TreeNode left; TreeNode</span></span><br><span class="line"><span class="comment"> * right; TreeNode(int x) &#123; val = x; &#125; &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ListNode <span class="title">findMiddleElement</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The pointer used to disconnect the left half from the mid node.</span></span><br><span class="line">    ListNode prevPtr = <span class="keyword">null</span>;</span><br><span class="line">    ListNode slowPtr = head;</span><br><span class="line">    ListNode fastPtr = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate until fastPr doesn't reach the end of the linked list.</span></span><br><span class="line">    <span class="keyword">while</span> (fastPtr != <span class="keyword">null</span> &amp;&amp; fastPtr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      prevPtr = slowPtr;</span><br><span class="line">      slowPtr = slowPtr.next;</span><br><span class="line">      fastPtr = fastPtr.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handling the case when slowPtr was equal to head.</span></span><br><span class="line">    <span class="keyword">if</span> (prevPtr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      prevPtr.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slowPtr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the head doesn't exist, then the linked list is empty</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the middle element for the list.</span></span><br><span class="line">    ListNode mid = <span class="keyword">this</span>.findMiddleElement(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The mid becomes the root of the BST.</span></span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(mid.val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Base case when there is just one element in the linked list</span></span><br><span class="line">    <span class="keyword">if</span> (head == mid) &#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively form balanced BSTs using the left and right halves of the original list.</span></span><br><span class="line">    node.left = <span class="keyword">this</span>.sortedListToBST(head);</span><br><span class="line">    node.right = <span class="keyword">this</span>.sortedListToBST(mid.next);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p>来自范例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ListNode head;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findSize</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode ptr = head;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ptr = ptr.next;  </span><br><span class="line">      c += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> TreeNode <span class="title">convertListToBST</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Invalid case</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First step of simulated inorder traversal. Recursively form</span></span><br><span class="line">    <span class="comment">// the left half</span></span><br><span class="line">    TreeNode left = <span class="keyword">this</span>.convertListToBST(l, mid - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Once left half is traversed, process the current node</span></span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(<span class="keyword">this</span>.head.val);</span><br><span class="line">    node.left = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Maintain the invariance mentioned in the algorithm</span></span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recurse on the right hand side and form BST out of them</span></span><br><span class="line">    node.right = <span class="keyword">this</span>.convertListToBST(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Get the size of the linked list first</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.findSize(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.head = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Form the BST now that we know the size</span></span><br><span class="line">    <span class="keyword">return</span> convertListToBST(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>树</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>H指数</title>
    <url>/2020/02/27/H%E6%8C%87%E6%95%B0/</url>
    <content><![CDATA[<p>来自Leetcode第274题H指数</p>
<p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 <em>h</em> 指数。</p>
<p><a href="https://baike.baidu.com/item/h-index/3991452?fr=aladdin" target="_blank" rel="noopener">h 指数的定义</a>: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）<strong>至多</strong>有 h 篇论文分别被引用了<strong>至少</strong> h 次。（其余的 <em>N - h</em> 篇论文每篇被引用次数<strong>不多于</strong> <em>h</em> 次。）”<br><a id="more"></a></p>
<p><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: citations = [<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 给定数组表示研究者总共有 <span class="number">5</span> 篇论文，每篇论文相应的被引用了 <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span> 次。</span><br><span class="line">     由于研究者有 <span class="number">3</span> 篇论文每篇至少被引用了 <span class="number">3</span> 次，其余两篇论文每篇被引用不多于 <span class="number">3</span> 次，所以她的 h 指数是 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong> 如果 <em>h</em> 有多种可能的值，<em>h</em> 指数是其中最大的那个。</p>
<hr>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>来源<a href="https://leetcode-cn.com/problems/h-index/solution/hzhi-shu-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<p>我们想象一个直方图，其中 <em>x</em> 轴表示文章，y 轴表示每篇文章的引用次数。如果将这些文章按照引用次数<em>降序</em>排序并在直方图上进行表示，那么直方图上的最大的正方形的边长 <em>h</em> 就是我们所要求的 <em>h</em>。</p>
<p><img src="/2020/02/27/H指数/274_H_index.svg" alt="h-index"></p>
<p>首先我们将引用次数降序排序，在排完序的数组citations 中，如果 citations[<em>i</em>]&gt;<em>i</em>，那么说明第 0 到 <em>i</em> 篇论文都有至少 i<em>+1 次引用。因此我们只要找到最大的 i满足 citations[</em>i<em>]&gt;</em>i*，那么 h 指数即为 i+1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(citations);</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; citations.length ;i++)&#123;</span><br><span class="line">        h = citations.length - i;</span><br><span class="line">        <span class="keyword">if</span>( h &lt;= citations[i])</span><br><span class="line">            <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p>来源<a href="https://leetcode-cn.com/problems/h-index/solution/hzhi-shu-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<p>要得到时间复杂度更低的算法. 可以考虑最常用的不基于比较的排序，<a href="https://baike.baidu.com/item/计数排序" target="_blank" rel="noopener">计数排序</a>。</p>
<p>然而，论文的引用次数可能会非常多，这个数值很可能会超过论文的总数 <em>n</em>，因此使用计数排序是非常不合算的（会超出空间限制）。在这道题中，我们可以通过一个不难发现的结论来让计数排序变得有用，即：</p>
<blockquote>
<p>如果一篇文章的引用次数超过论文的总数 <em>n</em>，那么将它的引用次数降低为 n 也不会改变 <em>h</em> 指数的值。</p>
</blockquote>
<p>由于 h 指数一定小于等于 <em>n</em>，因此这样做是正确的。在直方图中，将所有超过 <em>y</em> 轴值大于 <em>n</em> 的变为 <em>n</em> 等价于去掉 <em>y</em>&gt;<em>n</em> 的整个区域。</p>
<p><img src="/2020/02/27/H指数/274_H_index_2.svg" alt="h-index cut off"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = citations.length;</span><br><span class="line">        <span class="keyword">int</span>[] papers = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c: citations)</span><br><span class="line">            papers[Math.min(n, c)]++;</span><br><span class="line">        <span class="comment">// 找出最大的 k</span></span><br><span class="line">        <span class="keyword">int</span> k = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = papers[n]; k &gt; s; s += papers[k])</span><br><span class="line">            k--;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux有关笔记</title>
    <url>/2020/02/25/Linux%E6%9C%89%E5%85%B3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>以下内容为操作系统课设期间遇到的一些问题的补充</p>
<h2 id="user含意"><a href="#user含意" class="headerlink" title="__user含意"></a>__user含意</h2><p><code># define __user __attribute__((noderef, address_space(1)))</code><br><a id="more"></a><br>_user这个特性，即<strong>attribute</strong>((noderef, address_space(1)))，是用来修饰一个变量的，这个变量必须是非解除参考（no dereference）的，即这个变量地址必须是有效的，而且变量所在的地址空间必须是1，即用户程序空间的。<br>这里把程序空间分成了3个部分，0表示normal space，即普通地址空间，对内核代码来说，当然就是内核空间地址了。1表示用户地址空间，这个不用多讲，还有一个2，表示是设备地址映射空间，例如硬件设备的寄存器在内核里所映射的地址空间。</p>
<p><strong>attribute</strong>是gnu c编译器的一个功能，它用来让开发者使用此功能给所声明的函数或者变量附加一个属性，以方便编译器进行错误检查，其实就是一个内核检查器。</p>
<p>linux把操作系统内存和用户区内存隔离开，<br>用户程序只能通过系统调用访问系统功能，<br>内核态可以访问用户内存，但是要做检查，因为用户区内存是不可靠的，甚至是危险的。_user就表示这个意思。</p>
<p>以下内容<a href="https://blog.csdn.net/Rong_Toa/article/details/86585086" target="_blank" rel="noopener">来自</a></p>
<p>首先看一下linux内核4.20.1源码：</p>
<p><strong>linux/linux/compile_types.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __user		__attribute__((noderef, address_space(1)))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __kernel	__attribute__((address_space(0)))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __safe		__attribute__((safe))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __force	__attribute__((force))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __nocast	__attribute__((nocast))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __iomem	__attribute__((noderef, address_space(2)))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __must_hold(x)	__attribute__((context(x,1,1)))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __acquires(x)	__attribute__((context(x,0,1)))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __releases(x)	__attribute__((context(x,1,0)))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __acquire(x)	__context__(x,1)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __release(x)	__context__(x,-1)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __cond_lock(x,c)	((c) ? (&#123; __acquire(x); 1; &#125;) : 0)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __percpu	__attribute__((noderef, address_space(3)))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __rcu		__attribute__((noderef, address_space(4)))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __private	__attribute__((noderef))</span></span><br></pre></td></tr></table></figure>
<p>Sparse 诞生于 2004 年, 是由linux之父开发的, 目的就是提供一个静态检查代码的工具, 从而减少linux内核的隐患. 其实在Sparse之前, 已经有了一个不错的代码静态检查工具(“SWAT”), 只不过这个工具不是免费软件, 使用上有一些限制.所以 linus 还是自己开发了一个静态检查工具.（<a href="https://blog.csdn.net/Rong_Toa/article/details/86584999" target="_blank" rel="noopener">参考</a>，<a href="https://lwn.net/Articles/87538/" target="_blank" rel="noopener">原文</a>）</p>
<p>Sparse通过 gcc 的扩展属性 <strong>attribute</strong> 以及自己定义的 <strong>context</strong> 来对代码进行静态检查.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>宏名称</strong></th>
<th><strong>宏定义</strong></th>
<th><strong>检查点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>__bitwise</td>
<td><strong>attribute</strong>((bitwise))</td>
<td>确保变量是相同的位方式(比如 bit-endian, little-endiandeng)</td>
</tr>
<tr>
<td>__user</td>
<td><strong>attribute</strong>((noderef, address_space(1)))</td>
<td>指针地址必须在用户地址空间</td>
</tr>
<tr>
<td>__kernel</td>
<td><strong>attribute</strong>((noderef, address_space(0)))</td>
<td>指针地址必须在内核地址空间</td>
</tr>
<tr>
<td>__iomem</td>
<td><strong>attribute</strong>((noderef, address_space(2)))</td>
<td>指针地址必须在设备地址空间</td>
</tr>
<tr>
<td>__safe</td>
<td><strong>attribute</strong>((safe))</td>
<td>变量可以为空</td>
</tr>
<tr>
<td>__force</td>
<td><strong>attribute</strong>((force))</td>
<td>变量可以进行强制转换</td>
</tr>
<tr>
<td>__nocast</td>
<td><strong>attribute</strong>((nocast))</td>
<td>参数类型与实际参数类型必须一致</td>
</tr>
<tr>
<td>__acquires(x)</td>
<td><strong>attribute</strong>((context(x, 0, 1)))</td>
<td>参数x 在执行前引用计数必须是0,执行后,引用计数必须为1</td>
</tr>
<tr>
<td>__releases(x)</td>
<td><strong>attribute</strong>((context(x, 1, 0)))</td>
<td>与 __acquires(x) 相反</td>
</tr>
<tr>
<td>__acquire(x)</td>
<td><strong>context</strong>(x, 1)</td>
<td>参数x 的引用计数 + 1</td>
</tr>
<tr>
<td>__release(x)</td>
<td><strong>context</strong>(x, -1)</td>
<td>与 __acquire(x) 相反</td>
</tr>
<tr>
<td>__cond_lock(x,c)</td>
<td>((c) ? ({ __acquire(x); 1; }) : 0)</td>
<td>参数c 不为0时,引用计数 + 1, 并返回1</td>
</tr>
</tbody>
</table>
</div>
<h3 id="user-的使用"><a href="#user-的使用" class="headerlink" title="__user 的使用"></a>__user 的使用</h3><p>如果使用了 __user 宏的指针不在用户地址空间初始化, 或者指向内核地址空间, 设备地址空间等等, Sparse会给出警告.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 内核版本:v2.6.32.61  file:arch/score/kernel/signal.c 45行 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setup_sigcontext</span><span class="params">(struct pt_regs *regs, struct sigcontext __user *sc)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="关于get-ds-set-fs-get-fs函数的使用"><a href="#关于get-ds-set-fs-get-fs函数的使用" class="headerlink" title="关于get_ds, set_fs, get_fs函数的使用"></a>关于get_ds, set_fs, get_fs函数的使用</h2><p>在linux内核编程时，进行系统调用（如文件操作）时如果要访问用户空间的参数，可以用set_fs,get_ds等函数实现访问：</p>
<p>get_ds获得kernel的内存访问地址范围（IA32是4GB），</p>
<p>get_fs是取得当前的地址访问限制值。</p>
<p>set_fs是设置当前的地址访问限制值</p>
<p>进程由用户态进入核态，linux进程的task_struct结构中的成员addr_limit也应该由0xBFFFFFFF变为0xFFFFFFFF(addr_limit规定了进程有用户态核内核态情况下的虚拟地址空间访问范围，在用户态，addr_limit成员值是0xBFFFFFFF也就是有3GB的虚拟内存空间，在核心态，是0xFFFFFFFF,范围扩展了1GB)。使用这三个函数是为了安全性。为了保证用户态的地址所指向空间有效，函数会做一些检查工作。如果set_fs(KERNEL_DS),函数将跳过这些检查。</p>
<p>具体用法参考<a href="https://www.cnblogs.com/arnoldlu/p/8879800.html" target="_blank" rel="noopener">示例</a></p>
<h2 id="copy-to-user和copy-from-user"><a href="#copy-to-user和copy-from-user" class="headerlink" title="copy_to_user和copy_from_user"></a>copy_to_user和copy_from_user</h2><p>首先解决一个问题：</p>
<p><strong>1. 为什么要划分为内核空间和用户空间？</strong><br>Linux Kernel是操作系统的核心，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。<br>对于Kernel这么一个高安全级别的东西，显然是不容许其它的应用程序随便调用或访问的，所以需要对Kernel提供一定的保护机制，这个保护机制用来告诉那些应用程序，你只可以访问某些许可的资源，不许可的资源是拒绝被访问的，于是就把Kernel和上层的应用程序抽像的隔离开，分别称之为Kernel Space和User Space。</p>
<p><strong>2. 用户空间的程序如何对内核空间进行访问？</strong><br>上面说到用户态和内核态是两个隔离的空间，虽然从逻辑上被抽像的隔离，但无可避免的是,总是会有那么一些用户空间需要访问内核空间的资源，怎么办呢？</p>
<p><img src="/2020/02/25/Linux有关笔记/20151123145837317" alt="Linux内部结构"></p>
<p><a href="http://blog.csdn.net/ysgjiangsu/article/details/49995229" target="_blank" rel="noopener">http://blog.csdn.net/ysgjiangsu/article/details/49995229</a><br>从上图结构中可以看出，Kernel Space层从下至上包括：<br>Arch：对应Kernel里arch目录，含有诸如x86, ia64, arm, s390等体系结构的支持；<br>Device Driver：对应Kernel里drivers目录，含有block, char, net, usb等不同硬件驱动的支持；<br>在Arch和Driver之上，是对内存，进程，文件系统，网络协议栈等的支持；</p>
<p>最上一层是System Call Interface，系统调用接口，正如其名，这层就是用户空间与内核空间的桥梁，用户空间的应用程序通过System Call这个统一入口来访问系统中的硬件资源，通过此接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。</p>
<p><strong>3.copy_to_user()在内核定义如下：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * copy_to_user: - Copy a block of data into user space.</span></span><br><span class="line"><span class="comment"> * @to: Destination address, in user space.</span></span><br><span class="line"><span class="comment"> * @from: Source address, in kernel space.</span></span><br><span class="line"><span class="comment"> * @n: Number of bytes to copy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Context: User context only. This function may sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copy data from kernel space to user space.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns number of bytes that could not be copied.</span></span><br><span class="line"><span class="comment"> * On success, this will be zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span></span><br><span class="line"> copy_to_user(<span class="keyword">void</span> __user *to, <span class="keyword">const</span> <span class="keyword">void</span> *from, <span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (access_ok(VERIFY_WRITE, to, n))</span><br><span class="line">         n = __copy_to_user(to, from, n);</span><br><span class="line">     <span class="keyword">return</span> n;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>其功能是将内核空间的内容复制到用户空间，所复制的内容是从from来，到to去，复制n个位。 其中又牵扯到两个函数：<strong>access_ok()</strong>和<strong>__copy_to_user()</strong>,好我们继续往下深入，先来看看第一个函数<strong>access_ok()</strong>的源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* access_ok: - Checks if a user space pointer is valid</span></span><br><span class="line"><span class="comment"> * @type: Type of access: %VERIFY_READ or %VERIFY_WRITE. Note that</span></span><br><span class="line"><span class="comment"> * %VERIFY_WRITE is a superset of %VERIFY_READ - if it is safe</span></span><br><span class="line"><span class="comment"> * to write to a block, it is always safe to read from it.</span></span><br><span class="line"><span class="comment"> * @addr: User space pointer to start of block to check</span></span><br><span class="line"><span class="comment"> * @size: Size of block to check</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Context: User context only. This function may sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Checks if a pointer to a block of memory in user space is valid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns true (nonzero) if the memory block may be valid, false (zero)</span></span><br><span class="line"><span class="comment"> * if it is definitely invalid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that, depending on architecture, this function probably just</span></span><br><span class="line"><span class="comment"> * checks that the pointer is in the user space range - after calling</span></span><br><span class="line"><span class="comment"> * this function, memory access functions may still return -EFAULT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> access_ok(type,addr,size) (likely(__range_ok(addr,size) == 0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">access_ok</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> memory_start, memory_end;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> val = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> ((val &gt;= memory_start) &amp;&amp; ((val + size) &lt; memory_end));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_MMU */</span></span></span><br></pre></td></tr></table></figure>
<p>其功能是检查用户空间是否合法，它的第一个参数：type，有两种 类型：VERIFY_READ 和VERIFY_WRITE，前者为可读，后者可写，注意：如果标志为可写（VERIFY_WRITE）时，必然可读！因为可写是可读的超集 （%VERIFY_WRITE is a superset of %VERIFY_READ）。<br>检查过程如下：addr为起始地址，size为所要复制的大小，那么从addr到addr＋size则是所要检查的空间，如果它的范围在memory_start和memory_end之间的话，则返回真。至于memory_start详细信息，我没有读。<br>到此为止，如果检查合法，那么OK，我们来实现真正的复制功能：<strong>__copy_to_user()</strong>，其源码定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">__kernel_size_t</span> __copy_to_user(<span class="keyword">void</span> __user *to, <span class="keyword">const</span> <span class="keyword">void</span> *from,</span><br><span class="line">  <span class="keyword">__kernel_size_t</span> n)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">return</span> __copy_user((<span class="keyword">void</span> __force *)to, from, n);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>又遇到一个函数：<strong>__copy_user()</strong>，这个函数才真正在做底层的复制工作<br><strong>__copy_user</strong><br>宏__copy_user在include/asm-i386/uaccess.h中定义，是作为从用户空间和内核空间进行内存复制的关键。这个宏扩展为汇编后如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">000</span> <span class="meta">#<span class="meta-keyword">define</span> __copy_user(to,from,size)</span></span><br><span class="line"><span class="number">001</span> <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="number">002</span> <span class="keyword">int</span> __d0, __d1;</span><br><span class="line"><span class="number">003</span> __asm__ __volatile__(</span><br><span class="line"><span class="number">004</span> <span class="string">"0: rep; movsl\n"</span></span><br><span class="line"><span class="number">005</span> <span class="string">" movl %3,%0\n"</span></span><br><span class="line"><span class="number">006</span> <span class="string">"1: rep; movsb\n"</span></span><br><span class="line"><span class="number">007</span> <span class="string">"2:\n"</span></span><br><span class="line"><span class="number">008</span> <span class="string">".section .fixup,\"ax\"\n"</span></span><br><span class="line"><span class="number">009</span> <span class="string">"3: lea 0(%3,%0,4),%0\n"</span></span><br><span class="line"><span class="number">010</span> <span class="string">" jmp 2b\n"</span></span><br><span class="line"><span class="number">011</span> <span class="string">".previous\n"</span></span><br><span class="line"><span class="number">012</span> <span class="string">".section __ex_table,\"a\"\n"</span></span><br><span class="line"><span class="number">013</span> <span class="string">" .align 4\n"</span></span><br><span class="line"><span class="number">014</span> <span class="string">" .long 0b,3b\n"</span></span><br><span class="line"><span class="number">015</span> <span class="string">" .long 1b,2b\n"</span></span><br><span class="line"><span class="number">016</span> <span class="string">".previous"</span></span><br><span class="line"><span class="number">017</span> : <span class="string">"=&amp;c"</span>(size), <span class="string">"=&amp;D"</span> (__d0), <span class="string">"=&amp;S"</span> (__d1)</span><br><span class="line"><span class="number">018</span> : <span class="string">"r"</span>(size &amp; <span class="number">3</span>), <span class="string">"0"</span>(size / <span class="number">4</span>), <span class="string">"1"</span>(to), <span class="string">"2"</span>(from)</span><br><span class="line"><span class="number">019</span> : <span class="string">"memory"</span>);</span><br><span class="line"><span class="number">020</span> &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码的主要操作就是004-007行，它的主要功能是将from处长度为size的数据复制到to处。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>详见<a href="https://blog.csdn.net/liushengxi_root/article/details/87439737" target="_blank" rel="noopener">深入理解 Linux 文件系统</a></p>
<h2 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>系统调用是操作系统内核和应用程序之间的接口，而设备驱动程序是操作系统内核和机器硬件之间的接口。设备驱动程序为应用程序屏蔽了硬件的细节，这样在应用程序看来，硬件设备只是一个设备文件， 应用程序可以象操作普通文件一样对硬件设备进行操作。设备驱动程序是内核的一部分，它完成以下的功能：</p>
<ol>
<li>对设备初始化和释放. </li>
<li>把数据从内核传送到硬件和从硬件读取数据. </li>
<li>读取应用程序传送给设备文件的数据和回送应用程序请求的数据. </li>
<li>检测和处理设备出现的错误. </li>
</ol>
<p>Linux支持三中不同类型的设备：字符设备（character devices）、块设备（block devices）和网络设备（network interfaces）。字符设备和块设备的主要区别是:在对字符设备发出读/写请求时，实际的硬件I/O一般就紧接着发生了，块设备则不然，它利用一块系统内存作缓冲区，当用户进程对设备请求能满足用户的要求，就返回请求的数据，如果不能，就调用请求函数来进行实际的I/O操作.块设备是主要针对磁盘等慢速设备设计的，以免耗费过多的CPU时间来等待.</p>
<p>用户进程是通过设备文件来与实际的硬件打交道，每个设备文件都都有其文件属性(c/b)，表示是字符设备还是块设备。<strong>另外每个文件都有两个设备号，第一个是主设备号，标识驱动程序，第二个是从设备号，标识使用同一个设备驱动程序的不同的硬件设备，</strong>比如有两个软盘，就可以用从设备号来区分他们.设备文件的的主设备号必须与设备驱动程序在登记时申请的主设备号一致，否则用户进程将无法访问到驱动程序.。</p>
<p><strong>设备驱动程序工作的基本原理：</strong></p>
<p>用户进程利用系统调用对设备进行诸如read/write操作，系统调用通过设备文件的主设备号找到相应的设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数。</p>
<p>最后，在用户进程调用驱动程序时，系统进入核心态，这时不再是抢先式调度.也就是说，系统必须在你的驱动程序的子函数返回后才能进行其他的工作。如果你的驱动程序陷入死循环，你只有重新启动机器了。</p>
<h3 id="添加新模块的基本步骤"><a href="#添加新模块的基本步骤" class="headerlink" title="添加新模块的基本步骤"></a>添加新模块的基本步骤</h3><h4 id="写设备驱动源代码"><a href="#写设备驱动源代码" class="headerlink" title="写设备驱动源代码"></a>写设备驱动源代码</h4><p>在设备驱动程序中有一个非常重要的结构file_operations,该结构的每个域都对应着一个系统调用。用户进程利用系统调用在对设备文件进行诸如read/write操作时，系统调用通过设备文件的主设备号找到相应的设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span> </span><br><span class="line"><span class="keyword">int</span> (*seek) (struct inode * ，struct file *， <span class="keyword">off_t</span> ，<span class="keyword">int</span>); </span><br><span class="line"><span class="keyword">int</span> (*read) (struct inode * ，struct file *， <span class="keyword">char</span> ，<span class="keyword">int</span>); </span><br><span class="line"><span class="keyword">int</span> (*write) (struct inode * ，struct file *， <span class="keyword">off_t</span> ，<span class="keyword">int</span>); </span><br><span class="line"><span class="keyword">int</span> (*readdir) (struct inode * ，struct file *， struct dirent * ，<span class="keyword">int</span>); </span><br><span class="line"><span class="keyword">int</span> (*select) (struct inode * ，struct file *， <span class="keyword">int</span> ，select_table *); </span><br><span class="line"><span class="keyword">int</span> (*ioctl) (struct inode * ，struct file *， unsined <span class="keyword">int</span> ，<span class="keyword">unsigned</span> <span class="keyword">long</span>); </span><br><span class="line"><span class="keyword">int</span> (*mmap) (struct inode * ，struct file *， struct vm_area_struct *); </span><br><span class="line"><span class="keyword">int</span> (*open) (struct inode * ，struct file *); </span><br><span class="line"><span class="keyword">int</span> (*release) (struct inode * ，struct file *); </span><br><span class="line"><span class="keyword">int</span> (*fsync) (struct inode * ，struct file *); </span><br><span class="line"><span class="keyword">int</span> (*fasync) (struct inode * ，struct file *，<span class="keyword">int</span>); </span><br><span class="line"><span class="keyword">int</span> (*check_media_change) (struct inode * ，struct file *); </span><br><span class="line"><span class="keyword">int</span> (*revalidate) (<span class="keyword">dev_t</span> dev); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写设备驱动程序的<strong>主要工作是编写子函数，并填充**</strong>file_operations<strong>**的各个域</strong>。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Struct file_operations my_fops=&#123;</span><br><span class="line">       .read=my_read,</span><br><span class="line">       .write=my_write,</span><br><span class="line">       .open=my_open,</span><br><span class="line">       .release=my_release</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再定义函数my_read,my_write,my_open,my_release相应的函数体.对于可卸载的内核模块（LKM）,至少还有两个基本的模块：。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内核模块的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">globalvar_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int register_chrdev(unsigned int major, unsigned int baseminor,unsigned int count, const char *name,const struct file_operations *fops)</span></span><br><span class="line"><span class="comment">    返回值提示操作成功还是失败。负的返回值表示错误;0 或正的返回值表明操作成功。</span></span><br><span class="line"><span class="comment">    major参数是被请求的主设备号,name 是设备的名称,该名称将出现在 /proc/devices 中, </span></span><br><span class="line"><span class="comment">    fops是指向函数指针数组的指针,这些函数是调用驱动程序的入口点,</span></span><br><span class="line"><span class="comment">    在 2.6 的内核之后，新增了一个 register_chrdev_region 函数，</span></span><br><span class="line"><span class="comment">    它支持将同一个主设备号下的次设备号进行分段，每一段供给一个字符设备驱动程序使用，使得资源利用率大大提升，</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    宏定义：#define MKDEV(major,minor) (((major) &lt;&lt; MINORBITS) | (minor))</span></span><br><span class="line"><span class="comment">    成功执行返回dev_t类型的设备编号，dev_t类型是unsigned int 类型，32位，用于在驱动程序中定义设备编号，</span></span><br><span class="line"><span class="comment">    高12位为主设备号，低20位为次设备号,可以通过MAJOR和MINOR来获得主设备号和次设备号。</span></span><br><span class="line"><span class="comment">    在module_init宏调用的函数中去注册字符设备驱动</span></span><br><span class="line"><span class="comment">    major传0进去表示要让内核帮我们自动分配一个合适的空白的没被使用的主设备号</span></span><br><span class="line"><span class="comment">    内核如果成功分配就会返回分配的主设备号；如果分配失败会返回负数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">dev_t</span> dev = MKDEV(major, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(major)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//静态申请设备编号</span></span><br><span class="line">        result = register_chrdev_region(dev, <span class="number">1</span>, <span class="string">"charmem"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//动态分配设备号</span></span><br><span class="line">        result = alloc_chrdev_region(&amp;dev, <span class="number">0</span>, <span class="number">1</span>, <span class="string">"charmem"</span>);</span><br><span class="line">        major = MAJOR(dev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    file_operations这个结构体变量，让cdev中的ops成员的值为file_operations结构体变量的值。</span></span><br><span class="line"><span class="comment">    这个结构体会被cdev_add函数想内核注册cdev结构体，可以用很多函数来操作他。</span></span><br><span class="line"><span class="comment">    如：</span></span><br><span class="line"><span class="comment">    cdev_alloc：让内核为这个结构体分配内存的</span></span><br><span class="line"><span class="comment">    cdev_init：将struct cdev类型的结构体变量和file_operations结构体进行绑定的</span></span><br><span class="line"><span class="comment">    cdev_add：向内核里面添加一个驱动，注册驱动</span></span><br><span class="line"><span class="comment">    cdev_del：从内核中注销掉一个驱动。注销驱动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//注册字符设备驱动，设备号和file_operations结构体进行绑定</span></span><br><span class="line">    cdev_init(&amp;globalvar.devm, &amp;globalvar_fops);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    #define THIS_MODULE (&amp;__this_module)是一个struct module变量，代表当前模块，</span></span><br><span class="line"><span class="comment">    与那个著名的current有几分相似，可以通过THIS_MODULE宏来引用模块的struct module结构，</span></span><br><span class="line"><span class="comment">    比如使用THIS_MODULE-&gt;state可以获得当前模块的状态。</span></span><br><span class="line"><span class="comment">    现在你应该明白为啥在那个岁月里，你需要毫不犹豫毫不迟疑的将struct usb_driver结构里的owner设置为THIS_MODULE了吧，</span></span><br><span class="line"><span class="comment">    这个owner指针指向的就是你的模块自己。</span></span><br><span class="line"><span class="comment">    那现在owner咋就说没就没了那？这个说来可就话长了，咱就长话短说吧。</span></span><br><span class="line"><span class="comment">    不知道那个时候你有没有忘记过初始化owner，</span></span><br><span class="line"><span class="comment">    反正是很多人都会忘记，</span></span><br><span class="line"><span class="comment">    于是在2006年的春节前夕，在咱们都无心工作无心学习等着过春节的时候，Greg坚守一线，去掉了 owner，</span></span><br><span class="line"><span class="comment">    于是千千万万个写usb驱动的人再也不用去时刻谨记初始化owner了。</span></span><br><span class="line"><span class="comment">    咱们是不用设置owner了，可core里不能不设置，</span></span><br><span class="line"><span class="comment">    struct usb_driver结构里不是没有owner了么，</span></span><br><span class="line"><span class="comment">    可它里面嵌的那个struct device_driver结构里还有啊，设置了它就可以了。</span></span><br><span class="line"><span class="comment">    于是Greg同时又增加了usb_register_driver()这么一层，</span></span><br><span class="line"><span class="comment">    usb_register()可以通过将参数指定为THIS_MODULE去调用它，所有的事情都挪到它里面去做。</span></span><br><span class="line"><span class="comment">    反正usb_register() 也是内联的，并不会增加调用的开销。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    globalvar.devm.owner = THIS_MODULE;</span><br><span class="line">    err = cdev_add(&amp;globalvar.devm, dev, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">        printk(KERN_INFO <span class="string">"Error %d adding char_mem device"</span>, err);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">"globalvar register success\n"</span>);</span><br><span class="line">        sema_init(&amp;globalvar.sem,<span class="number">1</span>); <span class="comment">//初始化信号量</span></span><br><span class="line">        init_waitqueue_head(&amp;globalvar.outq); <span class="comment">//初始化等待队列</span></span><br><span class="line">        globalvar.rd = globalvar.buffer; <span class="comment">//读指针</span></span><br><span class="line">        globalvar.wr = globalvar.buffer; <span class="comment">//写指针</span></span><br><span class="line">        globalvar.end = globalvar.buffer + MAXNUM;<span class="comment">//缓冲区尾指针</span></span><br><span class="line">        globalvar.flag = <span class="number">0</span>; <span class="comment">// 阻塞唤醒标志置 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义在/include/linux/device.h</span></span><br><span class="line"><span class="comment">    创建class并将class注册到内核中，返回值为class结构指针</span></span><br><span class="line"><span class="comment">    在驱动初始化的代码里调用class_create为该设备创建一个class，再为每个设备调用device_create创建对应的设备。</span></span><br><span class="line"><span class="comment">    省去了利用mknod命令手动创建设备节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    my_class = class_create(THIS_MODULE, <span class="string">"chardev0"</span>);</span><br><span class="line">    device_create(my_class, <span class="literal">NULL</span>, dev, <span class="literal">NULL</span>, <span class="string">"chardev0"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">globalvar_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_destroy(my_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">    class_destroy(my_class);</span><br><span class="line">    cdev_del(&amp;globalvar.devm);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    参数列表包括要释放的主设备号和相应的设备名。</span></span><br><span class="line"><span class="comment">    参数中的这个设备名会被内核用来和主设备号参数所对应的已注册设备名进行比较,如果不同,则返回 -EINVAL。</span></span><br><span class="line"><span class="comment">    如果主设备号超出了所允许的范围,则内核同样返回 -EINVAL。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    unregister_chrdev_region(MKDEV(major, <span class="number">0</span>), <span class="number">1</span>);<span class="comment">//注销设备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编译安装模块"><a href="#编译安装模块" class="headerlink" title="编译安装模块"></a>编译安装模块</h3><p>Makefile:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-m += globalvar.o #obj-m 指编译成外部模块</span><br><span class="line"></span><br><span class="line">build:</span><br><span class="line">	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean</span><br></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">make</span></span><br><span class="line"><span class="selector-tag">insmod</span> <span class="selector-tag">globalvar</span><span class="selector-class">.ko</span></span><br></pre></td></tr></table></figure>
<p>卸载模块：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rmmod mydev</span></span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">int</span> start, len;</span><br><span class="line">	<span class="comment">//fd = open("/dev/chardev0", O_RDWR, S_IRUSR | S_IWUSR);</span></span><br><span class="line">	fd = open(<span class="string">"/dev/mydev"</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Open device error!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (argc == <span class="number">4</span> &amp;&amp; <span class="built_in">strncmp</span>(argv[<span class="number">1</span>], <span class="string">"read"</span>, <span class="number">4</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">		<span class="comment">//static ssize_t my_read(struct file* filp, char* buf, size_t len, loff_t* off) </span></span><br><span class="line">		start = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">		len = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">		lseek(fd, start, SEEK_SET);</span><br><span class="line">		read(fd, buf, len);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Character device read : %s\n"</span>, buf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">4</span> &amp;&amp; <span class="built_in">strncmp</span>(argv[<span class="number">1</span>], <span class="string">"write"</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		start = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">		lseek(fd, start, SEEK_CUR);</span><br><span class="line">		write(fd, argv[<span class="number">3</span>], <span class="built_in">strlen</span>(argv[<span class="number">3</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage : ./executable file &lt;read | write&gt; &lt;start_offset&gt; &lt;len | string&gt;\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考代码<a href="https://www.cnblogs.com/yueshangzuo/p/8078687.html" target="_blank" rel="noopener">来自</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参考：深入浅出linux设备驱动开发</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNUM 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAJOR_NUM 456 <span class="comment">//主设备号 ,没有被使用</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">devm</span>;</span> <span class="comment">//字符设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> outq;<span class="comment">//等待队列,实现阻塞操作</span></span><br><span class="line">    <span class="keyword">int</span> flag; <span class="comment">//阻塞唤醒标志</span></span><br><span class="line">    <span class="keyword">char</span> buffer[MAXNUM+<span class="number">1</span>]; <span class="comment">//字符缓冲区</span></span><br><span class="line">    <span class="keyword">char</span> *rd,*wr,*end; <span class="comment">//读,写,尾指针</span></span><br><span class="line">&#125;globalvar;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">my_class</span>;</span></span><br><span class="line"><span class="keyword">int</span> major=MAJOR_NUM;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">globalvar_read</span><span class="params">(struct file *,<span class="keyword">char</span> *,<span class="keyword">size_t</span> ,<span class="keyword">loff_t</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">globalvar_write</span><span class="params">(struct file *,<span class="keyword">const</span> <span class="keyword">char</span> *,<span class="keyword">size_t</span> ,<span class="keyword">loff_t</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">globalvar_open</span><span class="params">(struct inode *inode,struct file *filp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">globalvar_release</span><span class="params">(struct inode *inode,struct file *filp)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结构体file_operations在头文件 linux/fs.h中定义，用来存储驱动内核模块提供的对设备进行各种操作的函数的指针。</span></span><br><span class="line"><span class="comment">该结构体的每个域都对应着驱动内核模块用来处理某个被请求的事务的函数的地址。</span></span><br><span class="line"><span class="comment">设备"gobalvar"的基本入口点结构变量gobalvar_fops </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">globalvar_fops</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    标记化的初始化格式这种格式允许用名字对这类结构的字段进行初始化,这就避免了因数据结构发生变化而带来的麻烦。</span></span><br><span class="line"><span class="comment">    这种标记化的初始化处理并不是标准 C 的规范,而是对 GUN 编译器的一种(有用的)特殊扩展</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//用来从设备中获取数据. 在这个位置的一个空指针导致 read 系统调用以 -EINVAL("Invalid argument") 失败. 一个非负返回值代表了成功读取的字节数( 返回值是一个 "signed size" 类型, 常常是目标平台本地的整数类型).</span></span><br><span class="line">    .read=globalvar_read,</span><br><span class="line">    <span class="comment">//发送数据给设备. 如果 NULL, -EINVAL 返回给调用 write 系统调用的程序. 如果非负, 返回值代表成功写的字节数.</span></span><br><span class="line">    .write=globalvar_write,</span><br><span class="line">    <span class="comment">//尽管这常常是对设备文件进行的第一个操作, 不要求驱动声明一个对应的方法. 如果这个项是 NULL, 设备打开一直成功, 但是你的驱动不会得到通知.</span></span><br><span class="line">    .open=globalvar_open,</span><br><span class="line">    <span class="comment">//当最后一个打开设备的用户进程执行close ()系统调用时，内核将调用驱动程序的release () 函数：release 函数的主要任务是清理未结束的输入/输出操作、释放资源、用户自定义排他标志的复位等。</span></span><br><span class="line">    .release=globalvar_release,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//内核模块的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">globalvar_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int register_chrdev(unsigned int major, unsigned int baseminor,unsigned int count, const char *name,const struct file_operations *fops)</span></span><br><span class="line"><span class="comment">    返回值提示操作成功还是失败。负的返回值表示错误;0 或正的返回值表明操作成功。</span></span><br><span class="line"><span class="comment">    major参数是被请求的主设备号,name 是设备的名称,该名称将出现在 /proc/devices 中, </span></span><br><span class="line"><span class="comment">    fops是指向函数指针数组的指针,这些函数是调用驱动程序的入口点,</span></span><br><span class="line"><span class="comment">    在 2.6 的内核之后，新增了一个 register_chrdev_region 函数，</span></span><br><span class="line"><span class="comment">    它支持将同一个主设备号下的次设备号进行分段，每一段供给一个字符设备驱动程序使用，使得资源利用率大大提升，</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    宏定义：#define MKDEV(major,minor) (((major) &lt;&lt; MINORBITS) | (minor))</span></span><br><span class="line"><span class="comment">    成功执行返回dev_t类型的设备编号，dev_t类型是unsigned int 类型，32位，用于在驱动程序中定义设备编号，</span></span><br><span class="line"><span class="comment">    高12位为主设备号，低20位为次设备号,可以通过MAJOR和MINOR来获得主设备号和次设备号。</span></span><br><span class="line"><span class="comment">    在module_init宏调用的函数中去注册字符设备驱动</span></span><br><span class="line"><span class="comment">    major传0进去表示要让内核帮我们自动分配一个合适的空白的没被使用的主设备号</span></span><br><span class="line"><span class="comment">    内核如果成功分配就会返回分配的主设备号；如果分配失败会返回负数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">dev_t</span> dev = MKDEV(major, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(major)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//静态申请设备编号</span></span><br><span class="line">        result = register_chrdev_region(dev, <span class="number">1</span>, <span class="string">"charmem"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//动态分配设备号</span></span><br><span class="line">        result = alloc_chrdev_region(&amp;dev, <span class="number">0</span>, <span class="number">1</span>, <span class="string">"charmem"</span>);</span><br><span class="line">        major = MAJOR(dev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    file_operations这个结构体变量，让cdev中的ops成员的值为file_operations结构体变量的值。</span></span><br><span class="line"><span class="comment">    这个结构体会被cdev_add函数想内核注册cdev结构体，可以用很多函数来操作他。</span></span><br><span class="line"><span class="comment">    如：</span></span><br><span class="line"><span class="comment">    cdev_alloc：让内核为这个结构体分配内存的</span></span><br><span class="line"><span class="comment">    cdev_init：将struct cdev类型的结构体变量和file_operations结构体进行绑定的</span></span><br><span class="line"><span class="comment">    cdev_add：向内核里面添加一个驱动，注册驱动</span></span><br><span class="line"><span class="comment">    cdev_del：从内核中注销掉一个驱动。注销驱动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//注册字符设备驱动，设备号和file_operations结构体进行绑定</span></span><br><span class="line">    cdev_init(&amp;globalvar.devm, &amp;globalvar_fops);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    #define THIS_MODULE (&amp;__this_module)是一个struct module变量，代表当前模块，</span></span><br><span class="line"><span class="comment">    与那个著名的current有几分相似，可以通过THIS_MODULE宏来引用模块的struct module结构，</span></span><br><span class="line"><span class="comment">    比如使用THIS_MODULE-&gt;state可以获得当前模块的状态。</span></span><br><span class="line"><span class="comment">    现在你应该明白为啥在那个岁月里，你需要毫不犹豫毫不迟疑的将struct usb_driver结构里的owner设置为THIS_MODULE了吧，</span></span><br><span class="line"><span class="comment">    这个owner指针指向的就是你的模块自己。</span></span><br><span class="line"><span class="comment">    那现在owner咋就说没就没了那？这个说来可就话长了，咱就长话短说吧。</span></span><br><span class="line"><span class="comment">    不知道那个时候你有没有忘记过初始化owner，</span></span><br><span class="line"><span class="comment">    反正是很多人都会忘记，</span></span><br><span class="line"><span class="comment">    于是在2006年的春节前夕，在咱们都无心工作无心学习等着过春节的时候，Greg坚守一线，去掉了 owner，</span></span><br><span class="line"><span class="comment">    于是千千万万个写usb驱动的人再也不用去时刻谨记初始化owner了。</span></span><br><span class="line"><span class="comment">    咱们是不用设置owner了，可core里不能不设置，</span></span><br><span class="line"><span class="comment">    struct usb_driver结构里不是没有owner了么，</span></span><br><span class="line"><span class="comment">    可它里面嵌的那个struct device_driver结构里还有啊，设置了它就可以了。</span></span><br><span class="line"><span class="comment">    于是Greg同时又增加了usb_register_driver()这么一层，</span></span><br><span class="line"><span class="comment">    usb_register()可以通过将参数指定为THIS_MODULE去调用它，所有的事情都挪到它里面去做。</span></span><br><span class="line"><span class="comment">    反正usb_register() 也是内联的，并不会增加调用的开销。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    globalvar.devm.owner = THIS_MODULE;</span><br><span class="line">    err = cdev_add(&amp;globalvar.devm, dev, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">        printk(KERN_INFO <span class="string">"Error %d adding char_mem device"</span>, err);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">"globalvar register success\n"</span>);</span><br><span class="line">        sema_init(&amp;globalvar.sem,<span class="number">1</span>); <span class="comment">//初始化信号量</span></span><br><span class="line">        init_waitqueue_head(&amp;globalvar.outq); <span class="comment">//初始化等待队列</span></span><br><span class="line">        globalvar.rd = globalvar.buffer; <span class="comment">//读指针</span></span><br><span class="line">        globalvar.wr = globalvar.buffer; <span class="comment">//写指针</span></span><br><span class="line">        globalvar.end = globalvar.buffer + MAXNUM;<span class="comment">//缓冲区尾指针</span></span><br><span class="line">        globalvar.flag = <span class="number">0</span>; <span class="comment">// 阻塞唤醒标志置 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义在/include/linux/device.h</span></span><br><span class="line"><span class="comment">    创建class并将class注册到内核中，返回值为class结构指针</span></span><br><span class="line"><span class="comment">    在驱动初始化的代码里调用class_create为该设备创建一个class，再为每个设备调用device_create创建对应的设备。</span></span><br><span class="line"><span class="comment">    省去了利用mknod命令手动创建设备节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    my_class = class_create(THIS_MODULE, <span class="string">"chardev0"</span>);</span><br><span class="line">    device_create(my_class, <span class="literal">NULL</span>, dev, <span class="literal">NULL</span>, <span class="string">"chardev0"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在大部分驱动程序中,open 应完成如下工作:</span></span><br><span class="line"><span class="comment">● 递增使用计数。--为了老版本的可移植性</span></span><br><span class="line"><span class="comment">● 检查设备特定的错误(诸如设备未就绪或类似的硬件问题)。</span></span><br><span class="line"><span class="comment">● 如果设备是首次打开,则对其进行初始化。</span></span><br><span class="line"><span class="comment">● 识别次设备号,并且如果有必要,更新 f_op 指针。</span></span><br><span class="line"><span class="comment">● 分配并填写被置于 filp-&gt;private_data 里的数据结构。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">globalvar_open</span><span class="params">(struct inode *inode,struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    try_module_get(THIS_MODULE);<span class="comment">//模块计数加一</span></span><br><span class="line">    printk(<span class="string">"This chrdev is in open\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">release都应该完成下面的任务:</span></span><br><span class="line"><span class="comment">● 释放由 open 分配的、保存在 filp-&gt;private_data 中的所有内容。</span></span><br><span class="line"><span class="comment">● 在最后一次关闭操作时关闭设备。字符设备驱动程序</span></span><br><span class="line"><span class="comment">● 使用计数减 1。</span></span><br><span class="line"><span class="comment">如果使用计数不归0,内核就无法卸载模块。</span></span><br><span class="line"><span class="comment">并不是每个 close 系统调用都会引起对 release 方法的调用。</span></span><br><span class="line"><span class="comment">仅仅是那些真正释放设备数据结构的 close 调用才会调用这个方法,</span></span><br><span class="line"><span class="comment">因此名字是 release 而不是 close。内核维护一个 file 结构被使用多少次的计数器。</span></span><br><span class="line"><span class="comment">无论是 fork 还是 dup 都不创建新的数据结构(仅由 open 创建),它们只是增加已有结构中的计数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">globalvar_release</span><span class="params">(struct inode *inode,struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    module_put(THIS_MODULE); <span class="comment">//模块计数减一</span></span><br><span class="line">    printk(<span class="string">"This chrdev is in release\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">globalvar_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    device_destroy(my_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">    class_destroy(my_class);</span><br><span class="line">    cdev_del(&amp;globalvar.devm);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    参数列表包括要释放的主设备号和相应的设备名。</span></span><br><span class="line"><span class="comment">    参数中的这个设备名会被内核用来和主设备号参数所对应的已注册设备名进行比较,如果不同,则返回 -EINVAL。</span></span><br><span class="line"><span class="comment">    如果主设备号超出了所允许的范围,则内核同样返回 -EINVAL。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    unregister_chrdev_region(MKDEV(major, <span class="number">0</span>), <span class="number">1</span>);<span class="comment">//注销设备</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ssize_t read(struct file *filp, char *buff,size_t count, loff_t *offp);</span></span><br><span class="line"><span class="comment">参数 filp 是文件指针,参数 count 是请求传输的数据长度。</span></span><br><span class="line"><span class="comment">参数 buff 是指向用户空间的缓冲区,这个缓冲区或者保存将写入的数据,或者是一个存放新读入数据的空缓冲区。</span></span><br><span class="line"><span class="comment">最后的 offp 是一个指向“long offset type(长偏移量类型)”对象的指针,这个对象指明用户在文件中进行存取操作的位置。</span></span><br><span class="line"><span class="comment">返回值是“signed size type(有符号的尺寸类型)”</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">主要问题是,需要在内核地址空间和用户地址空间之间传输数据。</span></span><br><span class="line"><span class="comment">不能用通常的办法利用指针或 memcpy来完成这样的操作。由于许多原因,不能在内核空间中直接使用用户空间地址。</span></span><br><span class="line"><span class="comment">内核空间地址与用户空间地址之间很大的一个差异就是,用户空间的内存是可被换出的。</span></span><br><span class="line"><span class="comment">当内核访问用户空间指针时,相对应的页面可能已不在内存中了,这样的话就会产生一个页面失效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">globalvar_read</span><span class="params">(struct file *filp,<span class="keyword">char</span> *buf,<span class="keyword">size_t</span> len,<span class="keyword">loff_t</span> *off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(wait_event_interruptible(globalvar.outq,globalvar.flag!=<span class="number">0</span>)) <span class="comment">//不可读时 阻塞读进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -ERESTARTSYS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    down_interruptible 可以由一个信号中断,但 down 不允许有信号传送到进程。</span></span><br><span class="line"><span class="comment">    大多数情况下都希望信号起作用;否则,就有可能建立一个无法杀掉的进程,并产生其他不可预期的结果。</span></span><br><span class="line"><span class="comment">    但是,允许信号中断将使得信号量的处理复杂化,因为我们总要去检查函数(这里是 down_interruptible)是否已被中断。</span></span><br><span class="line"><span class="comment">    一般来说,当该函数返回 0 时表示成功,返回非 0 时则表示出错。</span></span><br><span class="line"><span class="comment">    如果这个处理过程被中断,它就不会获得信号量 , 因此,也就不能调用 up 函数了。</span></span><br><span class="line"><span class="comment">    因此,对信号量的典型调用通常是下面的这种形式:</span></span><br><span class="line"><span class="comment">    if (down_interruptible (&amp;sem))</span></span><br><span class="line"><span class="comment">        return -ERESTARTSYS;</span></span><br><span class="line"><span class="comment">    返回值 -ERESTARTSYS通知系统操作被信号中断。</span></span><br><span class="line"><span class="comment">    调用这个设备方法的内核函数或者重新尝试,或者返回 -EINTR 给应用程序,这取决于应用程序是如何设置信号处理函数的。</span></span><br><span class="line"><span class="comment">    当然,如果是以这种方式中断操作的话,那么代码应在返回前完成清理工作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    使用down_interruptible来获取信号量的代码不应调用其他也试图获得该信号量的函数,否则就会陷入死锁。</span></span><br><span class="line"><span class="comment">    如果驱动程序中的某段程序对其持有的信号量释放失败的话(可能就是一次出错返回的结果),</span></span><br><span class="line"><span class="comment">    那么其他任何获取该信号量的尝试都将阻塞在那里。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(down_interruptible(&amp;globalvar.sem)) <span class="comment">//P 操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -ERESTARTSYS;</span><br><span class="line">    &#125;</span><br><span class="line">    globalvar.flag = <span class="number">0</span>;</span><br><span class="line">    printk(<span class="string">"into the read function\n"</span>);</span><br><span class="line">    printk(<span class="string">"the rd is %c\n"</span>,*globalvar.rd); <span class="comment">//读指针</span></span><br><span class="line">    <span class="keyword">if</span>(globalvar.rd &lt; globalvar.wr)</span><br><span class="line">        len = min(len,(<span class="keyword">size_t</span>)(globalvar.wr - globalvar.rd)); <span class="comment">//更新读写长度</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        len = min(len,(<span class="keyword">size_t</span>)(globalvar.end - globalvar.rd));</span><br><span class="line">    printk(<span class="string">"the len is %d\n"</span>,len);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    read 和 write 代码要做的工作,就是在用户地址空间和内核地址空间之间进行整段数据的拷贝。</span></span><br><span class="line"><span class="comment">    这种能力是由下面的内核函数提供的,它们用于拷贝任意的一段字节序列,这也是每个 read 和 write 方法实现的核心部分:</span></span><br><span class="line"><span class="comment">    unsigned long copy_to_user(void *to, const void *from,unsigned long count);</span></span><br><span class="line"><span class="comment">    unsigned long copy_from_user(void *to, const void *from,unsigned long count);</span></span><br><span class="line"><span class="comment">    虽然这些函数的行为很像通常的 memcpy 函数,但当在内核空间内运行的代码访问用户空间时,则要多加小心。</span></span><br><span class="line"><span class="comment">    被寻址的用户空间的页面可能当前并不在内存,于是处理页面失效的程序会使访问进程转入睡眠,直到该页面被传送至期望的位置。</span></span><br><span class="line"><span class="comment">    例如,当页面必须从交换空间取回时,这样的情况就会发生。对于驱动程序编写人员来说,</span></span><br><span class="line"><span class="comment">    结果就是访问用户空间的任何函数都必须是可重入的,并且必须能和其他驱动程序函数并发执行。</span></span><br><span class="line"><span class="comment">    这就是我们使用信号量来控制并发访问的原因.</span></span><br><span class="line"><span class="comment">    这两个函数的作用并不限于在内核空间和用户空间之间拷贝数据,它们还检查用户空间的指针是否有效。</span></span><br><span class="line"><span class="comment">    如果指针无效,就不会进行拷贝;另一方面,如果在拷贝过程中遇到无效地址,则仅仅会复制部分数据。</span></span><br><span class="line"><span class="comment">    在这两种情况下,返回值是还未拷贝完的内存的数量值。</span></span><br><span class="line"><span class="comment">    如果发现这样的错误返回,就会在返回值不为 0 时,返回 -EFAULT 给用户。</span></span><br><span class="line"><span class="comment">    负值意味着发生了错误,该值指明发生了什么错误,错误码在&lt;linux/errno.h&gt;中定义。</span></span><br><span class="line"><span class="comment">    比如这样的一些错误:-EINTR(系统调用被中断)或 -EFAULT (无效地址)。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(copy_to_user(buf,globalvar.rd,len))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT<span class="string">"copy failed\n"</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        up递增信号量的值,并唤醒所有正在等待信号量转为可用状态的进程。</span></span><br><span class="line"><span class="comment">        必须小心使用信号量。被信号量保护的数据必须是定义清晰的,并且存取这些数据的所有代码都必须首先获得信号量。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        up(&amp;globalvar.sem);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">"the read buffer is %s\n"</span>,globalvar.buffer);</span><br><span class="line">    globalvar.rd = globalvar.rd + len;</span><br><span class="line">    <span class="keyword">if</span>(globalvar.rd == globalvar.end)</span><br><span class="line">        globalvar.rd = globalvar.buffer; <span class="comment">//字符缓冲区循环</span></span><br><span class="line">    up(&amp;globalvar.sem); <span class="comment">//V 操作</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">globalvar_write</span><span class="params">(struct file *filp,<span class="keyword">const</span> <span class="keyword">char</span> *buf,<span class="keyword">size_t</span> len,<span class="keyword">loff_t</span> *off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(down_interruptible(&amp;globalvar.sem)) <span class="comment">//P 操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -ERESTARTSYS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(globalvar.rd &lt;= globalvar.wr)</span><br><span class="line">        len = min(len,(<span class="keyword">size_t</span>)(globalvar.end - globalvar.wr));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        len = min(len,(<span class="keyword">size_t</span>)(globalvar.rd-globalvar.wr<span class="number">-1</span>));</span><br><span class="line">    printk(<span class="string">"the write len is %d\n"</span>,len);</span><br><span class="line">    <span class="keyword">if</span>(copy_from_user(globalvar.wr,buf,len))</span><br><span class="line">    &#123;</span><br><span class="line">        up(&amp;globalvar.sem); <span class="comment">//V 操作</span></span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">"the write buffer is %s\n"</span>,globalvar.buffer);</span><br><span class="line">    printk(<span class="string">"the len of buffer is %d\n"</span>,<span class="built_in">strlen</span>(globalvar.buffer));</span><br><span class="line">    globalvar.wr = globalvar.wr + len;</span><br><span class="line">    <span class="keyword">if</span>(globalvar.wr == globalvar.end)</span><br><span class="line">    globalvar.wr = globalvar.buffer; <span class="comment">//循环</span></span><br><span class="line">    up(&amp;globalvar.sem);</span><br><span class="line">    <span class="comment">//V 操作</span></span><br><span class="line">    globalvar.flag=<span class="number">1</span>; <span class="comment">//条件成立,可以唤醒读进程</span></span><br><span class="line">    wake_up_interruptible(&amp;globalvar.outq); <span class="comment">//唤醒读进程</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line">module_init(globalvar_init);</span><br><span class="line">module_exit(globalvar_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>
<p>mydev:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNUM 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAJOR_NUM 300  <span class="comment">//主设备号，没有被使用  查看/proc/devices可知</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定license版本</span></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">devm</span>;</span> <span class="comment">//字符设备</span></span><br><span class="line">	<span class="keyword">char</span> buf[MAXNUM + <span class="number">1</span>]; <span class="comment">//字符缓冲区</span></span><br><span class="line">	<span class="keyword">char</span>* rd, * wr, * end; <span class="comment">//读,写,尾指针</span></span><br><span class="line">&#125;globalvar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">class</span>* <span class="title">my_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件打开函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_open</span><span class="params">(struct inode* inode, struct file* filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">"Character device is open.\n"</span>);</span><br><span class="line">	<span class="comment">//try_module_get(THIS_MODULE);//模块计数加一</span></span><br><span class="line">	filp-&gt;private_data = &amp;globalvar;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件释放函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_release</span><span class="params">(struct inode* inode, struct file* filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">"Character device is released.\n"</span>);</span><br><span class="line">	<span class="comment">//module_put(THIS_MODULE); //模块计数减一</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//模块卸载函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mydev_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">"Unload module: mydev.\n"</span>);</span><br><span class="line">	device_destroy(my_class, MKDEV(MAJOR_NUM, <span class="number">0</span>));</span><br><span class="line">	class_destroy(my_class);</span><br><span class="line">	cdev_del(&amp;globalvar.devm);</span><br><span class="line">	cdev_del(&amp;globalvar.devm);  <span class="comment">//注销设备</span></span><br><span class="line">	unregister_chrdev_region(MKDEV(MAJOR_NUM, <span class="number">0</span>), <span class="number">1</span>);  <span class="comment">//释放设备号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">my_read</span><span class="params">(struct file* filp, <span class="keyword">char</span> __user* buf, <span class="keyword">size_t</span> len, <span class="keyword">loff_t</span>* off)</span> </span>&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">"Character device start read.\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> rtn = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> free_mem = MAXNUM - *off;  <span class="comment">//剩余可用空间</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev</span>* <span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (len &lt;= free_mem) &#123;  <span class="comment">//可用空间充足</span></span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(buf, dev-&gt;buf + *off, len)) &#123;</span><br><span class="line">			printk(KERN_ALERT <span class="string">"1.Copy to user buffer failed.\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">		*off += len;</span><br><span class="line">		rtn = len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//可用空间不足</span></span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(buf, dev-&gt;buf + *off, free_mem)) &#123;</span><br><span class="line">			printk(KERN_ALERT<span class="string">"2.Copy to user buffer failed.\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">		*off += free_mem;</span><br><span class="line">		rtn = free_mem;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//printk("the read buffer is %s\n", globalvar.buf);</span></span><br><span class="line">	printk(KERN_INFO <span class="string">"Character device has read %d bytes.\n"</span>, rtn);</span><br><span class="line">	<span class="keyword">return</span> rtn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">my_write</span><span class="params">(struct file* filp, <span class="keyword">const</span> <span class="keyword">char</span> __user * buf, <span class="keyword">size_t</span> len, <span class="keyword">loff_t</span>* off)</span> </span>&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">"Start write.\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> rtn = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> free_mem = MAXNUM - *off;  <span class="comment">//剩余可用空间</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev</span>* <span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">	<span class="comment">//printk(KERN_DEBUG "len: %d buf:%send.\n",strlen(dev-&gt;buf), dev-&gt;buf);</span></span><br><span class="line">	<span class="keyword">if</span> (len &lt;= free_mem) &#123;</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(dev-&gt;buf + *off, buf, len)) &#123;</span><br><span class="line">			printk(KERN_ALERT <span class="string">"1.Copy frome user buffer failed.\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">		*off += len;</span><br><span class="line">		rtn = len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(dev-&gt;buf + *off, buf, free_mem)) &#123;</span><br><span class="line">			printk(KERN_ALERT<span class="string">"2.Copy frome user buffer failed.\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">		*off += free_mem;</span><br><span class="line">		rtn = free_mem;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">"Character device has written %d bytes.\n"</span>, rtn);</span><br><span class="line">	<span class="keyword">return</span> rtn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件定位函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> loff_t <span class="title">my_llseek</span><span class="params">(struct file* filp, <span class="keyword">loff_t</span> off, <span class="keyword">int</span> whence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">"Character device start lseek.\n"</span>);</span><br><span class="line">	<span class="keyword">loff_t</span> rtn = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">switch</span> (whence) &#123;</span><br><span class="line">	<span class="keyword">case</span> SEEK_SET:</span><br><span class="line">		rtn = off;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SEEK_CUR:</span><br><span class="line">		rtn = filp-&gt;f_pos + off;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SEEK_END:</span><br><span class="line">		rtn = MAXNUM + off;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (rtn &lt; <span class="number">0</span> || rtn &gt; MAXNUM)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	printk(<span class="string">"Character device set offset at %d.\n"</span>, rtn);</span><br><span class="line">	filp-&gt;f_pos = rtn;</span><br><span class="line">	<span class="keyword">return</span> rtn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">my_fops</span> = &#123;</span></span><br><span class="line">	.open = my_open,</span><br><span class="line">	.read = my_read,</span><br><span class="line">	.write = my_write,</span><br><span class="line">	.release = my_release,</span><br><span class="line">	.llseek = my_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置初始化入口函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">mydev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//printk(KERN_DEBUG "hello %s!!!\n", name);</span></span><br><span class="line">	printk(KERN_DEBUG <span class="string">"Load module: mydev\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> rtn;</span><br><span class="line">	<span class="keyword">dev_t</span> devno = MKDEV(MAJOR_NUM, <span class="number">0</span>);  <span class="comment">//注册字符设备驱动</span></span><br><span class="line">	rtn = register_chrdev_region(devno, <span class="number">1</span>, <span class="string">"mydev"</span>);  <span class="comment">//静态申请设备编号</span></span><br><span class="line">	<span class="keyword">if</span> (rtn &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(KERN_ALERT <span class="string">"Register character device error."</span>);</span><br><span class="line">		<span class="keyword">return</span> rtn;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(globalvar.buf, <span class="string">'\0'</span>, MAXNUM + <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//printk(KERN_DEBUG "buf:%s\n", globalvar.buf);</span></span><br><span class="line">	cdev_init(&amp;(globalvar.devm), &amp;my_fops); <span class="comment">//注册字符设备驱动，设备号和file_operations结构体进行绑定</span></span><br><span class="line">	globalvar.devm.owner = THIS_MODULE;  <span class="comment">//通过THIS_MODULE宏来引用模块的struct module结构</span></span><br><span class="line">	rtn = cdev_add(&amp;(globalvar.devm), devno, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (rtn)</span><br><span class="line">		printk(KERN_ALERT <span class="string">"Error %d adding mydev device.\n"</span>, rtn);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		printk(KERN_INFO <span class="string">"Character device register success.\n"</span>);</span><br><span class="line">		globalvar.rd = globalvar.buf; <span class="comment">//读指针</span></span><br><span class="line">		globalvar.wr = globalvar.buf;  <span class="comment">//写指针</span></span><br><span class="line">		globalvar.end = globalvar.buf + MAXNUM;  <span class="comment">//缓冲区尾指针</span></span><br><span class="line">	&#125;</span><br><span class="line">	my_class = class_create(THIS_MODULE, <span class="string">"mydev"</span>);</span><br><span class="line">	device_create(my_class, <span class="literal">NULL</span>, devno, <span class="literal">NULL</span>, <span class="string">"mydev"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mydev_init);</span><br><span class="line">module_exit(mydev_exit);</span><br></pre></td></tr></table></figure>
<h2 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h2><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><p><strong>这是一个提供内核统计信息的文件系统接口。由内核动态创建，不需要任何存储设备。多数为只读，提供观察数据，一部分可写用于控制内核行为。</strong></p>
<p>/proc包含很多目录，其中以进程ID命名的目录代表就是那个进程。这些目录下众多文件包含了进程的信息和统计信息，由内核数据映射而来。</p>
<p><img src="/2020/02/25/Linux有关笔记/2019091016174868.png" alt="img"></p>
<ul>
<li>limits：实际的资源限制</li>
<li>maps：映射的内存区域</li>
<li>sched：CPU调度的各种统计</li>
<li>schedstat：CPU运行时间，延迟和时间分片</li>
<li>smaps：映射内存区域的使用统计</li>
<li>stat：进程状态和统计。包括总的CPU和内存使用情况</li>
<li>statm：以页为单位的内存使用总结</li>
<li>status：stat和statm的信息，用户可读</li>
<li>task：每个任务的统计目录</li>
</ul>
<p>系统级别的统计,与性能观察相关的系统级别的文件</p>
<p><img src="/2020/02/25/Linux有关笔记/20190910161839417.png" alt="img"></p>
<ul>
<li>cpuinfo:物理处理器信息，包含所有虚拟CPU、型号、时钟频率和缓存大小</li>
<li>diskstats：对于所有磁盘设备的磁盘IO统计</li>
<li>interrupts：每个CPU的中断计数器</li>
<li>loadavg：负载平均值</li>
<li>meminfo：系统内存使用明细</li>
<li>net/dev：网络接口统计</li>
<li>net/tcp：活跃的TCP套接字信息</li>
<li>schedstat：系统级别的CPU调度器统计</li>
<li>self：关联当前进程ID路径的链接符号。为了方便使用</li>
<li>slabinfo：内核slab分配器缓存统计</li>
<li>stat：内核和系统资源的统计</li>
<li>zoneinfo：内存区信息</li>
</ul>
<h3 id="proc-pid-stat"><a href="#proc-pid-stat" class="headerlink" title="/proc/(pid)/stat"></a>/proc/(pid)/stat</h3><p>可以通过查看/usr/src/linux/Documentation/filesystems/proc.txt文件来获得更多的信息</p>
<p>[root@localhost ~]# cat /proc/6873/stat</p>
<p>6873 (a.out) R 6723 6873 6723 34819 6873 8388608 77 0 0 0 41958 31 0 0 25 0 3 0 5882654 1409024 56 4294967295 134512640 134513720 3215579040 0 2097798 0 0 0 0 0 0 0 17 0 0 0 [root@localhost ~]#</p>
<p>每个参数意思为：<br>参数 解释<br>pid=6873 进程(包括轻量级进程，即线程)号<br>comm=a.out 应用程序或命令的名字<br>task_state=R 任务的状态，R:runnign, S:sleeping (TASK_INTERRUPTIBLE), D:disk sleep (TASK_UNINTERRUPTIBLE), T: stopped, T:tracing stop,Z:zombie, X:dead<br>ppid=6723 父进程ID<br>pgid=6873 线程组号<br>sid=6723 c该任务所在的会话组ID<br>tty_nr=34819(pts/3) 该任务的tty终端的设备号，INT（34817/256）=主设备号，（34817-主设备号）=次设备号<br>tty_pgrp=6873 终端的进程组号，当前运行在该任务所在终端的前台任务(包括shell 应用程序)的PID。<br>task-&gt;flags=8388608 进程标志位，查看该任务的特性<br>min_flt=77 该任务不需要从硬盘拷数据而发生的缺页（次缺页）的次数<br>cmin_flt=0 累计的该任务的所有的waited-for进程曾经发生的次缺页的次数目<br>maj_flt=0 该任务需要从硬盘拷数据而发生的缺页（主缺页）的次数<br>cmaj_flt=0 累计的该任务的所有的waited-for进程曾经发生的主缺页的次数目<br>utime=1587 该任务在用户态运行的时间，单位为jiffies<br>stime=1 该任务在核心态运行的时间，单位为jiffies<br>cutime=0 累计的该任务的所有的waited-for进程曾经在用户态运行的时间，单位为jiffies<br>cstime=0 累计的该任务的所有的waited-for进程曾经在核心态运行的时间，单位为jiffies<br>priority=25 任务的动态优先级<br>nice=0 任务的静态优先级<br>num_threads=3 该任务所在的线程组里线程的个数<br>it_real_value=0 由于计时间隔导致的下一个 SIGALRM 发送进程的时延，以 jiffy 为单位.<br>start_time=5882654 该任务启动的时间，单位为jiffies<br>vsize=1409024（B） 该任务的虚拟地址空间大小（很多说明上在此误导为vsize的单位为page实际是不正确的）<br>rss=56(page) 该任务当前驻留物理地址空间的大小<br>Number of pages the process has in real memory,minu 3 for administrative purpose.<br>这些页可能用于代码，数据和栈。<br>rlim=4294967295（bytes） 该任务能驻留物理地址空间的最大值<br>start_code=134512640 该任务在虚拟地址空间的代码段的起始地址<br>end_code=134513720 该任务在虚拟地址空间的代码段的结束地址<br>start_stack=3215579040 该任务在虚拟地址空间的栈的结束地址<br>kstkesp=0 esp(32 位堆栈指针) 的当前值, 与在进程的内核堆栈页得到的一致.<br>kstkeip=2097798 指向将要执行的指令的指针, EIP(32 位指令指针)的当前值.<br>pendingsig=0 待处理信号的位图，记录发送给进程的普通信号<br>block_sig=0 阻塞信号的位图<br>sigign=0 忽略的信号的位图<br>sigcatch=082985 被俘获的信号的位图<br>wchan=0 如果该进程是睡眠状态，该值给出调度的调用点<br>nswap 被swapped的页数，当前没用<br>cnswap 所有子进程被swapped的页数的和，当前没用<br>exit_signal=17 该进程结束时，向父进程所发送的信号<br>task_cpu(task)=0 运行在哪个CPU上<br>task_rt_priority=0 实时进程的相对优先级别<br>task_policy=0 进程的调度策略，0=非实时进程，1=FIFO实时进程；2=RR实时进程 </p>
<p>rss是实际占用内存，以页为单位存放，一般是4K每页，所以要乘以4<br>vsize则是以B的单位存放，转化到K所以除1024 </p>
<h3 id="proc-cpuinfo"><a href="#proc-cpuinfo" class="headerlink" title="/proc/cpuinfo"></a>/proc/cpuinfo</h3><p>/proc/cpuinfo文件分析</p>
<p>　　在<a href="http://en.wikipedia.org/wiki/Linux" target="_blank" rel="noopener">Linux</a>系统中，提供了<a href="http://en.wikipedia.org/wiki/Procfs" target="_blank" rel="noopener">proc文件系统</a>显示系统的软硬件信息。如果想了解系统中CPU的提供商和相关配置信息，则可以通过/proc/cpuinfo文件得到。本文章针对该文件进行简单的总结。</p>
<p>　　基于不同指令集（ISA）的CPU产生的/proc/cpuinfo文件不一样，基于X86指令集CPU的/proc/cpuinfo文件包含如下内容：</p>
<p>processor　　： 0<br>vendor_id　　：GenuineIntel<br>cpu family　　：6<br>model　　　　：26<br>model name　：Intel(R) Xeon(R) CPU      E5520 @ 2.27GHz<br>stepping　　 ：5<br>cpu MHz　　  ：1600.000<br>cache size　　： 8192 KB<br>physical id　　：0<br>siblings　　　 ：8<br>core id　　　 ： 0<br>cpu cores　　 ：4<br>apicid　　    ：0<br>fpu　　　　　 ：yes<br>fpu_exception ：yes<br>cpuid level　　 ： 11<br>wp　　　　　　：yes<br>flags 　　　　　： fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm syscall nx rdtscp lm constant_tsc ida nonstop_tsc pni monitor ds_cpl vmx est tm2 cx16 xtpr popcnt lahf_lm<br>bogomips　　 ：4522.12<br>clflush size　　：64<br>cache_alignment　　： 64<br>address sizes　　　 ： 40 bits physical, 48 bits virtual<br>power management ：</p>
<p>以上输出项的含义如下：</p>
<p>processor　：系统中逻辑处理核的编号。对于单核处理器，则课认为是其CPU编号，对于多核处理器则可以是物理核、或者使用超线程技术虚拟的逻辑核<br>vendor_id　：CPU制造商<br>cpu family　：CPU产品系列代号<br>model　　　：CPU属于其系列中的哪一代的代号<br>model name：CPU属于的名字及其编号、标称主频<br>stepping　 ：CPU属于制作更新版本<br>cpu MHz　 ：CPU的实际使用主频<br>cache size  ：CPU二级缓存大小<br>physical id  ：单个CPU的标号<br>siblings    ：单个CPU逻辑物理核数<br>core id    ：当前物理核在其所处CPU中的编号，这个编号不一定连续<br>cpu cores  ：该逻辑核所处CPU的物理核数<br>apicid     ：用来区分不同逻辑核的编号，系统中每个逻辑核的此编号必然不同，此编号不一定连续<br>fpu       ：是否具有浮点运算单元（Floating Point Unit）<br>fpu_exception ：是否支持浮点计算异常<br>cpuid level  ：执行cpuid指令前，eax寄存器中的值，根据不同的值<a href="http://en.wikipedia.org/wiki/CPUID" target="_blank" rel="noopener">cpuid</a>指令会返回不同的内容<br>wp       ：表明当前CPU是否在内核态支持对用户空间的写保护（Write Protection）<br>flags     ：当前CPU支持的功能<br><a href="http://en.wikipedia.org/wiki/Bogomips" target="_blank" rel="noopener">bogomips</a>  ：在系统内核启动时粗略测算的CPU速度（Million Instructions Per Second）<br>clflush size ：每次刷新缓存的大小单位<br>cache_alignment ：缓存地址对齐单位<br>address sizes   ：可访问地址空间位数<br>power management ：对能源管理的支持，有以下几个可选支持功能：</p>
<p>　　ts：　　temperature sensor</p>
<p>　　fid：　 frequency id control</p>
<p>　　vid：　 voltage id control</p>
<p>　　ttp：　 thermal trip</p>
<p>　　tm：</p>
<p>　　stc：</p>
<p>　　100mhzsteps：</p>
<p>　　hwpstate：</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>移动0</title>
    <url>/2020/02/24/%E7%A7%BB%E5%8A%A80/</url>
    <content><![CDATA[<p>来源Leetcode第283题移动0</p>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。<br><a id="more"></a><br><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>:</p>
<ol>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ol>
<hr>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>遍历一次数组，将非空元素入队，之后出队按序填充数组，数组剩下的元素赋0.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            que.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">        nums[i++] = que.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; nums.length;i++)</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双指针I"><a href="#双指针I" class="headerlink" title="双指针I"></a>双指针I</h3><p>用一个指针记录当前非0元素的位置，另一个指针用于遍历数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)</span><br><span class="line">            nums[pos++] = nums[i];</span><br><span class="line">    <span class="keyword">for</span>(;pos &lt; nums.length;pos++)</span><br><span class="line">        nums[pos] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双指针II"><a href="#双指针II" class="headerlink" title="双指针II"></a>双指针II</h3><p>如果当前元素是非 0 的，那么它的正确位置最多可以是当前位置或者更早的位置。如果是后者，则当前位置最终将被非 0 或 0 占据，该非 0 或 0 位于大于 “cur” 索引的索引处。我们马上用 0 填充当前位置，这样不像以前的解决方案，我们不需要在下一个迭代中回到这里。</p>
<p>换句话说，代码将保持以下不变：</p>
<blockquote>
<ol>
<li>慢指针（lastnonzerofoundat）之前的所有元素都是非零的。</li>
<li>当前指针和慢速指针之间的所有元素都是零。</li>
</ol>
</blockquote>
<p>因此，当我们遇到一个非零元素时，我们需要交换当前指针和慢速指针指向的元素，然后前进两个指针。如果它是零元素，我们只前进当前指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> , j = <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            temp = nums[j];</span><br><span class="line">            nums[j++] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>不同的二叉搜索树</title>
    <url>/2020/02/24/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p>来源Leetcode第96题不同的二叉搜索树</p>
<p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？<br><a id="more"></a><br><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释:</span><br><span class="line">给定 n = <span class="number">3</span>, 一共有 <span class="number">5</span> 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>         <span class="number">3</span>     <span class="number">3</span>      <span class="number">2</span>      <span class="number">1</span></span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span>      <span class="number">1</span>   <span class="number">3</span>      <span class="number">2</span></span><br><span class="line">    /     /       \                 \</span><br><span class="line">   <span class="number">2</span>     <span class="number">1</span>         <span class="number">2</span>                 <span class="number">3</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>来源<a href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/" target="_blank" rel="noopener">官方题解</a></p>
<p>给定一个有序序列 <code>1 ... n</code>，为了根据序列构建一棵二叉搜索树。我们可以遍历每个数字 <code>i</code>，将该数字作为树根，<code>1 ... (i-1)</code> 序列将成为左子树，<code>(i+1) ... n</code> 序列将成为右子树。于是，我们可以递归地从子序列构建子树。<br>在上述方法中，由于根各自不同，每棵二叉树都保证是独特的。</p>
<p>可见，问题可以分解成规模较小的子问题。因此，我们可以存储并复用子问题的解，而不是递归的（也重复的）解决这些子问题，这就是动态规划法。</p>
<p>假设n个节点存在二叉排序树的个数是G(n)，令f(i)为以i为根的二叉搜索树的个数，则<em>G</em>(<em>n</em>)=<em>f</em>(1)+<em>f</em>(2)+<em>f</em>(3)+<em>f</em>(4)+…+<em>f</em>(<em>n</em>)</p>
<p>当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则<br>f(i) = G(i−1)\∗G(n−i)</p>
<p>综合两个公式可以得到 <a href="https://baike.baidu.com/item/卡特兰数" target="_blank" rel="noopener">卡特兰数</a> 公式<em>G</em>(<em>n</em>)=<em>G</em>(0)∗<em>G</em>(<em>n</em>−1)+<em>G</em>(1)∗(<em>n</em>−2)+…+<em>G</em>(<em>n</em>−1)∗<em>G</em>(0)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Note: we should use long here instead of int, otherwise overflow</span></span><br><span class="line">    <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ans = ans * <span class="number">2</span> * (<span class="number">2</span> * i + <span class="number">1</span>) / (i + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>子集II</title>
    <url>/2020/02/18/%E5%AD%90%E9%9B%86II/</url>
    <content><![CDATA[<p>来自Leetcode第90题子集II</p>
<p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。</p>
<p><strong>说明：</strong>解集不能包含重复的子集。<br><a id="more"></a><br><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>判断当前数字和上一个数字是否相同，相同的话跳过即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; an = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span>[] num;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">this</span>.num = nums;</span><br><span class="line">    helper(<span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> an;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> start,List&lt;Integer&gt; tmp)</span></span>&#123;</span><br><span class="line">    an.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; num.length; i++)&#123;</span><br><span class="line">        <span class="comment">//和上个数字相等就跳过</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; start &amp;&amp; num[i] == num[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        tmp.add(num[i]);</span><br><span class="line">        helper(i + <span class="number">1</span>,tmp);</span><br><span class="line">        tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p><a href="https://leetcode-cn.com/problems/subsets-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-19/" target="_blank" rel="noopener">来自</a></p>
<p>先考虑 0 个数字的所有子串，再考虑 1 个的所有子串，再考虑 2 个的所有子串。而求 n 个的所有子串，就是 【n - 1 的所有子串】和 【n - 1 的所有子串加上 n】。当有重复数字的时候，我们只考虑上一步的新解，算法中用一个指针保存每一步的新解开始的位置即可。</p>
<p><img src="/2020/02/18/子集II/87ba90075a0a54e867ee05a65612d6f00766624c9f50f92beb9004e8b5a3ff27-image.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;());<span class="comment">// 初始化空数组</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>; <span class="comment">//保存新解的开始位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans_tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历之前的所有结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ans.size(); j++) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = ans.get(j);</span><br><span class="line">            <span class="comment">//如果出现重复数字，就跳过所有旧解</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; j &lt; start) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(list);</span><br><span class="line">            tmp.add(nums[i]); <span class="comment">// 加入新增数字</span></span><br><span class="line">            ans_tmp.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        start = ans.size(); <span class="comment">//更新新解的开始位置</span></span><br><span class="line">        ans.addAll(ans_tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种思路，参考<a href="https://leetcode.com/problems/subsets-ii/discuss/30168/C%2B%2B-solution-and-explanation" target="_blank" rel="noopener">这里</a>，当有重复数字出现的时候我们不再按照之前的思路走，而是单独考虑这种情况。</p>
<p>当有 n 个重复数字出现，其实就是在出现重复数字之前的所有解中，分别加 1 个重复数字， 2 个重复数字，3 个重复数字 … 什么意思呢，看一个例子。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">数组 [ <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> ] </span><br><span class="line">[ ]的所有子串 [ ]</span><br><span class="line">[ <span class="number">1</span> ] 个的所有子串 [ ] [ <span class="number">1</span> ] </span><br><span class="line">然后出现了重复数字 <span class="number">2</span>，那么我们记录重复的次数。然后遍历之前每个解即可</span><br><span class="line">对于 [ ] 这个解，</span><br><span class="line">加 <span class="number">1</span> 个 <span class="number">2</span>，变成 [ <span class="number">2</span> ] </span><br><span class="line">加 <span class="number">2</span> 个 <span class="number">2</span>，变成 [ <span class="number">2</span> <span class="number">2</span> ]</span><br><span class="line">加 <span class="number">3</span> 个 <span class="number">2</span>，变成 [ <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> ]</span><br><span class="line">对于 [ <span class="number">1</span> ] 这个解</span><br><span class="line">加 <span class="number">1</span> 个 <span class="number">2</span>，变成 [ <span class="number">1</span> <span class="number">2</span> ] </span><br><span class="line">加 <span class="number">2</span> 个 <span class="number">2</span>，变成 [ <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> ]</span><br><span class="line">加 <span class="number">3</span> 个 <span class="number">2</span>，变成 [ <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> ]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; empty = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    result.add(empty);</span><br><span class="line">    Arrays.sort(num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> dupCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断当前是否是重复数字，并且记录重复的次数</span></span><br><span class="line">        <span class="keyword">while</span>( ((i+<span class="number">1</span>) &lt; num.length) &amp;&amp; num[i+<span class="number">1</span>] == num[i]) &#123;</span><br><span class="line">            dupCount++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> prevNum = result.size();</span><br><span class="line">        <span class="comment">//遍历之前几个结果的每个解</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prevNum; j++) &#123;</span><br><span class="line">            List&lt;Integer&gt; element = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(result.get(j));</span><br><span class="line">            <span class="comment">//每次在上次的结果中多加 1 个重复数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= dupCount; t++) &#123;</span><br><span class="line">                element.add(num[i]); <span class="comment">//加入当前重复的数字</span></span><br><span class="line">                result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(element));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p><a href="https://leetcode-cn.com/problems/subsets-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-19/" target="_blank" rel="noopener">来自</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>n皇后</title>
    <url>/2020/02/18/n%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<p>来自Leetcode第51题n皇后</p>
<p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src="/2020/02/18/n皇后/8-queens.png" alt="img"><br><a id="more"></a><br>上图为 8 皇后问题的一种解法。</p>
<p>给定一个整数 <em>n</em>，返回所有不同的 <em>n</em> 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 <em>n</em> 皇后问题的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p>
<p><strong>示例:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: 4</span></span><br><span class="line"><span class="section">输出: [</span></span><br><span class="line"> [<span class="string">".Q.."</span>,  // 解法 1</span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"..Q."</span>],</span><br><span class="line"></span><br><span class="line"> [<span class="string">"..Q."</span>,  // 解法 2</span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">".Q.."</span>]</span><br><span class="line">]</span><br><span class="line"><span class="section">解释: 4 皇后问题存在两个不同的解法。</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>逐行放置皇后，检查第y列和(x,y)所在的两条斜线上是否有皇后即可。</p>
<ol>
<li>检查第y列是否有皇后，比对纵坐标即可；</li>
<li>检查(x,y)所在的两条斜线上是否有皇后：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; que = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ;j++)</span><br><span class="line">                board[i][j] = <span class="string">'.'</span>;  <span class="comment">//棋盘初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] queens = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            queens[i] = -<span class="number">1</span>;  <span class="comment">//皇后位置初始化</span></span><br><span class="line">        backtrack(board,<span class="number">0</span>,queens);</span><br><span class="line">        <span class="keyword">return</span> que;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> x,<span class="keyword">int</span>[] queue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == board.length)&#123;</span><br><span class="line">            <span class="comment">//有效解</span></span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span>[] row : board)</span><br><span class="line">                list.add(<span class="keyword">new</span> String(row));</span><br><span class="line">            que.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span> ; y &lt; board.length;y++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(can(board,x,y,queue))&#123;</span><br><span class="line">                board[x][y] = <span class="string">'Q'</span>;</span><br><span class="line">                queue[x] = y ;<span class="comment">// 放置皇后</span></span><br><span class="line">                backtrack(board,x + <span class="number">1</span>,queue); <span class="comment">//开始回溯</span></span><br><span class="line">                <span class="comment">//取消上一次的尝试</span></span><br><span class="line">                board[x][y] = <span class="string">'.'</span>;</span><br><span class="line">                queue[x] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查能否放置皇后</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">can</span> <span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span>[] queen)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y == board.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> dx,dy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; x; i++)&#123;</span><br><span class="line">            dy = y - queen[i];</span><br><span class="line">            <span class="keyword">if</span>(dy == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//同一列上有皇后</span></span><br><span class="line">            dx = x - i;</span><br><span class="line">            <span class="keyword">if</span>(dx == dy || dx == -dy)  <span class="comment">//对角线</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>补一个位运算的版本，看的不是很懂，不过这是针对下一题就总共解法的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dfs(n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> ld, <span class="keyword">int</span> rd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &gt;= n) &#123; res++; <span class="keyword">return</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> bits = ~(col | ld | rd) &amp; ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (bits &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pick = bits &amp; -bits;</span><br><span class="line">            dfs(n, row + <span class="number">1</span>, col | pick, (ld | pick) &lt;&lt; <span class="number">1</span>, (rd | pick) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            bits &amp;= bits - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>GTK入门学习</title>
    <url>/2020/02/18/GTK%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="一个简单的空白窗口"><a href="#一个简单的空白窗口" class="headerlink" title="一个简单的空白窗口"></a>一个简单的空白窗口</h3><a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line">	gtk_widget_show(window);</span><br><span class="line"></span><br><span class="line">	gtk_main();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写完代码后，我们对代码进程编译，直接用gcc编译即可，但是需要加上<code>pkg-config --cflags --libs gtk+-3.0</code></p>
<p>pkg-config 是一个为已经安装的包提供了include，以及实际库安装的位置编译选项的输出和管理的工具；</p>
<p>—cflags 选项作用为自动获得预处理参数，如宏定义，头文件的位置；</p>
<p>—libs 选项作用为自动获得链接参数，如库及依赖的其它库的位置，文件名及其它一些连接参数；</p>
<p>gtk+-3.0 选项作用为指定GTK版本。</p>
<p>具体编译命令如下：<br>gcc  demo.c  -o  demo  <code>pkg-config --cflags --libs gtk+-2.0</code></p>
<p>头文件〈gtk/gtk.h&gt; 包括了GTK+中所有的控件、变量、函数和结构的声明。</p>
<p><code>gtk_init (&amp;argc, &amp;argv);</code>所有 GTK应用程序都要调用该函数，而且必须在控件定义之前使用，它为我们设置一些缺省值( 例如视觉和颜色 )映射这个函数将函数库初始化，设置缺省的信号处理函数，并检查通过命令行传递给应用程序的参数，自动完成一些必要的初始化工作。</p>
<p><code>gtk_main()</code>是在每个Gtk应用程序都要调用的函数。程序运行停在这里等待事件(如键盘事件或鼠标事件)的发生，等待用户来操作窗口。</p>
<p><code>GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
gtk_window_new()</code>的功能创建一个窗口并返回这个窗口的控件指针。GTK_WINDOW_TOPLEVEL指明窗口的类型为最上层的主窗口，它最常用。接着创建一个GtkWidget *类型的window变量来接收。GtkWidget是GTK+控件类型，GtkWidget * 能指向任何控件的指针类型。</p>
<p><code>gtk_widget_show(window)；</code>用来显示上一步创建的窗口控件。<br>在这个简单例子里，所有事件都被忽略。用鼠标点击窗口右上角的“×”按钮也不能将窗口关闭。我们可以在终端敲 Ctrl + C 关闭程序。</p>
<h3 id="控件的添加"><a href="#控件的添加" class="headerlink" title="控件的添加"></a>控件的添加</h3><p>控件是对数据和方法的封装。控件有自己的属性和方法。属性是指控件的特征。方法是指控件的一些简单而可见的功能。如按钮就是一个控件，这个按钮是方形的，里面有张图片，这是我们能看到外观属性，同时，这个按钮具备被人按下的功能。</p>
<p>GTK中控件主要分为两类：<strong>容器控件</strong>，<strong>非容器控件</strong>。</p>
<p>容器控件：它可以容纳别的控件，我们可以理解为盒子，盒子拿来装东西。容器控件又分为两类，一类<strong>只能容纳一个控件</strong>，如窗口，按钮；另一类<strong>能容纳多个控件</strong>，如布局控件。</p>
<p>非容器控件：它不可以容纳别的控件，如标签、行编辑。</p>
<p>前面我们写的空白窗口是能容纳一个控件的控件，现在我们要做的是，给这个窗口添加一个按钮。</p>
<p>首先，我们需要创建一个按钮，然后需要把按钮添加到窗口，接着，显示按钮控件。</p>
<p><strong>按钮的创建：</strong><br><code>GtkWidget *gtk_button_new_with_label(const gchar *label);</code><br>label：按钮上的字符串类型，gchar相当于C语言的char<br>返回值：按钮控件指针</p>
<p><strong>容器添加控件：</strong><br><code>void gtk_container_add(GtkContainer *container, GtkWidget *widget);</code><br>container：容纳控件的容器<br>widget：要添加的控件</p>
<p><strong>显示控件：</strong><br><code>void gtk_widget_show(GtkWidget *widget);</code><br>widget：需要显示的控件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv);   <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);  <span class="comment">//创建顶层窗口</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建按钮，文本信息为"Hello World"</span></span><br><span class="line">	GtkWidget* button = gtk_button_new_with_label(<span class="string">"Hello World"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把按钮放入窗口(窗口也是一种容器)</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(window), button);</span><br><span class="line"></span><br><span class="line">	gtk_widget_show(button);	<span class="comment">// 显示按钮</span></span><br><span class="line">	gtk_widget_show(window);	<span class="comment">// 显示窗口</span></span><br><span class="line"></span><br><span class="line">	gtk_main();		<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码分析：</p>
<p><code>void gtk_container_add(GtkContainer *container, GtkWidget *widget);</code><br>这里我们是把按钮添加到窗口容器里，widget为按钮指针(以上代码的button)，container为窗口指针(以上代码的window)，这里需要注意的是，我们创建的窗口(window)返回值为GtkWidget *类型，而gtk_container_add()的第一个参数为GtkContainer *类型，由于 GtkWidget *类型的变量为指向任何控件的万能指针，所以，在函数传参时，根据参数类型进行相应的转换，如：<code>gtk_container_add( (GtkContainer *)window, button);</code></p>
<p>C语言里，我们常用这种方法转换。在GTK中，很多内部变量指针类型转换都定义了宏定义，如：<code>#define GTK_CONTAINER(x) (GtkContainer *)(x)</code></p>
<p>所以，我们还可以这么写：<code>gtk_container_add(GTK_CONTAINER(window), button);</code></p>
<p>那么，我们如何知道，哪个类型对应哪个宏定义呢？把要转换类型名字全部变为大写，同时，单词和单词之间以下划线“_”连接，然后，这个名字就是哪个宏定义的名字，如，(GtkButton *)x用宏定义的方法为 GTK_BUTTON(x)。</p>
<p>假如窗口里有100个控件，还是这样一个一个地显示出来会比较麻烦，这时候，我们可以通过<code>gtk_widget_show_all()</code>显示所有的控件，里面需要传的是容纳控件的那个容器(这里为窗口)。这样，容器上的控件也会跟着显示。</p>
<p><code>gtk_widget_show_all(window);// 显示窗口上的所有控件</code></p>
<h3 id="布局容器"><a href="#布局容器" class="headerlink" title="布局容器"></a>布局容器</h3><p>如果我们希望窗口里多放添加几个控件，直接添加是不成功的，因为窗口只能容纳一个控件的容器。这时候，我们需要借助布局容器，我们先把布局容器添加到窗口里，然后再把所需要添加的控件放在布局容器里。</p>
<p>布局容器的主要分类：水平布局( GtkHBox)、垂直布局(GtkVBox )、表格布局(GtkTable)、固定布局(GtkFixed )。</p>
<h4 id="水平布局"><a href="#水平布局" class="headerlink" title="水平布局"></a>水平布局</h4><p><strong>水平布局容器的创建：</strong><br><code>GtkWidget *gtk_hbox_new( gboolean homogeneous,  gint spacing );</code><br>homogeneous：容器内控件是否大小一致( gboolean 取值为TRUE 或 FALSE )<br>spacing：控件之间的间隔( 以像素点为单位 )，gint相当于 C语言的int<br>返回值：水平布局控件指针</p>
<p><strong>容器添加添加控件：</strong><br><code>void gtk_container_add(GtkContainer *container, GtkWidget *widget);</code><br>container：容纳控件的容器<br>widget：要添加的控件</p>
<p><strong>显示容器上所有控件</strong><br><code>void gtk_widget_show_all(GtkWidget *widget);</code><br>widget：需要显示的控件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv);   <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);  <span class="comment">//创建顶层窗口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建水平布局容器</span></span><br><span class="line">	GtkWidget* hbox = gtk_hbox_new(TRUE, <span class="number">10</span>);</span><br><span class="line">	<span class="comment">// 把容器添加到窗口</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(window), hbox);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// button1</span></span><br><span class="line">	GtkWidget* button = gtk_button_new_with_label(<span class="string">"button1"</span>);</span><br><span class="line">	gtk_container_add(GTK_CONTAINER(hbox), button); <span class="comment">// 按钮添加到水平布局容器里</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// button2</span></span><br><span class="line">	button = gtk_button_new_with_label(<span class="string">"button2"</span>);</span><br><span class="line">	gtk_container_add(GTK_CONTAINER(hbox), button); <span class="comment">// 按钮添加到水平布局容器里</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// button3</span></span><br><span class="line">	button = gtk_button_new_with_label(<span class="string">"button3"</span>);</span><br><span class="line">	gtk_container_add(GTK_CONTAINER(hbox), button); <span class="comment">// 按钮添加到水平布局容器里</span></span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window); <span class="comment">// 显示所有控件</span></span><br><span class="line"></span><br><span class="line">	gtk_main();		<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="垂直布局"><a href="#垂直布局" class="headerlink" title="垂直布局"></a>垂直布局</h4><p>垂直布局和水平布局的用法基本是一样，无非是新建垂直布局容器接口，还有控件摆放的方向不同。</p>
<p><strong>垂直布局容器的创建：</strong><br><code>GtkWidget *gtk_vbox_new( gboolean homogeneous,  gint spacing );</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv);   <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);  <span class="comment">//创建顶层窗口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建垂直布局容器</span></span><br><span class="line">	GtkWidget* hbox = gtk_vbox_new(TRUE, <span class="number">10</span>);</span><br><span class="line">	<span class="comment">// 把容器添加到窗口</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(window), hbox);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// button1</span></span><br><span class="line">	GtkWidget* button = gtk_button_new_with_label(<span class="string">"button1"</span>);</span><br><span class="line">	gtk_container_add(GTK_CONTAINER(hbox), button); <span class="comment">// 按钮添加到水平布局容器里</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// button2</span></span><br><span class="line">	button = gtk_button_new_with_label(<span class="string">"button2"</span>);</span><br><span class="line">	gtk_container_add(GTK_CONTAINER(hbox), button); <span class="comment">// 按钮添加到水平布局容器里</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// button3</span></span><br><span class="line">	button = gtk_button_new_with_label(<span class="string">"button3"</span>);</span><br><span class="line">	gtk_container_add(GTK_CONTAINER(hbox), button); <span class="comment">// 按钮添加到水平布局容器里</span></span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window); <span class="comment">// 显示所有控件</span></span><br><span class="line"></span><br><span class="line">	gtk_main();		<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h4><p>学习水平和垂直布局容器后，我们几乎能布出任何风格的布局，只需要嵌套使用水平布局容器和垂直布局容器即可。假如我们要完成下图的布局，我们该怎么做呢？</p>
<p><img src="/2020/02/18/GTK入门学习/20150115175419264" alt="img"></p>
<p>1）创建一个垂直布局容器( A )<br>2）创建一个水平布局容器( B )，一个close按钮( C )<br>3）将水平布局容器和close按钮添加到垂直布局容器里( 将 B 和 C 添加到 A )<br>4）创建button 1按钮( D ) 和 button 2按钮( E )<br>5）再将button 1按钮 和 button 2按钮添加到水平布局容器里( 将 D 和 E 添加到 B )</p>
<p>这样是可以完成上图的布局，但是，假如布局里有有很多控件，我们只是通过水平和垂直容器嵌套布局会很麻烦，而且，控件越多，布局越麻烦。有没有更简单的方法呢？有，就是我们马上要学习的表格布局，具体的操作流程和水平垂直布局一样。</p>
<p><strong>表格布局容器的创建：</strong><br><code>GtkWidget *gtk_table_new(guint rows, guint columns, gboolean homogeneous );</code><br>rows: 行数<br>coumns: 列数<br>homogeneous：容器内表格的大小是否相等<br>返回值：表格布局容器指针</p>
<p><strong>布局容器添加控件：</strong><br><code>void gtk_table_attach_defaults(GtkTable *table, GtkWidget *widget,guint left_attach,guint right_attach,guint top_attach,guint bottom_attach );</code><br>table:  容纳控件的容器<br>widget: 要添加的控件？<br>后四个参数为控件摆放的坐标，规则如下：<br><img src="/2020/02/18/GTK入门学习/20150115175902717" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv);   <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);  <span class="comment">//创建顶层窗口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	GtkWidget* table = gtk_table_new(<span class="number">2</span>, <span class="number">2</span>, TRUE);	<span class="comment">// 表格布局，2行2列</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(window), table); <span class="comment">// 容器加入窗口</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// button1</span></span><br><span class="line">	GtkWidget* button = gtk_button_new_with_label(<span class="string">"button1"</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">// 把按钮加入布局</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// button2</span></span><br><span class="line">	button = gtk_button_new_with_label(<span class="string">"button2"</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// button3</span></span><br><span class="line">	button = gtk_button_new_with_label(<span class="string">"button3"</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window); <span class="comment">// 显示所有控件</span></span><br><span class="line"></span><br><span class="line">	gtk_main();		<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="固定布局"><a href="#固定布局" class="headerlink" title="固定布局"></a>固定布局</h4><p>前面我们学习的水平、垂直和表格布局容器，控件会跟着容器大小的变化进行自动适应，而固定布局容器里的控件则不会跟着变化( 则固定不变 )。</p>
<p><strong>固定布局的创建：</strong><br><code>GtkWidget *gtk_fixed_new(void);</code><br>返回值：固定布局容器指针</p>
<p><strong>固定布局容器添加控件：</strong><br>void gtk_fixed_put( GtkFixed <em>fixed,GtkWidget </em>widget,gint x,gint y );<br>fixed：容纳控件的容器<br>widget：要添加的控件<br>x, y：控件摆放位置的起点坐标</p>
<p><strong>设置控件的大小( 宽和高 )：</strong><br><code>void gtk_widget_set_size_request(GtkWidget *widget,gint width,gint height );</code><br>widget：需要设置的控件<br>width：宽度<br>height：高度</p>
<p><strong>移动固定布局里控件的位置：</strong><br><code>void gtk_fixed_move(   GtkFixed *fixed,GtkWidget *widget,gint x,gint y);</code><br>fixed：固定布局容器<br>widget：需要移动的控件<br>x, y: 移动的位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv);   <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);  <span class="comment">//创建顶层窗口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	GtkWidget* fixed = gtk_fixed_new(); 	<span class="comment">//创建一个固定容器</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(window), fixed); <span class="comment">// 固定放进窗口</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// button1</span></span><br><span class="line">	GtkWidget* button = gtk_button_new_with_label(<span class="string">"button1"</span>);</span><br><span class="line">	gtk_fixed_put(GTK_FIXED(fixed), button, <span class="number">50</span>, <span class="number">50</span>); <span class="comment">// 按钮添加到固定布局</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// button2</span></span><br><span class="line">	GtkWidget*  button2 = gtk_button_new_with_label(<span class="string">"button2"</span>);</span><br><span class="line">	gtk_fixed_put(GTK_FIXED(fixed), button2, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 按钮添加到固定布局</span></span><br><span class="line">	gtk_fixed_move(GTK_FIXED(fixed), button2, <span class="number">150</span>, <span class="number">150</span>); <span class="comment">// 移动控件的位置</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// button3</span></span><br><span class="line">	<span class="comment">//GtkWidget*  button3 = gtk_button_new_with_label("button3");</span></span><br><span class="line">	gtk_widget_set_size_request(button2, <span class="number">100</span>, <span class="number">50</span>); <span class="comment">// 设置控件的大小</span></span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window); <span class="comment">// 显示所有控件</span></span><br><span class="line"></span><br><span class="line">	gtk_main();		<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="行编辑控件"><a href="#行编辑控件" class="headerlink" title="行编辑控件"></a>行编辑控件</h3><p><strong>行编辑的创建：</strong><br><code>GtkWidget * gtk_entry_new(void);</code><br>返回值：行编辑指针行</p>
<p><strong>编辑内容的设置：</strong><br><code>void gtk_entry_set_text (GtkEntry *entry,const gchar *text);</code><br>entry: 行编辑<br>text: 需要设置的内容</p>
<p><strong>设置行编辑是否允许编辑：</strong><br><code>void gtk_editable_set_editable(GtkEditable *editable, gboolean is_editable);</code><br>editable：行编辑<br>is_editable：TRUE代表可编辑，FALSE不允许编辑</p>
<p>表格布局练习之计算器<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt; 	// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>   argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv); 	<span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 窗口的操作</span></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL); 	 <span class="comment">// 创建窗口 </span></span><br><span class="line">	gtk_widget_set_size_request(window, <span class="number">270</span>, <span class="number">320</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 表格的操作</span></span><br><span class="line">	GtkWidget* table = gtk_table_new(<span class="number">5</span>, <span class="number">4</span>, TRUE);   <span class="comment">// 表格布局，5行4列  </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 行编辑的操作</span></span><br><span class="line">	GtkWidget* entry = gtk_entry_new();		<span class="comment">// 行编辑的创建</span></span><br><span class="line">	gtk_entry_set_text(GTK_ENTRY(entry), <span class="string">"2+2=4"</span>);	<span class="comment">// 给行编辑设置内容</span></span><br><span class="line">	gtk_editable_set_editable(GTK_EDITABLE(entry), FALSE);<span class="comment">// 设置行编辑不允许编辑，只做显示用</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按钮的操作</span></span><br><span class="line">	GtkWidget* button0 = gtk_button_new_with_label(<span class="string">"0"</span>);	<span class="comment">// 按钮0</span></span><br><span class="line">	GtkWidget* button1 = gtk_button_new_with_label(<span class="string">"1"</span>);	<span class="comment">// 按钮1</span></span><br><span class="line">	GtkWidget* button2 = gtk_button_new_with_label(<span class="string">"2"</span>);	<span class="comment">// 按钮2</span></span><br><span class="line">	GtkWidget* button3 = gtk_button_new_with_label(<span class="string">"3"</span>);	<span class="comment">// 按钮3</span></span><br><span class="line">	GtkWidget* button4 = gtk_button_new_with_label(<span class="string">"4"</span>);	<span class="comment">// 按钮4</span></span><br><span class="line">	GtkWidget* button5 = gtk_button_new_with_label(<span class="string">"5"</span>);	<span class="comment">// 按钮5</span></span><br><span class="line">	GtkWidget* button6 = gtk_button_new_with_label(<span class="string">"6"</span>);	<span class="comment">// 按钮6</span></span><br><span class="line">	GtkWidget* button7 = gtk_button_new_with_label(<span class="string">"7"</span>);	<span class="comment">// 按钮7</span></span><br><span class="line">	GtkWidget* button8 = gtk_button_new_with_label(<span class="string">"8"</span>);	<span class="comment">// 按钮8</span></span><br><span class="line">	GtkWidget* button9 = gtk_button_new_with_label(<span class="string">"9"</span>);	<span class="comment">// 按钮9</span></span><br><span class="line">	GtkWidget* button_add = gtk_button_new_with_label(<span class="string">"+"</span>);			<span class="comment">// 加</span></span><br><span class="line">	GtkWidget* button_minus = gtk_button_new_with_label(<span class="string">"-"</span>);	 	<span class="comment">// 减</span></span><br><span class="line">	GtkWidget* button_multiply = gtk_button_new_with_label(<span class="string">"*"</span>);	<span class="comment">// 乘</span></span><br><span class="line">	GtkWidget* button_divide = gtk_button_new_with_label(<span class="string">"/"</span>);		<span class="comment">// 除</span></span><br><span class="line">	GtkWidget* button_equal = gtk_button_new_with_label(<span class="string">"="</span>);		<span class="comment">// 等于</span></span><br><span class="line">	GtkWidget* button_detele = gtk_button_new_with_label(<span class="string">"c"</span>);		<span class="comment">// 退格</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 布局操作</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(window), table); <span class="comment">// 表格放入窗口 </span></span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), entry, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>);	<span class="comment">// 行编辑放入表格</span></span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button0, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>);<span class="comment">// 按钮放入表格</span></span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button1, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button2, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button3, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button4, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button5, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button6, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button7, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button8, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button9, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button_add, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button_minus, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button_multiply, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button_divide, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button_equal, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button_detele, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window);  <span class="comment">// 显示所有控件</span></span><br><span class="line"></span><br><span class="line">	gtk_main();  <span class="comment">//进入事件循环 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="信号与回调函数"><a href="#信号与回调函数" class="headerlink" title="信号与回调函数"></a>信号与回调函数</h3><p>前面我们学习的GTK界面都是静态的，我们按下按钮它是没有响应的，如何让它有响应呢？接下来我们一起学习GTK的信号与回调函数。</p>
<p>GTK采用了信号与回调函数来处理窗口外部传来的事件、消息或信号。当信号发生时，程序自动调用为信号连接的回调函数。</p>
<p>学习应用编程，我们会经常接触到“信号”这个名词。GTK中的“信号”实际上是一种软件中断。“中断”在我们生活中经常遇到，譬如，我正在房间里打游戏，突然送快递的来了，把正在玩游戏的我给“中断”了，我去签收快递( 处理中断 )，处理完成后，再继续玩我的游戏。<strong>GTK中的“信号”就是属于这么一种“中断”，当用户按下按钮的时候，就产生一个“中断”，相当于产生一个信号，接着就会处理这么一个“中断任务”(程序里体验为调用一个函数)。</strong></p>
<p>“信号”在GTK中可以认为一种中断的标志，如按下按钮的标志为”pressed”,释放按钮的标志为”released”，<strong>这些标志就相当于 C 语言的关键字一样，我们使用的时候必须完全按照它的名字来写。</strong>需要注意的是，每个控件的信号标志不一定都一样，如按钮（GtkButton）里有”pressed”信号，窗口(GtkWindow)里就没这个信号，每个控件具体有哪个信号，应该查看帮助文档来确定。</p>
<p>按钮的常用信号：</p>
<ul>
<li>“clicked” : 按下按钮时触发</li>
<li>“pressed” : 释放按钮时触发</li>
<li>“released” : 释放按钮时触发</li>
</ul>
<p>对于程序而言，我们按下按钮，是让其调用一个函数。假如有函数A, B, C，我们如何确定按下按钮后只调用函数A，而不是函数 B 或 C。这时候，我们需要一种规则规定，按下按钮后就调用函数A，就像交通规则一样，红灯走绿灯行，信号注册函数就是做这样的事情。</p>
<p><strong>信号注册函数：</strong><br><code>gulong g_signal_connect( gpointer instance,const gchar *detailed_signal,GCallback c_handler, gpointer data );</code><br>instance：信号发出者，可以认为我们操作的控件，如按下按钮，这个就为按钮指针<br>detailed_signal：信号标志，如”pressed”<br>c_handler：回调函数的名称，需要用G_CALLBACK()进行转换<br>data：给回调函数传的参数，gpointer 相当于C语言的 void *<br>返回值：注册函数的标志</p>
<p>如：<br><code>g_signal_connect(button, &quot;pressed&quot;,G_CALLBACK(callback), NULL);</code></p>
<p>当按下button按钮时，就会自动调用回调函数callback(相当于处理中断任务)，回调函数callback可以是任意函数，函数名字我们根据需要自行命名，如果不是库函数，我们还得定义这个回调函数，这里需要注意的是，回调函数的写法(返回值，参数)，不是我们想怎么写就怎么写，帮助文档里已经规定好了回调函数应该如何写，如果不按规定来写，可能产生意想不到的错误。</p>
<p><a href="http://blog.csdn.net/tennysonsky/article/details/42778635" target="_blank" rel="noopener">帮助文档的使用请点此处。</a></p>
<p><strong>回调函数的定义：</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(GtkButton *button,gpointer data)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>设置容器与控件之间的间距：</strong><br><code>void gtk_container_set_border_width(GtkContainer *container,guint border_width);</code><br>container：容器<br>border_width：容器与控件之间的间距，guint相当于C语言的uint</p>
<p><strong>获取按钮上的文本内容：</strong><br><code>const gchar *gtk_button_get_label(GtkButton *button);</code><br>button：按钮<br>返回值：获取到的文本内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;	// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮按下的处理函数, gpointer 相当于 void *</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal_pressed</span><span class="params">(GtkButton* button, gpointer user_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// button指向main函数的button</span></span><br><span class="line">	<span class="comment">// user_data 指向main函数的"I am a button"</span></span><br><span class="line">	<span class="comment">// 获得按钮的文本信息</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* text = gtk_button_get_label(button);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s /////// %s\n"</span>, (<span class="keyword">char</span>*)user_data, text); <span class="comment">// 打印内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv);		<span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL); <span class="comment">// 创建顶层窗口</span></span><br><span class="line">	<span class="comment">// 设置窗口边框的宽度(窗口里的控件与窗口边框间隔为15)</span></span><br><span class="line">	gtk_container_set_border_width(GTK_CONTAINER(window), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	GtkWidget* button = gtk_button_new_with_label(<span class="string">"^_^"</span>); <span class="comment">// 创建按钮</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(window), button);<span class="comment">// 把按钮放入窗口(窗口也是一种容器)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 按钮按下(pressed)后会自动调用deal_pressed()</span></span><br><span class="line"><span class="comment">	 * "I am a button"是传给回调函数deal_pressed()的参数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	g_signal_connect(button, <span class="string">"pressed"</span>, G_CALLBACK(deal_pressed), <span class="string">"I am a button"</span>);</span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window);	<span class="comment">// 显示窗口全部控件</span></span><br><span class="line"></span><br><span class="line">	gtk_main();		<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GTK简单版计算器"><a href="#GTK简单版计算器" class="headerlink" title="GTK简单版计算器"></a>GTK简单版计算器</h3><p>接下来我们做一个简单版的计算器。</p>
<ol>
<li>获取按钮上的内容。</li>
<li>如果获取的内容是“ c ”，则代表进行退格操作，相当于删去最后一个字符。</li>
<li>如果获取的内容不是“ c ”，则把每一次获取的内容连接起来，如：第一次按了 “ 1 ”， 第二次按了 “ + ”， 第三次按了 “ 1 ”， 连起来则变为 “1+1”。</li>
<li>如果获取的内容是“ = ”，则需要相应的运算。先把连起来的字符串拆出来，然后再进行相应操作，最后把运算结果重新显示到行编辑上。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt; 	// 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">50</span>] = &#123; <span class="number">0</span> &#125;;	<span class="comment">//全局变量，保存数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal_num</span><span class="params">(GtkButton* button, gpointer data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* txt = gtk_button_get_label(button); <span class="comment">// 获取点击按钮的内容</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 退格操作</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(<span class="string">"c"</span>, txt)) &#123; <span class="comment">// 如果是退格键</span></span><br><span class="line">		buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 最后一个字符变为 0</span></span><br><span class="line">		<span class="comment">//gtk_entry_set_text(GTK_ENTRY(data), buf);	//重新给行编辑设定内容</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">char</span> c;</span><br><span class="line">		<span class="built_in">strcat</span>(buf, txt);	<span class="comment">// 内容追加</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 运算操作</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(<span class="string">"="</span>, txt)) &#123;	<span class="comment">// 如果是 " = "</span></span><br><span class="line">			<span class="built_in">sscanf</span>(buf, <span class="string">"%d%c%d"</span>, &amp;a, &amp;c, &amp;b);	<span class="comment">// 拆包</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"a=%d, c = %c, b=%d\n"</span>, a, c, b);</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">'+'</span> == c) &#123;</span><br><span class="line">				<span class="built_in">sprintf</span>(buf, <span class="string">"%d"</span>, a + b);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'-'</span> == c) &#123;</span><br><span class="line">				<span class="built_in">sprintf</span>(buf, <span class="string">"%d"</span>, a - b);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'*'</span> == c) &#123;</span><br><span class="line">				<span class="built_in">sprintf</span>(buf, <span class="string">"%d"</span>, a * b);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'/'</span> == c) &#123;</span><br><span class="line">				<span class="built_in">sprintf</span>(buf, <span class="string">"%d"</span>, a / b);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gtk_entry_set_text(GTK_ENTRY(data), buf);	<span class="comment">// 给行编辑设定内容</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>   argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv); 	<span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 窗口的操作</span></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL); 	 <span class="comment">// 创建窗口 </span></span><br><span class="line">	gtk_widget_set_size_request(window, <span class="number">270</span>, <span class="number">320</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 表格的操作</span></span><br><span class="line">	GtkWidget* table = gtk_table_new(<span class="number">5</span>, <span class="number">4</span>, TRUE);   <span class="comment">// 表格布局，5行4列  </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 行编辑的操作</span></span><br><span class="line">	GtkWidget* entry = gtk_entry_new();		<span class="comment">// 行编辑的创建</span></span><br><span class="line">	<span class="comment">//gtk_entry_set_text(GTK_ENTRY(entry), "2+2=4");	// 给行编辑设置内容</span></span><br><span class="line">	gtk_editable_set_editable(GTK_EDITABLE(entry), FALSE);<span class="comment">// 设置行编辑不允许编辑，只做显示用</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按钮的操作</span></span><br><span class="line">	GtkWidget* button0 = gtk_button_new_with_label(<span class="string">"0"</span>);	<span class="comment">// 按钮0</span></span><br><span class="line">	GtkWidget* button1 = gtk_button_new_with_label(<span class="string">"1"</span>);	<span class="comment">// 按钮1</span></span><br><span class="line">	GtkWidget* button2 = gtk_button_new_with_label(<span class="string">"2"</span>);	<span class="comment">// 按钮2</span></span><br><span class="line">	GtkWidget* button3 = gtk_button_new_with_label(<span class="string">"3"</span>);	<span class="comment">// 按钮3</span></span><br><span class="line">	GtkWidget* button4 = gtk_button_new_with_label(<span class="string">"4"</span>);	<span class="comment">// 按钮4</span></span><br><span class="line">	GtkWidget* button5 = gtk_button_new_with_label(<span class="string">"5"</span>);	<span class="comment">// 按钮5</span></span><br><span class="line">	GtkWidget* button6 = gtk_button_new_with_label(<span class="string">"6"</span>);	<span class="comment">// 按钮6</span></span><br><span class="line">	GtkWidget* button7 = gtk_button_new_with_label(<span class="string">"7"</span>);	<span class="comment">// 按钮7</span></span><br><span class="line">	GtkWidget* button8 = gtk_button_new_with_label(<span class="string">"8"</span>);	<span class="comment">// 按钮8</span></span><br><span class="line">	GtkWidget* button9 = gtk_button_new_with_label(<span class="string">"9"</span>);	<span class="comment">// 按钮9</span></span><br><span class="line">	GtkWidget* button_add = gtk_button_new_with_label(<span class="string">"+"</span>);			<span class="comment">// 加</span></span><br><span class="line">	GtkWidget* button_minus = gtk_button_new_with_label(<span class="string">"-"</span>);	 	<span class="comment">// 减</span></span><br><span class="line">	GtkWidget* button_multiply = gtk_button_new_with_label(<span class="string">"*"</span>);	<span class="comment">// 乘</span></span><br><span class="line">	GtkWidget* button_divide = gtk_button_new_with_label(<span class="string">"/"</span>);		<span class="comment">// 除</span></span><br><span class="line">	GtkWidget* button_equal = gtk_button_new_with_label(<span class="string">"="</span>);		<span class="comment">// 等于</span></span><br><span class="line">	GtkWidget* button_detele = gtk_button_new_with_label(<span class="string">"c"</span>);		<span class="comment">// 退格</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 布局操作</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(window), table); <span class="comment">// 表格放入窗口 </span></span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), entry, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>);	<span class="comment">// 行编辑放入表格</span></span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button0, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>);	<span class="comment">// 按钮放入表格</span></span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button1, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button2, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button3, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button4, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button5, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button6, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button7, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button8, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button9, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button_add, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button_minus, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button_multiply, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button_divide, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button_equal, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">	gtk_table_attach_defaults(GTK_TABLE(table), button_detele, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册信号函数，把 entry 传给回调函数 deal_num()</span></span><br><span class="line">	g_signal_connect(button0, <span class="string">"pressed"</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">	g_signal_connect(button1, <span class="string">"pressed"</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">	g_signal_connect(button2, <span class="string">"pressed"</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">	g_signal_connect(button3, <span class="string">"pressed"</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">	g_signal_connect(button4, <span class="string">"pressed"</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">	g_signal_connect(button5, <span class="string">"pressed"</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">	g_signal_connect(button6, <span class="string">"pressed"</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">	g_signal_connect(button7, <span class="string">"pressed"</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">	g_signal_connect(button8, <span class="string">"pressed"</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">	g_signal_connect(button9, <span class="string">"pressed"</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">	g_signal_connect(button_add, <span class="string">"pressed"</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">	g_signal_connect(button_minus, <span class="string">"pressed"</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">	g_signal_connect(button_multiply, <span class="string">"pressed"</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">	g_signal_connect(button_divide, <span class="string">"pressed"</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">	g_signal_connect(button_equal, <span class="string">"pressed"</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line">	g_signal_connect(button_detele, <span class="string">"pressed"</span>, G_CALLBACK(deal_num), entry);</span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window);  <span class="comment">// 显示所有控件</span></span><br><span class="line"></span><br><span class="line">	gtk_main();  <span class="comment">//进入事件循环 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h3><h4 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h4><p><strong>窗口的创建</strong>：<br><code>GtkWidget *gtk_window_new(GtkWindowType type);</code><br>GtkWindowType是一个枚举，有两种情况：</p>
<ul>
<li>GTK_WINDOW_TOPLEVEL：顶层窗口，有边框</li>
<li>GTK_WINDOW_POPUP：  弹式窗口，没边框<br>返回值：窗口指针</li>
</ul>
<p><strong>标题的设置：</strong><br><code>void gtk_window_set_title(GtkWindow *window, const gchar *title);</code><br>window：窗口<br>title：标题</p>
<p><strong>控件最小大小的设置：</strong></p>
<p><code>void gtk_widget_set_size_request(GtkWidget *widget,gint width,gint height);</code><br>widget：需要操作的控件，可以是任何控件<br>width：宽度<br>height：高度</p>
<p><strong>窗口伸缩设置：</strong><br><code>void gtk_window_set_resizable(GtkWindow *window, gboolean resizable);</code><br>window：窗口<br>resizable：TURE默认属性，可伸缩，FALSE不可伸缩</p>
<p>显示或隐藏所有控件：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gtk_widget_show_all</span><span class="params">(GtkWidget *widget)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gtk_widget_hide_all</span><span class="params">(GtkWidget *widget)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>widget：控件</p>
<p>窗口在显示器位置的设置：<br><code>void gtk_window_set_position(GtkWindow *window, GtkWindowPosition position);</code><br>window：窗口<br>position常用有4种情况：<br>GTK_WIN_POS_NONE：  不固定<br>GTK_WIN_POS_CENTER: 居中<br>GTK_WIN_POS_MOUSE:  出现在鼠标位置<br>GTK_WIN_POS_CENTER_ALWAYS: 窗口总是居中 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;	// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv);		<span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建顶层窗口</span></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line">	<span class="comment">// 设置窗口的标题</span></span><br><span class="line">	gtk_window_set_title(GTK_WINDOW(window), <span class="string">"Window"</span>);</span><br><span class="line">	<span class="comment">// 设置窗口在显示器中的位置为居中</span></span><br><span class="line">	gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);</span><br><span class="line">	<span class="comment">// 设置窗口的最小大小</span></span><br><span class="line">	gtk_widget_set_size_request(window, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">	<span class="comment">// 固定窗口的大小</span></span><br><span class="line">	gtk_window_set_resizable(GTK_WINDOW(window), FALSE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// "destroy" 和 gtk_main_quit 连接</span></span><br><span class="line">	g_signal_connect(window, <span class="string">"destroy"</span>, G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window);	<span class="comment">// 显示窗口全部控件</span></span><br><span class="line">	<span class="comment">//gtk_widget_hide_all(window);	// 隐藏窗口</span></span><br><span class="line"></span><br><span class="line">	gtk_main();		<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意这一句<code>g_signal_connect(window, &quot;destroy&quot;, G_CALLBACK(gtk_main_quit), NULL);</code><br>把”destroy” 和 gtk_main_quit 连接</strong></p>
<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>标签主要是显示文本信息，用作标志。</p>
<p><strong>标签的创建：</strong><br><code>GtkWidget *gtk_label_new(const gchar *str);</code><br>str：文本内容<br>返回值：标签指针</p>
<p><strong>设置标签的内容：</strong><br><code>void  gtk_label_set_text (GtkLabel *label, const gchar *str);</code><br>label：操作的标签<br>str：文本内容</p>
<p><strong>获取标签的内容：</strong><br><code>const gchar *gtk_label_get_text( GtkLabel *label );</code><br>label：操作的标签<br>返回值：获取到的文本内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;	// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv); 	<span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);    <span class="comment">// 创建窗口</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* vbox = gtk_vbox_new(TRUE, <span class="number">10</span>);       <span class="comment">// 创建垂直布局容器</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(window), vbox); <span class="comment">// 把纵直布局容器放入窗口</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// label one</span></span><br><span class="line">	GtkWidget* label_one = gtk_label_new(<span class="string">"label one"</span>);	<span class="comment">// 创建标签</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(vbox), label_one); 	<span class="comment">// 将按钮放在布局容器里</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// label two</span></span><br><span class="line">	GtkWidget* label_two = gtk_label_new(<span class="string">"label two"</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* str = gtk_label_get_label(GTK_LABEL(label_two)); <span class="comment">// 获得标签的内容</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"str = %s\n"</span>, str);</span><br><span class="line"></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(vbox), label_two); <span class="comment">// 将按钮放在布局容器里</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// label three</span></span><br><span class="line">	GtkWidget* label_three = gtk_label_new(<span class="string">"label three"</span>);</span><br><span class="line">	gtk_label_set_text(GTK_LABEL(label_three), <span class="string">"change the label text"</span>); <span class="comment">// 设置内容</span></span><br><span class="line"></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(vbox), label_three); <span class="comment">// 将按钮放在布局容器里</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// "destroy" 和 gtk_main_quit 连接</span></span><br><span class="line">	g_signal_connect(window, <span class="string">"destroy"</span>, G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window);	<span class="comment">// 显示窗口控件</span></span><br><span class="line"></span><br><span class="line">	gtk_main(); 	<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="图片控件"><a href="#图片控件" class="headerlink" title="图片控件"></a>图片控件</h4><p>图片控件和标签的作用很类似，都是作为显示用的，只是图片控件显示的内容是图片。</p>
<p><strong>图片控件的创建：</strong><br><code>GtkWidget *gtk_image_new_from_file( const gchar *filename );</code><br>filename：图片的名字，带路径的话需要加上路径( 相对或绝对 )<br>返回值：图片控件指针</p>
<p>通过上面方法创建的图片控件，以图片默认大小来显示，不能修改其大小。如果要改变图片的大小，我们要借助图片资源对象GdkPixbuf，需要注意的是，GdkPixbuf不属于控件类，它以 Gdk 开头。</p>
<p><strong>图片资源对象pixbuf的创建：</strong></p>
<p><code>GdkPixbuf *gdk_pixbuf_new_from_file(const gchar *filename, GError **error);</code><br>filename：图片的名字，带路径的话需要加上路径( 相对或绝对 )<br>error：储存错误的指针<br>返回值：pixbuf指针</p>
<p><strong>设置图片的大小：</strong><br><code>GdkPixbuf *gdk_pixbuf_scale_simple(const GdkPixbuf *src, int dest_width, int dest_height, GdkInterpType interp_type);</code><br>src：gdk_pixbuf_new_from_file()的返回值<br>dest_width：图片的宽度<br>dest_height：图片的高度<br>interp_type：是一个枚举变量，标志图片的加载速度和质量，常用GDK_INTERP_BILINEAR<br>返回值：指定大小好的pixbuf指针</p>
<p>通过gdk_pixbuf_new_from_file(), gdk_pixbuf_scale_simple()创建的pixbuf，它会动态分配空间，占用资源，用完后，需要人为释放资源。</p>
<p><strong>释放资源：</strong><br><code>void g_object_unref(GtkObject *object);</code><br>object：需要释放的对象</p>
<p><strong>通过pixbuf来创建图片控件：</strong><br><code>GtkWidget *gtk_image_new_from_pixbuf(GdkPixbuf *pixbuf );</code><br>pixbuf：指定好大小的pixbuf<br>返回值：图片控件指针</p>
<p><strong>图片控件重新设置一张图片(pixbuf)：</strong><br><code>void gtk_image_set_from_pixbuf(GtkImage *image, GdkPixbuf *pixbuf );</code><br>image：图片控件指针<br>pixbuf：指定好大小的pixbuf</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;	// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv); 	<span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);    <span class="comment">// 创建窗口</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* hbox = gtk_hbox_new(TRUE, <span class="number">5</span>);       <span class="comment">// 创建水平布局容器</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(window), hbox); <span class="comment">// 把水平布局容器放入窗口</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建图片控件，这种方法创建以图片默认大小来显示，不能修改</span></span><br><span class="line">	GtkWidget* image_one = gtk_image_new_from_file(<span class="string">"./1.jpg"</span>);</span><br><span class="line">	<span class="comment">//gtk_container_add(GTK_CONTAINER(hbox), image_one);// 添加到布局里</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面借助GdkPixbuf来修改图片的大小，注意接口以gdk_开头，不属于控件类</span></span><br><span class="line">	<span class="comment">// 创建pixbuf，需要占用资源，使用完，需要人为释放</span></span><br><span class="line">	GdkPixbuf* src = gdk_pixbuf_new_from_file(<span class="string">"./1.jpg"</span>, <span class="literal">NULL</span>);<span class="comment">// 读取原图片	</span></span><br><span class="line">	GdkPixbuf* dst = gdk_pixbuf_scale_simple(src,<span class="number">100</span>, <span class="number">100</span>, GDK_INTERP_BILINEAR);	<span class="comment">// 修改图片大小(100, 100), 保存在dst</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* image_two = gtk_image_new_from_pixbuf(dst);	<span class="comment">// 通过pixbuf创建图片控件</span></span><br><span class="line">	g_object_unref(src);	<span class="comment">// pixbuf使用完，需要人为释放资源</span></span><br><span class="line">	g_object_unref(dst);</span><br><span class="line">	gtk_container_add(GTK_CONTAINER(hbox), image_two);	<span class="comment">// 添加到布局里</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取图片控件里的pixbuf，以这个pixbuf又重新创建一个图片控件</span></span><br><span class="line">	GdkPixbuf* tmp = gtk_image_get_pixbuf(GTK_IMAGE(image_two));</span><br><span class="line">	GtkWidget* image_three = gtk_image_new_from_pixbuf(tmp);</span><br><span class="line">	gtk_container_add(GTK_CONTAINER(hbox), image_three);	<span class="comment">// 添加到布局里</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 给创建的图片控件重新设置一张图片</span></span><br><span class="line">	GtkWidget* image_four = gtk_image_new_from_file(<span class="string">"./1.jpg"</span>);</span><br><span class="line">	src = gdk_pixbuf_new_from_file(<span class="string">"./2.jpg"</span>, <span class="literal">NULL</span>);<span class="comment">// 读取原图片	</span></span><br><span class="line">	dst = gdk_pixbuf_scale_simple(src,</span><br><span class="line">		<span class="number">200</span>, <span class="number">200</span>, GDK_INTERP_BILINEAR);	<span class="comment">// 修改图片大小(200, 200), 保存在dst</span></span><br><span class="line">	gtk_image_set_from_pixbuf(GTK_IMAGE(image_four), dst);<span class="comment">// 给image_four重新设置一张图片</span></span><br><span class="line">	g_object_unref(src);	<span class="comment">// pixbuf使用完，需要人为释放资源</span></span><br><span class="line">	g_object_unref(dst);</span><br><span class="line">	gtk_container_add(GTK_CONTAINER(hbox), image_four);	<span class="comment">// 添加到布局里</span></span><br><span class="line"></span><br><span class="line">	g_signal_connect(window, <span class="string">"destroy"</span>, G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window);	<span class="comment">// 显示窗口控件</span></span><br><span class="line"></span><br><span class="line">	gtk_main(); 	<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h4><p><strong>进度条的创建：</strong><br><code>GtkWidget *gtk_progress_bar_new(void);</code><br>返回值：进度条指针</p>
<p><strong>设置进度条显示的进度比例：</strong><br><code>void gtk_progress_bar_set_fraction(GtkProgressBar *pbar, gdouble fraction);</code><br>pbar：需要操作的进度条<br>fraction：0.0到1.0</p>
<p><strong>获取进度条显示的进度比例：</strong><br><code>gdouble  gtk_progress_bar_get_fraction (GtkProgressBar *pbar);</code><br>pbar：需要操作的进度条<br>返回值：进度比例</p>
<p><strong>设置滑槽上的文本显示：</strong><br><code>void gtk_progress_bar_set_text(GtkProgressBar *pbar, gchar *text);</code><br>pbar：需要操作的进度条<br>text：设置的文本内容</p>
<p><strong>设置进度条的移动方向：</strong><br><code>void gtk_progress_bar_set_orientation(GtkProgressBar *pbar, GtkProgressBarOrientation orientation);</code><br>pbar：需要操作的进度条<br>orientation：移动方向，它是一个枚举变量</p>
<ul>
<li>GTK_PROGRESS_LEFT_TO_RIGHT：从左向右 </li>
<li>GTK_PROGRESS_RIGHT_TO_LEFT：从右向左 </li>
<li>GTK_PROGRESS_BOTTOM_TO_TOP：从下向上 </li>
<li>GTK_PROGRESS_TOP_TO_BOTTOM：从上向下</li>
</ul>
<p><strong>获取进度条的方向：</strong><br><code>GtkProgressBarOrientation  gtk_progress_bar_get_orientation(GtkProgressBar *pbar);</code><br>pbar：需要操作的进度条<br>返回值：进度条的方向，它是一个枚举类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数，切换进度条的移动方向 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toggle_orientation</span><span class="params">(GtkWidget* widget, gpointer data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// gtk_progress_bar_get_orientation: 获得进度条当前移动的方向</span></span><br><span class="line">	<span class="comment">/*switch (gtk_progress_bar_get_orientation(GTK_PROGRESS_BAR(data))) &#123;</span></span><br><span class="line"><span class="comment">	case GTK_PROGRESS_LEFT_TO_RIGHT:</span></span><br><span class="line"><span class="comment">		gtk_progress_bar_set_orientation(GTK_PROGRESS_BAR(data), GTK_PROGRESS_RIGHT_TO_LEFT);</span></span><br><span class="line"><span class="comment">		break;</span></span><br><span class="line"><span class="comment">	case GTK_PROGRESS_RIGHT_TO_LEFT:</span></span><br><span class="line"><span class="comment">		gtk_progress_bar_set_orientation(GTK_PROGRESS_BAR(data), GTK_PROGRESS_LEFT_TO_RIGHT);</span></span><br><span class="line"><span class="comment">		break;</span></span><br><span class="line"><span class="comment">	default: // 什么也不做 </span></span><br><span class="line"><span class="comment">		break;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新进度条，这样就能够看到进度条的移动</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(GtkWidget* widget, gpointer data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 在原来值基础上增加 0.05</span></span><br><span class="line">	gdouble new_val = gtk_progress_bar_get_fraction(GTK_PROGRESS_BAR(data)) + <span class="number">0.05</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_val &gt; <span class="number">1.0</span>) &#123;	<span class="comment">// 越界处理</span></span><br><span class="line">		new_val = <span class="number">0.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置进度条的新值 </span></span><br><span class="line">	gtk_progress_bar_set_fraction(GTK_PROGRESS_BAR(data), new_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv);		<span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);		<span class="comment">// 创建主窗口</span></span><br><span class="line">	gtk_window_set_title(GTK_WINDOW(window), <span class="string">"GtkProgressBar"</span>);		<span class="comment">// 设置窗口标题</span></span><br><span class="line">	gtk_container_set_border_width(GTK_CONTAINER(window), <span class="number">10</span>);		<span class="comment">// 设置边框宽度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置窗口的最小大小</span></span><br><span class="line">	gtk_widget_set_size_request(window, <span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">	<span class="comment">// 窗口关联 destroy 信号 到 gtk_main_quit</span></span><br><span class="line">	g_signal_connect(G_OBJECT(window), <span class="string">"destroy"</span>, G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	GtkWidget* vbox = gtk_vbox_new(FALSE, <span class="number">5</span>);		 <span class="comment">// 垂直布局容器</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(window), vbox);  <span class="comment">// 容器加入窗口</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个进度条</span></span><br><span class="line">	GtkWidget* progress = gtk_progress_bar_new();</span><br><span class="line">	gtk_container_add(GTK_CONTAINER(vbox), progress);  <span class="comment">// 加入垂直布局容器</span></span><br><span class="line">	<span class="comment">// 设置进度条显示的百分比：50%</span></span><br><span class="line">	gtk_progress_bar_set_fraction(GTK_PROGRESS_BAR(progress), <span class="number">0.5</span>);</span><br><span class="line">	<span class="comment">// 设置在进度条的滑槽上的文本显示 </span></span><br><span class="line">	gtk_progress_bar_set_text(GTK_PROGRESS_BAR(progress), <span class="string">"some text"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加一个按钮，切换移动方向  </span></span><br><span class="line">	GtkWidget* button_orientation = gtk_button_new_with_label(<span class="string">"Right to Left"</span>);</span><br><span class="line">	g_signal_connect(button_orientation, <span class="string">"clicked"</span>, G_CALLBACK(toggle_orientation), progress);</span><br><span class="line">	gtk_container_add(GTK_CONTAINER(vbox), button_orientation);  <span class="comment">// 加入垂直布局容器</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加进度条进度按钮</span></span><br><span class="line">	GtkWidget* button = gtk_button_new_with_label(<span class="string">"add"</span>);</span><br><span class="line">	g_signal_connect(button, <span class="string">"clicked"</span>, G_CALLBACK(callback), progress); <span class="comment">// connect</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(vbox), button);  <span class="comment">// 加入垂直布局容器</span></span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window);</span><br><span class="line"></span><br><span class="line">	gtk_main();			<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该是GTK3.0取消了有关进度条方向操作的原因，在回调函数toggle_orientation里直接全部取消有关操作。</p>
<h4 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h4><p><strong>空按钮的创建(按钮上没有任何内容)：</strong><br><code>GtkWidget *gtk_button_new(void);</code><br>返回值：按钮指针</p>
<p><strong>创建带文本内容的按钮：</strong><br><code>GtkWidget *gtk_button_new_with_label (const gchar *label);</code><br>label：文本内容<br>返回值：按钮指针</p>
<p><strong>设置按钮的文本内容：</strong><br><code>void gtk_button_set_label(GtkButton *button, const gchar *label);</code><br>button：操作的按钮<br>label：要设置的文本内容</p>
<p><strong>获取按钮的文本内容：</strong><br><code>const gchar *gtk_button_get_label(GtkButton *button);</code><br>button：操作的按钮<br>返回值：获取到的文本内容</p>
<p><strong>控件使能设置：</strong><br><code>void gtk_widget_set_sensitive(GtkWidget *widget, gboolean sensitive);</code><br>widget：要操作的控件<br>sensitive：FALSE变灰，不允许相应响应；TRUE，正常响应</p>
<p><strong>给按钮设置一张图片：</strong><br><code>void gtk_button_set_image(GtkButton *button,GtkWidget *image);</code><br>button：按钮<br>image：图片控件</p>
<p><strong>获取按钮上的图片：</strong><br><code>GtkWidget *gtk_button_set_image(GtkButton *button);</code><br>button：按钮<br>返回值：图片控件</p>
<p><strong>设置按钮透明背景色：</strong><br><code>void gtk_button_set_relief(GtkButton *button,  newstyle);</code><br>button：按钮<br>newstyle： 枚举变量，GTK_RELIEF_NONE为透明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;	// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv); 	<span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);    <span class="comment">// 创建窗口</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* hbox = gtk_hbox_new(TRUE, <span class="number">10</span>); 		<span class="comment">// 水平布局容器</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(window), hbox); <span class="comment">// 把水平布局容器放入窗口</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 普通按钮</span></span><br><span class="line">	GtkWidget* normal_button = gtk_button_new_with_label(<span class="string">"normal button"</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* str = gtk_button_get_label(GTK_BUTTON(normal_button)); <span class="comment">// 获取按钮的文本内容</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"str === %s\n"</span>, str);</span><br><span class="line"></span><br><span class="line">	gtk_button_set_label(GTK_BUTTON(normal_button), <span class="string">"change"</span>);	<span class="comment">// 设置按钮的文本内容</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(hbox), normal_button);     <span class="comment">// 把按钮放入水平布局容器里</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 给按钮设置一张图片</span></span><br><span class="line">	GtkWidget* button = gtk_button_new(); <span class="comment">// 先创建空按钮</span></span><br><span class="line">	<span class="comment">//GtkWidget* image = gtk_image_new_from_file("./1.jpg"); // 图像控件</span></span><br><span class="line">	GdkPixbuf* src = gdk_pixbuf_new_from_file(<span class="string">"./1.jpg"</span>, <span class="literal">NULL</span>);<span class="comment">// </span></span><br><span class="line">	GdkPixbuf* dst = gdk_pixbuf_scale_simple(src, <span class="number">100</span>, <span class="number">100</span>, GDK_INTERP_BILINEAR);</span><br><span class="line"></span><br><span class="line">	GtkWidget* image = gtk_image_new_from_pixbuf(dst);	<span class="comment">// 通过pixbuf创建图片控件</span></span><br><span class="line">	g_object_unref(src);	<span class="comment">// pixbuf使用完，需要人为释放资源</span></span><br><span class="line">	g_object_unref(dst);</span><br><span class="line">	gtk_button_set_image(GTK_BUTTON(button), image); <span class="comment">// 给按钮添加图片</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(hbox), button);     <span class="comment">// 把按钮放入水平布局容器里</span></span><br><span class="line">	gtk_button_set_relief(GTK_BUTTON(button), GTK_RELIEF_NONE);	<span class="comment">// 按钮背景色透明</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按钮使能设置(是否变灰)，默认为使能TRUE，非使能FALSE</span></span><br><span class="line">	<span class="comment">//gtk_widget_set_sensitive(button, FALSE);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window);	<span class="comment">// 显示窗口控件</span></span><br><span class="line"></span><br><span class="line">	gtk_main(); 	<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="行编辑"><a href="#行编辑" class="headerlink" title="行编辑"></a>行编辑</h4><p>行编辑，只允许输入一行内容的控件，如密码输入框。</p>
<p><strong>行编辑的创建：</strong><br><code>GtkWidget *gtk_entry_new(void);</code><br>返回值：行编辑指针</p>
<p><strong>设置行编辑内容的最大长度：</strong><br><code>void gtk_entry_set_max_length(GtkEntry *entry, gint max);</code><br>entry：行编辑<br>max：长度的最大值，这里填0代表长度不作限制</p>
<p><strong>设置行编辑的文本内容：</strong><br><code>void gtk_entry_set_text(GtkEntry *entry,const gchar *text);</code><br>entry：行编辑<br>text：文本内容</p>
<p><strong>获取行编辑的内容：</strong><br><code>const gchar *gtk_entry_get_text(GtkEntry *entry);</code><br>entry：行编辑<br>返回值：获取到的行编辑内容</p>
<p><strong>设置编辑控件是否允许编辑：</strong><br><code>void gtk_editable_set_editable(GtkEditable *editable,gboolean is_editable);</code><br>editable：需要操作的控件<br>is_editable：TRUE代表能允许编辑，默认属性，FALSE不允许编辑</p>
<p><strong>设置行编辑的内容是否可视(不能可视相当于密码模式，看不到文本的内容) </strong><br><code>void gtk_entry_set_visibility(GtkEntry *entry,gboolean visible);</code><br>entry：行编辑<br>visible：TRUE可视，FALSE不可视</p>
<p>常用信号：”activate”<br>当用户在文本输入控件内部按回车键时引发activate信号；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按Enter，获取行编辑的内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_callback</span><span class="params">(GtkWidget* widget, gpointer entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> gchar* entry_text;</span><br><span class="line">	<span class="comment">// 获得文本内容</span></span><br><span class="line">	entry_text = gtk_entry_get_text(GTK_ENTRY(entry));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Entry contents: %s\n"</span>, entry_text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv); 	<span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL); 	<span class="comment">// 创建窗口</span></span><br><span class="line">	g_signal_connect(window, <span class="string">"destroy"</span>, G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line">	gtk_widget_set_size_request(window, <span class="number">200</span>, <span class="number">50</span>);				<span class="comment">// 设置窗口的大小</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* entry = gtk_entry_new();  <span class="comment">// 创建行编辑 	</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(window), entry); 	<span class="comment">// 表格放入窗口</span></span><br><span class="line">	gtk_entry_set_max_length(GTK_ENTRY(entry), <span class="number">100</span>);     <span class="comment">// 设置行编辑显示最大字符的长度</span></span><br><span class="line">	gtk_entry_set_text(GTK_ENTRY(entry), <span class="string">"hello word"</span>);  <span class="comment">// 设置内容</span></span><br><span class="line">	<span class="comment">//gtk_entry_set_visibility(GTK_ENTRY(entry), FALSE); 	 // 密码模式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果我们想在用户输入文本时进行响应，可以为activate设置回调函数。</span></span><br><span class="line"><span class="comment">	 * 当用户在文本输入构件内部按回车键时引发Activate信号；</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	g_signal_connect(entry, <span class="string">"activate"</span>, G_CALLBACK(enter_callback), entry);</span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window); <span class="comment">// 显示窗口所有控件</span></span><br><span class="line"></span><br><span class="line">	gtk_main(); 		<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="笔记本控件"><a href="#笔记本控件" class="headerlink" title="笔记本控件"></a>笔记本控件</h4><p>笔记本控件，可以让用户标签式地切换多个界面。当我们需要多窗口切换时，使用笔记本控件是一个明智的选择。</p>
<p><img src="/2020/02/18/GTK入门学习/20150126154311359" alt="img"></p>
<p><strong>笔记本控件的创建：</strong><br><code>GtkWidget *gtk_notebook_new(void);</code><br>返回值：笔记本控件指针</p>
<p><strong>设置页标签的位置：</strong><br><code>void gtk_notebook_set_tab_pos( GtkNotebook *notebook,  GtkPositionType pos );</code><br>notebook：笔记本控件<br>pos取值如下：</p>
<ul>
<li>GTK_POS_LEFT：  左</li>
<li>GTK_POS_RIGHT：  右</li>
<li>GTK_POS_TOP：   上</li>
<li>GTK_POS_BOTTOM： 下</li>
</ul>
<p><strong>追加页面：</strong><br><code>gint gtk_notebook_append_page(GtkNotebook *notebook, GtkWidget *child, GtkWidget *tab_label );</code><br>notebook： 容纳别的控件的笔记本<br>child：       放在笔记本页面里的子控件<br>tab_label：要添加页面的标题名<br>返回值：成功返回值页面值(从0开始)，失败返回-1</p>
<p><strong>在指定位置添加页面(从0开始)：</strong><br><code>gint gtk_notebook_insert_page(GtkNotebook *notebook,GtkWidget *child, tkWidget *tab_label,gint position );</code><br>notebook： 容纳别的控件的笔记本<br>child：       放在笔记本页面里的子控件<br>tab_label：要添加页面的标题名<br>position：页面的位置，从0开始，如果-1代表添加到最后<br>返回值：成功返回值页面值(从0开始)，失败返回-1</p>
<p><strong>设置起始页，从0开始算，相当于设置第几个页面显示：</strong><br><code>void gtk_notebook_set_current_page(GtkNotebook *notebook, gint page_num );</code><br>notebook：要设置的笔记本控件<br>page_num：页面数</p>
<p>常用信号：”switch-page”<br>当切换页面时，会触发”switch-page”信号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "switch-page"信号处理函数，page_num指第几个页面，从0开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal_switch_pape</span><span class="params">(GtkNotebook* notebook, gpointer page,</span></span></span><br><span class="line"><span class="function"><span class="params">	guint page_num, gpointer user_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This is page %d\n"</span>, page_num + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv); 	<span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL); <span class="comment">// 创建主窗口</span></span><br><span class="line">	gtk_widget_set_size_request(window, <span class="number">400</span>, <span class="number">300</span>);	<span class="comment">//设置窗口大小</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* notebook = gtk_notebook_new(); 	<span class="comment">// 创建笔记本控件</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(window), notebook); <span class="comment">// 笔记本放进窗口</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 页标签的位置，可以有四种位置：上、下、左或右。</span></span><br><span class="line">	gtk_notebook_set_tab_pos(GTK_NOTEBOOK(notebook), GTK_POS_LEFT);  <span class="comment">//上面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一个页面</span></span><br><span class="line">	GtkWidget* label = gtk_label_new(<span class="string">"Page one"</span>);	<span class="comment">//创建标签</span></span><br><span class="line">	GtkWidget* box = gtk_vbox_new(TRUE, <span class="number">5</span>);	<span class="comment">// 创建布局</span></span><br><span class="line">	GtkWidget* button_one = gtk_button_new_with_label(<span class="string">"I am first page"</span>);</span><br><span class="line">	GtkWidget* button_two = gtk_button_new_with_label(<span class="string">"I am first button of first page"</span>);</span><br><span class="line">	gtk_container_add(GTK_CONTAINER(box), button_one);</span><br><span class="line">	gtk_container_add(GTK_CONTAINER(box), button_two);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* gtk_notebook_append_page( GtkNotebook *notebook, GtkWidget *child,</span></span><br><span class="line"><span class="comment">	 *                     GtkWidget  *tab_label );</span></span><br><span class="line"><span class="comment">	 * 插入页面到笔记本的后端（append）或前端（prepend）来添加页面。</span></span><br><span class="line"><span class="comment">	 * child是放在笔记本页面里的子控件，它必须另外创建，一般是容器</span></span><br><span class="line"><span class="comment">	 * tab_label是要添加的页面的标签。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), box, label);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二个页面</span></span><br><span class="line">	label = gtk_label_new(<span class="string">"Page two"</span>);	<span class="comment">//创建标签</span></span><br><span class="line">	box = gtk_hbox_new(TRUE, <span class="number">5</span>);	<span class="comment">// 创建布局</span></span><br><span class="line">	button_one = gtk_button_new_with_label(<span class="string">"I am second page"</span>);</span><br><span class="line">	button_two = gtk_button_new_with_label(<span class="string">"I am first button of second page"</span>);</span><br><span class="line">	gtk_container_add(GTK_CONTAINER(box), button_one);</span><br><span class="line">	gtk_container_add(GTK_CONTAINER(box), button_two);</span><br><span class="line">	gtk_notebook_prepend_page(GTK_NOTEBOOK(notebook), box, label);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第三个页面，在指定位置添加页面，从0开始</span></span><br><span class="line">	button_one = gtk_button_new_with_label(<span class="string">"insert_page"</span>);</span><br><span class="line">	label = gtk_label_new(<span class="string">"Page three"</span>);</span><br><span class="line">	gtk_notebook_insert_page(GTK_NOTEBOOK(notebook), button_one, label, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理信号，当切换页面时，会触发"switch-page"信号</span></span><br><span class="line">	g_signal_connect(notebook, <span class="string">"switch-page"</span>,</span><br><span class="line">		G_CALLBACK(deal_switch_pape), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window); <span class="comment">//显示所有控件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置起始页(第2页)，从0开始算，相当于设置第2个页面显示</span></span><br><span class="line">	gtk_notebook_set_current_page(GTK_NOTEBOOK(notebook), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	gtk_main(); 		<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置窗口背景图"><a href="#设置窗口背景图" class="headerlink" title="设置窗口背景图"></a>设置窗口背景图</h3><p>有问题，暂且存疑</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 功能：  设置背景图</span></span><br><span class="line"><span class="comment"> * widget: 主窗口</span></span><br><span class="line"><span class="comment"> * w, h:   图片的大小</span></span><br><span class="line"><span class="comment"> * path：  图片路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chang_background</span><span class="params">(GtkWidget* widget, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">const</span> gchar* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_widget_set_app_paintable(widget, TRUE);		<span class="comment">//允许窗口可以绘图</span></span><br><span class="line">	gtk_widget_realize(widget);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 更改背景图时，图片会重叠</span></span><br><span class="line"><span class="comment">	 * 这时要手动调用下面的函数，让窗口绘图区域失效，产生窗口重绘制事件（即 expose 事件）。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gtk_widget_queue_draw(widget);</span><br><span class="line"></span><br><span class="line">	GdkPixbuf* src_pixbuf = gdk_pixbuf_new_from_file(path, <span class="literal">NULL</span>);	<span class="comment">// 创建图片资源对象</span></span><br><span class="line">	<span class="comment">// w, h是指定图片的宽度和高度</span></span><br><span class="line">	GdkPixbuf* dst_pixbuf = gdk_pixbuf_scale_simple(src_pixbuf, w, h, GDK_INTERP_BILINEAR);</span><br><span class="line"></span><br><span class="line">	GdkPixmap* pixmap = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建pixmap图像;</span></span><br><span class="line"><span class="comment">	 * NULL：不需要蒙版;</span></span><br><span class="line"><span class="comment">	 * 123： 0~255，透明到不透明</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gdk_pixbuf_render_pixmap_and_mask(dst_pixbuf, &amp;pixmap, <span class="literal">NULL</span>, <span class="number">200</span>);</span><br><span class="line">	<span class="comment">// 通过pixmap给widget设置一张背景图，最后一个参数必须为: FASLE</span></span><br><span class="line">	gdk_window_set_back_pixmap(widget-&gt;window, pixmap, FALSE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放资源</span></span><br><span class="line">	g_object_unref(src_pixbuf);</span><br><span class="line">	g_object_unref(dst_pixbuf);</span><br><span class="line">	g_object_unref(pixmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//主窗口操作</span></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line"></span><br><span class="line">	gtk_window_set_title(GTK_WINDOW(window), <span class="string">"设置窗口背景图"</span>);</span><br><span class="line">	gtk_widget_set_size_request(window, <span class="number">500</span>, <span class="number">450</span>);</span><br><span class="line"></span><br><span class="line">	chang_background(window, <span class="number">500</span>, <span class="number">400</span>, <span class="string">"./1.jpg"</span>);	<span class="comment">// 设置窗口背景图</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* hbox = gtk_hbox_new(TRUE, <span class="number">50</span>); 		<span class="comment">// 水平布局容器</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(window), hbox); <span class="comment">// 把水平布局容器放入窗口</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 普通按钮</span></span><br><span class="line">	GtkWidget* normal_button = gtk_button_new_with_label(<span class="string">"normal button"</span>);</span><br><span class="line">	gtk_container_add(GTK_CONTAINER(hbox), normal_button);     <span class="comment">// 把按钮放入水平布局容器里</span></span><br><span class="line">	gtk_widget_show_all(window); <span class="comment">// 显示所有部件</span></span><br><span class="line"></span><br><span class="line">	gtk_main();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="改变控件字体大小"><a href="#改变控件字体大小" class="headerlink" title="改变控件字体大小"></a>改变控件字体大小</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 功能:      设置控件字体大小</span></span><br><span class="line"><span class="comment"> * widget:    需要改变字体的控件</span></span><br><span class="line"><span class="comment"> * size:      字体大小</span></span><br><span class="line"><span class="comment"> * is_button: TRUE代表控件为按钮，FALSE为其它控件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_widget_font_size</span><span class="params">(GtkWidget* widget, <span class="keyword">int</span> size, gboolean is_button)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GtkWidget* labelChild;</span><br><span class="line">	PangoFontDescription* font;</span><br><span class="line">	gint fontSize = size;</span><br><span class="line"></span><br><span class="line">	font = pango_font_description_from_string(<span class="string">"Sans"</span>);          <span class="comment">//"Sans"字体名   </span></span><br><span class="line">	pango_font_description_set_size(font, fontSize * PANGO_SCALE);<span class="comment">//设置字体大小   </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_button) &#123;</span><br><span class="line">		labelChild = gtk_bin_get_child(GTK_BIN(widget));<span class="comment">//取出GtkButton里的label  </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		labelChild = widget;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置label的字体，这样这个GtkButton上面显示的字体就变了</span></span><br><span class="line">	gtk_widget_modify_font(GTK_WIDGET(labelChild), font);</span><br><span class="line">	pango_font_description_free(font);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//主窗口操作</span></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line"></span><br><span class="line">	gtk_window_set_title(GTK_WINDOW(window), <span class="string">"change "</span>);</span><br><span class="line">	gtk_container_set_border_width(GTK_CONTAINER(window), <span class="number">10</span>);</span><br><span class="line">	gtk_widget_set_size_request(window, <span class="number">500</span>, <span class="number">450</span>);</span><br><span class="line"></span><br><span class="line">	GtkWidget* vbox = gtk_vbox_new(TRUE, <span class="number">5</span>);	<span class="comment">// 创建垂直布局</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(window), vbox);	<span class="comment">// 把布局放在窗口里</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 改变标签字体大小，参数为 FALSE</span></span><br><span class="line">	GtkWidget* label = gtk_label_new(<span class="string">"I am a label"</span>);	<span class="comment">// 标签</span></span><br><span class="line">	set_widget_font_size(label, <span class="number">50</span>, FALSE);			<span class="comment">// 设置标签字体大小</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(vbox), label);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 改变按钮字体大小，参数为 TRUE</span></span><br><span class="line">	GtkWidget* button = gtk_button_new_with_label(<span class="string">"I am a button"</span>);</span><br><span class="line">	set_widget_font_size(button, <span class="number">50</span>, TRUE);		<span class="comment">// 改变按钮字体大小</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(vbox), button);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window); <span class="comment">// 显示所有部件</span></span><br><span class="line"></span><br><span class="line">	gtk_main();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>定时器在应用编程里用得很广，我们手机里的闹钟，幻灯片播放图片等应用都用到定时器。定时器，每隔一段时间干一件事(程序里表现为调用一个函数)，像闹钟，每隔一天响一次。</p>
<p><strong>定时器的创建：</strong><br><code>guint g_timeout_add(guint interval, GSourceFunc function, gpointer data);</code><br>interval：设置的时间间隔，以毫秒为单位( 1000即为1秒 )<br>function：回调函数的名字<br>data：给回调函数传的参数<br>返回值：定时器id号</p>
<p>使用实例：<br><code>guint timer = g_timeout_add(500, (GSourceFunc)deal_time, NULL);</code><br>每隔500ms会执行一次deal_time()回调函数。<br>注意：当回调函数返回值为FALSE时，定时器执行一次后便会停止工作，不再循环执行。所以，要想定时器连续工作，循环执行所指定的回调函数，应该返回TRUE。</p>
<p>定时器的移除：<br><code>gboolean g_source_remove(guint tag);</code><br>tag：定时器id号<br>返回值：TRUE代表成功，FALSE代表失败</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">guint timer;	<span class="comment">// 定时器id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 功能: 		设置控件字体大小</span></span><br><span class="line"><span class="comment"> * widget: 		需要改变字体的控件</span></span><br><span class="line"><span class="comment"> * size: 		字体大小</span></span><br><span class="line"><span class="comment"> * is_button: 	TRUE代表控件为按钮，FALSE为其它控件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_widget_font_size</span><span class="params">(GtkWidget* widget, <span class="keyword">int</span> size, <span class="keyword">int</span> is_button)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GtkWidget* labelChild;</span><br><span class="line">	PangoFontDescription* font;</span><br><span class="line">	gint fontSize = size;</span><br><span class="line"></span><br><span class="line">	font = pango_font_description_from_string(<span class="string">"Sans"</span>);<span class="comment">//"Sans"字体名   </span></span><br><span class="line">	pango_font_description_set_size(font, fontSize * PANGO_SCALE);<span class="comment">//设置字体大小   </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_button) &#123;</span><br><span class="line">		labelChild = gtk_bin_get_child(GTK_BIN(widget));<span class="comment">//取出GtkButton里的label  </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		labelChild = widget;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置label的字体，这样这个GtkButton上面显示的字体就变了</span></span><br><span class="line">	gtk_widget_modify_font(GTK_WIDGET(labelChild), font);</span><br><span class="line">	pango_font_description_free(font);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 功能:  定时器处理函数</span></span><br><span class="line"><span class="comment"> * label: 主要用于显示数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">gboolean <span class="title">deal_time</span><span class="params">(gpointer* label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">5</span>] = <span class="string">"Time"</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">	num--;</span><br><span class="line">	<span class="built_in">sprintf</span>(buf, <span class="string">"%d"</span>, num);</span><br><span class="line">	<span class="comment">//printf("%s \n", buf);</span></span><br><span class="line">	gtk_label_set_text(GTK_LABEL(label), buf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == num) &#123;</span><br><span class="line">		num = <span class="number">11</span>;</span><br><span class="line">		<span class="comment">//g_source_remove(timer); // 移除定时器 </span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;<span class="comment">//尽量返回TRUE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/////////////////主窗口操作</span></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line">	gtk_window_set_title(GTK_WINDOW(window), <span class="string">"timer"</span>);</span><br><span class="line">	gtk_container_set_border_width(GTK_CONTAINER(window), <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//设置窗口默认大小，设置一个最小大小</span></span><br><span class="line">	gtk_window_set_default_size(GTK_WINDOW(window), <span class="number">320</span>, <span class="number">400</span>);</span><br><span class="line">	<span class="comment">//设置窗口在显示器中的位置为居中。</span></span><br><span class="line">	gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);</span><br><span class="line">	g_signal_connect(G_OBJECT(window), <span class="string">"destroy"</span>,</span><br><span class="line">		G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>); <span class="comment">//按关闭按钮可以把程序中断</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 倒计时显示区域</span></span><br><span class="line">	GtkWidget* label = gtk_label_new(<span class="string">"10"</span>);		<span class="comment">// label的创建</span></span><br><span class="line">	set_widget_font_size(label, <span class="number">230</span>, FALSE);	<span class="comment">// 设置label的字体大小</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(window), label);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定时器的创建, label传给回调函数</span></span><br><span class="line">	timer = g_timeout_add(<span class="number">1000</span>, (GSourceFunc)deal_time, (gpointer)label);</span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window); <span class="comment">// 显示所有部件</span></span><br><span class="line"></span><br><span class="line">	gtk_main();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><p>鼠标事件，可以理解为操作鼠标的动作。对于窗口而言，用户操作鼠标，窗口检测到鼠标的操作( 产生一个信号 )，然后去做相应处理( 调用其规定的回调函数 )，即可认为是鼠标事件，还是信号与回调函数的知识点。</p>
<p>窗口默认不接收鼠标的操作，需要手动添加让其接收。</p>
<p><strong>设置控件捕获(接收)相应的事件:</strong><br><code>void gtk_widget_add_events( GtkWidget *widget, gint events );</code><br>widget：控件<br>events：事件类型，它是GdkEventMask的枚举常量，取值列举如下</p>
<ul>
<li>GDK_BUTTON_PRESS_MASK：鼠标点击</li>
<li>GDK_BUTTON_RELEASE_MASK：鼠标释放</li>
<li>GDK_BUTTON_MOTION_MASK：鼠标移动</li>
<li>GDK_KEY_PRESS_MASK：键盘按下</li>
<li>GDK_ENTER_NOTIFY_MASK：进入控件区域</li>
<li>…… ……</li>
</ul>
<p>鼠标点击事件产生的信号：button-press-event<br>鼠标释放事件产生的信号：button-release-event</p>
<p>其回调函数的定义如下：<br><code>gboolean callback( GtkWidget *widget, GdkEventButton *event, gpointer data )</code><br>event：鼠键事件结构体变量，系统内部的变量，不是用户传参的<br>event-&gt;x，event-&gt;y：得到点击坐标值<br>event-&gt;button： 鼠标哪个键按下<br>event-&gt;type:        是否双击<br>返回值：没有太大意义</p>
<p>鼠标移动事件产生的信号：motion-notify-event</p>
<p>其回调函数的定义如下：<br><code>gboolean callback( GtkWidget *widget, GdkEventMotion *event, gpointer data )</code><br>{<br>event-&gt;x，event-&gt;y：得到移动的坐标值<br>}</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;	// 头文件</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 鼠标点击事件处理函数</span></span><br><span class="line"><span class="function">gboolean <span class="title">deal_mouse_press</span><span class="params">(GtkWidget *widget, GdkEventButton *event, gpointer data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(event-&gt;button)&#123;	<span class="comment">// 判断鼠标点击的类型</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Left Button!!\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Middle Button!!\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Right Button!!\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Unknown Button!!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span>(event-&gt;type == GDK_2BUTTON_PRESS)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"double click\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 获得点击的坐标值，距离窗口左顶点</span></span><br><span class="line">	gint i = event-&gt;x;</span><br><span class="line">	gint j = event-&gt;y;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"press_x = %d, press_y = %d\n"</span>, i, j);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 鼠标移动事件(点击鼠标任何键)的处理函数</span></span><br><span class="line"><span class="function">gboolean <span class="title">deal_motion_notify_event</span><span class="params">(GtkWidget *widget, GdkEventMotion *event, gpointer data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 获得移动鼠标的坐标值，距离窗口左顶点</span></span><br><span class="line">	gint i = event-&gt;x;</span><br><span class="line">	gint j = event-&gt;y;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"motion_x = %d, motion_y = %d\n"</span>, i, j);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv);		<span class="comment">// 初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建顶层窗口</span></span><br><span class="line">	GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line">	<span class="comment">// 设置窗口的标题</span></span><br><span class="line">	gtk_window_set_title(GTK_WINDOW(window), <span class="string">"mouse_event"</span>);</span><br><span class="line">	<span class="comment">// 设置窗口在显示器中的位置为居中</span></span><br><span class="line">	gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);</span><br><span class="line">	<span class="comment">// 设置窗口的最小大小</span></span><br><span class="line">	gtk_widget_set_size_request(window, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">	<span class="comment">// "destroy" 和 gtk_main_quit 连接</span></span><br><span class="line">	g_signal_connect(window, <span class="string">"destroy"</span>, G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 窗口接收鼠标事件</span></span><br><span class="line">	<span class="comment">// GDK_BUTTON_PRESS_MASK：鼠标点击事件</span></span><br><span class="line">	<span class="comment">// GDK_BUTTON_MOTION_MASK：按住鼠标移动事件</span></span><br><span class="line">	gtk_widget_add_events(window, GDK_BUTTON_PRESS_MASK | GDK_BUTTON_MOTION_MASK);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// "button-press-event" 与 deal_mouse_event 连接，鼠标点击事件</span></span><br><span class="line">	g_signal_connect(window, <span class="string">"button-press-event"</span>, G_CALLBACK(deal_mouse_press), <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// "motion-notify-event" 与 deal_motion_notify_event 连接，按住鼠标移动事件</span></span><br><span class="line">	g_signal_connect(window, <span class="string">"motion-notify-event"</span>, G_CALLBACK(deal_motion_notify_event), <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">	gtk_widget_show_all(window);	<span class="comment">// 显示窗口全部控件</span></span><br><span class="line"> </span><br><span class="line">	gtk_main();		<span class="comment">// 主事件循环</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">​```C</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;	// 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标点击事件处理函数</span></span><br><span class="line"><span class="function">gboolean <span class="title">deal_mouse_press</span><span class="params">(GtkWidget* widget, GdkEventButton* event, gpointer data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (event-&gt;button) &#123;	<span class="comment">// 判断鼠标点击的类型</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Left Button!!\n"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Middle Button!!\n"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Right Button!!\n"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Unknown Button!!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (event-&gt;type == GDK_2BUTTON_PRESS) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"double click\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获得点击的坐标值，距离窗口左顶点</span></span><br><span class="line">	gint i = event-&gt;x;</span><br><span class="line">	gint j = event-&gt;y;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"press_x = %d, press_y = %d\n"</span>, i, j);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标移动事件(点击鼠标任何键)的处理函数</span></span><br><span class="line"><span class="function">gboolean <span class="title">deal_motion_notify_event</span><span class="params">(GtkWidget* widget, GdkEventMotion* event, gpointer data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 获得移动鼠标的坐标值，距离窗口左顶点</span></span><br><span class="line">	gint i = event-&gt;x;</span><br><span class="line">	gint j = event-&gt;y;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"motion_x = %d, motion_y = %d\n"</span>, i, j);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv);		<span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建顶层窗口</span></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line">	<span class="comment">// 设置窗口的标题</span></span><br><span class="line">	gtk_window_set_title(GTK_WINDOW(window), <span class="string">"mouse_event"</span>);</span><br><span class="line">	<span class="comment">// 设置窗口在显示器中的位置为居中</span></span><br><span class="line">	gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);</span><br><span class="line">	<span class="comment">// 设置窗口的最小大小</span></span><br><span class="line">	gtk_widget_set_size_request(window, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">	<span class="comment">// "destroy" 和 gtk_main_quit 连接</span></span><br><span class="line">	g_signal_connect(window, <span class="string">"destroy"</span>, G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 窗口接收鼠标事件</span></span><br><span class="line">	<span class="comment">// GDK_BUTTON_PRESS_MASK：鼠标点击事件</span></span><br><span class="line">	<span class="comment">// GDK_BUTTON_MOTION_MASK：按住鼠标移动事件</span></span><br><span class="line">	gtk_widget_add_events(window, GDK_BUTTON_PRESS_MASK | GDK_BUTTON_MOTION_MASK);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// "button-press-event" 与 deal_mouse_event 连接，鼠标点击事件</span></span><br><span class="line">	g_signal_connect(window, <span class="string">"button-press-event"</span>, G_CALLBACK(deal_mouse_press), <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// "motion-notify-event" 与 deal_motion_notify_event 连接，按住鼠标移动事件</span></span><br><span class="line">	g_signal_connect(window, <span class="string">"motion-notify-event"</span>, G_CALLBACK(deal_motion_notify_event), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window);	<span class="comment">// 显示窗口全部控件</span></span><br><span class="line"></span><br><span class="line">	gtk_main();		<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>键盘事件，可以理解为操作键盘的动作。对于窗口而言，用户操作键盘，窗口检测到键盘的操作( 产生一个信号 )，然后去做相应处理( 调用其规定的回调函数 )，即可认为是键盘事件，还是信号与回调函数的知识点。</p>
<p>窗口默认就能接收键盘事件，其中的键值定义在 /usr/include/gtk-2.0/gdk/gdkkeysyms.h 文件里</p>
<p><strong>键盘按下事件产生的信号：key-press-event<br>键盘释放事件产生的信号：key-release-event</strong></p>
<p>其回调函数的定义如下：<br><code>gboolean callback( GtkWidget *widget, GdkEventKey *event, gpointer data )</code><br>{<br>event：键盘事件结构体变量，系统内部的变量，不是用户传参的<br>event-&gt;keyval：获取按下(释放)键盘键值，每个键值对于一个ASCII码<br>}</p>
<p>注意：可以在 GtkWidget 里找到相应的事件信号，回调函数如何定义应该查看帮助文档。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;	// 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gdk/gdkkeysyms.h&gt;	//键盘头文件，GDK_Up在这声明</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 键盘按下事件处理函数</span></span><br><span class="line"><span class="function">gboolean <span class="title">deal_key_press</span><span class="params">(GtkWidget* widget, GdkEventKey* event, gpointer data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (event-&gt;keyval) &#123;	<span class="comment">// 键盘键值类型</span></span><br><span class="line">	<span class="keyword">case</span> GDK_KEY_Up:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Up\n"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> GDK_KEY_Left:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Left\n"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> GDK_KEY_Right:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Right\n"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> GDK_KEY_Down:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Down\n"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> key = event-&gt;keyval; <span class="comment">// 获取键盘键值类型</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"keyval = %d\n"</span>, key);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv);		<span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建顶层窗口</span></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line">	<span class="comment">// 设置窗口的标题</span></span><br><span class="line">	gtk_window_set_title(GTK_WINDOW(window), <span class="string">"mouse_event"</span>);</span><br><span class="line">	<span class="comment">// 设置窗口在显示器中的位置为居中</span></span><br><span class="line">	gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);</span><br><span class="line">	<span class="comment">// 设置窗口的最小大小</span></span><br><span class="line">	gtk_widget_set_size_request(window, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">	<span class="comment">// "destroy" 和 gtk_main_quit 连接</span></span><br><span class="line">	g_signal_connect(window, <span class="string">"destroy"</span>,</span><br><span class="line">		G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// "key-press-event" 与 deal_key_press 连接</span></span><br><span class="line">	g_signal_connect(window, <span class="string">"key-press-event"</span>,</span><br><span class="line">		G_CALLBACK(deal_key_press), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window);	<span class="comment">// 显示窗口全部控件</span></span><br><span class="line"></span><br><span class="line">	gtk_main();		<span class="comment">// 主事件循环</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性改变事件"><a href="#属性改变事件" class="headerlink" title="属性改变事件"></a>属性改变事件</h2><p>当窗口初始化，被移动或拉伸时，会触发属性改变事件。</p>
<p><strong>属性改变事件产生的信号：configure_event</strong></p>
<p>其回调函数的定义如下：</p>
<p><code>gboolean callback( GtkWidget *widget, GdkEventConfigure *event, gpointer data )</code><br>event：属性事件结构体变量，系统内部的变量，不是用户传参的<br>event-&gt;x，event-&gt;y：窗口的起点坐标<br>event-&gt;width，event-&gt;height：窗口的大小</p>
<p>以下例子为拉伸或移动窗口，能获取窗口的起点坐标以及大小：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;	// 头文件</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function">gboolean <span class="title">on_configure_event</span><span class="params">(GtkWidget * widget, </span></span></span><br><span class="line"><span class="function"><span class="params">							GdkEventConfigure * event, </span></span></span><br><span class="line"><span class="function"><span class="params">							gpointer data)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="comment">// 窗口的起点坐标</span></span><br><span class="line">	gint x = event-&gt;x;</span><br><span class="line">	gint y = event-&gt;y;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"x = %d, y = %d\n"</span>, x, y);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 窗口的宽度和高度</span></span><br><span class="line">	gint w = event-&gt;width;</span><br><span class="line">	gint h = event-&gt;height;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"w = %d, h = %d\n"</span>, w, h);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv);		<span class="comment">// 初始化</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 创建顶层窗口</span></span><br><span class="line">	GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line">	<span class="comment">// 设置窗口的标题</span></span><br><span class="line">	gtk_window_set_title(GTK_WINDOW(window), <span class="string">"mouse_event"</span>);</span><br><span class="line">	<span class="comment">// 设置窗口在显示器中的位置为居中</span></span><br><span class="line">	gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);</span><br><span class="line">	<span class="comment">// 设置窗口的最小大小</span></span><br><span class="line">	gtk_widget_set_size_request(window, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">	<span class="comment">// "destroy" 和 gtk_main_quit 连接</span></span><br><span class="line">	g_signal_connect(window, <span class="string">"destroy"</span>, G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// "configure_event" 与 on_configure_event 连接</span></span><br><span class="line">	g_signal_connect(window, <span class="string">"configure_event"</span>, G_CALLBACK(on_configure_event), <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">	gtk_widget_show_all(window);	<span class="comment">// 显示窗口全部控件</span></span><br><span class="line"> </span><br><span class="line">	gtk_main();		<span class="comment">// 主事件循环</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="事件盒子"><a href="#事件盒子" class="headerlink" title="事件盒子"></a>事件盒子</h2><p>有些控件( 如：标签GtkLabel，图片控件GtkImage 等)，不响应GDK事件，相当于鼠标在其上面点击，它是捕获不到的。用户通过事件盒子可以解决这个问题。</p>
<p>事件盒子给控件提供一个GDK窗口来捕获事件。我们把控件放在事件盒子里，当我们用鼠标点击这个控件时，这个事件盒子就能捕获到点击的状态。</p>
<p>事件盒子的创建：</p>
<p><code>GtkWidget *gtk_event_box_new(void);</code><br>返回值：事件盒子指针</p>
<p>把控件添加到事件盒子里：<br><code>void gtk_container_add(GtkContainer *container, GtkWidget *widget );</code><br>container：容纳控件的事件盒子<br>widget：要添加的控件</p>
<p>以下例子为，通过事件盒子实现，双击标签改变其内容：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "button_press_event"信号处理函数</span></span><br><span class="line"><span class="function">gboolean <span class="title">button_pressed</span><span class="params">(GtkWidget* eventbox,GdkEventButton* event,GtkLabel* label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (event-&gt;type == GDK_2BUTTON_PRESS) &#123;<span class="comment">// 双击</span></span><br><span class="line">		<span class="keyword">const</span> gchar* text = gtk_label_get_text(label); <span class="comment">// 获取label内容</span></span><br><span class="line">		<span class="keyword">if</span> (text[<span class="number">0</span>] == <span class="string">'D'</span>) &#123;</span><br><span class="line">			gtk_label_set_text(label, <span class="string">"I Was Double-Clicked!"</span>); <span class="comment">// 修改</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			gtk_label_set_text(label, <span class="string">"Double-Click Me Again!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gtk_init(&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">	GtkWidget* window = gtk_window_new(GTK_WINDOW_TOPLEVEL);	<span class="comment">// 主窗口</span></span><br><span class="line">	gtk_window_set_title(GTK_WINDOW(window), <span class="string">"Event Box"</span>);	    <span class="comment">// 标题</span></span><br><span class="line">	gtk_container_set_border_width(GTK_CONTAINER(window), <span class="number">10</span>);</span><br><span class="line">	gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER); <span class="comment">// 居中显示</span></span><br><span class="line">	gtk_widget_set_size_request(window, <span class="number">200</span>, <span class="number">50</span>);				     <span class="comment">// 最小大小</span></span><br><span class="line">	g_signal_connect(window, <span class="string">"destroy"</span>, G_CALLBACK(gtk_main_quit), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	GtkWidget* eventbox = gtk_event_box_new();				<span class="comment">// 事件盒子的创建</span></span><br><span class="line">	gtk_widget_set_events(eventbox, GDK_BUTTON_PRESS_MASK); <span class="comment">// 捕获鼠标点击事件</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(window), eventbox);	<span class="comment">// 事件盒子放入窗口</span></span><br><span class="line"></span><br><span class="line">	GtkWidget* label = gtk_label_new(<span class="string">"Double-Click Me!"</span>);	<span class="comment">// label</span></span><br><span class="line">	gtk_container_add(GTK_CONTAINER(eventbox), label);	<span class="comment">// label放入事件盒子里</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理"button_press_event"信号，把标签label传给回调函数</span></span><br><span class="line">	g_signal_connect(eventbox, <span class="string">"button_press_event"</span>,G_CALLBACK(button_pressed), (gpointer)label);</span><br><span class="line"></span><br><span class="line">	gtk_widget_show_all(window);	<span class="comment">// 显示所有控件</span></span><br><span class="line"></span><br><span class="line">	gtk_main();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 添加菜单 menu.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_menu_activate</span> <span class="params">(GtkMenuItem* item,gpointer data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//g_print("菜单项 %s 被激活\n",(gchar*)data);</span></span><br><span class="line">   g_print(<span class="string">"Menuitem %s is pressed.\n"</span>,(gchar*)data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   GtkWidget* window;</span><br><span class="line">   GtkWidget* box;</span><br><span class="line">   GtkWidget* menubar;</span><br><span class="line">   GtkWidget* menu;</span><br><span class="line">   GtkWidget* editmenu;</span><br><span class="line">   GtkWidget* helpmenu;</span><br><span class="line">   GtkWidget* rootmenu;</span><br><span class="line">   GtkWidget* menuitem;</span><br><span class="line">   GtkAccelGroup* accel_group ;</span><br><span class="line"> </span><br><span class="line">   gtk_init(&amp;argc,&amp;argv);</span><br><span class="line"> </span><br><span class="line">   window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line">   gtk_widget_set_size_request(window,<span class="number">400</span>,<span class="number">300</span>); </span><br><span class="line">   gtk_window_set_title(GTK_WINDOW(window),<span class="string">"菜单测试程序"</span>);</span><br><span class="line">   g_signal_connect(G_OBJECT(window),<span class="string">"destroy"</span>,</span><br><span class="line">      G_CALLBACK(gtk_main_quit),<span class="literal">NULL</span>);</span><br><span class="line">   accel_group = gtk_accel_group_new();</span><br><span class="line"> </span><br><span class="line">   gtk_window_add_accel_group(GTK_WINDOW(window),accel_group);<span class="comment">// AccelGroup</span></span><br><span class="line"> </span><br><span class="line">   box = gtk_vbox_new(FALSE,<span class="number">0</span>);</span><br><span class="line">   gtk_container_add(GTK_CONTAINER(window),box);</span><br><span class="line">   menu = gtk_menu_new();<span class="comment">//文件菜单</span></span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_NEW,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(menu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">"activate"</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)("新建"));</span></span><br><span class="line">      (gpointer)(<span class="string">"New"</span>));</span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_OPEN,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(menu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">"activate"</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)("打开"));</span></span><br><span class="line">      (gpointer)(<span class="string">"Open"</span>));</span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_SAVE,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(menu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">"activate"</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)("保存"));</span></span><br><span class="line">      (gpointer)(<span class="string">"Save"</span>));</span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_SAVE_AS,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(menu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">"activate"</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)("另存为"));</span></span><br><span class="line">      (gpointer)(<span class="string">"Save As"</span>));</span><br><span class="line">   menuitem = gtk_separator_menu_item_new();</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(menu),menuitem);</span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_QUIT,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(menu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">"activate"</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)("退出"));</span></span><br><span class="line">      (gpointer)(<span class="string">"Exit"</span>));</span><br><span class="line">   rootmenu = gtk_menu_item_new_with_label(<span class="string">" 文件 "</span>);</span><br><span class="line">   gtk_menu_item_set_submenu(GTK_MENU_ITEM(rootmenu),menu);</span><br><span class="line">   menubar = gtk_menu_bar_new();</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(menubar),rootmenu);</span><br><span class="line">   rootmenu = gtk_menu_item_new_with_label(<span class="string">" 编辑 "</span>);</span><br><span class="line">   editmenu = gtk_menu_new();<span class="comment">//编辑菜单</span></span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_CUT,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(editmenu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">"activate"</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)("剪切"));</span></span><br><span class="line">      (gpointer)(<span class="string">"Cut"</span>));</span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_COPY,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(editmenu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">"activate"</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)("复制"));</span></span><br><span class="line">      (gpointer)(<span class="string">"Copy"</span>));</span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_PASTE,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(editmenu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">"activate"</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)("粘贴"));</span></span><br><span class="line">      (gpointer)(<span class="string">"Paste"</span>));</span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_FIND,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(editmenu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">"activate"</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)("查找"));</span></span><br><span class="line">      (gpointer)(<span class="string">"Search"</span>));</span><br><span class="line">   gtk_menu_item_set_submenu(GTK_MENU_ITEM(rootmenu),editmenu);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(menubar),rootmenu);</span><br><span class="line">   rootmenu = gtk_menu_item_new_with_label(<span class="string">" 帮助 "</span>);</span><br><span class="line">   helpmenu = gtk_menu_new();</span><br><span class="line">   menuitem = gtk_image_menu_item_new_from_stock</span><br><span class="line">      (GTK_STOCK_HELP,accel_group);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(helpmenu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">"activate"</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)("帮助"));</span></span><br><span class="line">      (gpointer)(<span class="string">"Help"</span>));</span><br><span class="line">   menuitem = gtk_menu_item_new_with_label(<span class="string">" 关于... "</span>);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(helpmenu),menuitem);</span><br><span class="line">   g_signal_connect(G_OBJECT(menuitem),<span class="string">"activate"</span>,</span><br><span class="line">      G_CALLBACK(on_menu_activate),<span class="comment">//(gpointer)("关于"));</span></span><br><span class="line">   (gpointer)(<span class="string">"About"</span>));</span><br><span class="line">   gtk_menu_item_set_submenu(GTK_MENU_ITEM(rootmenu),helpmenu);</span><br><span class="line">   gtk_menu_shell_append(GTK_MENU_SHELL(menubar),rootmenu);</span><br><span class="line">   gtk_box_pack_start(GTK_BOX(box),menubar,FALSE,FALSE,<span class="number">0</span>);</span><br><span class="line">   gtk_widget_show_all(window);</span><br><span class="line">   gtk_main();</span><br><span class="line">   <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>GTK</tag>
      </tags>
  </entry>
  <entry>
    <title>接雨水</title>
    <url>/2020/02/18/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<p>来源Leetcode第42题接雨水</p>
<p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br><a id="more"></a><br><img src="/2020/02/18/接雨水/rainwatertrap.png" alt="img"></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 <strong>感谢 Marcos</strong> 贡献此图。</p>
<p><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="找短板"><a href="#找短板" class="headerlink" title="找短板"></a>找短板</h3><p>对每一个要求的位置，寻找左右两边最高的列，然后取较小的，如果较小列大于当前列，就可以装水。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(height.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; height.length - <span class="number">1</span> ; i++)&#123;</span><br><span class="line">        <span class="comment">//最两端的列不用考虑，因为一定不会有水。</span></span><br><span class="line">        <span class="keyword">int</span> left_max = <span class="number">0</span>,right_max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找出左边最高的列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            left_max = Math.max(left_max,height[j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; height.length; j++)</span><br><span class="line">            right_max = Math.max(right_max,height[j]);</span><br><span class="line">        <span class="keyword">int</span> min = Math.min(left_max,right_max);</span><br><span class="line">        <span class="keyword">if</span>(min &gt; height[i])</span><br><span class="line">            sum += min - height[i];  <span class="comment">//只有较小的一段大于当前列的高度才会有水</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/" target="_blank" rel="noopener">来源</a></p>
<p>对于每一列，我们求它左边最高的墙和右边最高的墙，都是重新遍历一遍所有高度，这里我们可以优化一下。</p>
<p>首先用两个数组，<code>max_left [i]</code>代表第 <code>i</code> 列左边最高的墙的高度，<code>max_right[i]</code> 代表第 <code>i</code> 列右边最高的墙的高度。（一定要注意下，第 i 列左（右）边最高的墙，是不包括自身的，和 leetcode 上边的讲的有些不同）</p>
<p>对于 <code>max_left</code>我们其实可以这样求。</p>
<p><code>max_left [i] = Max(max_left [i-1]</code>,<code>height[i-1])</code>。它前边的墙的左边的最高高度和它前边的墙的高度选一个较大的，就是当前列左边最高的墙了。</p>
<p>对于 max_right我们可以这样求。</p>
<p><code>max_right[i] = Max(max_right[i+1]</code>,<code>height[i+1])</code> 。它后边的墙的右边的最高高度和它后边的墙的高度选一个较大的，就是当前列右边最高的墙了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] max_left = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">    <span class="keyword">int</span>[] max_right = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        max_left[i] = Math.max(max_left[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = height.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        max_right[i] = Math.max(max_right[i + <span class="number">1</span>], height[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = Math.min(max_left[i], max_right[i]);</span><br><span class="line">        <span class="keyword">if</span> (min &gt; height[i]) &#123;</span><br><span class="line">            sum = sum + (min - height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/dong-tai-gui-hua-shuang-zhi-zhen-tu-jie-by-ml-zimi/" target="_blank" rel="noopener">来源</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = height.length - <span class="number">2</span>; <span class="comment">// 加右指针进去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//从左到右更</span></span><br><span class="line">        <span class="keyword">if</span> (height[left - <span class="number">1</span>] &lt; height[right + <span class="number">1</span>]) &#123;</span><br><span class="line">            max_left = Math.max(max_left, height[left - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> min = max_left;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; height[left]) &#123;</span><br><span class="line">                sum = sum + (min - height[left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        <span class="comment">//从右到左更</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max_right = Math.max(max_right, height[right + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> min = max_right;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; height[right]) &#123;</span><br><span class="line">                sum = sum + (min - height[right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明这里会有积水，我们将墙的高度的下标入栈。</p>
<p>如果当前高度大于栈顶的墙的高度，说明之前的积水到这里停下，我们可以计算下有多少积水了。计算完，就把当前的墙继续入栈，作为新的积水的墙。</p>
<p>总体的原则就是，</p>
<ol>
<li>当前高度小于等于栈顶高度，入栈，指针后移。</li>
<li>当前高度大于栈顶高度，出栈，计算出当前墙和栈顶的墙之间水的多少，然后计算当前的高度和新栈的高度的关系，重复第 2 步。直到当前墙的高度不大于栈顶高度或者栈空，然后把当前墙入栈，指针后移。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(height.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> popIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; height.length ; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[stack.peek()] &lt; height[i])&#123;</span><br><span class="line">            <span class="comment">//单调栈</span></span><br><span class="line">            popIndex = stack.pop();</span><br><span class="line">            <span class="comment">//将栈顶元素相等的出栈</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[stack.peek()] == height[popIndex])</span><br><span class="line">                stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">int</span> peekIndex = stack.peek();  <span class="comment">//栈顶</span></span><br><span class="line">                ans += (Math.min(height[stack.peek()],height[i]) - height[popIndex]) * (i - peekIndex - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>K个一组翻转链表</title>
    <url>/2020/02/17/K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>来源Leetcode第25题K个一组翻转链表</p>
<p>给你一个链表，每 <em>k</em> 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p><em>k</em> 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 <em>k</em> 的整数倍，那么请将最后剩余的节点保持原有顺序。<br><a id="more"></a><br><strong>示例 :</strong></p>
<p>给定这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>当 <em>k</em> = 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>当 <em>k</em> = 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p><strong>说明 :</strong></p>
<ul>
<li>你的算法只能使用常数的额外空间。</li>
<li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>最简单的思路，把K个结点压入栈中，然后出栈的顺序就是翻转后的顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || k == <span class="number">0</span> || k == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    ListNode ahead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode p1 = ahead,p2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        p2 = head;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span> &amp;&amp; count &lt; k)&#123;</span><br><span class="line">            stack.add(p2);</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count != k)&#123;</span><br><span class="line">            p1.next = head;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            p1.next = stack.pop();</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1.next = p2;</span><br><span class="line">        head = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ahead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pre</span><br><span class="line">tail    head</span><br><span class="line">dummy    <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>     <span class="number">5</span></span><br><span class="line"><span class="comment"># 我们用tail 移到要翻转的部分最后一个元素</span></span><br><span class="line">pre     head       tail</span><br><span class="line">dummy    <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>     <span class="number">5</span></span><br><span class="line">	       cur</span><br><span class="line"><span class="comment"># 我们尾插法的意思就是,依次把cur移到tail后面</span></span><br><span class="line">pre          tail  head</span><br><span class="line">dummy    <span class="number">2</span>     <span class="number">3</span>    <span class="number">1</span>     <span class="number">4</span>     <span class="number">5</span></span><br><span class="line">	       cur</span><br><span class="line"><span class="comment"># 依次类推</span></span><br><span class="line">pre     tail      head</span><br><span class="line">dummy    <span class="number">3</span>     <span class="number">2</span>    <span class="number">1</span>     <span class="number">4</span>     <span class="number">5</span></span><br><span class="line">		cur</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || k == <span class="number">0</span> || k == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode ahead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ahead.next = head;</span><br><span class="line">    ListNode pre = ahead,tail,tmp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        tail = head;</span><br><span class="line">        <span class="keyword">while</span>(tail != <span class="keyword">null</span> &amp;&amp; count &lt; k)&#123;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tail == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        tmp = pre.next;</span><br><span class="line">        <span class="keyword">while</span>(pre.next != tail)&#123;</span><br><span class="line">            ListNode cur = pre.next;  <span class="comment">// cur = 2</span></span><br><span class="line">            pre.next = cur.next; <span class="comment">//1 -&gt; 3</span></span><br><span class="line">            cur.next = tail.next; <span class="comment">//2 -&gt; k + 1</span></span><br><span class="line">            tail.next = cur;  <span class="comment">//k -&gt; 2</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = tmp;</span><br><span class="line">        tail = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ahead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode pre = dummy;</span><br><span class="line">    ListNode end = dummy;</span><br><span class="line">    <span class="keyword">while</span> (end.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="keyword">null</span>; i++) end = end.next;</span><br><span class="line">        <span class="keyword">if</span> (end == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        ListNode start = pre.next;</span><br><span class="line">        ListNode next = end.next;</span><br><span class="line">        end.next = <span class="keyword">null</span>;</span><br><span class="line">        pre.next = reverse(start);</span><br><span class="line">        start.next = next;</span><br><span class="line">        pre = start;</span><br><span class="line">        end = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = curr.next;</span><br><span class="line">        curr.next = pre;</span><br><span class="line">        pre = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>缺失的数字</title>
    <url>/2020/02/17/%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>来自Leetcode第268题缺失数字</p>
<p>给定一个包含 <code>0, 1, 2, ..., n</code> 中 <em>n</em> 个数的序列，找出 0 .. <em>n</em> 中没有出现在序列中的那个数。<br><a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>利用数组标记各个数字是否出现，最后遍历数组，找到没出现的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : nums)</span><br><span class="line">        map[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; map.length; i++)</span><br><span class="line">        <span class="keyword">if</span>(map[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> nums.length + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异或位运算"><a href="#异或位运算" class="headerlink" title="异或位运算"></a>异或位运算</h3><p>来自<a href="https://leetcode-cn.com/problems/missing-number/solution/que-shi-shu-zi-by-leetcode/" target="_blank" rel="noopener">官方题解</a></p>
<p>我们知道数组中有 <em>n</em> 个数，并且缺失的数在 [0..n][0..<em>n</em>] 中。因此我们可以先得到 [0..n][0..<em>n</em>] 的异或值，再将结果对数组中的每一个数进行一次异或运算。未缺失的数在 [0..n][0..<em>n</em>] 和数组中各出现一次，因此异或后得到 0。而缺失的数字只在 [0..n][0..<em>n</em>] 中出现了一次，在数组中没有出现，因此最终的异或结果即为这个缺失的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> missing = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            missing ^= i ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> missing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求和公式"><a href="#求和公式" class="headerlink" title="求和公式"></a>求和公式</h3><p>我们可以用 <a href="https://baike.baidu.com/item/高斯求和" target="_blank" rel="noopener">高斯求和公式</a> 求出 [0..n][0..<em>n</em>] 的和，减去数组中所有数的和，就得到了缺失的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expectedSum = nums.length*(nums.length + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> actualSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) actualSum += num;</span><br><span class="line">        <span class="keyword">return</span> expectedSum - actualSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以遍历一遍数组，在把0-n这n个自然数全加起来的同时也减去nums[i]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        sum -= nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>各位相加</title>
    <url>/2020/02/17/%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<p>来源Leetcode第258题</p>
<p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。<br><a id="more"></a><br><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">38</span></span><br><span class="line">输出: <span class="number">2</span> </span><br><span class="line">解释: 各位相加的过程为：<span class="number">3</span> + <span class="number">8</span> = <span class="number">11</span>, <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span>。 由于 <span class="number">2</span> 是一位数，所以返回 <span class="number">2</span>。</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong><br>你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？</p>
<hr>
<h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>按照题意暴力运算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(num/<span class="number">10</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        num = add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        res+=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="取余"><a href="#取余" class="headerlink" title="取余"></a>取余</h3><p>X = 100*a + 10*b + c = 99*a + 9*b + (a+b+c)；所以对9取余即可。</p>
<p>但是要注意当X是9的倍数时，即(a+b+c)也是9的倍数，这时候返回9即可，因为只要是9的倍数，其各位相加一定为9，否则返回X % 9.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num &lt; <span class="number">10</span> ? num : (num % <span class="number">9</span> == <span class="number">0</span> ? <span class="number">9</span> : num % <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大佬的精简代码</p>
<pre><code class="lang-JAVA">    public int addDigits(int num) {
        return (num-1)%9+1;
    }
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>只出现一次的数字III</title>
    <url>/2020/02/17/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97III/</url>
    <content><![CDATA[<p>来源Leetcode第260只出现一次的数字III</p>
<p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，<strong>其余所有元素均出现两次</strong>。 找出只出现一次的那两个元素。<br><a id="more"></a><br><strong>示例 :</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>建立一个值到频率的映射关系的哈希表，返回频率为 1 的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//int sum = 0;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(num % <span class="number">10</span>);</span><br><span class="line">            num = num / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!list.isEmpty())&#123;</span><br><span class="line">            num += list.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>来源<a href="https://leetcode-cn.com/problems/single-number-iii/solution/zhi-chu-xian-yi-ci-de-shu-zi-iii-by-leetcode/" target="_blank" rel="noopener">官方题解</a></p>
<p>在做这题时没有注意到题目给出了信息<strong>其余所有元素均出现两次</strong>，这样就好说了。</p>
<p>首先计算 <code>bitmask ^= x</code>，则 <code>bitmask</code> 不会保留出现两次数字的值，因为相同数字的异或值为 <code>0</code>。但是 <code>bitmask</code> 会保留只出现一次的两个数字（<code>x</code> 和 <code>y</code>）之间的差异。我们通过 <code>bitmask &amp; (-bitmask)</code> 保留 <code>bitmask</code> 最右边的 <code>1</code>，这个 <code>1</code> 要么来自 <code>x</code>，要么来自 <code>y</code>。当我们找到了 <code>x</code>，那么 <code>y = bitmask^x</code>。</p>
<p>另外一个解释：</p>
<p>1.对所有数字异或,一样的数字抵消,出现一次的两个数字异或运算后必定不为0;<br>2.这个数字和相反数做与运算得到一个二进制位最右边一位为1的数字;<br>3.mask和数组的每个数字做与运算,等于0的分为一组,等于mask的分为一组,同时也将两个不一样的数字分开;<br>4.完结。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//int sum = 0;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(num % <span class="number">10</span>);</span><br><span class="line">            num = num / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!list.isEmpty())&#123;</span><br><span class="line">            num += list.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums)<span class="comment">// 一样的抵消,不一样的两个数字异或运算结果必定有一位是1</span></span><br><span class="line">        xor ^= i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mask = xor &amp; (-xor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; mask) == <span class="number">0</span>)<span class="comment">//== 0、 == mask 两种结果</span></span><br><span class="line">            ans[<span class="number">0</span>] ^= i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans[<span class="number">1</span>] ^= i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Nim游戏</title>
    <url>/2020/02/15/Nim%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>来源Leetcode第292题Nim游戏</p>
<p>你和你的朋友，两个人一起玩 <a href="https://baike.baidu.com/item/Nim游戏/6737105" target="_blank" rel="noopener">Nim 游戏</a>：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p>
<p>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。<br><a id="more"></a><br><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">4</span></span><br><span class="line">输出: <span class="literal">false</span> </span><br><span class="line">解释: 如果堆中有 <span class="number">4</span> 块石头，那么你永远不会赢得比赛；</span><br><span class="line">     因为无论你拿走 <span class="number">1</span> 块、<span class="number">2</span> 块 还是 <span class="number">3</span> 块石头，最后一块石头总是会被你的朋友拿走。</span><br></pre></td></tr></table></figure>
<hr>
<p>直觉告诉我是4的倍数就稳输</p>
<p>以下内容来自<a href="https://leetcode-cn.com/problems/nim-game/solution/nimyou-xi-by-leetcode/" target="_blank" rel="noopener">官方题解</a></p>
<p>让我们考虑一些小例子。显而易见的是，如果石头堆中只有一块、两块、或是三块石头，那么在你的回合，你就可以把全部石子拿走，从而在游戏中取胜。而如果就像题目描述那样，堆中恰好有四块石头，你就会失败。因为在这种情况下不管你取走多少石头，总会为你的对手留下几块，使得他可以在游戏中打败你。因此，要想获胜，在你的回合中，必须避免石头堆中的石子数为 4 的情况。</p>
<p>同样地，如果有五块、六块、或是七块石头，你可以控制自己拿取的石头数，总是恰好给你的对手留下四块石头，使他输掉这场比赛。但是如果石头堆里有八块石头，你就不可避免地会输掉，因为不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，以确保在再一次轮到你的时候，你会面对四块石头。</p>
<p>显然，它以相同的模式不断重复 n=4,8,12,16，基本可以看出是 4 的倍数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n % <span class="number">4</span> != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>长度最小的子数组</title>
    <url>/2020/02/13/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>来自Leetcode第209题长度最小的子数组</p>
<p>给定一个含有 <strong>n</strong> 个正整数的数组和一个正整数 <strong>s ，</strong>找出该数组中满足其和 <strong>≥ s</strong> 的长度最小的连续子数组<strong>。</strong>如果不存在符合条件的连续子数组，返回 0。<br><a id="more"></a><br><strong>示例:</strong> </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="number">7</span>, nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 子数组 [<span class="number">4</span>,<span class="number">3</span>] 是该条件下的长度最小的连续子数组。</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong></p>
<p>如果你已经完成了<em>O</em>(<em>n</em>) 时间复杂度的解法, 请尝试 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度的解法。</p>
<h3 id="丢人写法"><a href="#丢人写法" class="headerlink" title="丢人写法"></a>丢人写法</h3><p>双指针，一开始按照等于做的直接错了，是大于等于，此外还要注意临界条件，当<code>nums[right] &gt;= s</code>时，可以直接返回1；当<code>if(minlen == Integer.MAX_VALUE || right - left == len)</code>时，意味着没满足条件，应当返回0.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minlen = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>,len = nums.length;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[right] &gt;= s)&#123;</span><br><span class="line">            <span class="comment">//minlen = 1;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= s)&#123;</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= s &amp;&amp; left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minlen &gt; right - left + <span class="number">1</span>) &#123;</span><br><span class="line">                    minlen = right - left + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                    sum -= nums[left];</span><br><span class="line">                    left++;  <span class="comment">//左指针移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minlen == Integer.MAX_VALUE || right - left == len)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> minlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="精简双指针"><a href="#精简双指针" class="headerlink" title="精简双指针"></a>精简双指针</h3><p>用双指针 left 和 right 表示一个窗口。</p>
<ol>
<li>right 向右移增大窗口，直到窗口内的数字和大于等于了 <code>s</code>。进行第 <code>2</code> 步。</li>
<li>记录此时的长度，left 向右移动，开始减少长度，每减少一次，就更新最小长度。直到当前窗口内的数字和小于了 <code>s</code>，回到第 1 步。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">            min = Math.min(min, right - left);</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="number">0</span> : min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-43/" target="_blank" rel="noopener">来自</a></p>
<p>题目中，我们要寻找连续的数字和大于等于 <code>s</code> 的最小长度。那么，我们可以对这个长度采取二分的方法去寻找吗？</p>
<p>答案是肯定的，原因就是长度为 <code>1</code> 的所有连续数字中最大的和、长度为 <code>2</code> 的所有连续数字中最大的和、长度为 <code>3</code> 的所有连续数字中最大的和 … 长度为 <code>n</code> 的所有连续数字中最大的和，同样是一个升序数组。</p>
<p>算法的话就是对长度进行二分，寻求满足条件的最小长度。</p>
<p>对于长度为 <code>n</code> 的数组，我们先去判断长度为 <code>n/2</code> 的连续数字中最大的和是否大于等于 <code>s</code>。</p>
<ul>
<li>如果大于等于 <code>s</code> ，那么我们需要减少长度，继续判断所有长度为 <code>n/4</code> 的连续数字</li>
<li>如果小于 <code>s</code>，我们需要增加长度，我们继续判断所有长度为 <code>(n/2 + n) / 2</code>，也就是 <code>3n/4</code> 的连续数字。</li>
</ul>
<p>可以再结合下边的代码看一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minLen = <span class="number">0</span>, maxLen = n;</span><br><span class="line">    <span class="keyword">int</span> midLen;</span><br><span class="line">    <span class="keyword">int</span> min = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (minLen &lt;= maxLen) &#123;</span><br><span class="line">        <span class="comment">//取中间的长度</span></span><br><span class="line">        midLen = (minLen + maxLen) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//判断当前长度的最大和是否大于等于 s</span></span><br><span class="line">        <span class="keyword">if</span> (getMaxSum(midLen, nums) &gt;= s) &#123;</span><br><span class="line">            maxLen = midLen - <span class="number">1</span>; <span class="comment">//减小长度</span></span><br><span class="line">            min = midLen; <span class="comment">//更新最小值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minLen = midLen + <span class="number">1</span>; <span class="comment">//增大长度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min == -<span class="number">1</span> ? <span class="number">0</span> : min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxSum</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 达到长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    maxSum = sum; <span class="comment">// 初始化 maxSum</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 加一个数字减一个数字，保持长度不变</span></span><br><span class="line">        sum += nums[i];</span><br><span class="line">        sum = sum - nums[i - len];</span><br><span class="line">        <span class="comment">// 更新 maxSum</span></span><br><span class="line">        maxSum = Math.max(maxSum, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口中的最大值</title>
    <url>/2020/02/13/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<p>来源Leetcode第239题滑动窗口中的最大值</p>
<p>给定一个数组 <em>nums</em>，有一个大小为 <em>k</em> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <em>k</em> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。<br><a id="more"></a><br><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], 和 k = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>] <span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [<span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span> [<span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">6</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<p>你可以假设 <em>k</em> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>
<hr>
<h3 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h3><p>思路同重复元素III，在数组中划定长度为k的滑动窗口，通过2重循环，依次找到每个滑动窗口里的最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len * k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> [] ans = <span class="keyword">new</span> <span class="keyword">int</span>[len - k + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - k + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; i + k; j++)</span><br><span class="line">            max = Math.max(max,nums[j]);</span><br><span class="line">        ans[i] = max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/dan-diao-dui-lie-by-labuladong/" target="_blank" rel="noopener">来源</a></p>
<p>「单调队列」的核心思路和「单调栈」类似。单调队列的 push 方法依然在队尾添加元素，但是要把前面比新元素小的元素都删掉.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!data.isEmpty() &amp;&amp; data.getLast() &lt; n)</span><br><span class="line">            data.removeLast();</span><br><span class="line">        data.addLast(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!data.isEmpty() &amp;&amp; data.getFirst() ==n)</span><br><span class="line">            data.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">deque</span><span class="params">()</span></span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len * k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> [] ans = <span class="keyword">new</span> <span class="keyword">int</span>[len - k + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span></span><br><span class="line">    deque window = <span class="keyword">new</span> deque();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; k - <span class="number">1</span>)</span><br><span class="line">            window.push(nums[i]);  <span class="comment">//先填满窗口前的k - 1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//窗口向前滑动</span></span><br><span class="line">            window.push(nums[i]);</span><br><span class="line">            ans[i - k + <span class="number">1</span>] = window.max();</span><br><span class="line">            window.pop(nums[i-k+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums.length * k == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] ans=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(nums.length&lt;k)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> begin=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end=k-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max=Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> stand=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k-<span class="number">1</span>;i++)&#123;  <span class="comment">//先填充初始滑动窗口</span></span><br><span class="line">        <span class="keyword">if</span>(max&lt;nums[i])&#123;</span><br><span class="line">            max=nums[i];</span><br><span class="line">            stand=i; <span class="comment">//记录最大值的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans[count]=nums[stand];</span><br><span class="line">    count++;</span><br><span class="line">    begin++;</span><br><span class="line">    end++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(end&lt;nums.length)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[end]&gt;max)&#123;</span><br><span class="line">            max=nums[end];</span><br><span class="line">            stand=end;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(begin&gt;stand)&#123;  <span class="comment">//最大值离开了滑动窗口</span></span><br><span class="line">            max=Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;=end;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(max&lt;nums[i])&#123;</span><br><span class="line">                    max=nums[i];</span><br><span class="line">                    stand=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans[count]=nums[stand];</span><br><span class="line">        count++;</span><br><span class="line">        begin++;</span><br><span class="line">        end++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树中第K小的元素</title>
    <url>/2020/02/13/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>来自Leetcode第230题二叉搜索树中第K小的元素</p>
<p>给定一个二叉搜索树，编写一个函数 <code>kthSmallest</code> 来查找其中第 <strong>k</strong> 个最小的元素。</p>
<p><strong>说明：</strong><br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。<br><a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: root = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">2</span>], k = <span class="number">1</span></span><br><span class="line">   <span class="number">3</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">  \</span><br><span class="line">   <span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="二叉树中序遍历"><a href="#二叉树中序遍历" class="headerlink" title="二叉树中序遍历"></a>二叉树中序遍历</h3><p>通过中序遍历按序保存二叉搜索树中的节点值，最后返回<code>K-1</code>位置的值即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; tree = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    helper(root);</span><br><span class="line">    <span class="keyword">return</span> tree.get(k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    helper(root.left);</span><br><span class="line">    tree.add(root.val);</span><br><span class="line">    helper(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>来源<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/solution/er-cha-sou-suo-shu-zhong-di-kxiao-de-yuan-su-by-le/" target="_blank" rel="noopener">官方题解</a></p>
<p>在栈的帮助下，可以将方法一的递归转换为迭代，这样可以加快速度，因为这样可以不用遍历整个树，可以在找到答案后停止。</p>
<p><img src="/2020/02/13/二叉搜索树中第K小的元素/25159a5137867644b75f203ee1917645d2cd454d8f4871e371d7edfa67bef083-file_1579413216176.jfif" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.add(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.removeLast();  <span class="comment">//最后入栈的是最小的元素，即最左边的根结点</span></span><br><span class="line">        <span class="keyword">if</span>(--k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        root = root.right;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>用一个变量记录遍历了的位置，最后返回对应位置的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>,minimum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    kthSmallest(root.left,k);</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">if</span>(num==k)</span><br><span class="line">    &#123;</span><br><span class="line">        minimum=root.val;</span><br><span class="line">        <span class="keyword">return</span> minimum;</span><br><span class="line">    &#125;</span><br><span class="line">    kthSmallest(root.right,k);</span><br><span class="line">    <span class="keyword">return</span> minimum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>除自身以外数组的乘积</title>
    <url>/2020/02/12/%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<p>来自Leetcode第238题除自身以外数组的乘积</p>
<p>给定长度为 <em>n</em> 的整数数组 <code>nums</code>，其中 <em>n</em> &gt; 1，返回输出数组 <code>output</code> ，其中 <code>output[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积。<br><a id="more"></a><br><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出: [<span class="number">24</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong> 请<strong>不要使用除法，</strong>且在 O(<em>n</em>) 时间复杂度内完成此题。</p>
<p><strong>进阶：</strong><br>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组<strong>不被视为</strong>额外空间。）</p>
<hr>
<p>这似乎是一个简单的问题，可以在线性时间和空间内解决。可以先计算给定数组所有元素的乘积，然后对数组中的每个元素 <em>x</em>，将乘积除以 x* 来求得除自身值的以外的数组乘积。</p>
<p>然后这样的解决方法有一个问题，就是如果输入数组中出现 0，那么这个方法就失效了。而且在问题中说明了不允许使用除法运算。这增加了这个问题的难度。</p>
<ol>
<li>初始化数组长度<em>n</em>。初始化r<strong>e</strong>s<em>=[0,0,…,0]为1\</em>n<em>的数组。初试化乘积k</em>=1</li>
<li>从左向右遍历，遍历区间[0,<em>n</em>)：<ul>
<li><em>r<strong>e</strong>s</em>每个位置保存它左侧所有元素的乘积。即<em>r<strong>e</strong>s</em>[<em>i</em>]=<em>k</em>,<em>k</em>∗=<em>n<strong>u</strong>ms</em>[<em>i</em>]</li>
</ul>
</li>
<li>重置乘积<em>k</em>=1，用来保存元素右边的乘积和</li>
<li>从右向左遍历，遍历区间(<em>n</em>,0]：<ul>
<li>r<strong>e</strong>s<em>[</em>i<em>]∗=</em>k，表示将当前位置的左积乘以右积。</li>
<li>更新右积k<em>∗=</em>n<strong>u</strong>m<em>s</em>[<em>i</em>]</li>
</ul>
</li>
<li>返回<em>r<strong>e</strong>s</em></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ans.length ; i++)&#123;</span><br><span class="line">        ans[i] = tmp;</span><br><span class="line">        tmp *= nums[i]; <span class="comment">// 此时数组存储的是除去当前元素左边的元素乘积</span></span><br><span class="line">    &#125;</span><br><span class="line">    tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ans.length - <span class="number">1</span>;i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">        ans[i] *= tmp;  <span class="comment">// tmp为该数右边的乘积。</span></span><br><span class="line">        tmp *= nums[i];  <span class="comment">// 此时数组等于左边的 * 该数右边的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的字母异位词</title>
    <url>/2020/02/12/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<p>来自Leetcode第242题有效的字母异位词</p>
<p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。<br><a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"anagram"</span>, <span class="attr">t</span> = <span class="string">"nagaram"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>用2个数组统计字符串里的字母出现次数，最后比对他们是否相等，进一步优化的，因为我们可以用一个计数器表计算 s 字母的频率，用 t减少计数器表中的每个字母的计数器，然后检查计数器是否回到零。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = s.length(), len2 = t.length();</span><br><span class="line">    <span class="keyword">if</span>(len1 != len2)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> []map1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> []map2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len1 ; i++)&#123;</span><br><span class="line">        map1[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        map2[t.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; i++)</span><br><span class="line">        <span class="keyword">if</span>(map1[i] != map2[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>将 <em>s</em> 的字母重新排列成 t<em> 来生成变位词。因此，如果 </em>T<em> 是 </em>S<em> 的变位词，对两个字符串进行排序将产生两个相同的字符串。此外，如果 </em>s<em> 和 t</em> 的长度不同，<em>t</em> 不能是 <em>s</em> 的变位词，我们可以提前返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] str1 = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] str2 = t.toCharArray();</span><br><span class="line">    Arrays.sort(str1);</span><br><span class="line">    Arrays.sort(str2);</span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(str1, str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>回文链表</title>
    <url>/2020/02/12/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>来自Leetcode第234题回文链表</p>
<p>请判断一个链表是否为回文链表。<br><a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="equals"><a href="#equals" class="headerlink" title=".equals"></a>.equals</h3><p>这种题目其实之前就做过了，但是很明显还是忘了，用了O(n)的空间复杂度来存储整个链表的内容，但是发现在比对的时候，如果直接用<code>!=</code>得到的结果是<code>.equals()</code>是不一样的，<code>!=</code>得不到正确的运行结果。</p>
<p>这里补充一下<code>.equals()</code>和<code>!=</code>的区别</p>
<p>equals是判断两个变量或者实例指向不同内存空间的值是不是相同</p>
<p>而==是判断两个变量或者实例是不是指向同一个内存空间</p>
<p>举个通俗的例子来说，==是判断两个人是不是住在同一个地址，而equals是判断不同地址里住的人是不是同一个</p>
<p>在这题中，有一个测试用例为-129，首先看一下Integer的源码</p>
<p><img src="/2020/02/12/回文链表/20170418111933837.jfif" alt="img"></p>
<p>high的值为127，low的值为-128，当进行这个方法时如果值在-128-127之间，返回的值也就是地址是相同的，因而用<code>!=</code>这个测试用例自然就过不了了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    LinkedList&lt;Integer&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ans.addLast(p1.val);</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ans.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ans.removeFirst().equals(ans.removeLast()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="翻转链表比对"><a href="#翻转链表比对" class="headerlink" title="翻转链表比对"></a>翻转链表比对</h3><p>避免使用 O(n)<em>O</em>(<em>n</em>) 额外空间的方法就是改变输入。</p>
<p>我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，因为使用该函数的人不希望链表结构被更改。</p>
<p><strong>算法：</strong></p>
<p>我们可以分为以下几个步骤：</p>
<ol>
<li><p>找到前半部分链表的尾节点。</p>
</li>
<li><p>反转后半部分链表。</p>
</li>
<li><p>判断是否为回文。</p>
</li>
<li><p>恢复链表。</p>
</li>
<li><p>返回结果。</p>
<p>执行步骤一，我们可以计算链表节点的数量，然后遍历链表找到前半部分的尾节点。</p>
<p>或者可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针到链表的中间。通过慢指针将链表分为两部分。</p>
<p>若链表有奇数个节点，则中间的节点应该看作是前半部分。</p>
<p>步骤二可以使用在反向链表问题中找到解决方法来反转链表的后半部分。</p>
<p>步骤三比较两个部分的值，当后半部分到达末尾则比较完成，可以忽略计数情况中的中间节点。</p>
<p>步骤四与步骤二使用的函数相同，再反转一次恢复链表本身。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从slow后面的链表逆序</span></span><br><span class="line">        ListNode node = slow.next;</span><br><span class="line">        ListNode curNode = node;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode nextNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(curNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            nextNode = curNode.next;</span><br><span class="line">            curNode.next = pre;</span><br><span class="line">            pre = curNode;</span><br><span class="line">            curNode = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.val != pre.val)&#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h3><p>从头到尾和从尾到头比对</p>
<p><strong>equals 默认是比较地址的<br>但是string重写了equals方法，让他比较内容<br>stringbuffer和stringbuilder并没有重写equals方法，所以比较的是地址<br>只有string可以比较内容
</strong></p>
<pre><code class="lang-JAVA">        public boolean isPalindrome(ListNode head) {
            if(head == null)
                return true;
            ListNode p1 = head;
            StringBuilder s1 = new StringBuilder();
            StringBuilder s2 = new StringBuilder();

            while(p1 != null){
                s1.append(p1.val);
                s2.insert(0,p1.val);
                p1 = p1.next;
            }
            return s1.toString().equals(s2.toString());
        }
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回文</tag>
      </tags>
  </entry>
  <entry>
    <title>用栈实现队列</title>
    <url>/2020/02/11/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>来自Leetcode第232题用栈实现队列</p>
<p>使用栈实现队列的下列操作：</p>
<ul>
<li>push(x) — 将一个元素放入队列的尾部。</li>
<li>pop() — 从队列首部移除元素。</li>
<li>peek() — 返回队列首部的元素。</li>
<li>empty() — 返回队列是否为空。<a id="more"></a>
<strong>示例:</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyQueue <span class="built_in">queue</span> = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">queue</span>.peek();  <span class="comment">// 返回 1</span></span><br><span class="line"><span class="built_in">queue</span>.pop();   <span class="comment">// 返回 1</span></span><br><span class="line"><span class="built_in">queue</span>.empty(); <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>你只能使用标准的栈操作 — 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li>
</ul>
<hr>
<h3 id="铁憨憨"><a href="#铁憨憨" class="headerlink" title="铁憨憨"></a>铁憨憨</h3><p>一开始想用1个栈实现队列，但是发现1个栈倒腾之后栈里元素的顺序会错乱，因而还是老老实实用了2个栈，一个用来压入元素，一个用来实现出队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; instack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; outstack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!outstack.empty())</span><br><span class="line">            instack.push(outstack.pop());</span><br><span class="line">        instack.push(x);</span><br><span class="line">        <span class="keyword">while</span> (!instack.empty())</span><br><span class="line">            outstack.push(instack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> outstack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> outstack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> outstack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行用时为-0-ms-的范例"><a href="#执行用时为-0-ms-的范例" class="headerlink" title="执行用时为 0 ms 的范例"></a>执行用时为 0 ms 的范例</h3><p>仔细看了看，这个范例8行，还得看题解的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s1, s2;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) top = x;</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == size - <span class="number">2</span>) &#123;</span><br><span class="line">                top = s1.pop();</span><br><span class="line">                s2.push(top);</span><br><span class="line">            &#125; <span class="keyword">else</span> s2.push(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> element = s1.pop();</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) s1.push(s2.pop());</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用两个栈-入队-O-1-，出队-摊还复杂度-O-1"><a href="#使用两个栈-入队-O-1-，出队-摊还复杂度-O-1" class="headerlink" title="使用两个栈 入队 - O(1)，出队 - 摊还复杂度 O(1)"></a>使用两个栈 入队 - O(1)，出队 - 摊还复杂度 O(1)</h3><p>来自<a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/yong-zhan-shi-xian-dui-lie-by-leetcode/" target="_blank" rel="noopener">官方题解</a></p>
<p>新元素总是压入 <code>s1</code> 的栈顶，同时我们会把 <code>s1</code> 中压入的第一个元素赋值给作为队首元素的 <code>front</code> 变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push element x to the back of queue.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.empty())</span><br><span class="line">        front = x;</span><br><span class="line">    s1.push(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据栈 <code>LIFO</code> 的特性，<code>s1</code> 中第一个压入的元素在栈底。为了弹出 <code>s1</code> 的栈底元素，我们得把 <code>s1</code> 中所有的元素全部弹出，再把它们压入到另一个栈 <code>s2</code> 中，这个操作会让元素的入栈顺序反转过来。通过这样的方式，<code>s1</code> 中栈底元素就变成了 <code>s2</code> 的栈顶元素，这样就可以直接从 <code>s2</code> 将它弹出了。一旦 <code>s2</code> 变空了，我们只需把 <code>s1</code> 中的元素再一次转移到 <code>s2</code> 就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Removes the element from in front of queue.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s2.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty())</span><br><span class="line">            s2.push(s1.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    s2.pop();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>s1</code> 和 <code>s2</code> 都存有队列的元素，所以只需要检查 <code>s1</code> 和 <code>s2</code> 是否都为空就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Return whether the queue is empty.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.isEmpty() &amp;&amp; s2.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了 <code>front</code> 变量来保存队首元素，每次 <code>入队</code> 操作我们都会随之更新这个变量。当 <code>s2</code> 为空，<code>front</code> 变量就是对首元素，当 <code>s2</code> 非空，<code>s2</code> 的栈顶元素就是队首元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get the front element.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s2.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数据结构设计</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>求众数II</title>
    <url>/2020/02/11/%E6%B1%82%E4%BC%97%E6%95%B0II/</url>
    <content><![CDATA[<p>来源Leetcode第229题求众数II</p>
<p>给定一个大小为 <em>n</em> 的数组，找出其中所有出现超过 <code>⌊ n/3 ⌋</code> 次的元素。<br><a id="more"></a><br><strong>说明:</strong> 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: [<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>如果无视了题目的要求，直接无脑上HashMap，那么这题非常简单，对数组一次遍历，将其出现次数存入Map，然后在对Map做一次遍历，取出里面的众数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> times = nums.length / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(nums[i]))&#123;</span><br><span class="line">            map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(nums[i],map.get(nums[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Map.Entry&lt;Integer,Integer&gt; entry = null;</span></span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Integer , Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">        <span class="keyword">if</span>(entry.getValue() &gt; times)</span><br><span class="line">            ans.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h3><p>来自<a href="https://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html" target="_blank" rel="noopener">网站</a></p>
<p>选票情况为：<br>A A A C C B B C C C B C C<br>结果应该是<code>C</code></p>
<ul>
<li>算法执行过程<br><img src="/2020/02/11/求众数II/76ab0f592cceba613016d5b9c6b5eb6a5e4607dc12d50deab1de33debd4604ff.gif" alt="img"></li>
</ul>
<p>因为可能会产生两名。所以候选人cand<em>c<strong>a</strong>n**d</em>与计数cnt<em>c<strong>n</strong>t</em>都转成相应的数组形式cands<em>c<strong>a</strong>n<strong>d</strong>s</em>与cnts<em>c<strong>n</strong>t**s</em>，长度都为2。<br>第一阶段成对抵销时，<code>cands[0]</code>与<code>cands[1]</code>的选票不相互抵销，即如果代表将票投给了<code>cands[0]</code>，则<code>cands[1]</code>对应的<code>cnts[1]</code>的值不变化。<br>投给<code>cands[1]</code>也是同样的道理。这样就转化成摩尔投票法的原始情形了。<br>第二阶段计数时，除了要判断两个候选的票数是否超过三分之一，还需判断两个候选是否相同。</p>
<p>至多选出m个代表，每个选票数大于n / (m + 1)，只需要将判断最后候选是否相同代码进行修改即可。</p>
<pre><code class="lang-JAVA">    public List&lt;Integer&gt; majorityElement(int[] nums) {
        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
        if(nums.length == 0 || nums == null)
            return ans;

        //初始化：定义两个候选人及其对应的票数
        int candidateA = nums[0];
        int candidateB = nums[0];
        int countA = 0;
        int countB = 0;

        //遍历数组
        for (int num : nums) {
            if (num == candidateA) {
                countA++;//投A
                continue;
            }
            if (num == candidateB) {
                countB++;//投B
                continue;
            }

            //此时当前值和AB都不等，检查是否有票数减为0的情况，如果为0，则更新候选人
            if (countA == 0) {
                candidateA = num;
                countA++;
                continue;
            }
            if (countB == 0) {
                candidateB = num;
                countB++;
                continue;
            }
            //若此时两个候选人的票数都不为0，且当前元素不投AB，那么A,B对应的票数都要--;
            countA--;
            countB--;
        }

        //上一轮遍历找出了两个候选人，但是这两个候选人是否均满足票数大于N/3仍然没法确定，需要重新遍历，确定票数
        countA = 0;
        countB = 0;
        for (int num : nums) {
            if (num == candidateA)
                countA++;
            else if (num == candidateB)
                countB++;
        }
        if (countA &gt; nums.length / 3)
            ans.add(candidateA);
        if (countB &gt; nums.length / 3)
            ans.add(candidateB);

        return ans;
    }
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>投票法</tag>
      </tags>
  </entry>
  <entry>
    <title>二的幂</title>
    <url>/2020/02/11/%E4%BA%8C%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<p>来源Leetcode第231题 2的幂</p>
<p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。<br><a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: <span class="number">20</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2147483648"><a href="#2147483648" class="headerlink" title="2147483648"></a>2147483648</h3><p>最开始的移位比对超时后，评论区有人提到用(2^32 % n)，因为2^32 % n一定为0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> test = <span class="number">2147483647</span>;</span><br><span class="line">    test += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; test % n == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p><a href="https://leetcode-cn.com/problems/power-of-two/solution/2de-mi-by-leetcode/" target="_blank" rel="noopener">来自</a></p>
<p>我们不打算在这里讨论时间复杂度为 O(log<em>N</em>) 的解决方案。该问题将通过位运算在 O(1) 的时间复杂度解决，通过使用如下的按位技巧：</p>
<ul>
<li>如何获取二进制中最右边的 <code>1</code>：<code>x &amp; (-x)</code>。</li>
<li>如何将二进制中最右边的 <code>1</code> 设置为 <code>0</code>：<code>x &amp; (x - 1)</code>。</li>
</ul>
<h4 id="位运算：获取二进制中最右边的-1"><a href="#位运算：获取二进制中最右边的-1" class="headerlink" title="位运算：获取二进制中最右边的 1"></a>位运算：获取二进制中最右边的 1</h4><p>易知，x 和 -x 只有一个共同点：最右边的 1。这说明 <code>x &amp; (-x)</code> 将保留最右边的 1。并将其他的位设置为 0。通过 <code>x &amp; (-x)</code> 保留了最右边的 1，并将其他位设置为 0 若 <code>x</code> 为 2 的幂，则它的二进制表示中只包含一个 1，则有 <code>x &amp; (-x) = x</code>。</p>
<p>若 <code>x</code> 不是 2 的幂，则在二进制表示中存在其他 1，因此 <code>x &amp; (-x) != x</code>。</p>
<p>因此判断是否为 2 的幂的关键是：判断 <code>x &amp; (-x) == x</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">long</span> x = (<span class="keyword">long</span>) n;</span><br><span class="line">    <span class="keyword">return</span> (x &amp; (-x)) == x;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="位运算：去除二进制中最右边的-1"><a href="#位运算：去除二进制中最右边的-1" class="headerlink" title="位运算：去除二进制中最右边的 1"></a>位运算：去除二进制中最右边的 1</h4><p>易知，<code>x &amp; (x - 1)</code> 可以将最右边的 1 设置为 0。因而，<code>x &amp; (x - 1)</code> 操作会将 2 的幂设置为 0，因此判断是否为 2 的幂是：判断 <code>x &amp; (x - 1) == 0</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">long</span> x = (<span class="keyword">long</span>) n;</span><br><span class="line">   <span class="keyword">return</span> (x &amp; (x - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>汇总区间</title>
    <url>/2020/02/11/%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<p>来源Leetcode第228题汇总区间</p>
<p>给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。<br><a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">输出: [<span class="string">"0-&gt;2"</span>,<span class="string">"4-&gt;5"</span>,<span class="string">"7"</span>]</span><br><span class="line">解释: <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span> 可组成一个连续的区间; <span class="number">4</span>,<span class="number">5</span> 可组成一个连续的区间。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>用两个指针i,j，分别初始化为0,1，利用尾指针j一直向前寻找满足<code>nums[j] - nums[j - 1] == 1</code>的位置，当i,j之差≥2时，说明产生了区间合并，这时将nums[j - 1]加入String中即可。最后在结束时还要判断一下指针i的位置，如果在最尾，说明最后一个独立的不连续的元素没有添加。</p>
<pre><code class="lang-JAVA">    public List&lt;String&gt; summaryRanges(int[] nums) {
        List&lt;String&gt; ans = new ArrayList&lt;&gt;();
        if(nums.length == 0 || nums == null)
            return ans;
        int i = 0 , j = 1;
        while(j &lt; nums.length){
            while (j &lt; nums.length &amp;&amp; nums[j] - nums[j - 1] == 1){
                j++;
            }
            String tmp = &quot;&quot; + nums[i];
            if(j - i &gt;= 2)
                tmp += &quot;-&gt;&quot; + nums[j - 1];
            ans.add(tmp);
            i = j;
            j = i + 1;
        }
        if(i == nums.length - 1){
            String tmp = &quot;&quot; + nums[i];
            ans.add(tmp);
        }
        return ans;
    }
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>用队列实现栈</title>
    <url>/2020/02/10/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    <content><![CDATA[<p>来自Leetcode第225题用队列实现栈</p>
<p>使用队列实现栈的下列操作：</p>
<ul>
<li>push(x) — 元素 x 入栈</li>
<li>pop() — 移除栈顶元素</li>
<li>top() — 获取栈顶元素</li>
<li><p>empty() — 返回栈是否为空</p>
<a id="more"></a>
<p><strong>注意:</strong></p>
</li>
<li><p>你只能使用队列的基本操作— 也就是 <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, 和 <code>is empty</code> 这些操作是合法的。</p>
</li>
<li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
<li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li>
</ul>
<hr>
<p>用一个链表实现，压栈时就先将元素压到队列尾，然后在依次移除队列里的元素，在添加到队列尾。</p>
<pre><code class="lang-JAVA">    class MyStack {

        private LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        /** Initialize your data structure here. */
        public MyStack() {
        }

        /** Push element x onto stack. */
        public void push(int x) {
            queue.add(x);
            int size = queue.size();
            while(size &gt; 1){
                queue.add(queue.remove());  //移动队首元素至队列尾，从而实现了后进先出
                size--;
            }
        }

        /** Removes the element on top of the stack and returns that element. */
        public int pop() {
            return queue.remove();
        }

        /** Get the top element. */
        public int top() {
            return queue.peek();
        }

        /** Returns whether the stack is empty. */
        public boolean empty() {
            return queue.isEmpty();
        }
    }
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数据结构设计</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>矩形面积</title>
    <url>/2020/02/10/%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<p>来源Leetcode第223题矩形面积</p>
<p>在<strong>二维</strong>平面上计算出两个<strong>由直线构成的</strong>矩形重叠后形成的总面积。</p>
<p>每个矩形由其左下顶点和右上顶点坐标表示，如图所示。<br><a id="more"></a><br><img src="/2020/02/10/矩形面积/rectangle_area.png" alt="Rectangle Area"></p>
<p><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">-3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">9</span>, <span class="number">2</span></span><br><span class="line">输出: <span class="number">45</span></span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong> 假设矩形面积不会超出 <strong>int</strong> 的范围。</p>
<hr>
<p>把两个矩形叫做 A 和 B，不重叠就有四种情况，A 在 B 左边，A 在 B 右边，A 在 B 上边，A 在 B 下边。</p>
<p>判断上边的四种情况也很简单，比如判断 A 是否在 B 左边，只需要判断 A 的最右边的坐标是否小于 B 的最左边的坐标即可。其他情况类似。</p>
<p>此时矩形覆盖的面积就是两个矩形的面积和。</p>
<p>接下来考虑有重叠的情况。</p>
<p>此时我们只要求出重叠形成的矩形的面积，然后用两个矩形的面积减去重叠矩形的面积就是两个矩形覆盖的面积了。</p>
<p>而求重叠矩形的面积也很简单，我们只需要确认重叠矩形的四条边即可，可以结合题目的图想。</p>
<p>左边只需选择两个矩形的两条左边靠右的那条。</p>
<p>上边只需选择两个矩形的两条上边靠下的那条。</p>
<p>右边只需选择两个矩形的两条右边靠左的那条。</p>
<p>下边只需选择两个矩形的两条下边靠上的那条。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeArea</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C, <span class="keyword">int</span> D, <span class="keyword">int</span> E, <span class="keyword">int</span> F, <span class="keyword">int</span> G, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//求第一个矩形的面积</span></span><br><span class="line">    <span class="keyword">int</span> len1_1 = C - A;  <span class="comment">//长</span></span><br><span class="line">    <span class="keyword">int</span> len1_2 = D - B; <span class="comment">//高</span></span><br><span class="line">    <span class="keyword">int</span> s1 = len1_1 * len1_2;  <span class="comment">//面积</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//求第二个矩形面积</span></span><br><span class="line">    <span class="keyword">int</span> len2_1 = G - E;</span><br><span class="line">    <span class="keyword">int</span> len2_2 = H - F;</span><br><span class="line">    <span class="keyword">int</span> s2 = len2_1 * len2_2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(E &gt;= C || G &lt;= A || F &gt;= D || H &lt;=B)</span><br><span class="line">        <span class="keyword">return</span> s1 + s2;  <span class="comment">//没有重叠</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cover_x = Math.max(A,E);</span><br><span class="line">    <span class="keyword">int</span> cover_x2 = Math.min(C,G);</span><br><span class="line">    <span class="keyword">int</span> len = cover_x2 - cover_x;  <span class="comment">//重叠在x轴的边长</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cover_y = Math.min(D,H);</span><br><span class="line">    <span class="keyword">int</span> cover_y2 = Math.max(F,B);</span><br><span class="line">    <span class="keyword">int</span> len_2 = cover_y - cover_y2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cover_s = len * len_2;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 - cover_s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>最大正方形</title>
    <url>/2020/02/10/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    <content><![CDATA[<p>来源Leetcode第221题最大正方形</p>
<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。<br><a id="more"></a><br><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h3><p>如果当前节点是<code>1</code>就以此点为正方形的左上角，进行向右向下的遍历，在遍历时维护一个变量，当前正方形的边长和最大正方形的边长，如果新增加的行列均为<code>1</code>，则当前边长+1，直到检索到<code>0</code>，移动到下一点，并且更新最大正方形边长。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;  <span class="comment">//记录最大边长</span></span><br><span class="line">    <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                <span class="comment">//从当前点开始搜索</span></span><br><span class="line">                <span class="keyword">int</span> curlen = <span class="number">1</span>;  <span class="comment">//记录能组成的最大正方形边长</span></span><br><span class="line">                <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(curlen + i &lt; row &amp;&amp; curlen + j &lt; col &amp;&amp; flag)&#123;</span><br><span class="line">                    <span class="comment">//从当前点向右向下搜索</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = j ; k &lt;= curlen + j;k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(matrix[i + curlen][k] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                            flag = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = i ; k &lt;= curlen + i ; k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(matrix[k][j + curlen] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                            flag = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(flag) <span class="comment">// 为真，增加搜索的边长</span></span><br><span class="line">                        curlen++;</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max,curlen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max * max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><a href="https://leetcode-cn.com/problems/maximal-square/solution/li-jie-san-zhe-qu-zui-xiao-1-by-lzhlyle/" target="_blank" rel="noopener">来源</a></p>
<p>如题，动态规划方法的题解中，都会涉及到下列形式的代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (grid(<span class="built_in">i</span>, <span class="built_in">j</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">    dp(<span class="built_in">i</span>, <span class="built_in">j</span>) = <span class="built_in">min</span>(dp(<span class="built_in">i</span><span class="number">-1</span>, <span class="built_in">j</span>), dp(<span class="built_in">i</span>, <span class="built_in">j</span><span class="number">-1</span>), dp(<span class="built_in">i</span><span class="number">-1</span>, <span class="built_in">j</span><span class="number">-1</span>)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译成中文</p>
<blockquote>
<p>若某格子值为 <code>1</code> ，则以此为<strong>右下角</strong>的正方形的、最大边长为：上面的正方形、左面的正方形或左上的正方形中，最小的那个，再加上此格。</p>
</blockquote>
<p>先来阐述简单共识</p>
<ul>
<li>若形成正方形（非单 <code>1</code>），以当前为右下角的视角看，则需要：当前格、上、左、左上都是 <code>1</code></li>
<li>可以换个角度：当前格、上、左、左上都不能受 <code>0</code> 的限制，才能成为正方形</li>
</ul>
<p><img src="/2020/02/10/最大正方形/8c4bf78cf6396c40291e40c25d34ef56bd524313c2aa863f3a20c1f004f32ab0-image.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base condition</span></span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt; <span class="number">1</span> || matrix[<span class="number">0</span>].length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> height = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> width = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于已经预处理新增第一行、第一列均为0</span></span><br><span class="line"><span class="comment">//        int[][] dp = new int[height + 1][width + 1];</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[width + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> northwest = <span class="number">0</span>; <span class="comment">// 西北角、左上角</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (int row = 0; row &lt; height; row++) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>[] chars : matrix) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; width; col++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextNorthwest = dp[col + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (chars[col] == <span class="string">'1'</span>) &#123;</span><br><span class="line"><span class="comment">//                    dp[row + 1][col + 1] = Math.min(Math.min(dp[row + 1][col], dp[row][col + 1]), dp[row][col]) + 1;</span></span><br><span class="line">                dp[col + <span class="number">1</span>] = Math.min(Math.min(dp[col], dp[col + <span class="number">1</span>]), northwest) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                    maxSide = Math.max(maxSide, dp[row + 1][col + 1]);</span></span><br><span class="line">                maxSide = Math.max(maxSide, dp[col + <span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[col + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            northwest = nextNorthwest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>存在重复元素III</title>
    <url>/2020/02/10/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0III/</url>
    <content><![CDATA[<p>给定一个整数数组，判断数组中是否有两个不同的索引 <em>i</em> 和 <em>j</em>，使得 <strong>nums [i]</strong> 和 <strong>nums [j]</strong> 的差的绝对值最大为 <em>t</em>，并且 <em>i</em> 和 <em>j</em> 之间的差的绝对值最大为 <em>ķ</em>。<br><a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>], k = <span class="number">3</span>, t = <span class="number">0</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="面向测试用例编程"><a href="#面向测试用例编程" class="headerlink" title="面向测试用例编程"></a>面向测试用例编程</h3><p>暴力遍历，经过评论区提示，加了一句<code>if(k == 10000) return false;</code>，速度直接到了0ms。。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">10000</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = Math.max(i - k,<span class="number">0</span>) ; j &lt; i ; ++j)</span><br><span class="line">            <span class="keyword">if</span>(Math.abs((<span class="keyword">long</span>)nums[i] - nums[j]) &lt;= t)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p><a href="https://www.jianshu.com/p/5392b68826a7" target="_blank" rel="noopener">TreeSet</a>的介绍</p>
<p>来自<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-46/" target="_blank" rel="noopener">windliang</a></p>
<p>TreeSet中有一个方法 <code>public E ceiling(E e)</code> ，返回 <code>treeSet</code> 中大于等于 <code>e</code> 的元素中最小的元素，如果没有大于等于 <code>e</code> 的元素就返回 <code>null</code>。</p>
<p>还有一个对应的方法，<code>public E floor(E e)</code>，返回 <code>treeSet</code> 中小于等于 <code>e</code> 的元素中最大的元素，如果没有小于等于 <code>e</code> 的元素就返回 <code>null</code>。</p>
<p>维护一个滑动窗口，去寻找窗口中是否存在 <code>x - t ~ x + t</code> 的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    TreeSet&lt;Long&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; k)</span><br><span class="line">            set.remove((<span class="keyword">long</span>)nums[i - k - <span class="number">1</span>]); <span class="comment">//滑动窗口满，移出最早进入窗口的元素</span></span><br><span class="line">        Long tmp = set.ceiling((<span class="keyword">long</span>)nums[i] - t);  <span class="comment">//找到元素在 &gt;= nums[i] - t 的最小元素</span></span><br><span class="line">        <span class="keyword">if</span>(tmp != <span class="keyword">null</span> &amp;&amp; tmp &lt;= (<span class="keyword">long</span>)nums[i] + t)  <span class="comment">//并且确认其 &lt;= nums[i] + t 因为|nums[i] - tmp| &lt;= t -&gt; ,nums[i] - t &lt;= tmp &lt;= nums[i] + t</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//以上不满足继续加入Tree</span></span><br><span class="line">        set.add((<span class="keyword">long</span>)nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍II</title>
    <url>/2020/02/10/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/</url>
    <content><![CDATA[<p>来自Leetcode第213题打家劫舍II</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈，</strong>这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。<br><a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 你不能先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">2</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">2</span>）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>环状排列</strong>意味着第一个房子和最后一个房子中<strong>只能选择一个偷窃</strong>，因此可以把此<strong>环状排列房间</strong>问题约化为两个<strong>单排排列房间</strong>子问题：</p>
<ol>
<li>在不偷窃第一个房子的情况下（即 <em>n<strong>u</strong>m</em>s[1:]），最大金额是 <em>p</em>1 ；</li>
<li>在不偷窃最后一个房子的情况下（即 n<strong>u</strong>ms<em>[:</em>n−1]），最大金额是 p2 。</li>
</ol>
<ul>
<li><strong>综合偷窃最大金额：</strong> 为以上两种情况的较大值，即 m<strong>a</strong>x<em>(</em>p<em>1,</em>p2) 。</li>
</ul>
<p>记：</p>
<blockquote>
<p><em>f</em>(<em>k</em>) = 从前 <em>k</em> 个房屋中能抢劫到的最大数额，<em>Ai</em> = 第 i 个房屋的钱数。</p>
</blockquote>
<p>首先看 <code>n = 1</code> 的情况，显然 <em>f</em>(1) = A1。</p>
<p>再看 <code>n = 2</code>，<em>f</em>(2) = max(A<em>1, A</em>2)。</p>
<p>对于 <code>n = 3</code>，有两个选项:</p>
<ol>
<li>抢第三个房子，将数额与第一个房子相加。</li>
<li>不抢第三个房子，保持现有最大数额。</li>
</ol>
<p>显然，你想选择数额更大的选项。于是，可以总结出公式：</p>
<blockquote>
<p><em>f</em>(<em>k</em>) = max(<em>f</em>(<em>k</em> – 2) + A_k, <em>f</em>(<em>k</em> – 1))</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.max(helper(Arrays.copyOfRange(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>)),helper(Arrays.copyOfRange(nums,<span class="number">1</span>,nums.length)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : nums)&#123;</span><br><span class="line">        tmp = cur;</span><br><span class="line">        cur = Math.max(pre + x,cur);</span><br><span class="line">        pre = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>存在重复元素</title>
    <url>/2020/02/09/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>来自Leetcode第219题存在重复元素II</p>
<p>给定一个整数数组和一个整数 <em>k</em>，判断数组中是否存在两个不同的索引 <em>i</em> 和 <em>j</em>，使得 <strong>nums [i] = nums [j]</strong>，并且 <em>i</em> 和 <em>j</em> 的差的绝对值最大为 <em>k</em>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>维护一个哈希表，里面始终最多包含 <code>k</code> 个元素，当出现重复值时则说明在 <code>k</code> 距离内存在重复元素,每次遍历一个元素则将其加入哈希表中，如果哈希表的大小大于 <code>k</code>，则移除最前面的数字</p>
<pre><code class="lang-JAVA">    public boolean containsNearbyDuplicate(int[] nums, int k) {
        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for(int i = 0 ; i &lt; nums.length ; ++i){
            if(set.contains(nums[i]))
                return true;
            set.add(nums[i]);
            if(set.size() &gt; k)
                set.remove(nums[i - k]);
        }
        return false;
    }
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>第K大元素</title>
    <url>/2020/02/09/%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>来自Leetcode第215题数组中的第K大元素</p>
<p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br><a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>] 和 k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">5</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h3><p>利用快速排序里的partition过程实现。<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/" target="_blank" rel="noopener">参考</a></p>
<p>partition（切分）操作，使得：</p>
<ul>
<li>对于某个索引 <code>j</code>，<code>nums[j]</code> 已经排定，即 <code>nums[j]</code> 经过 partition（切分）操作以后会放置在它 “最终应该放置的地方”；</li>
<li><code>nums[left]</code> 到 <code>nums[j - 1]</code> 中的所有元素都不大于 <code>nums[j]</code>；</li>
<li><code>nums[j + 1]</code> 到 <code>nums[right]</code> 中的所有元素都不小于 <code>nums[j]</code>。</li>
</ul>
<p><img src="/2020/02/09/第K大元素/65ec311c3e9792bb17e9c08cabd4a07f251c9cd65a011b6c5ffb54b46d8e5012-image.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> []nums;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random ran = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> target = len - k;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            index = partition(left,right);</span><br><span class="line">            <span class="keyword">if</span>(index &lt; target)</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index &gt; target)</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//在区间随机选择一个点作为枢纽</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt; left)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = left + <span class="number">1</span> + ran.nextInt(right - left);</span><br><span class="line">            swap(left,index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">int</span> j = left;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left + <span class="number">1</span> ; i &lt;= right ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.nums[i] &lt; pivot)&#123;</span><br><span class="line">                <span class="comment">//小于枢纽的交换位置</span></span><br><span class="line">                j++;</span><br><span class="line">                swap(j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在之前遍历的过程中，满足 [left + 1, j] &lt; pivot，并且 (j, i] &gt;= pivot</span></span><br><span class="line">        <span class="comment">// 交换以后 [left, j - 1] &lt; pivot, nums[j] = pivot, [j + 1, right] &gt;= pivot</span></span><br><span class="line">        swap(j,left);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="keyword">this</span>.nums[left];</span><br><span class="line">        <span class="keyword">this</span>.nums[left] = <span class="keyword">this</span>.nums[right];</span><br><span class="line">        <span class="keyword">this</span>.nums[right] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/" target="_blank" rel="noopener">参考</a></p>
<p>优先队列的思路是很朴素的。因为第 <code>K</code> 大元素，其实就是整个数组排序以后后半部分最小的那个元素。因此，我们可以维护一个有 <code>K</code> 个元素的最小堆：</p>
<p>1、如果当前堆不满，直接添加；</p>
<p>2、堆满的时候，如果新读到的数小于等于堆顶，肯定不是我们要找的元素，只有新都到的数大于堆顶的时候，才将堆顶拿出，然后放入新读到的数，进而让堆自己去调整内部结构。</p>
<p>说明：这里最合适的操作其实是 <code>replace</code>，即直接把新读进来的元素放在堆顶，然后执行下沉（<code>siftDown</code>）操作。Java 当中的 <code>PriorityQueue</code> 没有提供这个操作，只好先 <code>poll()</code> 再 <code>offer()</code>。</p>
<p>优先队列的写法就很多了，这里例举一下我能想到的（以下的写法大同小异，没有本质差别）。</p>
<p>假设数组有 <code>len</code> 个元素。</p>
<p>思路1：把 <code>len</code> 个元素都放入一个最小堆中，然后再 <code>pop()</code> 出 <code>len - k</code> 个元素，此时最小堆只剩下 <code>k</code> 个元素，堆顶元素就是数组中的第 <code>k</code> 个最大元素。</p>
<p>思路2：把 <code>len</code> 个元素都放入一个最大堆中，然后再 <code>pop()</code> 出 <code>k - 1</code> 个元素，因为前 <code>k - 1</code> 大的元素都被弹出了，此时最大堆的堆顶元素就是数组中的第 <code>k</code> 个最大元素。</p>
<p>思路 3：只用 <code>k</code> 个容量的优先队列，而不用全部 <code>len</code> 个容量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 使用一个含有 k 个元素的最小堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, (a, b) -&gt; a - b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            minHeap.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 看一眼，不拿出，因为有可能没有必要替换</span></span><br><span class="line">            Integer topEle = minHeap.peek();</span><br><span class="line">            <span class="comment">// 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; topEle) &#123;</span><br><span class="line">                minHeap.poll();</span><br><span class="line">                minHeap.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>优先队列，堆</tag>
      </tags>
  </entry>
  <entry>
    <title>课程表</title>
    <url>/2020/02/08/%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    <content><![CDATA[<p>来源Leetcode第207题课程表</p>
<p>现在你总共有 <em>n</em> 门课需要选，记为 <code>0</code> 到 <code>n-1</code>。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: <code>[0,1]</code></p>
<p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？<br><a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>]] </span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 总共有 <span class="number">2</span> 门课程。学习课程 <span class="number">1</span> 之前，你需要完成课程 <span class="number">0</span>。所以这是可能的。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 总共有 <span class="number">2</span> 门课程。学习课程 <span class="number">1</span> 之前，你需要先完成课程 <span class="number">0</span>；并且学习课程 <span class="number">0</span> 之前，你还应先完成课程 <span class="number">1</span>。这是不可能的。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ol>
<li>输入的先决条件是由<strong>边缘列表</strong>表示的图形，而不是邻接矩阵。详情请参见<a href="http://blog.csdn.net/woaidapaopao/article/details/51732947" target="_blank" rel="noopener">图的表示法</a>。</li>
<li>你可以假定输入的先决条件中没有重复的边。</li>
</ol>
<p><strong>提示:</strong></p>
<ol>
<li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li>
<li><a href="https://www.coursera.org/specializations/algorithms" target="_blank" rel="noopener">通过 DFS 进行拓扑排序</a> - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。</li>
<li>拓扑排序也可以通过 <a href="https://baike.baidu.com/item/宽度优先搜索/5224802?fr=aladdin&amp;fromid=2148012&amp;fromtitle=广度优先搜索" target="_blank" rel="noopener">BFS</a> 完成。</li>
</ol>
<hr>
<h3 id="BFS拓扑排序"><a href="#BFS拓扑排序" class="headerlink" title="BFS拓扑排序"></a>BFS拓扑排序</h3><p>来源<a href="https://leetcode-cn.com/problems/course-schedule/solution/tuo-bu-pai-xu-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></p>
<ul>
<li><p>本题可约化为：课程安排图是否是 <strong>有向无环图(DAG)</strong>。即课程间规定了前置条件，但不能构成任何环路，否则课程前置条件将不成立。</p>
</li>
<li><p>思路是通过<strong>拓扑排序</strong>判断此课程安排图是否是<strong>有向无环图(DAG)</strong>。</p>
<ul>
<li>拓扑排序是对 DAG 的顶点进行排序，使得对每一条有向边 (u, v)(<em>u</em>,<em>v</em>)，均有 u<em>u</em>（在排序记录中）比 v<em>v</em> 先出现。亦可理解为对某点 v<em>v</em> 而言，只有当 v<em>v</em> 的所有源点均出现了，v<em>v</em> 才能出现。</li>
</ul>
</li>
<li><p>通过课程前置条件列表 <code>prerequisites</code> 可以得到课程安排图的 <strong>邻接矩阵</strong> <code>adjacency</code>，以下两种方法都会用到邻接矩阵。</p>
</li>
</ul>
<p>拓扑排序实际上应用的是<strong>贪心算法</strong>。贪心算法简而言之：每一步最优，全局就最优。</p>
<p>具体到拓扑排序，每一次都从图中删除没有前驱的顶点，这里并不需要真正的做删除操作，我们可以设置一个入度数组，每一轮都输出入度为 0 的结点，并移除它、修改它指向的结点的入度（-1−1即可），依次得到的结点序列就是拓扑排序的结点序列。如果图中还有结点没有被移除，则说明“不能完成所有课程的学习”。</p>
<p>拓扑排序保证了每个活动（在这题中是“课程”）的所有前驱活动都排在该活动的前面，并且可以完成所有活动。拓扑排序的结果不唯一。拓扑排序还可以用于检测一个有向图是否有环。相关的概念还有 AOV 网，这里就不展开了。</p>
<p><strong>算法流程</strong>：</p>
<p>1、在开始排序前，扫描对应的存储空间（使用邻接表），将入度为 0 的结点放入队列。</p>
<p>2、只要队列非空，就从队首取出入度为 0 的结点，将这个结点输出到结果集中，并且将这个结点的所有邻接结点（它指向的结点）的入度减 1，在减1 以后，如果这个被减 1 的结点的入度为 0 ，就继续入队。</p>
<p>3、当队列为空的时候，检查结果集中的顶点个数是否和课程数相等即可。</p>
<p><img src="/2020/02/08/课程表/ca22fa351d5278e95c4c8c94aba6da42ae45d465ff3e8e82149777274293e194-0210.gif" alt="0210.gif"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numCourses &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(prerequisites.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> []indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    Integer ve;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> [] tmp : prerequisites)</span><br><span class="line">        indegree[tmp[<span class="number">0</span>]]++;  <span class="comment">//记录各节点的入度数</span></span><br><span class="line">    LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; numCourses ; i++)</span><br><span class="line">        <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">            queue.addLast(i);  <span class="comment">//入度为0的点入队尾</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        ve = queue.removeFirst();  <span class="comment">//队首元素出队</span></span><br><span class="line">        numCourses--;  <span class="comment">//对应的课程数减一</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] tmp:prerequisites)&#123;  <span class="comment">//在表里去掉与之有关的边</span></span><br><span class="line">            <span class="keyword">if</span>(tmp[<span class="number">1</span>] != ve) <span class="comment">//如果该边的起点不是出队节点，continue</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(--indegree[tmp[<span class="number">0</span>]] == <span class="number">0</span>)  <span class="comment">//是就删去该边，并且入度数-1</span></span><br><span class="line">                queue.addLast(tmp[<span class="number">0</span>]); <span class="comment">//入度为0入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>图</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>同构字符串</title>
    <url>/2020/02/08/%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>来自Leetcode第205题同构字符串</p>
<p>给定两个字符串 <strong><em>s</em></strong> 和 <strong><em>t</em></strong>，判断它们是否是同构的。</p>
<p>如果 <strong><em>s</em></strong> 中的字符可以被替换得到 <strong><em>t</em></strong> ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。<br><a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"egg"</span>, <span class="attr">t</span> = <span class="string">"add"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>维护一个HashMap，里面存放2个字符串相对的映射方式，要注意Map里的元素应当是唯一的，如果出现重复，可以直接返回false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">""</span>) || s == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">char</span> tmp_t,tmp_s;</span><br><span class="line">    HashMap&lt;Character,Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; s.length() ; i++)&#123;</span><br><span class="line">        tmp_s = s.charAt(i);</span><br><span class="line">        tmp_t = t.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(tmp_s))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsValue(tmp_t)) </span><br><span class="line">                map.put(tmp_s,tmp_t);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp_t != map.get(tmp_s))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字母映射成数字"><a href="#字母映射成数字" class="headerlink" title="字母映射成数字"></a>字母映射成数字</h3><p>最开始写的时候是考虑过将字符串add映射成122这种形式，最后比较生成的2个字符串是否一致即可，于是我选择了维护2个HashMap，但是这导致了超时。</p>
<p>原代码如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">""</span>) || s == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    String s1 = <span class="string">""</span>,s2 = <span class="string">""</span>;</span><br><span class="line">    HashMap&lt;Character,Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    HashMap&lt;Character,Integer&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; s.length() ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map1.containsKey(s.charAt(i)))&#123;</span><br><span class="line">            map1.put(s.charAt(i),i);</span><br><span class="line">            s1 += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s1 += map1.get(s.charAt(i));</span><br><span class="line">        <span class="keyword">if</span>(!map2.containsKey(t.charAt(i)))&#123;</span><br><span class="line">            map2.put(t.charAt(i),i);</span><br><span class="line">            s2 += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s2 += map2.get(t.charAt(i));</span><br><span class="line">        <span class="keyword">if</span>(!s1.equals(s2))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在参考了<a href="https://leetcode-cn.com/problems/isomorphic-strings/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-42/" target="_blank" rel="noopener">windliang</a>的解答后发现可以不用HashMap，可以直接用2个数组处理，但是本质思想是差不多的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">""</span>) || s == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">char</span> tmp_t,tmp_s;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">int</span>[] map1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span>[] map2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len; i ++)&#123;</span><br><span class="line">        tmp_s = s.charAt(i);</span><br><span class="line">        tmp_t = t.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(map1[tmp_s] != map2[tmp_t])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(map1[tmp_s] == <span class="number">0</span>)&#123;</span><br><span class="line">                map1[tmp_s] = i + <span class="number">1</span>;</span><br><span class="line">                map2[tmp_t] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>计数质数</title>
    <url>/2020/02/07/%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<p>来自Leetcode第204题计数质数</p>
<p>统计所有小于非负整数 <em>n</em> 的质数的数量。<br><a id="more"></a><br><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">10</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 小于 <span class="number">10</span> 的质数一共有 <span class="number">4</span> 个, 它们是 <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span> 。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h3><p>来自<a href="https://leetcode-cn.com/problems/count-primes/solution/ru-he-gao-xiao-pan-ding-shai-xuan-su-shu-by-labula/" target="_blank" rel="noopener">labuladong</a></p>
<p>首先从 2 开始，我们知道 2 是一个素数，那么 2 × 2 = 4, 3 × 2 = 6, 4 × 2 = 8… 都不可能是素数了。</p>
<p>然后我们发现 3 也是素数，那么 3 × 2 = 6, 3 × 3 = 9, 3 × 4 = 12… 也都不可能是素数了。</p>
<p>看到这里，你是否有点明白这个排除法的逻辑了呢？先看我们的第一版代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] isPrim = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="comment">// 将数组都初始化为 true</span></span><br><span class="line">    Arrays.fill(isPrim, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) </span><br><span class="line">        <span class="keyword">if</span> (isPrim[i]) </span><br><span class="line">            <span class="comment">// i 的倍数不可能是素数了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; n; j += i) </span><br><span class="line">                    isPrim[j] = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (isPrim[i]) count++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/07/计数质数/23d348bef930ca4bb73f749500f664ccffc5e41467aac0ba9787025392ca207b-1.gif" alt="1.gif"></p>
<p>首先，回想刚才判断一个数是否是素数的 <code>isPrime</code> 函数，由于因子的对称性，其中的 for 循环只需要遍历 <code>[2,sqrt(n)]</code> 就够了。这里也是类似的，我们外层的 for 循环也只需要遍历到 <code>sqrt(n)</code>：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">2</span>; <span class="built_in">i</span> * <span class="built_in">i</span> &lt; n; <span class="built_in">i</span>++) </span><br><span class="line">    <span class="keyword">if</span> (isPrim[<span class="built_in">i</span>]) </span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>除此之外，很难注意到内层的 for 循环也可以优化。我们之前的做法是：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="number">2</span> * <span class="built_in">i</span>; <span class="built_in">j</span> &lt; n; <span class="built_in">j</span> += <span class="built_in">i</span>) </span><br><span class="line">    isPrim[<span class="built_in">j</span>] = <span class="built_in">false</span>;</span><br></pre></td></tr></table></figure>
<p>这样可以把 <code>i</code> 的整数倍都标记为 <code>false</code>，但是仍然存在计算冗余。</p>
<p>比如 <code>n = 25</code>，<code>i = 4</code> 时算法会标记 4 × 2 = 8，4 × 3 = 12 等等数字，但是这两个数字已经被 <code>i = 2</code> 和 <code>i = 3</code> 的 2 × 4 和 3 × 4 标记了。</p>
<p>我们可以稍微优化一下，让 <code>j</code> 从 <code>i</code> 的平方开始遍历，而不是从 <code>2 * i</code> 开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) </span><br><span class="line">    isPrim[j] = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p>这样，素数计数的算法就高效实现了，其实这个算法有一个名字，叫做 Sieve of Eratosthenes。看下完整的最终代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] isPrim = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    Arrays.fill(isPrim, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; n; i++) </span><br><span class="line">        <span class="keyword">if</span> (isPrim[i]) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) </span><br><span class="line">                isPrim[j] = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (isPrim[i]) count++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐数</title>
    <url>/2020/02/07/%E5%BF%AB%E4%B9%90%E4%B9%A6/</url>
    <content><![CDATA[<p>来源Leetcode第202题快乐数</p>
<p>编写一个算法来判断一个数是不是“快乐数”。</p>
<p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。<br><a id="more"></a><br><strong>示例:</strong> </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">19</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: </span><br><span class="line"><span class="number">12</span> + <span class="number">92</span> = <span class="number">82</span></span><br><span class="line"><span class="number">82</span> + <span class="number">22</span> = <span class="number">68</span></span><br><span class="line"><span class="number">62</span> + <span class="number">82</span> = <span class="number">100</span></span><br><span class="line"><span class="number">12</span> + <span class="number">02</span> + <span class="number">02</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h3><p>根据在1-9里只有1和7是快乐数，其他的均不是，以此来判断退出循环的条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">7</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">16</span> || n == <span class="number">37</span> || n == <span class="number">58</span> || n == <span class="number">89</span> || n == <span class="number">145</span> || n == <span class="number">42</span> || n == <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            sum = sum + (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>来自<a href="https://leetcode-cn.com/problems/happy-number/solution/shi-yong-kuai-man-zhi-zhen-si-xiang-zhao-chu-xun-h/" target="_blank" rel="noopener">题解</a></p>
<p>方法：使用“快慢指针”思想找出循环：“快指针”每次走两步，“慢指针”每次走一步，当二者相等时，即为一个循环周期。此时，判断是不是因为1引起的循环，是的话就是快乐数，否则不是快乐数。</p>
<p>注意：此题不建议用集合记录每次的计算结果来判断是否进入循环，因为这个集合可能大到无法存储；另外，也不建议使用递归，同理，如果递归层次较深，会直接导致调用栈崩溃。不要因为这个题目给出的整数是int型而投机取巧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = n, fast = n;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        slow = Square(slow);</span><br><span class="line">        fast = Square(fast);</span><br><span class="line">        fast = Square(fast);</span><br><span class="line">    &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">    <span class="keyword">return</span> slow == <span class="number">1</span> || slow == <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Square</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        ans += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数字范围按位与</title>
    <url>/2020/02/07/%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/</url>
    <content><![CDATA[<p>来源Leetcode第201题数字范围按位与</p>
<p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。<br><a id="more"></a><br><strong>示例 1:</strong> </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>按顺序执行按位运算，然后有一个测试算例超时了，在运算时排除全0与全1的数，即到了0xFFFF和0x0就可以返回运算结果了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == Integer.MAX_VALUE)</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    <span class="keyword">int</span> ans = m++;</span><br><span class="line">    <span class="keyword">while</span>(m &lt;= n) &#123;</span><br><span class="line">        ans &amp;= m;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">0</span> || m == Integer.MAX_VALUE)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二进制1的个数"><a href="#二进制1的个数" class="headerlink" title="二进制1的个数"></a>二进制1的个数</h3><p>来源<a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/shu-zi-fan-wei-an-wei-yu-qu-qi-gao-wei-wu-bian-hua/" target="_blank" rel="noopener">题解</a></p>
<p>此题其实就是寻找[m,n]范围内二进制数高位（左边）没有变化的数，后面补上0即为所求的结果。</p>
<p>判断m、n是否相等，如果不相等，m+1会使m的二进制数末位进位，有进位说明m的末位肯定有0的情况，0与任何数相与皆得0，所以结果的末位肯定是0。同理，不断右移1位进行比较，直到最终 m=n 时，说明找到了[m,n]这个范围内高位没有变化的数，左移相同位数得到的结果就是所求的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == Integer.MAX_VALUE || m == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span> ; <span class="comment">// 记录移位次数</span></span><br><span class="line">    <span class="keyword">while</span>(m &lt; n)&#123;</span><br><span class="line">        m &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &lt;&lt;= count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二进制最右边1置0"><a href="#二进制最右边1置0" class="headerlink" title="二进制最右边1置0"></a>二进制最右边1置0</h3><p>有一个方法，可以把最右边的 <code>1</code> 置为 <code>0</code>，举个具体的例子。</p>
<p>比如十进制的 <code>10</code>，二进制形式是 <code>1010</code>，然后我们只需要把它和 <code>9</code> 进行按位与操作，也就是 <code>10 &amp; 9 = (1010) &amp; (1001) = 1000</code>，也就是把 <code>1010</code> 最右边的 <code>1</code> 置为 <code>0</code>。</p>
<p>规律就是对于任意一个数 <code>n</code>，然后 <code>n &amp; (n-1)</code> 的结果就是把 <code>n</code> 的最右边的 <code>1</code> 置为 <code>0</code> 。</p>
<p>也比较好理解，当我们对一个数减 <code>1</code> 的话，比如原来的数是 <code>...1010000</code>，然后减一就会向前借位，直到遇到最右边的第一个 <code>1</code>，变成 <code>...1001111</code>，然后我们把它和原数按位与，就会把从原数最右边 <code>1</code> 开始的位置全部置零了 <code>...10000000</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> zeros = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; m) &#123;</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿数量</title>
    <url>/2020/02/06/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<p>来源Leetcode第200题 岛屿数量</p>
<p>给定一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。<br><a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="number">11110</span></span><br><span class="line"><span class="number">11010</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00000</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>在初始化并查集的根节点时，记录所有为<code>1</code>的点的数量，同时将为<code>1</code>的点的根节点初始化为自身，对数组进行遍历，如果遍历时当前点为<code>1</code>，并且其上下左右里有点为<code>1</code>，就意味着相连，合并，并将对应的并查集里的岛屿数减1，最后返回并查集里的岛屿数即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parents;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        parents = <span class="keyword">new</span> <span class="keyword">int</span>[row * col];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; row; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; col ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    parents[i * col + j] = i * col + j; <span class="comment">//初始化陆地并查集</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并连通区域是通过find来操作的, 即看这两个节点是不是在一个连通区域内.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> node1, <span class="keyword">int</span> node2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root1 = find(node1);</span><br><span class="line">        <span class="keyword">int</span> root2 = find(node2);</span><br><span class="line">        <span class="keyword">if</span> (root1 != root2) &#123;</span><br><span class="line">            parents[root2] = root1;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (parents[node] != node) &#123;</span><br><span class="line">            <span class="comment">// 当前节点的父节点 指向父节点的父节点.</span></span><br><span class="line">            <span class="comment">// 保证一个连通区域最终的parents只有一个.</span></span><br><span class="line">            parents[node] = parents[parents[node]];</span><br><span class="line">            node = parents[node];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> node1, <span class="keyword">int</span> node2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(node1) == find(node2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> row = grid.length;</span><br><span class="line">    <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    UnionFind uf = <span class="keyword">new</span> UnionFind(grid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; row ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; col ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="string">'1'</span>)</span><br><span class="line">                    uf.union(i * col + j , (i - <span class="number">1</span>) * col + j);</span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">1</span> &lt; row &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="string">'1'</span>)</span><br><span class="line">                    uf.union(i * col + j , (i + <span class="number">1</span>) * col + j);</span><br><span class="line">                <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="string">'1'</span>)</span><br><span class="line">                    uf.union(i * col + j , i* col + j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(j + <span class="number">1</span> &lt; col &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="string">'1'</span>)</span><br><span class="line">                    uf.union(i * col + j , i* col + j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uf.count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>线性扫描整个二维网格，如果一个结点包含 <code>1</code>，则以其为根结点启动深度优先搜索。在深度优先搜索过程中，每个访问过的结点被标记为 <code>0</code>。计数启动深度优先搜索的根结点的数量，即为岛屿的数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nRow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> nColumn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;</span><br><span class="line">    nRow = grid.length;</span><br><span class="line">    nColumn = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || column &lt; <span class="number">0</span> || row &gt;= nRow || column &gt;= nColumn || grid[row][column] == <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[row][column] = <span class="string">'0'</span>;</span><br><span class="line">    dfs(grid, row - <span class="number">1</span>, column);</span><br><span class="line">    dfs(grid, row + <span class="number">1</span>, column);</span><br><span class="line">    dfs(grid, row, column - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, row, column + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nRow = grid.length;</span><br><span class="line">    nColumn = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nRow; ++r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nColumn; ++c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                ++num;</span><br><span class="line">                dfs(grid, r, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>被围绕的区域</title>
    <url>/2020/02/06/%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>来源Leetcode第130题被围绕的区域</p>
<p>给定一个二维的矩阵，包含 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code>（<strong>字母 O</strong>）。</p>
<p>找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。<br><a id="more"></a><br><strong>示例:</strong></p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="meta">X</span> <span class="meta">X</span> <span class="meta">X</span> <span class="meta">X</span></span><br><span class="line"><span class="meta">X</span> O O <span class="meta">X</span></span><br><span class="line"><span class="meta">X</span> <span class="meta">X</span> O <span class="meta">X</span></span><br><span class="line"><span class="meta">X</span> O <span class="meta">X</span> <span class="meta">X</span></span><br></pre></td></tr></table></figure>
<p>运行你的函数后，矩阵变为：</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="meta">X</span> <span class="meta">X</span> <span class="meta">X</span> <span class="meta">X</span></span><br><span class="line"><span class="meta">X</span> <span class="meta">X</span> <span class="meta">X</span> <span class="meta">X</span></span><br><span class="line"><span class="meta">X</span> <span class="meta">X</span> <span class="meta">X</span> <span class="meta">X</span></span><br><span class="line"><span class="meta">X</span> O <span class="meta">X</span> <span class="meta">X</span></span><br></pre></td></tr></table></figure>
<p><strong>解释:</strong></p>
<p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 <code>&#39;O&#39;</code> 都不会被填充为 <code>&#39;X&#39;</code>。 任何不在边界上，或不与边界上的 <code>&#39;O&#39;</code> 相连的 <code>&#39;O&#39;</code> 最终都会被填充为 <code>&#39;X&#39;</code>。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p>
<hr>
<h3 id="DFS递归"><a href="#DFS递归" class="headerlink" title="DFS递归"></a>DFS递归</h3><p>从边界出发吧，先把边界上和 <code>O</code> 连通点找到, 把这些变成 <code>#</code>,然后遍历整个 <code>board</code> 把 <code>O</code> 变成 <code>X</code>, 把 <code>#</code> 变成 <code>O</code><br>最上、下或最左、右，且是<code>O</code>的是为边界,在DFS中,已经被置为不能访问标识的无需再DFS最后遍历中，无需再遍历边界条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> row = board.length;</span><br><span class="line">    <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= row - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= col - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isEdge = i == <span class="number">0</span> || j == <span class="number">0</span> || i == row - <span class="number">1</span> || j == col -<span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span>(isEdge &amp;&amp; board[i][j] == <span class="string">'O'</span>)</span><br><span class="line">                surround(board,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= row - <span class="number">1</span> ; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= col - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)</span><br><span class="line">                board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">'#'</span>)</span><br><span class="line">                board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">surround</span><span class="params">(<span class="keyword">char</span>[][] board , <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= board.length || j &gt;= board[<span class="number">0</span>].length || board[i][j] == <span class="string">'X'</span> || board[i][j] == <span class="string">'#'</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">    surround(board,i - <span class="number">1</span>,j);</span><br><span class="line">    surround(board,i + <span class="number">1</span>,j);</span><br><span class="line">    surround(board,i ,j - <span class="number">1</span>);</span><br><span class="line">    surround(board,i , j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>来源<a href="https://leetcode-cn.com/problems/surrounded-regions/solution/bfsdi-gui-dfsfei-di-gui-dfsbing-cha-ji-by-ac_pipe/" target="_blank" rel="noopener">题解</a></p>
<p>并查集常用来解决连通性的问题，即将一个图中连通的部分划分出来。当我们判断图中两个点之间是否存在路径时，就可以根据判断他们是否在一个连通区域。 而这道题我们其实求解的就是和边界的 <em>O</em> 在一个连通区域的的问题。</p>
<p>并查集的思想就是，同一个连通区域内的所有点的根节点是同一个。将每个点映射成一个数字。先假设每个点的根节点就是他们自己，然后我们以此输入连通的点对，然后将其中一个点的根节点赋成另一个节点的根节点，这样这两个点所在连通区域又相互连通了。<br>并查集的主要操作有：</p>
<ul>
<li><code>find(int m)</code>：这是并查集的基本操作，查找 <em>m</em> 的根节点。</li>
<li><code>isConnected(int m,int n)</code>：判断 m，<em>n</em> 两个点是否在一个连通区域。</li>
<li><code>union(int m,int n)</code>:合并 m，<em>n</em> 两个点所在的连通区域。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parents;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> totalNodes)</span> </span>&#123;</span><br><span class="line">        parents = <span class="keyword">new</span> <span class="keyword">int</span>[totalNodes];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalNodes; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 合并连通区域是通过find来操作的, 即看这两个节点是不是在一个连通区域内.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> node1, <span class="keyword">int</span> node2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root1 = find(node1);</span><br><span class="line">        <span class="keyword">int</span> root2 = find(node2);</span><br><span class="line">        <span class="keyword">if</span> (root1 != root2) &#123;</span><br><span class="line">            parents[root2] = root1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (parents[node] != node) &#123;</span><br><span class="line">            <span class="comment">// 当前节点的父节点 指向父节点的父节点.</span></span><br><span class="line">            <span class="comment">// 保证一个连通区域最终的parents只有一个.</span></span><br><span class="line">            parents[node] = parents[parents[node]];</span><br><span class="line">            node = parents[node];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> node1, <span class="keyword">int</span> node2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(node1) == find(node2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的思路是把所有边界上的 <em>O</em> 看做一个连通区域。遇到 <em>O</em> 就执行并查集合并操作，这样所有的 O 就会被分成两类</p>
<ul>
<li>和边界上的 O 在一个连通区域内的。这些 <em>O</em> 我们保留。</li>
<li>不和边界上的 O 在一个连通区域内的。这些 <em>O</em> 就是被包围的，替换。</li>
</ul>
<p>由于并查集我们一般用一维数组来记录，方便查找 <code>parants</code>，所以我们将二维坐标用 <code>node</code> 函数转化为一维坐标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = board.length;</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用一个虚拟节点, 边界上的O 的父节点都是这个虚拟节点</span></span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(rows * cols + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> dummyNode = rows * cols;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    <span class="comment">// 遇到O进行并查集操作合并</span></span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || i == rows - <span class="number">1</span> || j == <span class="number">0</span> || j == cols - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 边界上的O,把它和dummyNode 合并成一个连通区域.</span></span><br><span class="line">                        uf.union(node(i, j), dummyNode);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 和上下左右合并成一个连通区域.</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; board[i - <span class="number">1</span>][j] == <span class="string">'O'</span>)</span><br><span class="line">                            uf.union(node(i, j), node(i - <span class="number">1</span>, j));</span><br><span class="line">                        <span class="keyword">if</span> (i &lt; rows - <span class="number">1</span> &amp;&amp; board[i + <span class="number">1</span>][j] == <span class="string">'O'</span>)</span><br><span class="line">                            uf.union(node(i, j), node(i + <span class="number">1</span>, j));</span><br><span class="line">                        <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; board[i][j - <span class="number">1</span>] == <span class="string">'O'</span>)</span><br><span class="line">                            uf.union(node(i, j), node(i, j - <span class="number">1</span>));</span><br><span class="line">                        <span class="keyword">if</span> (j &lt; cols - <span class="number">1</span> &amp;&amp; board[i][j + <span class="number">1</span>] == <span class="string">'O'</span>)</span><br><span class="line">                            uf.union(node(i, j), node(i, j + <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uf.isConnected(node(i, j), dummyNode)) &#123;</span><br><span class="line">                    <span class="comment">// 和dummyNode 在一个连通区域的,那么就是O；</span></span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">node</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i * cols + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并查集有关补充"><a href="#并查集有关补充" class="headerlink" title="并查集有关补充"></a>并查集有关补充</h3><p>来自<a href="https://blog.csdn.net/liujian20150808/article/details/50848646" target="_blank" rel="noopener">文章</a></p>
<p>首先在地图上给你若干个城镇，这些城镇都可以看作点，然后告诉你哪些对城镇之间是有道路直接相连的。最后要解决的是整幅图的连通性问题。比如随意给你两个点，让你判断它们是否连通，或者问你整幅图一共有几个连通分支，也就是被分成了几个互相独立的块。像畅通工程这题，问还需要修几条路，实质就是求有几个连通分支。如果是1个连通分支，说明整幅图上的点都连起来了，不用再修路了；如果是2个连通分支，则只要再修1条路，从两个分支中各选一个点，把它们连起来，那么所有的点都是连起来的了；如果是3个连通分支，则只要再修两条路……</p>
<p>以下面这组数据输入数据来说明</p>
<p>4 2 1 3 4 3</p>
<p>第一行告诉你，一共有4个点，2条路。下面两行告诉你，1、3之间有条路，4、3之间有条路。那么整幅图就被分成了1-3-4和2两部分。只要再加一条路，把2和其他任意一个点连起来，畅通工程就实现了，那么这个这组数据的输出结果就是1。好了，现在编程实现这个功能吧，城镇有几百个，路有不知道多少条，而且可能有回路。 这可如何是好？</p>
<p>并查集由一个整数型的数组和两个函数构成。数组pre[]记录了每个点的前导点是什么，函数find是查找，join是合并。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">1000</span> ];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>                                       <span class="comment">//查找根节点</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> r=x;</span><br><span class="line">    <span class="keyword">while</span> ( pre[r] != r )                           <span class="comment">//返回根节点 r</span></span><br><span class="line">          r=pre[r];</span><br><span class="line">    <span class="keyword">int</span> i=x , j ;</span><br><span class="line">    <span class="keyword">while</span>( i != r )                                   <span class="comment">//路径压缩</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">         j = pre[ i ]; 				<span class="comment">// 在改变上级之前用临时变量  j 记录下他的值 </span></span><br><span class="line">         pre[ i ]= r ; 				<span class="comment">//把上级改为根节点</span></span><br><span class="line">         i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>                           <span class="comment">//判断x y是否连通，</span></span></span><br><span class="line"><span class="function">                                         <span class="comment">//如果已经连通，就不用管了 如果不连通，就把它们所在的连通分支合并起,</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)</span><br><span class="line">        pre[fx ]=fy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解释并查集的原理，我将举一个更有爱的例子。 话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的群落，通过两两之间的朋友关系串联起来。而不在同一个群落的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？</p>
<p>我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物，这样，每个圈子就可以这样命名“齐达内朋友之队”“罗纳尔多朋友之队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。</p>
<p>但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长，要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样一来，队长面子上挂不住了，而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。</p>
<p><img src="http://hi.csdn.net/attachment/201107/29/0_1311901712oy9f.gif" alt="img"></p>
<p>下面我们来看并查集的实现。 int pre[1000]; 这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。 find这个函数就是找掌门用的，意义再清楚不过了（路径压缩算法先不论，后面再说）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>                    <span class="comment">//查找我（x）的掌门</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=x;                      <span class="comment">//委托 r 去找掌门</span></span><br><span class="line">    <span class="keyword">while</span> (pre[r ]!=r)           <span class="comment">//如果r的上级不是r自己（也就是说找到的大侠他不是掌门 = =）</span></span><br><span class="line">    r=pre[r ] ;                 <span class="comment">// r 就接着找他的上级，直到找到掌门为止。</span></span><br><span class="line">    <span class="keyword">return</span>  r ;                <span class="comment">//掌门驾到~~~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看看join函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？ 还是举江湖的例子，假设现在武林中的形势如图所示。虚竹小和尚与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”抗议无效，上天安排的，最大。反正谁加入谁效果是一样的，我就随手指定了一个。这段函数的意思很明白了吧？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>          <span class="comment">//我想让虚竹和周芷若做朋友</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=find(x),fy=find(y);         <span class="comment">//虚竹的老大是玄慈，芷若MM的老大是灭绝</span></span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)                         <span class="comment">//玄慈和灭绝显然不是同一个人</span></span><br><span class="line">    pre[fx ]=fy;                       <span class="comment">//方丈只好委委屈屈地当了师太的手下啦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看看路径压缩算法。建立门派的过程是用join函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么胎唇样，我也完全无法预计，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。 设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能揍。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是记己人，西礼西礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位同学请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其习偶们的掌门是曹公公。不如偶们一起及接拜在曹公公手下吧，省得级别太低，以后查找掌门麻环。” “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。路径压缩的代码，看得懂很好，看不懂也没关系，直接抄上用就行了。总之它所实现的功能就是这么个意思。</p>
<p><img src="http://hi.csdn.net/attachment/201107/29/0_131190167189S8.gif" alt="img"></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>深度优先搜索</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>最大数</title>
    <url>/2020/01/24/%E6%9C%80%E5%A4%A7%E6%95%B0/</url>
    <content><![CDATA[<p>来自Leetcode第179题最大数</p>
<p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">10</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">210</span></span><br></pre></td></tr></table></figure>
<h2 id><a href="#" class="headerlink" title></a><a id="more"></a></h2><p>首先，我们将每个整数变成字符串。然后进行排序。</p>
<pre><code class="lang-JAVA">    public String largestNumber(int[] nums) {
        Integer[] n = new Integer[nums.length];
        for(int i = 0 ; i &lt; nums.length ; i++)
            n[i] = nums[i];
        Arrays.sort(n, new Comparator&lt;Integer&gt;() {
            @Override
            public int compare(Integer o1, Integer o2) {
                String s1 = o1 + &quot;&quot; + o2;
                String s2 = o2 + &quot;&quot; + o1;
                return  s2.compareTo(s1);
            }
        });
        StringBuilder ans = new StringBuilder();
        for(int i = 0 ; i &lt; nums.length ; i++)
            ans.append(n[i]);
        String res = ans.toString();
         return res.charAt(0) == &#39;0&#39; ? &quot;0&quot; : res;
    }
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>单词拆分</title>
    <url>/2020/01/24/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<p>来源Leetcode第139题单词拆分</p>
<p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。<br><a id="more"></a><br><strong>说明：</strong></p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"leetcode"</span>, <span class="attr">wordDict</span> = [<span class="string">"leet"</span>, <span class="string">"code"</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 返回 <span class="literal">true</span> 因为 <span class="string">"leetcode"</span> 可以被拆分成 <span class="string">"leet code"</span>。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>最简单的实现方法是用递归和回溯。为了找到解，我们可以检查字典单词中每一个单词的可能前缀，如果在字典中出现过，那么去掉这个前缀后剩余部分回归调用。同时，如果某次函数调用中发现整个字符串都已经被拆分且在字典中出现过了，函数就返回 <code>true</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set ;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.set = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">    <span class="keyword">return</span> helper(s,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String s,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == s.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span> ; i &lt;= s.length(); i++)</span><br><span class="line">        <span class="keyword">if</span>(set.contains(s.substring(start,i)) &amp;&amp; helper(s,i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>题解的看不是很懂，摸了</p>
<p>在先前的方法中，我们看到许多函数调用都是冗余的，也就是我们会对相同的字符串调用多次回溯函数。为了避免这种情况，我们可以使用记忆化的方法，其中一个 memo<em>m<strong>e</strong>m**o</em> 数组会被用来保存子问题的结果。每当访问到已经访问过的后缀串，直接用 memo<em>m<strong>e</strong>m**o</em> 数组中的值返回而不需要继续调用函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> word_Break(s, <span class="keyword">new</span> HashSet(wordDict), <span class="number">0</span>, <span class="keyword">new</span> Boolean[s.length()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">word_Break</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start, Boolean[] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[start] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(s.substring(start, end)) &amp;&amp; word_Break(s, wordDict, end, memo)) &#123;</span><br><span class="line">                <span class="keyword">return</span> memo[start] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[start] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="宽度优先搜索"><a href="#宽度优先搜索" class="headerlink" title="宽度优先搜索"></a>宽度优先搜索</h3><p>另一个方法是使用宽度优先搜索。将字符串可视化成一棵树，每一个节点是用 end<em>e<strong>n</strong>d</em> 为结尾的前缀字符串。当两个节点之间的所有节点都对应了字典中一个有效字符串时，两个节点可以被连接。</p>
<p>为了形成这样的一棵树，我们从给定字符串的第一个字符开始（比方说 s<em>s</em> ），将它作为树的根部，开始找所有可行的以该字符为首字符的可行子串。进一步的，将每一个子字符串的结束字符的下标（比方说 i<em>i</em>）放在队列的尾部供宽搜后续使用。</p>
<p>每次我们从队列最前面弹出一个元素，并考虑字符串 s(i+1,end)<em>s</em>(<em>i</em>+1,<em>e<strong>n</strong>d</em>) 作为原始字符串，并将当前节点作为树的根。这个过程会一直重复，直到队列中没有元素。如果字符串最后的元素可以作为树的一个节点，这意味着初始字符串可以被拆分成多个给定字典中的子字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> [] visit = <span class="keyword">new</span> <span class="keyword">int</span> [s.length()];</span><br><span class="line">    queue.add(<span class="number">0</span>); <span class="comment">//起始位置0入队列</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> start = queue.remove();  <span class="comment">//队首元素出队</span></span><br><span class="line">        <span class="keyword">if</span>(visit[start] == <span class="number">0</span>)&#123;  <span class="comment">//如果这个点没看过</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span> ; i &lt;= s.length() ; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (set.contains(s.substring(start, i))) &#123;</span><br><span class="line">                    queue.add(i); <span class="comment">// 包含字符串的子串，就加入队列</span></span><br><span class="line">                    <span class="keyword">if</span> (i == s.length())  <span class="comment">//能遍历完，说明完成了拆分</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[start] = <span class="number">1</span>;  <span class="comment">//对遍历点做标记，之后拆分到该点的都可以认为是没有完成拆分的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>这题和算法导论上的解答是差不多的</p>
<p>这个方法的想法是对于给定的字符串（<em>s</em>）可以被拆分成子问题 <em>s</em>1 和 <em>s</em>2 。如果这些子问题都可以独立地被拆分成符合要求的子问题，那么整个问题 <em>s</em> 也可以满足。也就是，如果 “catsanddog” 可以拆分成两个子字符串 “catsand” 和 “dog” 。子问题 “catsand” 可以进一步拆分成 “cats” 和 “and” ，这两个独立的部分都是字典的一部分，所以 “catsand” 满足题意条件，再往前， “catsand” 和 “dog” 也分别满足条件，所以整个字符串 “catsanddog” 也满足条件。</p>
<p>现在，我们考虑 dp 数组求解的过程。我们使用 <em>n</em>+1 大小数组的 dp ，其中 <em>n</em> 是给定字符串的长度。我们也使用 2 个下标指针 <em>i</em> 和 <em>j</em> ，其中 <em>i</em> 是当前字符串从头开始的子字符串（<em>s</em>′）的长度， <em>j</em> 是当前子字符串（<em>s</em>′）的拆分位置，拆分成 <em>s</em>′(0,<em>j</em>) 和 <em>s</em>′(<em>j</em>+1,<em>i</em>) 。</p>
<p>为了求出dp 数组，我们初始化 dp[0] 为 true ，这是因为空字符串总是字典的一部分。dp 数组剩余的元素都初始化为 false 。</p>
<p>我们用下标 <em>i</em> 来考虑所有从当前字符串开始的可能的子字符串。对于每一个子字符串，我们通过下标 <em>j</em> 将它拆分成 <em>s</em>1′ 和 <em>s</em>2′ （注意 <em>i</em> 现在指向 <em>s</em>2′ 的结尾）。为了将dp[<em>i</em>] 数组求出来，我们依次检查每个 dp[<em>j</em>] 是否为 true ，也就是子字符串 <em>s</em>1′ 是否满足题目要求。如果满足，我们接下来检查 <em>s</em>2′ 是否在字典中。如果包含，我们接下来检查 <em>s</em>2′ 是否在字典中，如果两个字符串都满足要求，我们让 dp[<em>i</em>] 为 true ，否则令其为 false 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; wordDictSet=<span class="keyword">new</span> HashSet(wordDict);</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>从中序与后序遍历构造二叉树</title>
    <url>/2020/01/23/%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>来源Leetcode第106题从中序与后序遍历构造二叉树</p>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。<br><a id="more"></a><br>例如，给出</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">中序遍历 inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">后序遍历 postorder = [<span class="number">9</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>返回如下的二叉树：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="递归构造"><a href="#递归构造" class="headerlink" title="递归构造"></a>递归构造</h3><p>思路同上一题，先确定根节点，然后在中序遍历中找根节点的位置，然后分出左子树和右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> [] inorder,postorder;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; inorder.length ; i++)</span><br><span class="line">        map.put(inorder[i],i);</span><br><span class="line">    <span class="keyword">this</span>.inorder = inorder;</span><br><span class="line">    <span class="keyword">this</span>.postorder = postorder;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>,postorder.length,<span class="number">0</span>,inorder.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> p_start,<span class="keyword">int</span> p_end,<span class="keyword">int</span> i_start,<span class="keyword">int</span> i_end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p_start == p_end)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(<span class="keyword">this</span>.postorder[p_end - <span class="number">1</span>]);  <span class="comment">//构造根节点</span></span><br><span class="line">    <span class="keyword">int</span> i_root_index = <span class="keyword">this</span>.map.get(<span class="keyword">this</span>.postorder[p_end - <span class="number">1</span>]);  <span class="comment">//得到中序遍历根节点的位置</span></span><br><span class="line">    <span class="keyword">int</span> left = i_root_index - i_start;  <span class="comment">//这一块为根节点的左子树</span></span><br><span class="line">    root.left = helper(p_start , p_start + left,i_start,i_root_index);</span><br><span class="line">    root.right = helper(p_start + left,p_end - <span class="number">1</span>,i_root_index + <span class="number">1</span> , i_end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>从前序与中序遍历构造二叉树</title>
    <url>/2020/01/23/%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>来源Leetcode第105题从前序与中序遍历构造二叉树</p>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。<br><a id="more"></a><br><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">中序遍历 inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>返回如下的二叉树：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="递归构造"><a href="#递归构造" class="headerlink" title="递归构造"></a>递归构造</h3><p>前序序列的第一个节点为根节点，根据根节点在中序序列里的位置，划分出根节点的左右子树，进一步的递归构造。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">首先根据 preorder 找到根节点是 <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">然后根据根节点将 inorder 分成左子树和右子树</span><br><span class="line">左子树</span><br><span class="line">inorder [<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">右子树</span><br><span class="line">inorder [<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">把相应的前序遍历的数组也加进来</span><br><span class="line">左子树</span><br><span class="line">preorder[<span class="number">9</span>] </span><br><span class="line">inorder [<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">右子树</span><br><span class="line">preorder[<span class="number">20</span> <span class="number">15</span> <span class="number">7</span>] </span><br><span class="line">inorder [<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">现在我们只需要构造左子树和右子树即可，成功把大问题化成了小问题</span><br><span class="line">然后重复上边的步骤继续划分，直到 preorder 和 inorder 都为空，返回 <span class="literal">null</span> 即可</span><br></pre></td></tr></table></figure>
<p>用一个Map存储中序遍历每一个节点的位置，由此确定对应的左右子树范围。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> [] preorder,inorder;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; inorder.length ;i++)</span><br><span class="line">        map.put(inorder[i],i);</span><br><span class="line">    <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">    <span class="keyword">this</span>.inorder = inorder;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>,preorder.length ,<span class="number">0</span>,inorder.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> p_start,<span class="keyword">int</span> p_end,<span class="keyword">int</span> i_start,<span class="keyword">int</span> i_end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p_start == p_end)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(<span class="keyword">this</span>.preorder[p_start]);  <span class="comment">//构造根节点</span></span><br><span class="line">    <span class="keyword">int</span> i_root_index = <span class="keyword">this</span>.map.get(<span class="keyword">this</span>.preorder[p_start]);  <span class="comment">//得到中序遍历根节点的位置</span></span><br><span class="line">    <span class="keyword">int</span> left = i_root_index - i_start;  <span class="comment">//这一块为根节点的左子树</span></span><br><span class="line">    root.left = helper(p_start + <span class="number">1</span> , p_start + left + <span class="number">1</span>,i_start,i_root_index);</span><br><span class="line">    root.right = helper(p_start + <span class="number">1</span> + left,p_end,i_root_index + <span class="number">1</span> , i_end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代-栈"><a href="#迭代-栈" class="headerlink" title="迭代 栈"></a>迭代 栈</h3><p>来源<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--22/" target="_blank" rel="noopener">题解</a></p>
<p>我们用一个栈保存已经遍历过的节点，遍历前序遍历的数组，一直作为当前根节点的左子树，直到当前节点和中序遍历的数组的节点相等了，那么我们正序遍历中序遍历的数组，倒着遍历已经遍历过的根节点（用栈的 pop 实现），找到最后一次相等的位置，把它作为该节点的右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; roots = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> in = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//先序遍历第一个值作为根节点</span></span><br><span class="line">    TreeNode curRoot = <span class="keyword">new</span> TreeNode(preorder[pre]);</span><br><span class="line">    TreeNode root = curRoot;</span><br><span class="line">    roots.push(curRoot);</span><br><span class="line">    pre++;</span><br><span class="line">    <span class="comment">//遍历前序遍历的数组</span></span><br><span class="line">    <span class="keyword">while</span> (pre &lt; preorder.length) &#123;</span><br><span class="line">        <span class="comment">//出现了当前节点的值和中序遍历数组的值相等，寻找是谁的右子树</span></span><br><span class="line">        <span class="keyword">if</span> (curRoot.val == inorder[in]) &#123;</span><br><span class="line">            <span class="comment">//每次进行出栈，实现倒着遍历</span></span><br><span class="line">            <span class="keyword">while</span> (!roots.isEmpty() &amp;&amp; roots.peek().val == inorder[in]) &#123;</span><br><span class="line">                curRoot = roots.peek();</span><br><span class="line">                roots.pop();</span><br><span class="line">                in++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设为当前的右孩子</span></span><br><span class="line">            curRoot.right = <span class="keyword">new</span> TreeNode(preorder[pre]);</span><br><span class="line">            <span class="comment">//更新 curRoot</span></span><br><span class="line">            curRoot = curRoot.right;</span><br><span class="line">            roots.push(curRoot);</span><br><span class="line">            pre++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则的话就一直作为左子树</span></span><br><span class="line">            curRoot.left = <span class="keyword">new</span> TreeNode(preorder[pre]);</span><br><span class="line">            curRoot = curRoot.left;</span><br><span class="line">            roots.push(curRoot);</span><br><span class="line">            pre++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记II</title>
    <url>/2020/01/23/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0II/</url>
    <content><![CDATA[<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>TBC 269</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>阶乘后的零</title>
    <url>/2020/01/22/%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/</url>
    <content><![CDATA[<p>来源Leetcode第172题阶乘后的零</p>
<p>给定一个整数 <em>n</em>，返回 <em>n</em>! 结果尾数中零的数量。<br><a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: <span class="number">3</span>! = <span class="number">6</span>, 尾数中没有零。</span><br></pre></td></tr></table></figure>
<hr>
<p>来源于<a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/q172-factorial-trailing-zeroes-by-ronhou/" target="_blank" rel="noopener">题解</a></p>
<p>计算N的阶乘(<code>N!=1*2*...*N</code>)有多少个后缀0，即计算N!里有多少个10，也就是计算N!里有多少个2和5（<code>数学原理：分解质因数</code>），最后结果即2的个数和5的个数取较小值。因此，得到下面时间复杂度为O(NlogN)的暴力求解的算法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> nCountTwo = <span class="number">0</span>, nCountFive = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> value = i;</span><br><span class="line">			<span class="keyword">while</span> (value % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				++nCountTwo;</span><br><span class="line">				value /= <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (value % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				++nCountFive;</span><br><span class="line">				value /= <span class="number">5</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">std</span>::min(nCountTwo, nCountFive);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不关注其它质因数，用x代替</span></span><br><span class="line"><span class="number">0</span>! = <span class="number">1</span></span><br><span class="line"><span class="number">1</span>! = <span class="number">1</span></span><br><span class="line"><span class="number">2</span>! = <span class="number">2</span>^<span class="number">1</span> * <span class="number">5</span>^<span class="number">0</span> * <span class="number">1</span></span><br><span class="line"><span class="number">3</span>! = <span class="number">2</span>^<span class="number">1</span> * <span class="number">5</span>^<span class="number">0</span> * <span class="number">3</span></span><br><span class="line"><span class="number">4</span>! = <span class="number">2</span>^<span class="number">3</span> * <span class="number">5</span>^<span class="number">0</span> * <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>! = <span class="number">2</span>^<span class="number">3</span> * <span class="number">5</span>^<span class="number">1</span> * <span class="number">3</span></span><br><span class="line"><span class="number">6</span>! = <span class="number">2</span>^<span class="number">4</span> * <span class="number">5</span>^<span class="number">1</span> * <span class="number">3</span>^<span class="number">2</span></span><br><span class="line"><span class="number">7</span>! = <span class="number">2</span>^<span class="number">4</span> * <span class="number">5</span>^<span class="number">1</span> * x</span><br><span class="line"><span class="number">8</span>! = <span class="number">2</span>^<span class="number">7</span> * <span class="number">5</span>^<span class="number">1</span> * x</span><br><span class="line"><span class="number">9</span>! = <span class="number">2</span>^<span class="number">7</span> * <span class="number">5</span>^<span class="number">1</span> * x</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>! = <span class="number">2</span>^<span class="number">8</span> * <span class="number">5</span>^<span class="number">2</span> * x</span><br><span class="line"><span class="number">11</span>! = <span class="number">2</span>^<span class="number">8</span> * <span class="number">5</span>^<span class="number">2</span> * x</span><br><span class="line"><span class="number">12</span>! = <span class="number">2</span>^<span class="number">10</span> * <span class="number">5</span>^<span class="number">2</span> * x</span><br><span class="line"><span class="number">13</span>! = <span class="number">2</span>^<span class="number">10</span> * <span class="number">5</span>^<span class="number">2</span> * x</span><br><span class="line"><span class="number">14</span>! = <span class="number">2</span>^<span class="number">11</span> * <span class="number">5</span>^<span class="number">2</span> * x</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>! = <span class="number">2</span>^<span class="number">11</span> * <span class="number">5</span>^<span class="number">3</span> * x</span><br><span class="line"><span class="number">16</span>! = <span class="number">2</span>^<span class="number">15</span> * <span class="number">5</span>^<span class="number">3</span> * x</span><br><span class="line"></span><br><span class="line"><span class="number">24</span>! = <span class="number">5</span>^i * x</span><br><span class="line"></span><br><span class="line"><span class="number">25</span>! = <span class="number">5</span>^(i+<span class="number">2</span>) * x</span><br><span class="line"><span class="number">26</span>! = <span class="number">5</span>^(i+<span class="number">2</span>) * x</span><br><span class="line"><span class="number">27</span>! = <span class="number">5</span>^(i+<span class="number">2</span>) * x</span><br><span class="line"><span class="number">28</span>! = <span class="number">5</span>^(i+<span class="number">2</span>) * x</span><br><span class="line"><span class="number">29</span>! = <span class="number">5</span>^(i+<span class="number">2</span>) * x</span><br><span class="line"></span><br><span class="line"><span class="number">30</span>! = <span class="number">5</span>^(i+<span class="number">3</span>) * x</span><br><span class="line"><span class="number">35</span>! = <span class="number">5</span>^(i+<span class="number">4</span>) * x</span><br><span class="line"><span class="number">40</span>! = <span class="number">5</span>^(i+<span class="number">5</span>) * x</span><br><span class="line"><span class="number">45</span>! = <span class="number">5</span>^(i+<span class="number">6</span>) * x</span><br><span class="line"></span><br><span class="line"><span class="number">49</span>! = <span class="number">5</span>^j * x</span><br><span class="line"><span class="number">50</span>! = <span class="number">5</span>^(j+<span class="number">2</span>) * x</span><br><span class="line"><span class="number">51</span>! = <span class="number">5</span>^(j+<span class="number">2</span>) * x</span><br><span class="line"></span><br><span class="line"><span class="number">74</span>! = <span class="number">5</span>^k * x</span><br><span class="line"><span class="number">75</span>! = <span class="number">5</span>^(k+<span class="number">2</span>) * x</span><br><span class="line"><span class="number">76</span>! = <span class="number">5</span>^(k+<span class="number">2</span>) * x</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line"><span class="number">125</span>! = <span class="number">124</span>! * <span class="number">5</span>^<span class="number">3</span></span><br><span class="line"><span class="number">250</span>! = <span class="number">249</span>! * <span class="number">5</span>^<span class="number">3</span> * <span class="number">2</span></span><br><span class="line"><span class="number">375</span>! = <span class="number">374</span>! * <span class="number">5</span>^<span class="number">3</span> * <span class="number">3</span></span><br><span class="line"><span class="number">500</span>! = <span class="number">499</span>! * <span class="number">5</span>^<span class="number">3</span> * <span class="number">4</span></span><br><span class="line"><span class="number">625</span>! = <span class="number">624</span>! * <span class="number">5</span>^<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>从上面的数据我们可以看出以下几点</p>
<ul>
<li>N!质因数里2的个数总是要比5的个数多，因此此题就变成了求解<code>N!里有多少个质因数5</code>。这里缺少具体的数学证明，不过解决了这道题，基本就能理解为什么2的个数要比5的个数多了，大致上来说就是<code>每两个数字就会多一个质因数2，而每五个数字才多一个质因数5</code>。</li>
<li>每5个数字就会多一个质因数5。0~4的阶乘里没有质因数5，5~9的阶乘里有1个质因数5，10~14的阶乘里有2个质因数5，依此类推。</li>
<li>25!里质因数5的个数要比24!多2个，并不满足上面第3条描述的规律。</li>
<li>26~49的阶乘仍然满足上面第3条描述的规律；50!里质因数5的个数要比49!多2个，不满足上面第3条描述的规律；51~74的阶乘仍然满足上面第3条描述的规律；依此类推。</li>
<li>如果上面第3条规律描述成<code>每5个一组，N!里质因数5的个数要比前一组多一个</code>，那么上面两点就可以整理成：<code>每25(5^2)个一组，N!里质因数5的个数要比前一组再多一个</code>；依此类推，还可以继续划分成125(5^3)一组，625(5^4)一组，等等。</li>
</ul>
<p>综上</p>
<ul>
<li>N!有多少个后缀0，即N!有多少个质因数5。</li>
<li>N!有多少个质因数5，即N可以划分成多少组5个数字一组，加上划分成多少组25个数字一组，加上划分多少组成125个数字一组，等等。即<code>Ans = N/5 + N/(5^2) + N/(5^3) + ...</code></li>
<li><code>Ans = N/5 + N/(5^2) + N/(5^3) + ... = ((N / 5) / 5) / 5 /...</code></li>
<li>最终算法复杂度为O(logN)，代码如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        n /= <span class="number">5</span>;</span><br><span class="line">        cnt += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel表列序号</title>
    <url>/2020/01/22/Excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/</url>
    <content><![CDATA[<p>来自Leetcode第171题Excel表列序号</p>
<p>给定一个Excel表格中的列名称，返回其相应的列序号。<br><a id="more"></a><br>例如，</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">A -&gt; <span class="number">1</span></span><br><span class="line">B -&gt; <span class="number">2</span></span><br><span class="line">C -&gt; <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Z -&gt; <span class="number">26</span></span><br><span class="line">AA -&gt; <span class="number">27</span></span><br><span class="line">AB -&gt; <span class="number">28</span> </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: "A"</span></span><br><span class="line"><span class="section">输出: 1</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p>26进制转换思路</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.equals(<span class="string">""</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, len = s.length(),temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">        temp = s.charAt(i) - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">        temp *= Math.pow(<span class="number">26</span>,len - i - <span class="number">1</span>);</span><br><span class="line">        sum += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="倒序遍历"><a href="#倒序遍历" class="headerlink" title="倒序遍历"></a>倒序遍历</h3><p>即从字符串的最高位，即进制转换里的最低位开始转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mul = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = c.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        res = res + mul * (c[i] - <span class="string">'A'</span> + <span class="number">1</span>);</span><br><span class="line">        mul *= <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>比较版本号</title>
    <url>/2020/01/21/%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/</url>
    <content><![CDATA[<p>来源Leetcode第165题比较版本号</p>
<p>比较两个版本号 <em>version1</em> 和 <em>version2</em>。<br>如果 <code>*version1* &gt; *version2*</code> 返回 <code>1</code>，如果 <code>*version1* &lt; *version2*</code> 返回 <code>-1</code>， 除此之外返回 <code>0</code>。<br><a id="more"></a><br>你可以假设版本字符串非空，并且只包含数字和 <code>.</code> 字符。</p>
<p> <code>.</code> 字符不代表小数点，而是用于分隔数字序列。</p>
<p>例如，<code>2.5</code> 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。</p>
<p>你可以假设版本号的每一级的默认修订版号为 <code>0</code>。例如，版本号 <code>3.4</code> 的第一级（大版本）和第二级（小版本）修订号分别为 <code>3</code> 和 <code>4</code>。其第三级和第四级修订号均为 <code>0</code>。</p>
<h3 id="利用split分割"><a href="#利用split分割" class="headerlink" title="利用split分割"></a>利用split分割</h3><p>利用split对字符串进行切割，然后转成Int比较。对于已经遍历完的部分直接赋值为0即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">    String [] temp1 = version1.split(<span class="string">"\\."</span>);</span><br><span class="line">    String [] temp2 = version2.split(<span class="string">"\\."</span>);</span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span> , p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> v1,v2;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt; temp1.length || p2 &lt; temp2.length)&#123;</span><br><span class="line">        String num1 = p1 &lt; temp1.length ? temp1[p1] : <span class="string">"0"</span>;</span><br><span class="line">        String num2 = p2 &lt; temp2.length ? temp2[p2] : <span class="string">"0"</span>;</span><br><span class="line">        v1 = Integer.parseInt(num1);</span><br><span class="line">        v2 = Integer.parseInt(num2);</span><br><span class="line">        <span class="keyword">if</span> (v1 &gt; v2)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(v1 &lt; v2)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p1++;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分割后字符串比较"><a href="#分割后字符串比较" class="headerlink" title="分割后字符串比较"></a>分割后字符串比较</h3><p>利用Integer.parseInt在一定程度上增加了运行时间并且当数字过大时，可能会溢出，无法比较，因而可以进一步直接用字符串比较。<br>然而提交后还是一样的用时，我傻了。</p>
<pre><code class="lang-JAVA">    public int compareVersion(String version1, String version2) {
        String [] temp1 = version1.split(&quot;\\.&quot;);
        String [] temp2 = version2.split(&quot;\\.&quot;);
        int p1 = 0 , p2 = 0;
        int v1,v2;
        while(p1 &lt; temp1.length || p2 &lt; temp2.length){
            String num1 = p1 &lt; temp1.length ? temp1[p1] : &quot;0&quot;;
            String num2 = p2 &lt; temp2.length ? temp2[p2] : &quot;0&quot;;
            //去掉前导0
            v1 = 0;
            v2 = 0;
            for(int i = 0 ; i &lt; num1.length(); i++){
                if(num1.charAt(i) == &#39;0&#39;)
                    v1++;
                else
                    break;
            }
            for(int i = 0 ; i &lt; num2.length(); i++){
                if(num2.charAt(i) == &#39;0&#39;)
                    v2++;
                else
                    break;
            }
            num1 = num1.substring(v1);
            num2 = num2.substring(v2);
            //开始比较字符串
            if(num1.length() &gt; num2.length())
                return 1;
            else if(num2.length() &gt; num1.length())
                return -1;
            else
            {
                for(int i = 0 ; i &lt; num1.length() ; i++){
                    if (num1.charAt(i) - num2.charAt(i) &gt; 0) {
                        return 1;
                    } else if (num1.charAt(i) - num2.charAt(i) &lt; 0) {
                        return -1;
                    }
                }
                p1++;
                p2++;
            }
        }
        return 0;
    }
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找旋转数组中的最小值II</title>
    <url>/2020/01/21/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII/</url>
    <content><![CDATA[<p>来源Leetcode第154题寻找旋转数组中的最小值II</p>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p>
<p>请找出其中最小的元素。<br><a id="more"></a><br>注意数组中可能存在重复的元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>思路同上一题153，只是在判断相等时直接舍弃即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; nums[left] &gt;= nums[right]) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[right])&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right])&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p>可以做一个预处理，保证所有重复数字不在两段里出现即可，再简单化，也就是保证切割的位置不要是重复数字。也就是比较 <code>start</code> 和 <code>end</code> 是否相同，相同的话 <code>end--</code> 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (nums[end] == nums[start] &amp;&amp; end &gt; start) &#123;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[end]) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>峰值元素</title>
    <url>/2020/01/19/%E5%B3%B0%E5%80%BC%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>来源Leetcode第162题寻找峰值</p>
<p>峰值元素是指其值大于左右相邻值的元素。</p>
<p>给定一个输入数组 <code>nums</code>，其中 <code>nums[i] ≠ nums[i+1]</code>，找到峰值元素并返回其索引。</p>
<p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。<br><a id="more"></a><br>你可以假设 <code>nums[-1] = nums[n] = -∞</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: <span class="number">3</span> 是峰值元素，你的函数应该返回其索引 <span class="number">2</span>。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="一次扫描"><a href="#一次扫描" class="headerlink" title="一次扫描"></a>一次扫描</h3><p>因为 <code>nums[-1]</code> 看做负无穷，所以从第 <code>0</code> 个元素开始，它一定是上升的趋势，由于我们要找峰顶，所以当它第一次出现下降，下降前的值就是我们要找的了。</p>
<p>如果它一直上升到最后一个值，又因为 <code>nums[n]</code> 看做负无穷，所以最后一个值就可以看做一个峰顶。</p>
<p>题解的解法比我提交时的答案相对的少了很多无谓的判断及比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//第一次下降</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一直上升</span></span><br><span class="line">    <span class="keyword">return</span> nums.length - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>我们可以将 <em>nums</em> 数组中的任何给定序列视为交替的升序和降序序列。通过利用这一点，以及“可以返回任何一个峰作为结果”的要求，我们可以利用二分查找来找到所需的峰值元素。</p>
<p>在简单的二分查找中，我们处理的是一个有序数列，并通过在每一步减少搜索空间来找到所需要的数字。在本例中，我们对二分查找进行一点修改。首先从数组 nums中找到中间的元素 <em>m<strong>i</strong>d</em>。若该元素恰好位于降序序列或者一个局部下降坡度中（通过将 <em>n<strong>u</strong>m**s</em>[<em>i</em>] 与右侧比较判断)，则说明峰值会在本元素的左边。于是，我们将搜索空间缩小为 <em>m<strong>i</strong>d</em> 的左边(包括其本身)，并在左侧子数组上重复上述过程。</p>
<p>若该元素恰好位于升序序列或者一个局部上升坡度中（通过将 <em>n<strong>u</strong>m**s</em>[<em>i</em>] 与右侧比较判断)，则说明峰值会在本元素的右边。于是，我们将搜索空间缩小为 <em>m<strong>i</strong>d</em> 的右边，并在右侧子数组上重复上述过程。</p>
<p>就这样，我们不断地缩小搜索空间，直到搜索空间中只有一个元素，该元素即为峰值元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>])</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>相交链表</title>
    <url>/2020/01/17/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>来源Leetcode第160题相交链表</p>
<p>编写一个程序，找到两个单链表相交的起始节点。<br><a id="more"></a><br>如下面的两个链表<strong>：</strong></p>
<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" target="_blank" rel="noopener"><img src="/2020/01/17/相交链表/160_statement.png" alt="img"></a></p>
<p>在节点 c1 开始相交。</p>
<p><strong>示例 1：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" target="_blank" rel="noopener"><img src="/2020/01/17/相交链表/160_example_1.png" alt="img"></a></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">int</span>ersectVal = <span class="number">8</span>, listA = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], listB = [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], skipA = <span class="number">2</span>, skipB = <span class="number">3</span></span><br><span class="line">输出：Reference of the node with value = <span class="number">8</span></span><br><span class="line">输入解释：相交节点的值为 <span class="number">8</span> （注意，如果两个列表相交则不能为 <span class="number">0</span>）。从各自的表头开始算起，链表 A 为 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]，链表 B 为 [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]。在 A 中，相交节点前有 <span class="number">2</span> 个节点；在 B 中，相交节点前有 <span class="number">3</span> 个节点。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>遍历链表 <code>A</code> 并将每个结点的地址/引用存储在哈希表中。然后检查链表 <code>B</code> 中的每一个结点 b_i<em>b**i</em> 是否在哈希表中。若在，则 b_i<em>b**i</em> 为相交结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode p1 = headA;</span><br><span class="line">    Set&lt;ListNode&gt; map = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        map.add(p1);</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p1 = headB;</span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.contains(p1))</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        <span class="keyword">else</span> p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><ul>
<li>创建两个指针 pA<em>p**A</em> 和 pB<em>p**B</em>，分别初始化为链表 <code>A</code> 和 <code>B</code> 的头结点。然后让它们向后逐结点遍历。</li>
<li>当 pA<em>p**A</em> 到达链表的尾部时，将它重定位到链表 <code>B</code> 的头结点 (你没看错，就是链表 <code>B</code>); 类似的，当 pB<em>p**B</em> 到达链表的尾部时，将它重定位到链表 <code>A</code> 的头结点。</li>
<li>若在某一时刻 pA<em>p**A</em> 和 pB<em>p**B</em> 相遇，则 pA<em>p**A</em>/pB<em>p**B</em> 为相交结点。</li>
<li>想弄清楚为什么这样可行, 可以考虑以下两个链表: <code>A={1,3,5,7,9,11}</code> 和 <code>B={2,4,9,11}</code>，相交于结点 <code>9</code>。 由于 <code>B.length (=4) &lt; A.length (=6)</code>，pB<em>p**B</em> 比 pA<em>p**A</em> 少经过 22 个结点，会先到达尾部。将 pB<em>p**B</em> 重定向到 <code>A</code> 的头结点，pA<em>p**A</em> 重定向到 <code>B</code> 的头结点后，pB<em>p**B</em> 要比 pA<em>p**A</em> 多走 <code>2</code> 个结点。因此，它们会同时到达交点。</li>
<li>如果两个链表存在相交，它们末尾的结点必然相同。因此当 pA<em>p**A</em>/pB<em>p**B</em> 到达链表结尾时，记录下链表 <code>A/B</code> 对应的元素。若最后元素不相同，则两个链表不相交。</li>
</ul>
<pre><code class="lang-JAVA">        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
            if(headA == null || headB == null)
                return null;
            ListNode pa = headA , pb = headB;
            while(pa != pb){
                pa = pa == null ? headB : pa.next;
                pb = pb == null ? headA : pb.next;
            }
            return pa;
        }
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找旋转排序数组中的最小值</title>
    <url>/2020/01/17/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    <content><![CDATA[<p>来源Leetcode第153题寻找旋转排序数组中的最小值</p>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。<br>请找出其中最小的元素。<br>你可以假设数组中不存在重复元素。<br><a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>由于给定的数组是有序的，我们就可以使用二分搜索。</p>
<ol>
<li>找到数组的中间元素 <code>mid</code>。</li>
<li>如果<code>中间元素 &gt; 数组第一个元素</code>，我们需要在 <code>mid</code> 右边搜索变化点。</li>
<li>如果<code>中间元素 &lt; 数组第一个元素</code>，我们需要在 <code>mid</code> 做边搜索变化点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left&lt;right &amp;&amp; nums[left] &gt; nums[right]) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid]&gt;=nums[left])&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>颠倒二进制位</title>
    <url>/2020/01/16/%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</url>
    <content><![CDATA[<p>来自Leetcode第190题颠倒二进制位</p>
<p>颠倒给定的 32 位无符号整数的二进制位。</p>
<a id="more"></a>
<p><strong>示例 1：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">00000010100101000001111010011100</span></span><br><span class="line">输出: <span class="number">00111001011110000010100101000000</span></span><br><span class="line">解释: 输入的二进制串 <span class="number">00000010100101000001111010011100</span> 表示无符号整数 <span class="number">43261596</span>，</span><br><span class="line">      因此返回 <span class="number">964176192</span>，其二进制表示形式为 <span class="number">00111001011110000010100101000000</span>。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Integer-reverse"><a href="#Integer-reverse" class="headerlink" title="Integer.reverse()"></a>Integer.reverse()</h3><pre><code>public int reverseBits(int n) {
    return Integer.reverse(n);
}
</code></pre><h3 id="错位交换"><a href="#错位交换" class="headerlink" title="错位交换"></a>错位交换</h3><p>其实就是Integer.reverse的源码。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">初始为</span> <span class="string">abcdefghijklmnopqrstuvwxyz012345</span></span><br><span class="line"><span class="string">第一步结果:</span>  <span class="string">qrstuvwxyz012345</span>  <span class="string">abcdefghijklmnop</span>               </span><br><span class="line"><span class="string">第二步结果:</span>  <span class="string">yz012345</span> <span class="string">qrstuvwx</span>   <span class="string">ijklmnop</span> <span class="string">abcdefgh</span>           </span><br><span class="line"><span class="string">第三步结果:</span>  <span class="number">2345</span> <span class="string">yz01</span> <span class="string">uvwx</span> <span class="string">qrst</span>  <span class="string">mnop</span>  <span class="string">ijkl</span> <span class="string">efgh</span> <span class="string">abcd</span> </span><br><span class="line"><span class="string">第四步结果:</span>  <span class="number">45</span> <span class="number">23</span> <span class="number">01</span> <span class="string">yz</span> <span class="string">wx</span> <span class="string">uv</span> <span class="string">st</span> <span class="string">qr</span>  <span class="string">op</span> <span class="string">mn</span> <span class="string">kl</span> <span class="string">ij</span> <span class="string">gh</span> <span class="string">ef</span> <span class="string">cd</span> <span class="string">ab</span> </span><br><span class="line"><span class="string">第五步结果:</span>  <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="string">z</span> <span class="string">y</span> <span class="string">x</span> <span class="string">w</span> <span class="string">v</span> <span class="string">u</span> <span class="string">t</span> <span class="string">s</span> <span class="string">r</span> <span class="string">q</span>  <span class="string">p</span> <span class="string">o</span> <span class="string">n</span> <span class="string">m</span> <span class="string">l</span> <span class="string">k</span> <span class="string">j</span> <span class="string">i</span> <span class="string">h</span> <span class="string">g</span> <span class="string">f</span> <span class="string">e</span> <span class="string">d</span> <span class="string">c</span> <span class="string">b</span> <span class="string">a</span></span><br></pre></td></tr></table></figure>
<p>这种换法本质是错位法 即创造两个互相错位的数据 这样保证数据不会丢失</p>
<p>好比两排16个的麻将 一排拿掉后边8个, 再右移8个单位, 另一排拿掉前面8个, 再左移8个单位, 再合并, 那么便得到了一排16个的麻将 但前8和后8的相对位置不变, 但整体位置却前后变换了. 再一排拿掉中间的4个, 右移4位 另一排同理 再合并. 所以这个算法实际上模拟的这个过程. 下面用数字解释:</p>
<p>如何创造? 先屏蔽 再移位 比如要创造4位错位, 即12345678换位56781234, 那么先屏蔽5678得到12340000, 移位得到00001234, 同理可得56780000, 再加起来得到56781234; 然后再2位错位, 即屏蔽得到56001200, 移位得到00560012, 同理可得78003400, 加起来得到78563412; 再创造一位错位, 即先屏蔽得到70503010,移位得到07050301, 同理可得80604020, 加起来就是最后结果即87654321.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    n = ((n &amp; <span class="number">0xffff0000</span>) &gt;&gt;&gt; <span class="number">16</span>) | ((n &amp; <span class="number">0x0000ffff</span>) &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h3><p>用一个变量 <code>res</code> 去存储结果，依次得到要转换数字的低位，然后依次保存到 <code>res</code> 中。<code>res</code> 每得到一位后进行左移腾出位置保存下一位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">32</span>) &#123;</span><br><span class="line">        res &lt;&lt;= <span class="number">1</span>;  <span class="comment">//res 左移一位空出位置</span></span><br><span class="line">        res |= (n &amp; <span class="number">1</span>); <span class="comment">//得到的最低位加过来</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;<span class="comment">//原数字右移一位去掉已经处理过的最低位</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>将有序数组转化为二叉搜索树</title>
    <url>/2020/01/16/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p>来源Leetcode第108题将有序数组转化为二叉搜索树</p>
<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。<br><a id="more"></a><br><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">给定有序数组: [<span class="number">-10</span>,<span class="number">-3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[<span class="number">0</span>,<span class="number">-3</span>,<span class="number">9</span>,<span class="number">-10</span>,<span class="literal">null</span>,<span class="number">5</span>]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      <span class="number">0</span></span><br><span class="line">     / \</span><br><span class="line">   <span class="number">-3</span>   <span class="number">9</span></span><br><span class="line">   /   /</span><br><span class="line"> <span class="number">-10</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="中点作为根节点"><a href="#中点作为根节点" class="headerlink" title="中点作为根节点"></a>中点作为根节点</h3><p>数组的中点就是根节点，然后将数组截断，以此类推</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = nums.length / <span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    <span class="keyword">if</span>(mid &gt; <span class="number">0</span>) </span><br><span class="line">        root.left = sortedArrayToBST(Arrays.copyOfRange(nums,<span class="number">0</span>,mid));</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; nums.length - <span class="number">1</span>)</span><br><span class="line">    root.right = sortedArrayToBST(Arrays.copyOfRange(nums,mid + <span class="number">1</span>,nums.length));</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉树</title>
    <url>/2020/01/16/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>来源Leetcode第110题平衡二叉树</p>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过1。<br><a id="more"></a><br><strong>示例 1:</strong></p>
</blockquote>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>返回 <code>true</code> 。</p>
<h3 id="自底向上的递归"><a href="#自底向上的递归" class="headerlink" title="自底向上的递归"></a>自底向上的递归</h3><p>这道题和求树的高度是一样的，只是在递归求解的时候需要判断树的左右高度是否是平衡的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    hlper(root);</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hlper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> height_l = <span class="number">0</span>,height_r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">        height_l = <span class="number">1</span> + hlper(root.left);</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">        height_r = <span class="number">1</span> + hlper(root.right);</span><br><span class="line">    <span class="keyword">if</span>(Math.abs(height_l - height_r) &gt; <span class="number">1</span>)</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(height_l,height_r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分支-限界"><a href="#分支-限界" class="headerlink" title="分支 - 限界"></a>分支 - 限界</h3><p>当递归求解出现左右子树高度相差大于1的情况时，记返回值为-1，这样遇到-1，就可以一路返回上一层，避免了多余的计算。<br>来自<a href="https://leetcode-cn.com/problems/balanced-binary-tree/solution/ti-qian-zu-duan-fa-gei-da-lao-de-xie-fa-xie-zhu-sh/" target="_blank" rel="noopener">题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//-1 即为存在层数相差大于1</span></span><br><span class="line">		<span class="keyword">return</span> depth(root)!=-<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 以当前节点为根节点的树的层数</span></span><br><span class="line"><span class="comment">	 * 返回-1的话说明 不满足要求不用求了直接 -1 退出</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前节点不存在其层数为0</span></span><br><span class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取左节点的层数</span></span><br><span class="line">		<span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="comment">//如果层数为-1直接截断</span></span><br><span class="line">		<span class="keyword">if</span>(left==-<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//获取右节点的层数</span></span><br><span class="line">		<span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">		<span class="comment">//如果层数为-1直接退出</span></span><br><span class="line">        <span class="keyword">if</span>(right==-<span class="number">1</span>)<span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">		<span class="comment">//如果左右节点层数相差大于1 直接返回-1 否则返回真实层数</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(left-right)&lt;<span class="number">2</span>?Math.max(left,right)+<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记I</title>
    <url>/2020/01/16/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。<br><a id="more"></a><br>C++ 引用 vs 指针</p>
<p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>
<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
</ul>
<p>引用的好处之一就是在函数调用时在内存中不会生成副本。</p>
<p>引用总结</p>
<ul>
<li>在引用的使用中，单纯给某个变量取个别名是毫无意义的，引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。</li>
<li>用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过<strong>const</strong>的使用，保证了引用传递的安全性。</li>
<li>引用与指针的区别是，指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。</li>
<li>使用引用的时机。流操作符<strong>&lt;&lt;</strong>和<strong>&gt;&gt;</strong>、赋值操作符<strong>=</strong>的返回值、拷贝构造函数的参数、赋值操作符<strong>=</strong>的参数、其它情况都推荐使用引用。</li>
<li>声明引用时，必须同时对其进行初始化。</li>
<li>引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。ra=1; 等价于 a=1; </li>
<li>声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。故：对引用求地址，就是对目标变量求地址。&amp;ra与&amp;a相等。</li>
<li>不能建立数组的引用。因为数组是一个由若干个元素所成的集合，所以无法建立一个数组的别名。</li>
<li>不能建立引用的引用，不能建立指向引用的指针。因为引用不是一种数据类型！！所以没有引用的引用，没有引用的指针。<br>引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。</li>
</ul>
<p>引用的声明方法：类型标识符<strong>&amp;</strong>引用名=目标变量名；</p>
<h3 id="引用应用"><a href="#引用应用" class="headerlink" title="引用应用"></a>引用应用</h3><h4 id="引用作为参数"><a href="#引用作为参数" class="headerlink" title="引用作为参数"></a>引用作为参数</h4><p>引用的一个重要作用就是作为函数的参数。以前的C语言中函数参数传递是值传递，如果有大块数据作为参数传递的时候，采用的方案往往是指针，因为这样可以避免将整块数据全部压栈，可以提高程序的效率。但是现在（C++中）又增加了一种同样有效率的选择（在某些特殊情况下又是必须的选择），就是引用。</p>
<p>递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。</p>
<p>使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</p>
<p>使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</p>
<h4 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h4><p>常引用声明方式：const 类型标识符 &amp;引用名=目标变量名；</p>
<p>用这种方式声明的引用，不能通过引用对目标变量的值进行修改,从而使引用的目标成为const，达到了引用的安全性。</p>
<h4 id="引用作为返回值"><a href="#引用作为返回值" class="headerlink" title="引用作为返回值"></a>引用作为返回值</h4><p>要以引用返回函数值，则函数定义时要按以下格式：<br>类型标识符 &amp;函数名（形参列表及类型说明）<br>{函数体}</p>
<p>说明：<br>（1）以引用返回函数值，定义函数时需要在函数名前加&amp;<br>（2）用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。</p>
<p>引用作为返回值，必须遵守以下规则：<br>（1）不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了”无所指”的引用，程序会进入未知状态。 </p>
<p>（2）不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak(内存泄露)。</p>
<p>（3）可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。</p>
<p>（4）引用与一些操作符的重载：流操作符&lt;&lt;和&gt;&gt;，这两个操作符常常希望被连续使用，例如：cout &lt;&lt; “hello” &lt;&lt; endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个&lt;&lt;操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用&lt;&lt;操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。 赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。</p>
<p>（5）在另外的一些操作符中，却千万不能返回引用：+-*/ 四则运算符。它们不能返回引用，Effective C++[1]的Item23详细的讨论了这个问题。主要原因是这四个操作符没有side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个new分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第2、3两个方案都被否决了。静态对象的引用又因为((a+b) == (c+d))会永远为true而导致错误。所以可选的只剩下返回一个对象了。</p>
<h4 id="引用和多态"><a href="#引用和多态" class="headerlink" title="引用和多态"></a>引用和多态</h4><p>引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。</p>
<p>【例7】：<br>class 　A;<br>class 　B：public A{……};<br>B 　b;<br>A 　&amp;Ref = b;  // 用派生类对象初始化基类对象的引用<br>Ref 只能用来访问派生类对象中从基类继承下来的成员，是基类引用指向派生类。如果A类中定义有虚函数，并且在B类中重写了这个虚函数，就可以通过Ref产生多态效果。</p>
<h2 id="顶层const与底层const"><a href="#顶层const与底层const" class="headerlink" title="顶层const与底层const"></a>顶层const与底层const</h2><p>2.4.3.Top-Level const<br>As we’ve seen, a pointer is an object that can point to a different object. As a result,we can talk independently about whether a pointer is const and whether the objects to which it can point are const. We use the term <strong>top-level const</strong> to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer to that const as a <strong>low-level const</strong>.</p>
<p>指针本身是一个对象，因为，指针实际对应着内存单元的一段存储空间，然而，指针所指向的也是一个数据对象，因此，指针是一个常量与指针所指向的是一个常量是两个完全不同的概念， <strong>顶层 const</strong> 表示的是 <strong>指针本身是一个常量</strong>， <strong>底层 const</strong> 表示的是 <strong>指针所指的对象是一个常量</strong>，更一般情况下， <strong>顶层 const 可以表示任意对象是一个常量</strong>，这对于算术类型、类、指针等任何数据类型都是成立的， <strong>底层 const 则与指针和引用等复合类型的基本类型部分有关</strong> ，比较特殊的是，指针既可以是顶层 const 也可以是底层 const ，这一点与其他类型区别明显。</p>
<p>顶层和底层的翻译很容易让人误解为就只有两层，实际上当然是不是的。首先我们假设有这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> Const = <span class="keyword">const</span> T;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> Ptr = T*;</span><br></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *** <span class="keyword">const</span> shit = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>要怎么看呢？很简单，不要用const和*，用Const和Ptr来表达，马上明白：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Const&lt;Ptr&lt;Ptr&lt;Ptr&lt;Const&lt;<span class="keyword">int</span>&gt;&gt;&gt;&gt;&gt; shit = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>从右向左读，星号读作pointer，没多一层加一个to，然后最前面加上declare就行。比如对const int <em>*</em> const shit;，可以读作：declare shit as const pointer to pointer to pointer to const int。</p>
<h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><p><code>constexpr</code> 说明符声明可以在编译时求得函数或变量的值。然后这些变量和函数（若给定了合适的函数实参）即可用于仅允许编译时<a href="https://zh.cppreference.com/w/cpp/language/constant_expression" target="_blank" rel="noopener">常量表达式</a>之处。用于对象或非静态成员函数 (C++14 前)声明的 constexpr 说明符蕴含 const。用于函数声明的 constexpr 说明符或 <a href="https://zh.cppreference.com/w/cpp/language/static" target="_blank" rel="noopener">static</a> 成员变量 (C++17 起)蕴含 inline。若函数或函数模板的任何声明拥有 <code>constexpr</code> 说明符，则每个声明必须都含有该说明符。</p>
<p><strong>constexpr 变量</strong>必须满足下列要求：</p>
<ul>
<li>其类型必须是<a href="https://zh.cppreference.com/w/cpp/named_req/LiteralType" target="_blank" rel="noopener"><em>字面类型</em> (<em>LiteralType</em>) </a>。</li>
<li>它必须被立即初始化</li>
<li>其初始化的<a href="https://zh.cppreference.com/w/cpp/language/eval_order" target="_blank" rel="noopener">全表达式</a>，包括所有隐式转换、构造函数调用等，都必须是<a href="https://zh.cppreference.com/w/cpp/language/constant_expression" target="_blank" rel="noopener">常量表达式</a></li>
</ul>
<p><strong>constexpr 函数</strong>必须满足下列要求：</p>
<ul>
<li>它必须非<a href="https://zh.cppreference.com/w/cpp/language/virtual" target="_blank" rel="noopener">虚</a> </li>
</ul>
<h2 id="显示强制转换"><a href="#显示强制转换" class="headerlink" title="显示强制转换"></a>显示强制转换</h2><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>用法：static_cast &lt; type-id &gt; ( expression )，</p>
<p>该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性，它主要有如下几种用法：</p>
<ol>
<li>用于基本数据类型之间的转换，如把int转换为char，把int转换成enum，但这种转换的安全性需要开发者自己保证（这可以理解为保证数据的精度，即程序员能不能保证自己想要的程序安全），如在把int转换为char时，如果char没有足够的比特位来存放int的值（int&gt;127或int&lt;-127时），那么static_cast所做的只是简单的截断，及简单地把int的低8位复制到char的8位中，并直接抛弃高位。</li>
<li>把空指针转换成目标类型的空指针</li>
<li>把任何类型的表达式类型转换成void类型</li>
<li>用于类层次结构中父类和子类之间指针和引用的转换。</li>
</ol>
<p>对于以上第（4）点，存在两种形式的转换，即上行转换（子类到父类）和下行转换（父类到子类）。对于static_cast，上行转换时安全的，而下行转换时不安全的，为什么呢？因为static_cast的转换时粗暴的，它仅根据类型转换语句中提供的信息（尖括号中的类型）来进行转换，这种转换方式对于上行转换，由于子类总是包含父类的所有数据成员和函数成员，因此从子类转换到父类的指针对象可以没有任何顾虑的访问其（指父类）的成员。而对于下行转换为什么不安全，是因为static_cast只是在编译时进行类型坚持，没有运行时的类型检查，具体原理在dynamic_cast中说明。</p>
<p><strong>一句话概括：</strong></p>
<p>仅当类型之间可隐式转换时（除类层次间的下行转换以外），static_cast的转换才是合法的，否则将产生错误。（基类指针或引用转换成子类指针或引用为下行转换）</p>
<p>类层次间的下行转换不能通过隐式转换完成，但是可以通过static_cast完成，但是由于没有动态类型检查，所以是不安全的。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d=<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> i=d;    <span class="comment">//编译器的隐式转换，等价于下面这条语句</span></span><br><span class="line"><span class="keyword">int</span> i= <span class="keyword">static_cast</span> &lt;<span class="keyword">int</span>&gt;(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指针之间的转换*/</span></span><br><span class="line"><span class="keyword">char</span> str[]=<span class="string">"good"</span>;</span><br><span class="line"><span class="keyword">char</span> *ptr=str;</span><br><span class="line"><span class="keyword">int</span> *p=<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(ptr);<span class="comment">//编译错误，两者之间的转换要显式，如下</span></span><br><span class="line"><span class="keyword">int</span> *p=(<span class="keyword">int</span> *)(ptr);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span>:</span><span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line">  </span><br><span class="line">Base b;</span><br><span class="line">child c;</span><br><span class="line">c=<span class="keyword">static_cast</span>&lt;child *&gt;(b);  <span class="comment">//下行转换，正确；</span></span><br><span class="line">c=b;    <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>只用使用const_cast才能将const性质转换掉。在这种情况下，试图使用其他三种形式的强制转换都会导致编译时的错误。类似地，除了<strong>添加或者删除const特性</strong>，用const_cast符来执行其他任何类型转换，都会引起编译错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> val=<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *ptr=<span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*为了使ptr指向val，使用const_cast*/</span></span><br><span class="line">ptr=<span class="keyword">const_cast</span>&lt;<span class="keyword">double</span> *&gt;(&amp;val);</span><br></pre></td></tr></table></figure>
<p>在《C++ primer》（第五版）中是这样介绍const_cast的：</p>
<p>const_cast只能改变运算对象的底层const</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</span><br><span class="line"><span class="keyword">char</span> *p=<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);<span class="comment">//正确但是通过p写值是未定义的行为</span></span><br></pre></td></tr></table></figure>
<p>对于将常量对象转换成非常量对象的行为，我们一般称其为“去掉const性质（cast away the const）”。一旦我们去掉了某个对象的const性质，编译器就不再阻止我们对该对象进行写操作了。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果。</p>
<p>只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。同样的，也不能用const_cast改变表达式的 类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cp;</span><br><span class="line"><span class="comment">//错误：static_cast不能转换const的性质</span></span><br><span class="line"><span class="keyword">char</span> *q=<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(cp);</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="built_in">string</span>&gt;(cp);<span class="comment">//正确：字符串字面值转换为string类型</span></span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&gt;(cp);<span class="comment">//const_cast只改变常量属性</span></span><br></pre></td></tr></table></figure>
<h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>从语法上看，这个操作符仅用于指针类型的转换（返回值是指针）。它用来将一个类型指针转换为另一个类型指针，它只需在编译时重新解释指针的类型。这个操作符基本不考虑转换类型之间是否是相关的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> *pc=<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span> *&gt;(ip);</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*注：必须牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用</span></span><br><span class="line"><span class="comment">*就可能在运行时发生错误*/</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<p>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</p>
<p>在《C++ Primer（中文 第五版 ）》指出reinterpret_cast很危险，不建议使用。</p>
<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>该运算符把expression转换成type类型的对象。type必须是类型的指针、类的引用或者void*。type和expression的形式要对应，如果type是指针类型，那么expression也必须是一个指针，如果type是一个引用，那么expression也必须是一个引用。</p>
<p>static_cast只在编译时进行类型检查，与其他强制类型转换不同，dynamic_cast涉及运行时类型检查。dynamic_cast运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表，故对没有虚函数表的类使用会导致dynamic_cast编译错误。</p>
<p>所以dynamic_cast主要用于类层次结构中父类和子类之间指针和引用的转换，由于具有运行时类型检查，因此可以保证下行转换的安全性，何为安全性？即转换成功就返回转换后的正确类型指针，如果转换失败，则返回NULL（如果是转换到引用类型的dynamic_cast失败，则抛出bad_cast类型的异常），之所以说static_cast在下行转换时不安全，是因为即使转换失败，它也不返回NULL。</p>
<p>另外，若绑定到引用或指针的对象类型不是目标类型，则dynamic_cast会失败（这点下面细说）。若转换到指针的失败，dynamic_cast的结果是0值，若转换到引用类型的失败，则抛出一个bad_cast类型的异常。</p>
<p>dynamic_cast主要符主要用于类层次间的上行转换和下行转换。</p>
<ol>
<li>在类层次间上行转换时，dynamic_cast和static_cast的效果一样。因为在公有继承方式（保护继承、私有继承，不能隐式转换）下，派生类的对象/对象指针/对象引用可以赋值给基类的对象/对象指针/对象引用（发生隐式转换），反过来则不行。</li>
<li>若发生下行转换是安全的，也就是，如果基类指针或者引用的确指向一个派生类对象，这个运算符会传回转型过的指针，若不安全，则会传回空指针。</li>
</ol>
<p>针对下行转换，换句话说：向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     Base():b(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">     <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     Derived():d(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">     <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Base *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     Derived *pd1=<span class="keyword">static_cast</span>&lt;Derived *&gt;(p);     <span class="comment">//语句1</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;pd1-&gt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;pd1-&gt;d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     Derived *pd2=<span class="keyword">dynamic_cast</span>&lt;Derived *&gt;(p);    <span class="comment">//语句2</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;pd2-&gt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;pd2-&gt;d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>若调用函数func的实参p指向一个Derived类型的对象，即<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base *p=<span class="keyword">new</span> Derived;</span><br><span class="line">func(p);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>则pd1和pd2是一样的，并且对这两个指针执行 Derived类的任何操作都是安全的，语句1和2都是输出1、2；</p>
<ol>
<li>若p指向的是一个Base类型的对象，即<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base *p=<span class="keyword">new</span> Base;</span><br><span class="line">func(p);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>那么pd1指向Base对象的地址，对它进行Derived类型的操作将是不安全的（如访问d），输出d的值时，将会是一个垃圾值；而pd2将是一个空指针，对空指针进行操作，将会发生异常。</p>
<h2 id="异常处理-try-catch"><a href="#异常处理-try-catch" class="headerlink" title="异常处理(try catch)"></a>异常处理(try catch)</h2><h3 id="C-异常机制概述"><a href="#C-异常机制概述" class="headerlink" title="C++异常机制概述"></a>C++异常机制概述</h3><p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p>
<p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>
<ul>
<li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li>
<li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li>
<li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li>
</ul>
<p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>( ExceptionName e1 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="keyword">catch</span>( ExceptionName e2 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="keyword">catch</span>( ExceptionName eN )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异常事件发生时，程序使用throw关键字抛出异常表达式，抛出点称为异常出现点，由操作系统为程序设置当前异常对象，然后执行程序的当前异常处理代码块，在包含了异常出现点的最内层的<strong>try</strong>块，依次匹配catch语句中的异常对象（只进行类型匹配，catch参数有时在catch语句中并不会使用到）。若匹配成功，则执行catch块内的异常处理语句，然后接着执行<strong>try…catch…</strong>块之后的代码。如果在当前的try…catch…块内找不到<strong>匹配</strong>该异常对象的catch语句,则由更外层的try…catch…块来处理该异常；如果当前函数内所有的try…catch…块都不能匹配该异常，则递归回退到调用栈的上一层去处理该异常。如果一直退到主函数main()都不能处理该异常，则调用系统函数terminate()终止程序。</p>
<p>执行throw语句时，throw表达式将作为对象被复制构造为一个新的对象，称为异常对象。异常对象放在内存的特殊位置，该位置既不是栈也不是堆，在window上是放在线程信息块TIB中。这个构造出来的新对象与本级的try所对应的catch语句进行<strong>类型匹配</strong>，类型匹配的原则在下面介绍。</p>
<p><img src="/2020/01/16/C-学习笔记/610439-20160117105031678-298323359.png" alt="img"></p>
<h3 id="异常对象"><a href="#异常对象" class="headerlink" title="异常对象"></a>异常对象</h3><p><strong>异常对象</strong>是一种特殊的对象，编译器依据异常抛出表达式复制构造异常对象，这要求抛出异常表达式不能是一个不完全类型（一个类型在声明之后定义之前为一个不完全类型。不完全类型意味着该类型没有完整的数据与操作描述），而且可以进行复制构造，这就要求异常抛出表达式的复制构造函数（或移动构造函数）、析构函数不能是私有的。</p>
<p>异常对象不同于函数的局部对象，局部对象在函数调用结束后就被自动销毁，而异常对象将驻留在所有可能被激活的catch语句都能访问到的内存空间中，也即上文所说的TIB。当异常对象与catch语句成功匹配上后，在该catch语句的结束处被自动析构。</p>
<p>在函数中返回局部变量的引用或指针几乎肯定会造成错误，同样的道理，在throw语句中抛出局部变量的指针或引用也几乎是错误的行为。如果指针所指向的变量在执行catch语句时已经被销毁，对指针进行解引用将发生意想不到的后果。</p>
<p>throw出一个表达式时，该表达式的静态编译类型将决定异常对象的类型。所以当throw出的是基类指针的解引用，而该指针所指向的实际对象是派生类对象，此时将发生派生类对象切割。</p>
<p>除了抛出用户自定义的类型外，C++标准库定义了一组类，用户报告标准库函数遇到的问题。这些标准库异常类只定义了几种运算，包括创建或拷贝异常类型对象，以及为异常类型的对象赋值。</p>
<p>C++ 提供了一系列标准的异常，定义在 <em>**</em> 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：</p>
<p><img src="/2020/01/16/C-学习笔记/exceptions_in_cpp.png" alt="C++ 异常的层次结构"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标准异常类</th>
<th>描述</th>
<th>头文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>exception</td>
<td>最通用的异常类，只报告异常的发生而不提供任何额外的信息</td>
<td>exception</td>
</tr>
<tr>
<td>runtime_error</td>
<td>只有在运行时才能检测出的错误</td>
<td>stdexcept</td>
</tr>
<tr>
<td>rang_error</td>
<td>运行时错误：产生了超出有意义值域范围的结果</td>
<td>stdexcept</td>
</tr>
<tr>
<td>overflow_error</td>
<td>运行时错误：计算上溢</td>
<td>stdexcept</td>
</tr>
<tr>
<td>underflow_error</td>
<td>运行时错误：计算下溢</td>
<td>stdexcept</td>
</tr>
<tr>
<td>logic_error</td>
<td>程序逻辑错误</td>
<td>stdexcept</td>
</tr>
<tr>
<td>domain_error</td>
<td>逻辑错误：参数对应的结果值不存在</td>
<td>stdexcept</td>
</tr>
<tr>
<td>invalid_argument</td>
<td>逻辑错误：无效参数</td>
<td>stdexcept</td>
</tr>
<tr>
<td>length_error</td>
<td>逻辑错误：试图创建一个超出该类型最大长度的对象</td>
<td>stdexcept</td>
</tr>
<tr>
<td>out_of_range</td>
<td>逻辑错误：使用一个超出有效范围的值</td>
<td>stdexcept</td>
</tr>
<tr>
<td>bad_alloc</td>
<td>内存动态分配错误</td>
<td>new</td>
</tr>
<tr>
<td>bad_cast</td>
<td>dynamic_cast类型转换出错</td>
<td>type_info</td>
</tr>
<tr>
<td>bad_exception</td>
<td>这在处理 C++ 程序中无法预期的异常时非常有用。</td>
<td>exception</td>
</tr>
<tr>
<td>bad_typeid</td>
<td>该异常可以通过 <strong>typeid</strong> 抛出。</td>
<td>typeinfo</td>
</tr>
</tbody>
</table>
</div>
<h3 id="catch-关键字"><a href="#catch-关键字" class="headerlink" title="catch 关键字"></a>catch 关键字</h3><p>catch语句匹配被抛出的异常对象。如果catch语句的参数是引用类型，则该参数可直接作用于异常对象，即参数的改变也会改变异常对象，而且在catch中<strong>重新抛出异常</strong>时会继续传递这种改变。如果catch参数是传值的，则复制构函数将依据异常对象来构造catch参数对象。在该catch语句结束的时候，先析构catch参数对象，然后再析构异常对象。</p>
<p>在进行异常对象的匹配时，编译器不会做任何的隐式类型转换或类型提升。除了以下几种情况外，异常对象的类型必须与catch语句的声明类型完全匹配：</p>
<ul>
<li>允许从非常量到常量的类型转换。</li>
<li>允许派生类到基类的类型转换。</li>
<li>数组被转换成指向数组（元素）类型的指针。</li>
<li>函数被转换成指向函数类型的指针。</li>
</ul>
<p>寻找catch语句的过程中，匹配上的未必是类型完全匹配那项，而在是最靠前的第一个匹配上的catch语句（我称它为最先匹配原则）。所以，派生类的处理代码catch语句应该放在基类的处理catch语句之前，否则先匹配上的总是参数类型为基类的catch语句，而能够精确匹配的catch语句却不能够被匹配上。</p>
<p>在catch块中，如果在当前函数内无法解决异常，可以继续向外层抛出异常，让外层catch异常处理块接着处理。此时可以使用不带表达式的throw语句将捕获的异常重新抛出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(type x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//做了一部分处理</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被重新抛出的异常对象为保存在TIB中的那个异常对象，与catch的参数对象没有关系，若catch参数对象是引用类型，可能在catch语句内已经对异常对象进行了修改，那么重新抛出的是修改后的异常对象；若catch参数对象是非引用类型，则重新抛出的异常对象并没有受到修改。</p>
<p>使用catch(…){}可以捕获所有类型的异常，根据最先匹配原则，catch(…){}应该放在所有catch语句的最后面，否则无法让其他可以精确匹配的catch语句得到匹配。通常在catch(…){}语句中执行当前可以做的处理，然后再重新抛出异常。注意，catch中重新抛出的异常只能被外层的catch语句捕获。</p>
<h3 id="栈展开、RAII"><a href="#栈展开、RAII" class="headerlink" title="栈展开、RAII"></a>栈展开、RAII</h3><p>其实栈展开已经在前面说过，就是从异常抛出点一路向外层函数寻找匹配的catch语句的过程，寻找结束于某个匹配的catch语句或标准库函数terminate。这里重点要说的是栈展开过程中对局部变量的销毁问题。我们知道，在函数调用结束时，函数的局部变量会被系统自动销毁，类似的，throw可能会导致调用链上的语句块提前退出，此时，语句块中的局部变量将按照构成生成顺序的逆序，依次调用析构函数进行对象的销毁。例如下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个没有任何意义的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() :a(<span class="number">0</span>)&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A默认构造函数"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    A(<span class="keyword">const</span>  A&amp; rsh)&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A复制构造函数"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A析构函数"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>  a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            A a ;</span><br><span class="line">            <span class="keyword">throw</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (A a)</span><br><span class="line">        &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序将输出：<br><img src="/2020/01/16/C-学习笔记/610439-20160117104044460-1503720621.png" alt="img"></p>
<p>定义变量a时调用了默认构造函数，使用a初始化异常变量时调用了复制构造函数，使用异常变量复制构造catch参数对象时同样调用了复制构造函数。三个构造对应三个析构，也即try语句块中局部变量a自动被析构了。然而，如果a是在自由存储区上分配的内存时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        A * a= <span class="keyword">new</span> A;</span><br><span class="line">        <span class="keyword">throw</span> *a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (A a)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果：<br><img src="/2020/01/16/C-学习笔记/610439-20160117104140975-1118592832.png" alt="img"></p>
<p>同样的三次构造，却只调用了两次的析构函数！说明a的内存在发生异常时并没有被释放掉，发生了内存泄漏。<br><strong>RAII机制有助于解决这个问题</strong>，RAII（Resource acquisition is initialization，资源获取即初始化）。它的思想是<strong>以对象管理资源</strong>。为了更为方便、鲁棒地释放已获取的资源，避免资源死锁，一个办法是把资源数据用对象封装起来。程序发生异常，执行栈展开时，封装了资源的对象会被自动调用其析构函数以释放资源。C++中的智能指针便符合RAII。关于这个问题详细可以看<strong>《Effective C++》条款13.</strong></p>
<h3 id="异常机制与构造函数"><a href="#异常机制与构造函数" class="headerlink" title="异常机制与构造函数"></a>异常机制与构造函数</h3><p>异常机制的一个合理的使用是在构造函数中。构造函数没有返回值，所以应该使用异常机制来报告发生的问题。更重要的是，构造函数抛出异常表明构造函数还没有执行完，其对应的析构函数不会自动被调用，因此析构函数应该先析构所有所有已初始化的基对象，成员对象，再抛出异常。<br>C++类构造函数初始化列表的异常机制，称为function-try block。一般形式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myClass::myClass(type1 pa1)</span><br><span class="line">    <span class="keyword">try</span>:  _myClass_val (初始化值)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*构造函数的函数体 */</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">catch</span> ( exception&amp; err )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 构造函数的异常处理部分 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="异常机制与析构函数"><a href="#异常机制与析构函数" class="headerlink" title="异常机制与析构函数"></a>异常机制与析构函数</h3><p>C++不禁止析构函数向外界抛出异常，但析构函数被期望不向外界函数抛出异常。析构函数中向函数外抛出异常，将直接调用terminator()系统函数终止程序。如果一个析构函数内部抛出了异常，就应该在析构函数的内部捕获并处理该异常，不能让异常被抛出析构函数之外。可以如此处理：</p>
<ul>
<li>若析构函数抛出异常，调用std::abort()来终止程序。</li>
<li>在析构函数中catch捕获异常并作处理。</li>
</ul>
<p>关于具体细节，有兴趣可以看《Effective C++》条款08：<strong>别让异常逃离析构函数</strong>。</p>
<h3 id="noexcept修饰符与noexcept操作符"><a href="#noexcept修饰符与noexcept操作符" class="headerlink" title="noexcept修饰符与noexcept操作符"></a>noexcept修饰符与noexcept操作符</h3><p>noexcept修饰符是C++11新提供的异常说明符，用于声明一个函数不会抛出异常。编译器能够针对不抛出异常的函数进行优化，另一个显而易见的好处是你明确了某个函数不会抛出异常，别人调用你的函数时就知道不用针对这个函数进行异常捕获。在C++98中关于异常处理的程序中你可能会看到这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span> ,<span class="keyword">double</span> )</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>这是throw作为函数异常说明，前者表示func（）这个函数可能会抛出int或double类型的异常，后者表示func()函数不会抛出异常。事实上前者很少被使用，在C++11这种做法已经被摒弃，而后者则被C++11的noexcept异常声明所代替：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//等价于void func() throw()&#123;...&#125;</span></span><br></pre></td></tr></table></figure>
<p>在C++11中，编译器并不会在编译期检查函数的noexcept声明，因此，被声明为noexcept的函数若携带异常抛出语句还是可以通过编译的。在函数运行时若抛出了异常，编译器可以选择直接调用terminate()函数来终结程序的运行，因此，noexcept的一个作用是<strong>阻止异常的传播,提高安全性</strong>.</p>
<p>上面一点提到了，我们不能让异常逃出析构函数，因为那将导致程序的不明确行为或直接终止程序。实际上出于安全的考虑，C++11标准中让类的析构函数默认也是noexcept的。 同样是为了安全性的考虑，经常被析构函数用于释放资源的delete函数，C++11也默认将其设置为noexcept。</p>
<p>noexcept也可以接受一个常量表达式作为参数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(常量表达式)</span></span>;</span><br></pre></td></tr></table></figure>
<p>常量表达式的结果会被转换成bool类型，noexcept(true)表示函数不会抛出异常，noexcept(false)则表示函数有可能会抛出异常。故若你想更改析构函数默认的noexcept声明，可以显式地加上noexcept(false)声明，但这并不会带给你什么好处。</p>
<h3 id="定义新的异常"><a href="#定义新的异常" class="headerlink" title="定义新的异常"></a>定义新的异常</h3><p>以通过继承和重载 exception 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyException</span> :</span> <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">what</span> <span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"C++ Exception"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> MyException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(MyException&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"MyException caught"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(<span class="built_in">std</span>::exception&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//其他的错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常处理的性能分析"><a href="#异常处理的性能分析" class="headerlink" title="异常处理的性能分析"></a>异常处理的性能分析</h3><p>异常处理机制的主要环节是运行期类型检查。当抛出一个异常时，必须确定异常是不是从try块中抛出。异常处理机制为了完善异常和它的处理器之间的匹配，需要存储每个异常对象的类型信息以及catch语句的额外信息。由于异常对象可以是任何类型（如用户自定义类型），并且也可以是多态的，获取其动态类型必须要使用运行时类型检查（RTTI），此外还需要运行期代码信息和关于每个函数的结构。</p>
<p>当异常抛出点所在函数无法解决异常时，异常对象沿着调用链被传递出去，程序的控制权也发生了转移。转移的过程中为了将异常对象的信息携带到程序执行处（如对异常对象的复制构造或者catch参数的析构），在时间和空间上都要付出一定的代价，本身也有不安全性，特别是异常对象是个复杂的类的时候。</p>
<p>异常处理技术在不同平台以及编译器下的实现方式都不同，但都会给程序增加额外的负担，当异常处理被关闭时，额外的数据结构、查找表、一些附加的代码都不会被生成，正是因为如此，对于明确不抛出异常的函数，我们需要使用noexcept进行声明。</p>
<h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><h3 id="自动对象"><a href="#自动对象" class="headerlink" title="自动对象"></a>自动对象</h3><p>默认情况下，局部变量的生命期局限于所在函数的每次执行期间。只有当定义它的函数被调用时才存在的对象称为自动对象。自动对象在每次调用函数时创建和撤销。该类型局部变量存储在栈上，在动态存储区。<br>局部变量所对应的自动对象在函数控制经过变量定义语句时创建。如果在定义时提供了初始化，那么每次创建对象时，对象都会被赋予指定的初值。对于未初始化的内置类型局部变量，其初值不确定。当函数调用时结束，自动对象就会被撤销。<br>形参也是自动对象，其所占存储空间在函数调用时被创建，在函数结束时撤销。</p>
<h3 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h3><p>静态局部变量的意义：</p>
<ol>
<li>分配空间在全局数据栈上</li>
<li>作用域只局限于当前的函数范围内（局部）</li>
<li>生命周期为整个程序，不会随着当前的函数结束而结束</li>
<li>首次初始化时赋值生效，以后的初始化赋值自动跳过</li>
</ol>
<h3 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h3><h4 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h4><p>initializer_list是C++11提供的新类型，定义在同名头文件中。<br>用于表示某种特定类型的值的数组，和vector一样，initializer_list也是一种模板类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">initializer_list</span>;</span></span><br></pre></td></tr></table></figure>
<p>它提供的操作如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">initializer_list</span>&lt;T&gt; lst; </span><br><span class="line"><span class="comment">//默认初始化；T类型元素的空列表</span></span><br><span class="line"><span class="built_in">initializer_list</span>&lt;T&gt; lst&#123;a,b,c...&#125;;</span><br><span class="line"><span class="comment">//lst的元素数量和初始值一样多；lst的元素是对应初始值的副本</span></span><br><span class="line">lst2(lst)   </span><br><span class="line">lst2=lst  </span><br><span class="line"><span class="comment">//拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本元素共享</span></span><br><span class="line">lst.size()  <span class="comment">//列表中的元素数量</span></span><br><span class="line">lst.begin()  <span class="comment">//返回指向lst中首元素的指针</span></span><br><span class="line">lst.end()   <span class="comment">//返回指向lst中尾元素下一位置的指针</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是,initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。并且，拷贝或赋值一个initializer_list对象不会拷贝列表中的元素，其实只是引用而已，原始列表和副本共享元素。</p>
<p>和使用vector一样，我们也可以使用迭代器访问initializer_list里的元素</p>
<p>如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号内：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//expected和actual是string对象</span></span><br><span class="line"><span class="keyword">if</span>(expected != actual)</span><br><span class="line">   error_msg(&#123;<span class="string">"functionX"</span>,expectde,actual&#125;);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   error_msg(&#123;<span class="string">"functionX"</span>,<span class="string">"okay"</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>而现在c++11添加了initializer_list后，我们可以这样初始化<code>std::vector v = { 1, 2, 3, 4 };</code>,并且，C++11允许构造函数和其他函数把初始化列表当做参数。</p>
<h4 id="省略符形参"><a href="#省略符形参" class="headerlink" title="省略符形参"></a>省略符形参</h4><p>省略符形参函数定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整数求和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> x, ...)</span>		<span class="comment">//用...表示后续参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//定义一个参数列表</span></span><br><span class="line">	va_list ap;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> var;</span><br><span class="line">	<span class="comment">//请看正文介绍va_start()</span></span><br><span class="line">	va_start(ap, x);</span><br><span class="line">	<span class="comment">//请看正文介绍va_arg()</span></span><br><span class="line">	<span class="keyword">while</span> (var = va_arg(ap, <span class="keyword">int</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		result += var;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//销毁列表</span></span><br><span class="line">	va_end(ap);</span><br><span class="line">	<span class="keyword">return</span> result + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省略符形参 <strong>可以接受不同的参数类型</strong>，但是使用起来相对复杂：</p>
<p><strong>va_list</strong> 在头文件 <stdarg.h> 或 <cstdarg> 中,它是用来存储实参的。<br><strong>va_arg(ap,int)</strong> 方法用来获取实参列表中的实参，“int”是实参的类型。它从首个实参依次获取，将获取到的结果作为返回值返回。<br><strong>va_start(ap,x)</strong> 就是用来设置首个实参，表示取参数的时候从x的下一个参数开始。（不取x）<br><strong>va_end(ap)</strong> 表示用完ap，即要释放内存。</cstdarg></stdarg.h></p>
<p>在获取参数列表的时候，va_list并不能判断实参的总个数，所以需要设置结束参数。<br>在上例中，判断取得的参数是否为0，如果为0，表示参数结尾：while (var = va_arg(ap, int)) 。</p>
<p>所以在使用函数时，需要以0作为结束参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//省略符形参不需要用&#123;&#125;，但是要以0做结尾：</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h3><h4 id="返回列表"><a href="#返回列表" class="headerlink" title="返回列表"></a>返回列表</h4><ul>
<li><p>C++11规定，函数可以返回花括号包围的值的列表</p>
</li>
<li><p>如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间</p>
</li>
<li><p>如果函数返回的是类类型，由类本身定义初始值如何使用</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; func()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"World"</span>;</span><br><span class="line">    <span class="keyword">return</span>&#123; <span class="string">"Info"</span>,s1 ,s2 &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v= func();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = v.begin(); i != v.end(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="尾置返回类型"><a href="#尾置返回类型" class="headerlink" title="尾置返回类型"></a>尾置返回类型</h4><p>尾置返回类型是在C++11标准中新增的语法，可以用于任何函数定义中，旨在方便复杂函数的定义。尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，需要在本应该出现返回类型的地方放置一个auto关键字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个返回指向数组的指针的函数</span></span><br><span class="line"><span class="comment">//传统定义</span></span><br><span class="line"><span class="keyword">int</span> (* func1(<span class="keyword">int</span> arr[][<span class="number">3</span>], <span class="keyword">int</span> n))[<span class="number">3</span>] </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;arr[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用尾置返回类型后</span></span><br><span class="line">auto func1(int arr[][3], int n) -&gt; int(*)[3] </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;arr[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用decltype声明函数返回值类型"><a href="#使用decltype声明函数返回值类型" class="headerlink" title="使用decltype声明函数返回值类型"></a>使用decltype声明函数返回值类型</h4><p>有时候我们知道函数的返回值是什么类型，就可以使用decltype来简化函数声明</p>
<p>例如：下面的arrPtr函数返回一个数组指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> even[] = &#123; <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span>(odd) *arrPtr(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%<span class="number">2</span>)? &amp;odd : &amp;even;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> (*arr)[<span class="number">5</span>] =arrPtr(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (end(*arr) - begin(*arr)); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *(*arr + i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><h3 id="函数指针介绍"><a href="#函数指针介绍" class="headerlink" title="函数指针介绍"></a>函数指针介绍</h3><p>函数指针指向某种特定类型，函数的类型由其参数及返回类型共同决定，与函数名无关。举例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> nLeft,<span class="keyword">int</span> nRight)</span></span>;<span class="comment">//函数定义</span></span><br></pre></td></tr></table></figure>
<p>该函数类型为int(int,int),要想声明一个指向该类函数的指针，只需用指针替换函数名即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pf)(<span class="keyword">int</span>,<span class="keyword">int</span>);<span class="comment">//未初始化</span></span><br></pre></td></tr></table></figure>
<p>则pf可指向int(int,int)类型的函数。pf前面有*，说明pf是指针，右侧是形参列表，表示pf指向的是函数，左侧为int，说明pf指向的函数返回值为int。则pf可指向int(int,int)类型的函数。而add类型为int(int,int),则pf可指向add函数。</p>
<h3 id="标准C函数指针"><a href="#标准C函数指针" class="headerlink" title="标准C函数指针"></a>标准C函数指针</h3><h4 id="函数指针定义"><a href="#函数指针定义" class="headerlink" title="函数指针定义"></a>函数指针定义</h4><p>普通函数指针定义<code>int (*pf)(int,int);</code></p>
<p>使用typedef定义函数指针类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PF)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;  </span><br><span class="line">PF pf;<span class="comment">//此时，为指向某种类型函数的函数指针类型，而不是具体指针，用它可定义具体指针</span></span><br></pre></td></tr></table></figure>
<h4 id="函数指针的普通使用"><a href="#函数指针的普通使用" class="headerlink" title="函数指针的普通使用"></a>函数指针的普通使用</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pf = add;  </span><br><span class="line">pf(<span class="number">100</span>,<span class="number">100</span>);<span class="comment">//与其指向的函数用法无异  </span></span><br><span class="line">(*pf)(<span class="number">100</span>,<span class="number">100</span>);<span class="comment">//此处*pf两端括号必不可少</span></span><br></pre></td></tr></table></figure>
<p>注意：add类型必须与pf可指向的函数类型完全匹配</p>
<h4 id="函数指针作为形参"><a href="#函数指针作为形参" class="headerlink" title="函数指针作为形参"></a>函数指针作为形参</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二个形参为函数类型，会自动转换为指向此类函数的指针  </span></span><br><span class="line"><span class="function">Void <span class="title">fuc</span><span class="params">(<span class="keyword">int</span> nValue,<span class="keyword">int</span> pf(<span class="keyword">int</span>,<span class="keyword">int</span>))</span></span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//等价的声明，显示的将形参定义为指向函数的指针  </span></span><br><span class="line"><span class="function">Void <span class="title">fuc</span><span class="params">(<span class="keyword">int</span> nValue,<span class="keyword">int</span> (*pf)(<span class="keyword">int</span>,<span class="keyword">int</span>))</span></span>;  </span><br><span class="line"><span class="function">Void <span class="title">fuc</span><span class="params">(<span class="keyword">int</span> nValue,PF)</span></span>;</span><br></pre></td></tr></table></figure>
<p>形参中有函数指针的函数调用，以fuc为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pf = add;//pf是函数指针  </span><br><span class="line">fuc(1,add);//add自动转换为函数指针  </span><br><span class="line">fuc(1,pf);</span><br></pre></td></tr></table></figure>
<h4 id="返回指向函数的指针"><a href="#返回指向函数的指针" class="headerlink" title="返回指向函数的指针"></a>返回指向函数的指针</h4><p>使用typedef定义的函数指针类型作为返回参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">PF <span class="title">fuc2</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//PF为函数指针类型</span></span><br></pre></td></tr></table></figure>
<p>直接定义函数指针作为返回参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fuc2(<span class="keyword">int</span>))(<span class="keyword">int</span>,<span class="keyword">int</span>);<span class="comment">//显示定义</span></span><br></pre></td></tr></table></figure>
<p>说明：按照有内向外的顺序阅读此声明语句。fuc2有形参列表，则fuc2是一个函数，其形参为fuc2(int),fuc2前面有*，所以fuc2返回一个指针，指针本身也包含形参列表（int，int），因此指针指向函数，该函数的返回值为int.</p>
<p>总结：fuc2是一个函数，形参为(int),返回一个指向int(int,int)的函数指针。</p>
<h3 id="C-函数指针"><a href="#C-函数指针" class="headerlink" title="C++函数指针"></a>C++函数指针</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>由于C++完全兼容C，则C中可用的函数指针用法皆可用于C++</p>
<p>C++其他函数(指针)定义方式及使用</p>
<p>typedef与decltype组合定义函数类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(add)</span> add2</span>;</span><br></pre></td></tr></table></figure>
<p>decltype返回函数类型,add2是与add相同类型的函数，不同的是add2是类型，而非具体函数。</p>
<p>使用方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">add2* pf;<span class="comment">//pf指向add类型的函数指针，未初始化</span></span><br></pre></td></tr></table></figure>
<p>typedef与decltype组合定义函数指针类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(add)</span>* PF2</span>;<span class="comment">//PF2与1.1PF意义相同  </span></span><br><span class="line">PF2 pf;<span class="comment">// pf指向int(int,int)类型的函数指针，未初始化</span></span><br></pre></td></tr></table></figure>
<p>使用推断类型关键字auto定义函数类型和函数指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pf = add;<span class="comment">//pf可认为是add的别名(个人理解)   </span></span><br><span class="line"><span class="keyword">auto</span> *pf = add;<span class="comment">//pf为指向add的指针</span></span><br></pre></td></tr></table></figure>
<h4 id="函数指针使用"><a href="#函数指针使用" class="headerlink" title="函数指针使用"></a>函数指针使用</h4><p>函数指针形参</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(add)</span> add2</span>;  </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(add)</span>* PF2</span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fuc2</span> <span class="params">(add2 add)</span></span>;<span class="comment">//函数类型形参，调用自动转换为函数指针 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fuc2</span> <span class="params">(PF2 add)</span></span>;<span class="comment">//函数指针类型形参，传入对应函数(指针)即可</span></span><br></pre></td></tr></table></figure>
<p>说明：不论形参声明的是函数类型：void fuc2 (add2 add);还是函数指针类型void fuc2 (PF2 add);都可作为函数指针形参声明，在参数传入时，若传入函数名，则将其自动转换为函数指针。</p>
<p>返回指向函数的指针</p>
<p>使用auto关键字    </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">auto fuc2(int)-&gt; int(*)(int,int) //fuc2返回函数指针为int(*)(int,int)</span><br></pre></td></tr></table></figure>
<p>使用decltype关键字</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(add)* fuc2(<span class="keyword">int</span>)<span class="comment">//明确知道返回哪个函数，可用decltype关键字推断其函数类型,</span></span><br></pre></td></tr></table></figure>
<h4 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h4><h5 id="普通成员函数指针使用"><a href="#普通成员函数指针使用" class="headerlink" title="普通成员函数指针使用"></a>普通成员函数指针使用</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>//定义类<span class="title">A</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">  </span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> nLeft, <span class="keyword">int</span> nRight)</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">       </span>&#123;  </span><br><span class="line">              <span class="keyword">return</span> (nLeft + nRight);  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  </span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">fuc</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">       </span>&#123;  </span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">"Hello  world\n"</span>);  </span><br><span class="line">             </span><br><span class="line">       &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(A::*PF1)</span><span class="params">()</span></span>;<span class="comment">//指针名前需加上类名限定  </span></span><br><span class="line">  </span><br><span class="line">PF1 pf1 = &amp;A::fuc; <span class="comment">//必须有&amp;  </span></span><br><span class="line">  </span><br><span class="line">A a;<span class="comment">//成员函数地址解引用必须附驻与某个对象地址，所以必须创建一个对象</span></span><br><span class="line">  </span><br><span class="line">(a.*pf1)();<span class="comment">//使用成员函数指针调用函数</span></span><br></pre></td></tr></table></figure>
<h5 id="继承中的函数指针使用"><a href="#继承中的函数指针使用" class="headerlink" title="继承中的函数指针使用"></a>继承中的函数指针使用</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">fuc</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">       </span>&#123;  </span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">"Hello fuc()\n"</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">fuc2</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">       </span>&#123;  </span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">"Hello A::fuc2()\n"</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fuc2</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">       </span>&#123;  </span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">"Hello B::fuc2()\n"</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(A::*PF1)</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(B::*PF2)</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">PF1 pf1 = &amp;A::fuc;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>         </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">       A a;  </span><br><span class="line">       B b;  </span><br><span class="line">       (a.*pf1)();  <span class="comment">//调用A::fuc  </span></span><br><span class="line">       (b.*pf1)();   <span class="comment">//调用A::fuc  </span></span><br><span class="line">  </span><br><span class="line">       pf1 = &amp;A::fuc2;  </span><br><span class="line">       (a.*pf1)();  <span class="comment">//调用A::fuc2  </span></span><br><span class="line">       (b.*pf1)();  <span class="comment">//调用A::fuc2  </span></span><br><span class="line">  </span><br><span class="line">       PF2 pf2 = &amp;A::fuc2;   </span><br><span class="line">       (b.*pf2)(); <span class="comment">//调用A::fuc2  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树展开为链表</title>
    <url>/2020/01/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>来源Leetcode第114二叉树展开为链表</p>
<p>给定一个二叉树，<a href="https://baike.baidu.com/item/原地算法/8010757" target="_blank" rel="noopener">原地</a>将它展开为链表。</p>
<p>例如，给定二叉树<br><a id="more"></a><br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>将其展开为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">6</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="栈的先序遍历"><a href="#栈的先序遍历" class="headerlink" title="栈的先序遍历"></a>栈的先序遍历</h3><p>由题目可知这是一道先序遍历的题目，于是考虑了用栈，通过栈提前保存二叉树的右左子树，然后通过出栈解决。<br>但是与普通的二叉树先序遍历不一样，需要对出栈节点的<strong>左子树赋值为null</strong>，并且保存当前遍历节点。<br>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode temp = <span class="keyword">null</span>;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        TreeNode tmp = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            temp.right = tmp;</span><br><span class="line">            temp.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(tmp.right);</span><br><span class="line">        <span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(tmp.left);</span><br><span class="line">        temp = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h3><p>来自<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/" target="_blank" rel="noopener">题解</a></p>
<p>可以发现展开的顺序其实就是二叉树的先序遍历。算法和 94 题中序遍历的 Morris 算法有些神似，我们需要两步完成这道题。</p>
<ol>
<li>将左子树插入到右子树的地方</li>
<li>将原来的右子树接到左子树的最右边节点</li>
<li>考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null</li>
</ol>
<p>可以看图理解下这个过程。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">   <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 1 的左子树插入到右子树的地方</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>         <span class="number">5</span></span><br><span class="line">     / \         \</span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>         <span class="number">6</span>        </span><br><span class="line"><span class="comment">//将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">     / \          </span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>  </span><br><span class="line">         \</span><br><span class="line">          <span class="number">5</span></span><br><span class="line">           \</span><br><span class="line">            <span class="number">6</span></span><br><span class="line">            </span><br><span class="line"> <span class="comment">//将 2 的左子树插入到右子树的地方</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>       <span class="number">4</span>  </span><br><span class="line">                 \</span><br><span class="line">                  <span class="number">5</span></span><br><span class="line">                   \</span><br><span class="line">                    <span class="number">6</span>   </span><br><span class="line">        </span><br><span class="line"> <span class="comment">//将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>      </span><br><span class="line">         \</span><br><span class="line">          <span class="number">4</span>  </span><br><span class="line">           \</span><br><span class="line">            <span class="number">5</span></span><br><span class="line">             \</span><br><span class="line">              <span class="number">6</span>         </span><br><span class="line">  </span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>
<p>于是相应的，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = root.right;  <span class="comment">//左子树为空可以直接进行下一层的遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode tmp = root.left;</span><br><span class="line">            <span class="keyword">while</span> (tmp.right != <span class="keyword">null</span>)</span><br><span class="line">                tmp = tmp.right;</span><br><span class="line">            tmp.right = root.right;  <span class="comment">//根节点右子树成为左子树最右节点</span></span><br><span class="line">            root.right = root.left;  <span class="comment">//根节点的右子树成为左子树</span></span><br><span class="line">            root.left = <span class="keyword">null</span>;  <span class="comment">//根节点左子树赋值为空</span></span><br><span class="line">            root = root.right;  <span class="comment">//进行下一个节点的遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>我们可以逆过来进行。</p>
<p>我们依次遍历 <code>6 5 4 3 2 1</code>，然后每遍历一个节点就将当前节点的右指针更新为上一个节点。</p>
<p>遍历到 <code>5</code>，把 <code>5</code> 的右指针指向 <code>6</code>。<code>6 &lt;- 5 4 3 2 1</code>。</p>
<p>遍历到 <code>4</code>，把 <code>4</code> 的右指针指向 <code>5</code>。<code>6 &lt;- 5 &lt;- 4 3 2 1</code>。</p>
<p>… …</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>这样就不会有丢失孩子的问题了，因为更新当前的右指针的时候，当前节点的右孩子已经访问过了。</p>
<p>而 <code>6 5 4 3 2 1</code> 的遍历顺序其实变形的后序遍历，遍历顺序是右子树-&gt;左子树-&gt;根节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    flatten(root.right);</span><br><span class="line">    flatten(root.left);</span><br><span class="line">    root.right = pre;</span><br><span class="line">    root.left = <span class="keyword">null</span>;</span><br><span class="line">    pre = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论考试理论部分</title>
    <url>/2020/01/07/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E8%80%83%E8%AF%95%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>算法的基本概念和性质：</p>
<p>算法就是任何良定义（well-defined）的计<br>算过程，该过程取某个值或值的集合作为输入（input），并<br>产生某个值或者值的集合作为输出（output）。<br>   —— 算法就是把输入转换成输出的计算步骤。<br>   —— 在计算机科学中，算法是使用计算机解一类问题的精确、有效方法的代名词；<br>   算法是一组有穷的规则，它规定了解决某一特定类型问题 的一系列运算。 （选自《计算机算法基础》） </p>
<hr>
<p>渐近表示：O、Ω、Θ记号的定义和相关性质及其证明。 </p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法导论</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>主存管理</title>
    <url>/2020/01/05/%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="主存管理概述"><a href="#主存管理概述" class="headerlink" title="主存管理概述"></a>主存管理概述</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>现代操作系统将主存区分为物理主存和逻辑主存2类。<br>物理主存是共享的物质基础。<br><a id="more"></a></p>
</blockquote>
<h3 id="主存共享方式—分片共享"><a href="#主存共享方式—分片共享" class="headerlink" title="主存共享方式—分片共享"></a>主存共享方式—分片共享</h3><ul>
<li>大小不等的区域<br>① 分区存储管理<br>② 段式存储管理</li>
<li>大小相等的区域<br>页式存储管理</li>
<li>二者结合<br>段页式存储管理</li>
</ul>
<p>现代操作系统的主存管理必须实现主存分配、主存保护、虚拟主存等功能，即：</p>
<ol>
<li>将逻辑地址映射为物理主存地址</li>
<li>在多用户之间分配物理主存</li>
<li>对各用户区的信息提供保护措施</li>
<li>扩充逻辑主存区</li>
</ol>
<h3 id="程序的逻辑组织"><a href="#程序的逻辑组织" class="headerlink" title="程序的逻辑组织"></a>程序的逻辑组织</h3><p>一维地址结构</p>
<ul>
<li>一个程序是一个连续、线性的地址结构；</li>
<li>确定线性地址空间中的指令地址或操作数地址只需要一个信息。</li>
</ul>
<p>二维地址结构 </p>
<ul>
<li>一个程序由若干个分段组成，每个分段是一个连续的地址区； </li>
<li>确定线性地址空间中的指令地址或操作数地址需要两个 信息，一是该信息所在的分段，另一个是该信息在段内的偏移量。</li>
</ul>
<p><img src="/2020/01/05/主存管理/image-20200105085223070.png" alt="image-20200105085223070"></p>
<h2 id="主存管理功能"><a href="#主存管理功能" class="headerlink" title="主存管理功能"></a>主存管理功能</h2><h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><ul>
<li>物理地址 (绝对地址、实地址)<br>物理地址是计算机主存单元的真实地址，又称为绝对地址或实地址。</li>
<li>主存空间<br>物理地址的集合所对应的空间组成了主存空间。</li>
<li>逻辑地址 (相对地址、虚地址)<br>用户的程序地址 (指令地址或操作数地址)均为逻辑地址。 </li>
<li>程序地址空间<br>用户程序所有的逻辑地址集合对应的空间。</li>
</ul>
<h3 id="主存管理功能-1"><a href="#主存管理功能-1" class="headerlink" title="主存管理功能"></a>主存管理功能</h3><ul>
<li>地址映射——实现逻辑地址到物理主存地址的映射</li>
<li>主存分配 ——在多用户之间分配物理主存</li>
<li>存储保护——对各用户区的信息提供保护措施</li>
<li>主存扩充/虚拟主存——扩充逻辑主存区</li>
</ul>
<h4 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h4><p>什么是地址映射 ：将程序地址空间中使用的逻辑地址变换成主存中的物理地 址的过程，称为地址映射。</p>
<p>地址映射的时机和类别<br>① 编程或编译时确定地址映射关系<br>在程序编写或程序编译时确定虚、实地址之间的对应关系，结果是一 个不能浮动的程序模块。<br>② 在程序装入时确定地址映射关系<br>在程序装入过程中随即进行的地址变换方式称为静态地址映射<br>在这种情况下，一个已开始执行的程序是无法在主存中移动的；同时，如果该程序因某种原因暂时放在辅存，若再调入主存时，还必须把它放回到主存的同一位置上。<br><img src="/2020/01/05/主存管理/image-20200105091248853.png" alt="image-20200105091248853"><br>③ 在程序运行时确定地址映射关系 在程序执行期间，随着每条指令和数据的访问自动地连续 地进行地址映射，这种地址变换方式称为动态地址映射。<br>经过动态重定位的程序，可以不经过任何改变而装入主存单元。<br>可满足以下目标：</p>
<ol>
<li>具有给用户程序分配一个主存区域的能力</li>
<li>在改变系统设备时，具有不需要重新编程和重新编辑的能力</li>
<li>具有在任何时刻，在主存可用空间中重新分配一个程序的能力</li>
<li>对于一个用户程序，具有以间断方式分配主存的能力</li>
<li>具有只装入用户程序的部分代码即可投入运行的能力</li>
</ol>
<p><img src="/2020/01/05/主存管理/image-20200105091228936.png" alt="image-20200105091228936"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>静态地址映射</th>
<th>动态地址映射</th>
</tr>
</thead>
<tbody>
<tr>
<td>在程序装入过程中进行地址映射</td>
<td>在程序执行期间进行地址映射</td>
</tr>
<tr>
<td>需软件(重定位装入程序)</td>
<td>需硬件地址变换机构(重定位寄存器)</td>
</tr>
<tr>
<td>需花费较多CPU时间</td>
<td>地址变换快</td>
</tr>
<tr>
<td>不灵活</td>
<td>灵活</td>
</tr>
</tbody>
</table>
</div>
<h3 id="主存分配"><a href="#主存分配" class="headerlink" title="主存分配"></a>主存分配</h3><p>构造分配用的数据结构<br>主存资源信息块：等待队列；空闲区队列；主存分配程序</p>
<p>制定策略<br>① 分配策略 —— 在众多个请求者中选择一个请求者的原则<br>② 放置策略 —— 在可用资源中，选择一个空闲区的原则<br>③ 调入策略 —— 决定信息装入主存的时机<br>预调策略：预先将信息调入主存<br>请调策略：当需要信息时，将信息调入主存<br>④ 淘汰策略 —— 在主存中没有可用的空闲区 (对某一程序 而言)时，决定哪些信息从主存中移走，即确定淘汰已占用的内存区的原则。</p>
<h3 id="主存分配-1"><a href="#主存分配-1" class="headerlink" title="主存分配"></a>主存分配</h3><p>构造分配用的数据结构<br>主存资源信息块：等待队列；空闲区队列；主存分配程序</p>
<p>制定策略<br>① 分配策略 —— 在众多个请求者中选择一个请求者的原则<br>② 放置策略 —— 在可用资源中，选择一个空闲区的原则<br>③ 调入策略 —— 决定信息装入主存的时机<br>预调策略：预先将信息调入主存<br>请调策略：当需要信息时，将信息调入主存<br>④ 淘汰策略 —— 在主存中没有可用的空闲区 (对某一程序 而言)时，决定哪些信息从主存中移走，即确定淘汰已占 用的内存区的原则。</p>
<p>实施主存分配与回收</p>
<h3 id="主存扩充"><a href="#主存扩充" class="headerlink" title="主存扩充"></a>主存扩充</h3><p>可行性 局部性特征</p>
<p>实现方法</p>
<ul>
<li>程序的全部代码和数据存放在辅存中；</li>
<li>将程序当前执行所涉及的那部分程序代码放入主存中；</li>
<li>程序执行时，当所需信息不在主存，由操作系统和硬件相配合来完成主存从辅存中调入信息，程序继续执行。</li>
</ul>
<p>虚拟存储器：由操作系统和硬件相配合来完成主存和辅存之间的信息的动态调度。这样的计算机系统好像为用户提供了一个其存储容量比实际主存大得多的存储器，这个存储器称为虚拟存储器<br>虚拟存储器的核心</p>
<ul>
<li>逻辑地址与物理地址分开</li>
<li>存储空间与虚地址空间分开</li>
<li>提供地址变换机构 </li>
</ul>
<p>实现虚拟存储器的物质基础</p>
<ul>
<li>有相当容量的辅存： 足以存放应用程序的虚地址空间</li>
<li>有一定容量的主存： 存放进入主存的多进程的信息</li>
<li>地址变换机构</li>
</ul>
<h3 id="存储保护"><a href="#存储保护" class="headerlink" title="存储保护"></a>存储保护</h3><p>什么是存储保护 ：在多用户环境中，主存储器按区分配给各用户程序使用。 为了互不影响，必须由硬件 (软件配合)保证各用户程序只 能在给定的存储区域内活动，这种措施叫做存储保护。</p>
<p>实现方法</p>
<ol>
<li>界地址保护<ol>
<li>上下界防护  物理地址<br><img src="/2020/01/05/主存管理/image-20200105091048112.png" alt="image-20200105091048112"></li>
<li>基地址、限长防护 逻辑地址<br><img src="/2020/01/05/主存管理/image-20200105091157055.png" alt="image-20200105091157055"></li>
</ol>
</li>
<li>存储键保护</li>
</ol>
<h2 id="分区存储管理"><a href="#分区存储管理" class="headerlink" title="分区存储管理"></a>分区存储管理</h2><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><p>什么是动态分区分配：在处理程序的过程中，建立分区，依用户请求的大小分配分区。</p>
<p>分区分配数据结构<br>① 主存资源信息块 (M_RIB)<br>② 分区描述器 (PD)<br>flag： 为 0  —— 空闲区<br>     为 1  —— 已分配区<br>size： 分区大小<br>next：空闲区——自由主存队列中的勾链字<br>     已分配区——此项为零</p>
<p>M_RIB</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>等待队列头指针</th>
</tr>
</thead>
<tbody>
<tr>
<td>空闲区队列头指针</td>
</tr>
<tr>
<td>主存分配程序入口地址</td>
</tr>
</tbody>
</table>
</div>
<p>PD</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分配标志</th>
<th>flag</th>
</tr>
</thead>
<tbody>
<tr>
<td>大小</td>
<td>size</td>
</tr>
<tr>
<td>勾链字</td>
<td>next</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2020/01/05/主存管理/image-20200105091701189.png" alt="image-20200105091701189"></p>
<h3 id="分区的分配与回收"><a href="#分区的分配与回收" class="headerlink" title="分区的分配与回收"></a>分区的分配与回收</h3><p>分区分配思路<br>① 寻找空闲块<br>依申请者所要求的主存区的大小，分区分配程序在自由主存队列中找一个满足用户需要的空闲块；<br>② 若找到了所需的空闲区，有两种情况<br>ⅰ 空闲区与要求的大小相等，将该空闲区分配并从队列中摘除；<br>ⅱ 空闲区大于所要求的的大小，将空闲区分为两部分：一 部分成为已分配区，建立已分配区的描述器；剩下部分 仍为空闲区。返回所分配区域的首址；<br>③ 否则，告之不能满足要求。</p>
<p>分区回收思路<br>① 检查释放分区 (即为回收分区)在主存中的邻接情况<br>若上、下邻接空闲区，则合并，成为一个连续的空闲区<br>② 若回收分区不与任何空闲区相邻接<br>建立一个新的空闲区，并加入到空闲区队列中。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>处理机的调度</title>
    <url>/2020/01/04/%E5%A4%84%E7%90%86%E6%9C%BA%E7%9A%84%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="处理机的多级调度"><a href="#处理机的多级调度" class="headerlink" title="处理机的多级调度"></a>处理机的多级调度</h2><ul>
<li>作业调度(宏观)：决定哪些程序调入计算机系统</li>
<li>进程调度(微观)：决定哪个（些）进程占用CPU，使用多长时间等<a id="more"></a>
<h2 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h2></li>
</ul>
<h3 id="作业及作业调度的功能"><a href="#作业及作业调度的功能" class="headerlink" title="作业及作业调度的功能"></a>作业及作业调度的功能</h3><p>一般来说，计算机系统把用户要求处理的一项工作称为一个作业。</p>
<p>作业有四种状态：<br>1.提交状态 用户将程序和数据提交计算中心；<br>2.后备状态 将作业录入到后援存储设备；<br>3.执行状态 作业调入计算机系统内存；<br>4.完成状态 作业计算完成的善后处理。</p>
<p><img src="/2020/01/04/处理机的调度/image-20200104223306933.png" alt="image-20200104223306933"></p>
<p>作业调度的主要任务是完成作业从后备状态到执行状态和从执行状态到完成状态的转变。<br>功能：<br>1.确定数据结构，记录已进入系统的各作业的情况（JCB，Job Control Block）；<br>2.按一定的调度算法，从后备作业中选择一个或几个作业进入内存；<br>3.分配资源，为被选中的作业创建进程，并为其申请系统资源；<br>4.作业结束后作善后处理。</p>
<p>每个作业进入系统时由系统为其建立一个作业控制块JCB（Job Control Block)，它是存放作业控制和管理信息的数据结构，主要信息见下表。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">作业名</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">资源要求</td>
<td style="text-align:center">估计运行时间</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">最迟完成时间</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">要求的主存量</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">要求外设的类型及台数</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">要求文件量和输出量</td>
</tr>
<tr>
<td style="text-align:center">资源使用情况</td>
<td style="text-align:center">进入系统的时间</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">开始运行的时间</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">已运行的时间</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">内存地址</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">外设台号</td>
</tr>
<tr>
<td style="text-align:center">类型</td>
<td style="text-align:center">控制方式</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">作业类型</td>
</tr>
<tr>
<td style="text-align:center">优先级</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">状态数</td>
</tr>
</tbody>
</table>
</div>
<h3 id="性能的衡量"><a href="#性能的衡量" class="headerlink" title="性能的衡量"></a>性能的衡量</h3><p>作业调度算法规定了从后备作业中选择作业进入系统内存的原则。</p>
<p>确定调度算法时应考虑的因素<br>1.应与系统的整体设计目标一致<br>2.考虑系统中各种资源的负载均匀<br>3.保证作业的执行<br>4.对一些专用资源的使用特性的考虑</p>
<p>平均周转时间和带权平均周转时间<br><img src="/2020/01/04/处理机的调度/image-20200104225107056.png" alt="image-20200104225107056"></p>
<h3 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a>作业调度算法</h3><ul>
<li><p>先来先服务调度算法（FCFS）</p>
<ul>
<li>先来先服务算法是按作业来到的先后次序进行调度的，换句话说，调度程序每次选择的作业是等待时间最久的，而不管作业的运行时间的长短。这种调度算法突出的优点是实现简单，效率较低，在一些实际的系统和一般应用程序中采用这种算法的较多。</li>
</ul>
</li>
<li>短作业优先调度算法（SJF）<ul>
<li>短作业优先调度算法考虑作业的运行时间，每次总是选择一个运行时间最小的作业调入内存（系统） </li>
<li>在一般情况下这种调度算法比先来先服务调度算法的效率要高一些。实现相对先来先服务调度算法要困难些，如果作业的到来顺序及运行时间不合适，会出现饿死现象。</li>
</ul>
</li>
<li>响应比高者优先调度算法<ul>
<li>先来先服务和短作业优先算法都有其片面性，先来先服务调度算法只考虑作业的等待时间，而忽视了作业的运行时间，短作业优先算法则相反，只考虑了作业的运行时间，而忽视了作业的等待时间。响应比高者优先调度算法是介于这两种算法之间的一种拆衷的算法。<br><img src="/2020/01/04/处理机的调度/image-20200104225428235.png" alt="image-20200104225428235"></li>
<li>响应比高者优先调度算法从理论上讲是比较完备的，但需要作业调度程序：<ul>
<li>统计作业的等待时间</li>
<li>使用用户估计的运行时间</li>
<li>作浮点运算（这是系统程序最忌讳的）</li>
<li>复杂，开销大</li>
</ul>
</li>
</ul>
</li>
<li>优先数调度算法（Priority Scheduling）<ul>
<li>优先数调度算法是终合考虑各方面的因素（作业等待时间、运行时间、缓急程度，系统资源使用等），给每个作业设置一个优先数，调度程序总是选择一个优先数最大（或者最小）的作业调入（系统）内存。</li>
<li>这种算法的关键：<ul>
<li>如何终合考虑多种因素及其关系确定优先数</li>
<li>优先数是否动态变化</li>
<li>优先数什么时候变化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="进程-线程调度"><a href="#进程-线程调度" class="headerlink" title="进程/线程调度"></a>进程/线程调度</h2><h3 id="进程调度-分派"><a href="#进程调度-分派" class="headerlink" title="进程调度/分派"></a>进程调度/分派</h3><p>处理机分配由调度和分派两个功能组成：</p>
<ul>
<li>调度：依照确定的策略将一批进程排序，排在首位的进程一定是满足调度原则，可被选择的进程；组织和维护就绪进程队列。包括确定调度算法、按调度算法组织和维护就绪进程队列。</li>
<li>分派：是指当处理机空闲时，从就绪队列队首中移一个PCB，并将该进程投入运行。  </li>
</ul>
<p>调度与进程控制和进程通信的功能有密切的联系，当一个进程阻塞时，这种进程将进入相应的等待队列中，并让出CPU，调用进程分派程序选择一个就绪进程占用CPU；当一进程被唤醒时，这种进程将插入到就绪进程队列中。<br>在一般的操作系统教材中把上述功能称为进程调度。</p>
<p>功能：</p>
<ul>
<li>记录和保持系统中所有进程的有关情况和状态特征<br>进程调度的信息记录在PCB中，包括进程的状态、调度优先级（优先数）、就绪进程队列等。</li>
<li>决定分配（处理机）策略<ul>
<li>先来先服务</li>
<li>优先数调度策略</li>
<li>调度策略的不同，组织就绪进程队列的方式不同</li>
</ul>
</li>
<li>实施处理机的分配和回收<ul>
<li>调度算法的选择（调度算法）<ul>
<li>先来先服务算法（FCFS）</li>
<li>短进程优先算法（SPF）</li>
<li>高响应比优先调度算法（HRRN）</li>
<li><strong>优先级调度算法（PSA）</strong></li>
<li><strong>基于时间片的轮转调度算法（RR）</strong></li>
</ul>
</li>
<li>调度时机的选择（调度时机）<br>和调度方式相关</li>
<li>实施进程调度（调度程序）</li>
</ul>
</li>
</ul>
<p>进程调度方式<br>若一个进程正在处理机上运行，若有一个更为紧迫的进程来到，系统的处理方式有：<br>(1) 非剥夺方式(不可抢先，non-preemptive)：进程已执行，若一个更为紧迫的进程来到，必须该进程执行完或时间片到，才让更紧迫的进程执行。<br>(2) 可剥夺方式(可抢先，preemptive)：有更紧迫的进程到来，中止当前进程的执行，立即让更紧迫的进程执行。</p>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><h4 id="进程优先数调度算法"><a href="#进程优先数调度算法" class="headerlink" title="进程优先数调度算法"></a>进程优先数调度算法</h4><ul>
<li>优先数调度算法赋予每个进程一个优先数，在处理机空闲时，进程调度程序就从就绪进程中选择一个优先数最大（或者最小）的进程占用CPU。</li>
<li>如何确定进程的优先数？</li>
<li>优先数是固定的，还是随着该进程运行的情况的变化而变化？</li>
</ul>
<p>进程优先数调度算法优先数的确定</p>
<ul>
<li>静态优先数<ul>
<li>进程的优先数在进程创建时确定后就不再变化。</li>
<li>系统确定（运行时间、使用资源，进程的类型）</li>
<li>用户确定（紧迫程度，计费有关）</li>
<li>系统与用户结合</li>
<li>缺点：很多计算优先数所依赖的特征都将随进程的推进改变，静态优先数并非自始至终都能准确地反映出这些特性。</li>
</ul>
</li>
<li>动态进程优先数<ul>
<li>系统在运行的过程中，根据系统的设计目标，不断地调整进程的优先数，这种方法的优点是能比较客观地反映进程的实际情况和保证达到系统设计目标。</li>
</ul>
</li>
</ul>
<h4 id="循环轮转调度算法（Round-Robin）"><a href="#循环轮转调度算法（Round-Robin）" class="headerlink" title="循环轮转调度算法（Round Robin）"></a>循环轮转调度算法（Round Robin）</h4><ul>
<li>把系统的响应时间分成若干时间片（ Time Quantum or Time Slice）</li>
<li>进程被调度到后，占用一个时间片</li>
<li>多个进程循环轮转占用CPU</li>
</ul>
<p>时间片长度的选择</p>
<ul>
<li>轮转法的性能取决于时间片（记为q,q = t / n ,t 为用户能接收的响应时间，n为进入系统的进程数）长度的选择，进程间在CPU上的切换需要时间。</li>
<li>q足够大到每一进程执行完，FCFS (先到先服务)</li>
<li>q 适当 ––– 进程均匀执行</li>
<li>q 太小 ––– 开销太大，有切换时间，CPU利用率低。</li>
<li>通常来说，选择时间片为10~100毫秒左右比较适宜，上下文切换时间少于10微秒。</li>
</ul>
<p>与时间片大小有关的因素</p>
<ul>
<li>系统响应时间(进程等待时间)</li>
<li>就绪进程个数（就绪队列长度）</li>
<li>轮换时间 (切换时间) </li>
</ul>
<p>简单循环轮转虽然比较简单，但由于采用固定时间片和仅有一个就绪队列，可对其进行改性：</p>
<ul>
<li>将固定时间片改为可变时间片</li>
<li>将单就绪队列改为多就绪队列</li>
</ul>
<h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><p>设有N个队列（Q1,Q2….QN），其中各个队列对于处理机的优先级是不一样的，也就是说位于各个队列中的作业(进程)的优先级也是不一样的。一般来说，优先级Priority(Q1) &gt; Priority(Q2) &gt; … &gt; Priority(QN)。怎么讲，位于Q1中的任何一个作业(进程)都要比Q2中的任何一个作业(进程)相对于CPU的优先级要高（也就是说，Q1中的作业一定要比Q2中的作业先被处理机调度），依次类推其它的队列。</p>
<p>对于优先级最低的队列来说，里面是遵循时间片轮转法。也就是说，位于队列QN中有M个作业，它们的运行时间是通过QN这个队列所设定的时间片来确定的；对于其他队列，遵循的是先来先服务算法，每一进程分配一定的时间片，若时间片运行完时进程未结束，则进入下一优先级队列的末尾。</p>
<p>各个队列的时间片是一样的吗？不一样，这就是该算法设计的精妙之处。各个队列的时间片是随着优先级的增加而减少的，也就是说，优先级越高的队列中它的时间片就越短。同时，为了便于那些超大作业的完成，最后一个队列QN(优先级最低的队列)的时间片一般很大(不需要考虑这个问题)。</p>
<p>算法描述：<br>1、进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。<br>2、首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。例如：Q1,Q2,Q3三个队列，当且仅当在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3。<br>3、对于同一个队列中的各个进程，按照FCFS分配时间片调度。比如Q1队列的时间片为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列，直至完成。<br>4、在最后一个队列QN中的各个进程，按照时间片轮转分配时间片调度。<br>5、在低优先级的队列中的进程在运行时，又有新到达的作业，此时须立即把正在运行的进程放回当前队列的队尾，然后把处理机分给高优先级进程。换而言之，任何时刻，只有当第1~i-1队列全部为空时，才会去执行第i队列的进程（抢占式）。特别说明，当再度运行到当前队列的该进程时，仅分配上次还未完成的时间片，不再分配该队列对应的完整时间片。</p>
<p><img src="/2020/01/04/处理机的调度/500fd9f9d72a6059d09c84e42334349b023bba44@wm_1,g_7,k_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5.jfif" alt="img"></p>
<h2 id="UNIX系统进程调度"><a href="#UNIX系统进程调度" class="headerlink" title="UNIX系统进程调度"></a>UNIX系统进程调度</h2><p>优先数的确定</p>
<ul>
<li>系统设置<br>在sleep（）中设置将要进入睡眠状态进程的优先数，如果是等待较紧迫的事件，优先数设置较小，一般为负数，当该进程被唤醒后，就以系统给它设置的优先数去参与处理机的竟争。例如0＃进程（－100优先数）；<br> +所有处于用户态运行进程同步（一般情况下为大于0）。</li>
<li>优先数的计算<br>p_pri = min{127, (p_cpu/16+p_nice+PUSER)}<br>其中：<br>p_cpu:  进程占用CPU的程度<br>p_nice: 用户通过系统调用nice(priority)设置的进程优先数<br>PUSER: 常数，其值为100</li>
</ul>
<h2 id="Linux系统的进程调度"><a href="#Linux系统的进程调度" class="headerlink" title="Linux系统的进程调度"></a>Linux系统的进程调度</h2><h3 id="Linux进程调度目标和特点"><a href="#Linux进程调度目标和特点" class="headerlink" title="Linux进程调度目标和特点"></a>Linux进程调度目标和特点</h3><ul>
<li>进程调度程序是内核的组成部分，负责选择下一个要运行的进程。</li>
<li>进程调度可看作在可运行态进程之间分配有限的处理器间资源的内核子系统。</li>
<li>进程调度程序是如Linux这样的多任务操作系统的基础。</li>
<li>Linux进程调度策略<ul>
<li>基于动态优先级和可变时间片的调度</li>
<li>调度方式为可抢占式调度</li>
</ul>
</li>
</ul>
<p>调度目标</p>
<ul>
<li>实现算法复杂度为O(1)级的调度<ul>
<li>进程调度算法保证在恒定的时间内完成</li>
<li>算法执行时间与系统中处于就绪(可运行)状态的进程个数无关</li>
</ul>
</li>
<li>提高交互性能<ul>
<li>提高交互性能，保证系统能快速响应</li>
</ul>
</li>
<li>保证公平<ul>
<li>在合理设定的时间范围内，没有进程会出现饥饿状态，</li>
<li>也不会有进程获得大量的时间片 </li>
</ul>
</li>
<li>实现对称多处理器（SMP）可扩展性</li>
</ul>
<p>I/O消耗型和处理器消耗型的进程</p>
<ul>
<li>I/O消耗型进程<br>   大部分时间是使用外部设备，交互式进程具有此特征</li>
<li>处理器消耗型进程<br>   大部分时间是使用CPU，计算进程具有此特征</li>
</ul>
<p>交互式的程序都是I/O消耗型的。<br>Linux为了保证交互式应用，优化了进程的响应，更倾向于优先调度I/O消耗型进程，但并未忽略处理器消耗型程序。</p>
<p>进程调度的特点</p>
<ul>
<li>Linux系统实现了基于进程过去行为的启发式算法；</li>
<li>Linux系统选择优先级高的进程先运行，相同优先级的进程按循环方式调度；</li>
<li>动态优先级依进程占有CPU的情况、休眠时间的长短来增、减 ；</li>
<li>系统根据进程优先级调整分配给它的时间片； </li>
<li>实施可抢占调度方式 </li>
</ul>
<p>动态优先级</p>
<ul>
<li>基于优先级的调度<br>优先级高的进程先运行，低的后运行，相同优先级的进程按轮转方式进行调度。</li>
<li>静态优先级<ul>
<li>静态优先级在进程创建时确定，新创建的进程继承父进程的静态优先级;</li>
<li>静态优先级的取值范围是100(最高优先级)  139(最低优先级)，取值越小，优先级越高;</li>
<li>用户可以通过系统调用改变nice值，从而改变自己拥有的静态优先级。</li>
</ul>
</li>
<li>动态优先级<ul>
<li>每个进程有一个动态优先级，它是进程调度程序选择可运行进程所使用的参数，<br>其取值范围是100(最高优先级) ~ 139(最低优先级) </li>
<li>动态优先级的计算<br> 动态优先级 = max(100，min(静态优先级－ bonus + 5，139))<br> bonus是范围 0 ～ 10的值，<pre><code>          值小于5表示降低动态优先级以示惩罚
          值大于5表示增加动态优先级以示奖励
</code></pre>进程调度使用的是动态优先级，通过effective_prio( )函    数来计算一个进程的动态优先级。</li>
</ul>
</li>
</ul>
<p>确定I/O消耗型和处理器消耗型进程的方法</p>
<ul>
<li>依据 —— 进程睡眠时间的长短<br>   若进程睡眠时间长 —— I/O消耗型<br>   若进程睡眠时间短 ——处理器消耗型</li>
<li>方法<br>   Linux记录进程睡眠和执行时间 (存放在task_struct的sleep_avg域中)，范围：0 ～ MAX_SLEEP_AVG，默认值为10ms<ul>
<li>当进程从开始休眠到要恢复执行这一时间内，sleep_avg增加，直到达到MAX_SLEEP_AVG为止；</li>
<li>进程每执行一个时钟节拍， sleep_avg递减，直到0为止</li>
</ul>
</li>
</ul>
<p>进程休眠时间与bonus值的关系</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>平均休眠时间</th>
<th>bonus值</th>
</tr>
</thead>
<tbody>
<tr>
<td>大于或等于0，  小于 100ms</td>
<td>0</td>
</tr>
<tr>
<td>大于或等于100，小于 200ms</td>
<td>1</td>
</tr>
<tr>
<td>大于或等于200，小于 300ms</td>
<td>2</td>
</tr>
<tr>
<td>大于或等于300，小于 400ms</td>
<td>3</td>
</tr>
<tr>
<td>大于或等于400，小于 500ms</td>
<td>4</td>
</tr>
<tr>
<td>大于或等于600，小于 700ms</td>
<td>6</td>
</tr>
<tr>
<td>大于或等于700，小于 800ms</td>
<td>7</td>
</tr>
<tr>
<td>大于或等于800，小于 900ms</td>
<td>8</td>
</tr>
<tr>
<td>大于或等于900，小于 1000ms</td>
<td>9</td>
</tr>
<tr>
<td>大于1s</td>
<td>10</td>
</tr>
</tbody>
</table>
</div>
<p>可变时间片<br>Linux系统的目标</p>
<ul>
<li>对交互式进程,系统提供较长的时间片</li>
<li>调度程序根据进程的优先级动态调整分配给它的时间片</li>
</ul>
<p>时间片处理的时机</p>
<ul>
<li>创建新进程时的处理<ul>
<li>新创建的子进程和父进程均分父进程剩余的时间片 </li>
</ul>
</li>
<li>进程用完时间片时的处理<ul>
<li>当一个进程的时间片用完时，依任务的静态优先级重新计算时间片；</li>
<li>task_timeslice()函数为给定任务返回一个新的时间片</li>
</ul>
</li>
</ul>
<p>时间片的使用</p>
<ul>
<li>一个进程拥有的时间片可分多次使用，放弃CPU时进入活动队列</li>
<li>当一个进程的时间片耗尽时，认为是过期进程，进入过期队列</li>
</ul>
<p>时间片的计算</p>
<ul>
<li>基本时间片<pre><code>静态优先级本质上决定了进程的基本时间片
 (140 －静态优先级) ×20    若静态优先级 ＜ 120
 (140 －静态优先级) ×5      若静态优先级 ≥ 120
静态优先级越高(值越小)，基本时间片越长。
</code></pre></li>
</ul>
<p>活动队列和过期队列<br>每个处理器维护两个优先级数组—— 活动数组和过期数组</p>
<ul>
<li>活动数组上的可执行队列中的进程都有剩余时间片</li>
<li>过期数组上的可执行队列中的进程都已耗尽时间片<br>   当一个进程的时间片耗尽时，被移至过期队列中；<br>   当活动数组上的可执行队列中的所有进程都已耗尽时时间片，这时，在活动数组和过期数组之间切换指针。</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>资源分配与调度</title>
    <url>/2020/01/04/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%B8%8E%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="资源管理概述"><a href="#资源管理概述" class="headerlink" title="资源管理概述"></a>资源管理概述</h2><p>资源 ：应用程序执行时所需要的全部硬件、软件和数据。 </p>
<p>为什么要对资源进行管理？ </p>
<ul>
<li>管理好各种资源是计算机系统的重要职责。 <a id="more"></a></li>
<li>随着软硬件的发展，操作系统要管理的软硬件资源和种类越来越多； </li>
<li>用户的需求和应用量也在不断增长。</li>
</ul>
<p>资源管理的目标</p>
<ul>
<li>保证资源的高利用率。 </li>
<li>在“合理”时间内使所有顾客有获得所需资源的机会。 </li>
<li>对不可共享的资源实施互斥使用。</li>
<li>防止由资源分配不当而引起的死锁。</li>
<li>这些目标之间需要<strong>平衡</strong>！</li>
</ul>
<p>资源管理的任务</p>
<ul>
<li>资源数据结构的描述<br>应包含该类资源最小分配单位的描述信息，如资源的物理名、逻辑名、类型、地址、分配状态等信息。 </li>
<li>确定资源的分配原则 (调度原则)<br>决定资源应分给谁，何时分配，分配多少等问题。</li>
<li>实施资源分配<br>执行资源分配；资源收回工作。 </li>
<li>存取控制和安全保护<br>对资源的存取进行控制并对资源实施安全保护措施。</li>
</ul>
<p>资源资源的静态分配和动态分配</p>
<ul>
<li>资源的静态分配<br>系统对作业一级采用资源静态分配方法。系统在调度作业时，根据作业所需资源进行分配；并在作业运行完毕 时，收回所分配的全部资源。这种分配通常称为资源的静态分配。 </li>
<li>资源的动态分配<br>系统对进程一级采用资源动态分配方法。 系统在进程运行中，根据进程提出的资源需求，进行资源的动态分配和回收。这种分配通常称为资源的动态分配。</li>
</ul>
<p>虚拟资源<br>操作系统对资源区分二种不同的概念</p>
<ul>
<li>物理资源 (实资源)</li>
<li>虚拟资源 (逻辑资源) ：用户使用的逻辑资源，这是经过操作系统改造的、使用方便的虚资源，而不是物理的、 实际的资源。</li>
</ul>
<p>目的</p>
<ul>
<li>方便用户使用</li>
<li>资源可动态分配，提高资源利用率</li>
</ul>
<p>计算机系统中的物理资源与虚拟资源分析</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>资源表格</th>
<th>物理资源</th>
<th>虚拟(逻辑)</th>
<th>映射</th>
</tr>
</thead>
<tbody>
<tr>
<td>处理机</td>
<td>CPU</td>
<td>进程</td>
<td>进程调度</td>
</tr>
<tr>
<td>存储器</td>
<td>主存</td>
<td>虚存（程序地址空间）</td>
<td>地址映射</td>
</tr>
<tr>
<td>设备</td>
<td>外部设备</td>
<td>逻辑设备、虚拟设备</td>
<td>设备分配、动态映射</td>
</tr>
<tr>
<td>信息</td>
<td>文件物理结构</td>
<td>文件逻辑结构</td>
<td>磁盘空间分配、文件目录查找</td>
</tr>
</tbody>
</table>
</div>
<h2 id="资源分配结构和策略"><a href="#资源分配结构和策略" class="headerlink" title="资源分配结构和策略"></a>资源分配结构和策略</h2><p>资源管理的实质</p>
<ul>
<li>资源管理的实质是<strong>资源管理的机制</strong>和<strong>资源管理的策略</strong>。</li>
<li>机制：进行资源分配所必须的基本设施和部件，包括描述资源状态的数据结构、保证不可共享资源互斥使用的同步机构以及对不能立即得到满足的资源请求进行排队的各种资源队列的结构。</li>
<li>策略：给出了实现该功能的内涵，设计资源分配的原则。</li>
</ul>
<h3 id="资源分配的机构"><a href="#资源分配的机构" class="headerlink" title="资源分配的机构"></a>资源分配的机构</h3><h4 id="资源描述器"><a href="#资源描述器" class="headerlink" title="资源描述器"></a>资源描述器</h4><p>资源描述器 定义：描述描述各类资源的最小分配单位的数 据结构称为资源描述器 rd（resource descriptor）。 如：主存分区分配方法中， 最小分配单位为主存分区。</p>
<p>资源描述器内容 ：资源名、资源类型、最小分配单位的大 小、地址、分配标志、描述器链接信息、 存取权限、密级、存取时间。</p>
<ul>
<li>若它具有N个资源分配器，则有N个资源描述器。这些描述器的组织是个重要问题。</li>
<li>描述器的组织方式取决于资源分配单位的数量和数量是否可变这一特征。<ul>
<li>如果数量不可变，使用表结构。</li>
<li>如果数量可变，使用队列结构。</li>
<li>如果数目变化范围可知且不大，使用数组。</li>
</ul>
</li>
</ul>
<h4 id="资源信息块（rib-resource-information-block）"><a href="#资源信息块（rib-resource-information-block）" class="headerlink" title="资源信息块（rib, resource information block）"></a>资源信息块（rib, resource information block）</h4><p>资源信息块定义：描述某类资源的请求者、可用资源和该类资源分配程序等必要信息的数据结构。</p>
<p>资源信息块内容<img src="/2020/01/04/资源分配与调度/image-20200104211547478.png" alt="image-20200104211547478"></p>
<p>资源信息块示例：<img src="/2020/01/04/资源分配与调度/image-20200104211709887.png" alt="image-20200104211709887"></p>
<h3 id="资源分配策略"><a href="#资源分配策略" class="headerlink" title="资源分配策略"></a>资源分配策略</h3><ul>
<li>对某类资源而言，在多个资源有多个请求者申请的情况下，资源分配的策略包括<strong>选择请求者的策略</strong>和<strong>选择资源的策略</strong>两种。</li>
<li>选择请求者的策略：即资源分配策略，即在众多请求者中选一个满足条件的请求者的原则。</li>
<li>选择资源的策略：是在同等资源间选择一个满足条件的资源的原则。</li>
<li>具体实现：体现在队列的排队原则上。</li>
</ul>
<p>资源分配的时机</p>
<ul>
<li>请求者发出一个明确的资源请求命令时；</li>
<li>当处理机空闲时；</li>
<li>当一个存储区被释放变为空闲时；</li>
<li>当一个外存设备发生完成中断时。</li>
</ul>
<p>常用的资源分配策略</p>
<ul>
<li>先请求先服务<ul>
<li>每一个新产生的请求均排在队尾； </li>
<li>当资源可用时，取队首元素，并满足其需要。 排序原则：按请求的先后次序排序。（有饿死现象！）<br><img src="/2020/01/04/资源分配与调度/image-20200104212028817.png" alt="image-20200104212028817"></li>
</ul>
</li>
<li>优先调度<ul>
<li>对每一个进程指定一个优先级，优先级反映了进程要求处理的紧迫程度；</li>
<li>每一个新产生的请求，按其优先级的高低插到相应的位置；</li>
<li>当资源可用时，取队首元素，并满足其需要。<br>排序原则：按优先级的高低排序。</li>
</ul>
</li>
<li>针对设备特性的调度策略<ul>
<li>移臂调度 ：总是选取与当前移动臂前进方向上最近的那个I/O请求，<br>使移臂距离最短。</li>
<li>旋转调度 ：总是选取与当前读写头最近的那个I/O请求，使旋转圈 数最少。</li>
</ul>
</li>
</ul>
<p>几种移臂调度算法</p>
<ul>
<li>最短寻道时间优先算法（SSTF） <ul>
<li>从等待访问者中挑选寻找时间最短的那个请求先执行 </li>
<li>缺点：可能会引起读写头在盘面上的大范围移 动，可能会推迟请求的服务导致无限拖延 </li>
</ul>
</li>
<li>扫描算法（SCAN，即电梯调度算法） <ul>
<li>磁头前进方向上的最短查找时间优先算法 </li>
<li>很大程度上消除了SSTF的不公平性</li>
<li>不仅要己组读写磁头的位置，还必须记住移动臂的当前前进方向</li>
<li>当磁头刚从里向外移动过某一磁道时，恰有一进程访问此磁道，必须等待。</li>
</ul>
</li>
<li>循环扫描算法(CSCAN)<ul>
<li>规定磁头单向移动，如果只是从里向外移动，当磁头移到最外的磁道并访问时，磁头立即返回到最里的欲访问磁道，即将最小磁道号紧接着最大磁道号循环，进行循环扫描。</li>
</ul>
</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁及起因"><a href="#死锁及起因" class="headerlink" title="死锁及起因"></a>死锁及起因</h3><p>什么是死锁<br>在两个或多个并发进程中，如果每个进程持有某种资源而又都等待着别的进程释放它或它们现在保持着的资源，否 则就不能向前推进。此时，称这一组进程产生了死锁。</p>
<p>引起死锁的原因</p>
<ul>
<li>系统资源不足</li>
<li>进程推进顺序非法</li>
</ul>
<p>产生死锁的必要条件</p>
<ul>
<li>互斥条件<br>涉及的资源是非共享的，即为临界资源。</li>
<li>不剥夺条件<br>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走。</li>
<li>部分分配<br>进程每次申请它所需要的一部分资源。在等待一新资源的 同时，进程继续占用已分配到的资源。 </li>
<li><p>环路条件<br>存在一种进程的循环链，链中的每一个进程已获得的资 源同时被链中下一个进程所请求。 </p>
<p><img src="/2020/01/04/资源分配与调度/20180317174724920.png" alt="img"><br>利用资源分配图可判断死锁。<br>若图没有环，系统没有发生死锁；如果图有环，可能存在死锁。如果环涉及一组资源类型，而每个资源类型只有一个实例，呢么有环就意味着出现死锁，即环所涉及的进程发生了死锁。在这种情况下，环就是死锁存在的充分必要条件。</p>
</li>
</ul>
<p>解决死锁问题的策略——破坏产生死锁的四个必要条件之一</p>
<ul>
<li>采用静态资源分配方法——预防死锁。</li>
<li>采用有控资源分配方法——避免死锁</li>
<li>死锁的检测与忽略</li>
</ul>
<h3 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h3><ul>
<li>破坏互斥条件<ul>
<li>就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。但一般“互斥”条件是无法破坏的。因此，在死锁预防里主要是破坏其他三个必要条件，而不去涉及破坏“互斥”条件。</li>
</ul>
</li>
<li>破坏请求并保持条件<ul>
<li>在系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源。有两种方法：</li>
<li>方法一：所有进程在运行之前，必须一次性地申请在整个运行过程中所需的全部资源。这样，该进程在整个运行期间，便不会再提出资源请求，从而破坏了“请求”条件。系统在分配资源时，只要有一种资源不能满足进程的要求，即使其它所需的各资源都空闲也不分配给该进程，而让该进程等待。由于该进程在等待期间未占有任何资源，于是破坏了“保持”条件。</li>
<li>该方法优点：简单、易行且安全。</li>
<li>缺点：<br>a.资源被严重浪费，严重恶化了资源的利用率。<br>b.使进程经常会发生饥饿现象。</li>
<li>方法二：要求每个进程提出新的资源申请前，释放它所占有的资源，然后再尝试一次获得所需的全部资源。</li>
</ul>
</li>
<li>破环不可抢占条件<ul>
<li>允许对资源实行抢占。</li>
<li>方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。</li>
<li>方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，该方法才能预防死锁。</li>
</ul>
</li>
<li><p>破坏环路等待条件</p>
<ul>
<li>保证每一个进程在任何时刻只能占用一个资源，若要请求另外一个资源，它必须先释放第一个资源。</li>
<li>将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。</li>
</ul>
</li>
<li><p>静态预防死锁的方法</p>
<ul>
<li>在作业调度时为选中的作业分配它所需要的所有资源，当资源一旦分配给该作业后，在其整个运行期间这些资源为它独占。</li>
<li>一个用户在作业运行之前可能提不出其作业将要使用的全部设备</li>
<li>用户作业的所有资源满足后才投入运行，实际上某些资源可能要到运行后期才会用到</li>
<li>一个作业运行期间，某些设备的使用时间很少，甚至不会用到。 </li>
</ul>
</li>
<li>动态避免死锁的方法<ul>
<li>有序资源分配法<br>系统中所有资源都给定一个唯一的编号，所有分配请求必须以上升的次序进行。当遵守上升次序的规则时，若资源可用，则予以分配；否则，请求者等待。（缺点：资源浪费！当有资源序列1234，实际访问序列为4321时，需要先请求1，在2，在3、4，但是123是较长时间后运行的，造成了资源的浪费。）</li>
<li>银行家算法<br>申请者事先说明对各类资源的最大需求量。在进程活动期间动态申请某类资源时，由系统审查现有该类资源的数目是否能满足当前进程的最大需求量，如能满足就予以分配，否则拒绝（缺点：要求每个进程必须事先说明对各类资源的最大需求，而且在系统运行过程中，考察每个进程对各类资源的申请需要花费较多的时间。此外，由于银行家算法总是考虑最坏情况，有时为了避免死锁，可能拒绝某一请求，实际上，即使该请求得到满足也不会出现死锁。<strong>过于谨慎</strong>以及<strong>开销较大</strong>是银行家算法的主要障碍）</li>
</ul>
</li>
</ul>
<h3 id="死锁的检测和恢复"><a href="#死锁的检测和恢复" class="headerlink" title="死锁的检测和恢复"></a>死锁的检测和恢复</h3><h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><p>首先针对每种资源类型只有一个实例的情况。</p>
<p>构建资源分配图，采用深度优先遍历算法确定是否存在环路：依次将每一个节点作为一棵树的根节点，并进行深度优先搜索，如果再次碰到已经遇到过的节点，那么就算找到了一个环。如果从任何给定的节点出发的弧都被穷举了，那么就回溯到前面的节点。如果回溯到根并且不能再深入下去，那么从当前节点出发的子图中就不包含任何环。如果所有的节点都是如此，那么整个图就不存在环也就是说系统不存在死锁。</p>
<p>第二种情况是每种资源类型还有多个实例的情况。</p>
<p>构建向量矩阵，利用向量矩阵算法模拟资源分配。这种算法的第一步是寻找可以运行完毕的进程Pi，该进程的特点是它有资源请求并且该请求可被当前的可用资源满足(R矩阵第i行向量小于A)。这一选中的进程随后就被运行完毕，在这段时间内它释放自己持有的所有资源并将它们返回到可用资源库中（将C矩阵的第i行向量加到A）。然后这一进程被标记为完成。如果所有的进程最终都能运行完毕的话，就不存在死锁的情况。</p>
<p>假设n个进程，m种资源：</p>
<p>E=（E1,E2,…,Em）现有资源向量，</p>
<p>A=（A1,A2,…,Am）可用资源向量，</p>
<p>Cn*m当前分配矩阵，Rn*m请求矩阵，C(ij)表示进程i所持有的资源j的数量，R(ij)表示进程i所需要的资源j的数量。</p>
<p>Ej=Aj+C11+C21+……+Cn1</p>
<p>死锁检测：算法复杂，开销很大<br>忽略则后患无穷</p>
<h4 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h4><p>抢占：不通知原进程的情况下，将某一资源从一个进程强行取走给另一个进程使用，接着送回。</p>
<p>回滚：周期性对进程进行检查点检查，即将进程的状态写入一个文件以备以后重启，包括存储映象、资源状态，即哪些资源分配给了哪些进程。新的检查点不覆盖原有的文件，而是写到新文件中。检测到死锁时，从一个较早的检查点开始，将该进程复位到更早的状态。</p>
<p>杀死进程：杀死环中的一个或多个进程；杀死一个环外的进程以释放该进程的资源。（最好杀死可以从头开始重新运行且不会带来副作用的进程）</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>进程及进程管理</title>
    <url>/2020/01/04/%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="进程引入"><a href="#进程引入" class="headerlink" title="进程引入"></a>进程引入</h2><h3 id="顺序程序及特点"><a href="#顺序程序及特点" class="headerlink" title="顺序程序及特点"></a>顺序程序及特点</h3><ul>
<li>计算：程序的一次执行过程称为一个计算，它由许多简单操作所组成。</li>
<li>程序的顺序执行：一个计算的若干操作必须按照严格的先后次序顺序地执行，这类计算过程就是程序的顺序执行过程。<a id="more"></a></li>
</ul>
<p>单道系统的工作情况：对用户作业的处理 —— 首先输入用户的程序和数据；然后进行计算；最后打印计 算结果，即有三个顺序执行的操作。 I：输入操作 C：计算操作 P：输出操作</p>
<p>特点：</p>
<ul>
<li>顺序性 —— 处理机的操作严格按照程序所规定的 顺序执行。</li>
<li>封闭性 —— 程序一旦开始执行，其计算结果不受 外界因素的影响。</li>
<li>可再现性 —— 程序执行的结果与它的执行速度无 关 (即与时间无关)，而只与初始条件有关。</li>
</ul>
<h3 id="并发程序"><a href="#并发程序" class="headerlink" title="并发程序"></a>并发程序</h3><p>若干个程序段同时在系统中运行，这些程序段的执行在时间上是重叠的，一个程序段的执行尚未结束，另一个程序段的执行已经开始，即使这种重叠是很小的一部分，也称这几个程序段是并发执行的。</p>
<p>特点：</p>
<ul>
<li>失去程序的封闭性和可再现性<br> 若一个程序的执行可以改变另一个程序的变量，那么，后 者的输出就可能有赖于各程序执行的相对速度，即失去了 程序的封闭性特点。 </li>
<li>程序与计算不再一一对应<br>一个程序可以对应多个计算。</li>
<li>程序并发执行的相互制约<ul>
<li>间接的相互制约关系 —— 资源共享</li>
<li>直接的相互制约关系 —— 公共变量</li>
</ul>
</li>
</ul>
<h3 id="与时间有关的错误"><a href="#与时间有关的错误" class="headerlink" title="与时间有关的错误"></a>与时间有关的错误</h3><p>程序并发执行时，若共享了公共变量，其执行结果与各并发程序的相对速度有关，即给定相同的初始条件，若不加以控制，也可能得到不同的结果，此为与时间有关的错误。<br>为了保证得到唯一的正确结果，需要实现并发程序执行时的<strong>互斥和同步</strong>。</p>
<h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><h3 id="进程定义"><a href="#进程定义" class="headerlink" title="进程定义"></a>进程定义</h3><p>什么是进程？<br>所谓进程，就是一个程序在给定活动空间和初始环境下， 在一个处理机上的执行过程。</p>
<p>进程与程序的区别</p>
<ul>
<li>程序是指令的有序计合，是一个静态的概念，进程是程序在处理及上的一次执行过程，是动态的概念；</li>
<li>进程是一个独立运行的活动单位，能与其他进程并行的活动；</li>
<li>进程是竞争计算机系统资源的基本单位，也是进行处理机调度的基本单位；</li>
<li>一个程序可以对应多个进程，一个进程至少包含一个程序。</li>
</ul>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程的基本状态 </p>
<ul>
<li>运行状态(running) 该进程已获得运行所必需的资源，它的程序正在处理机上 执行。</li>
<li>等待状态(wait) 进程正等待着某一事件的发生而暂时停止执行。这时， 即使给它CPU控制权，它也无法执行。 </li>
<li>就绪状态(ready) 进程已获得除CPU之外的运行所必需的资源，一旦得到 CPU控制权，立即可以运行。</li>
</ul>
<p><img src="/2020/01/04/进程及进程管理/image-20200104193543416.png" alt="image-20200104193543416"></p>
<h3 id="进程描述"><a href="#进程描述" class="headerlink" title="进程描述"></a>进程描述</h3><p>什么是进程控制块<br>描述进程与其他进程、系统资源的关系以及进程在各个不同时期所处的状态的数据结构，称为进程控制块 PCB (process control block)。 </p>
<p>进程的组成</p>
<ul>
<li>程序与数据<br> 描述进程本身所应完成的功能</li>
<li><p>PCB<br> 进程的动态特征，该进程与其他进 程和系统资源的关系。</p>
<p> <img src="/2020/01/04/进程及进程管理/image-20200104193922671.png" alt="image-20200104193922671"></p>
</li>
</ul>
<p>进程控制块的主要内容</p>
<ul>
<li>进程标识符 进程符号名或内部 id号 </li>
<li>进程当前状态 本进程目前处于何种状态</li>
<li>当前队列指针next 该项登记了处于同一状态的下一个进程的 PCB地址。 </li>
<li>进程优先级 反映了进程要求CPU的紧迫程度。 </li>
<li>CPU现场保护区 当进程由于某种原因释放处理机时，CPU现场信息被保存在PCB的该区域中。 </li>
<li>通信信息 进程间进行通信时所记录的有关信息。 </li>
<li>家族联系 指明本进程与家族的联系 </li>
<li>占有资源清单</li>
</ul>
<p><img src="/2020/01/04/进程及进程管理/image-20200104194258703.png" alt="image-20200104194258703"></p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制的职责 ：对系统中的进程实施有效的管理，负责进程状态的改变。<br>常用的进程控制原语：创建原语creat、撤消原语kill、阻塞原语susp、唤醒原语wakeup</p>
<h2 id="进程之间的约束关系"><a href="#进程之间的约束关系" class="headerlink" title="进程之间的约束关系"></a>进程之间的约束关系</h2><h3 id="进程竞争与合作"><a href="#进程竞争与合作" class="headerlink" title="进程竞争与合作"></a>进程竞争与合作</h3><p>进程之间的约束关系可分为两种情况：</p>
<ul>
<li>由于竞争系统资源而引起的间接相互制约关系</li>
<li>由于进程之间存在共享数据而引起的直接相互制约关系<ul>
<li>进程协作：信息共享和并行处理</li>
</ul>
</li>
</ul>
<h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h3><p>临界资源：一次仅允许一个进程使用的<strong>资源</strong>称为临界资源。 硬件：如输入机、打印机、磁带机等 软件：如公用变量、数据、表格、队列等 。</p>
<p>临界区是进程中对公共变量 (或存储区)进行审查与修改的<strong>程序段</strong>，称为相对于该公共变量的临界区。<br>注意：</p>
<ul>
<li>临界区是针对某一临界资源而言的</li>
<li>相对于某临界资源的临界区个数就是共享该临界资源的进程个数</li>
<li>相对于同一个公共变量的若干个临界区，必须是互斥地进入</li>
</ul>
<p>互斥：在操作系统中，当某一进程正在访问某一存储区域时，就 不允许其他进程来读出或者修改存储区的内容，否则，就 会发生后果无法估计的错误。进程间的这种相互制约关系 称为互斥。</p>
<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>什么是进程同步：并发进程在一些关键点上可能需要互相等待与互通消息， 这种相互制约的等待与互通消息称为进程同步。 同步意味着两个或多个进程之间根据它们一致同意的协议进行相互作用。同步的实质是使各合作进程的行为保持某种一致性或不变关系。</p>
<p>进程同步示例：</p>
<ul>
<li>病员就诊</li>
<li>共享缓冲区的计算进程与打印进程的同步</li>
</ul>
<h2 id="同步机构"><a href="#同步机构" class="headerlink" title="同步机构"></a>同步机构</h2><h3 id="锁和上锁、开锁操作"><a href="#锁和上锁、开锁操作" class="headerlink" title="锁和上锁、开锁操作"></a>锁和上锁、开锁操作</h3><p>什么是锁：用变量w代表某种资源的状态，w称为“锁” 。用<strong>1</strong>表示资源已经被<strong>占用</strong>。</p>
<p>上锁操作和开锁操作</p>
<ul>
<li>检测w的值 (是0还是1)；</li>
<li>如果w的值为1，继续检测；</li>
<li>如果w的值为0，将锁位置1 (表示占用资源)，进入临界区执行。 (此为上锁操作)</li>
<li>临界资源使用完毕，将锁位置0。 (此为开锁操作)</li>
</ul>
<h3 id="信号灯和P、V操作"><a href="#信号灯和P、V操作" class="headerlink" title="信号灯和P、V操作"></a>信号灯和P、V操作</h3><p>什么是信号灯<br>信号灯是一个确定的二元组 (s，q)，s是一个具有非负初值的整型变量，q是一个初始状态为空的队列。操作系统利用信号灯的状态对并发进程和共享资源进行控制和管理。<br><strong>信号灯是整型变量。</strong><br>变量值 ≥ 0 时，表示绿灯，进程执行； 变量值 ＜ 0 时，表示红灯，进程停止执行。<br>注意：创建信号灯时，应准确说明信号灯 s 的意义和初值<br><strong>(这个初值绝不能为负值)</strong>。</p>
<p>P 操作 定义：对信号灯s的 p操作记为 p(s)。p(s)是一个不可分割的原语操作，即取信号灯值减1，若相减结果为负，则调用p(s)的进程被阻，并插入到<br>该信号灯的等待队列中，否则可以继续执行。 </p>
<p>V 操作 定义：对信号灯s的 v操作记为 v(s)。v(s)是一个不可分割的原语操作，即取信号灯值加1，若相加结果大于零，进程继续执行，否则，要帮助唤醒在信号灯等待队列上的一个进程。 </p>
<h2 id="同步机构-1"><a href="#同步机构-1" class="headerlink" title="同步机构"></a>同步机构</h2><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p>生产者与消费者的同步关系</p>
<ul>
<li>生产者：<ul>
<li>当有界缓冲区中无空位置时，要等待； </li>
<li>向有界缓冲区放入物品后，要发消息。 </li>
</ul>
</li>
<li>消费者：<ul>
<li>当有界缓冲区中无物品时，要等待；</li>
<li>从有界缓冲区取出物品后，要发消息。</li>
</ul>
</li>
</ul>
<p>信号灯设置</p>
<ul>
<li>两个同步信号灯——<ul>
<li>sb ：表示空缓冲区的数目，初值 = n </li>
<li>sa ： 表示满缓冲区 (即信息)的数目，初值 = 0</li>
</ul>
</li>
<li>一个互斥信号灯——<ul>
<li>mutex：表示有界缓冲区是否被占用，初值 = 1</li>
</ul>
</li>
</ul>
<p>程序描述<br>程序 prod_cons<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main( )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> sa=<span class="number">0</span>； ∕/满缓冲区数目  </span><br><span class="line">   <span class="keyword">int</span> sb=n； ∕/空缓冲区数目</span><br><span class="line">   <span class="keyword">int</span>  mutex=<span class="number">1</span>； ∕/对有界缓冲区进行操作 </span><br><span class="line">   cobegin </span><br><span class="line">   p1 ( )； p2 ( )；… pm ( )； </span><br><span class="line">   c1 ( )； c2 ( )；… ck ( )； </span><br><span class="line">   coend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pi( )                                                     </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">while</span>(生产未完成)</span><br><span class="line">   &#123;</span><br><span class="line">      M</span><br><span class="line">      生产一个产品;</span><br><span class="line">      p(sb)；</span><br><span class="line">      p(mutex)； </span><br><span class="line">      送一个产品到有界缓冲区；</span><br><span class="line">      v(mutex)；</span><br><span class="line">      v(sa)；</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cj( ) </span><br><span class="line">&#123; </span><br><span class="line">   <span class="keyword">while</span>(还要继续消费)</span><br><span class="line">   &#123;</span><br><span class="line">        p(sa)； </span><br><span class="line">        p(mutex)；</span><br><span class="line">        从有界缓冲区中取产品</span><br><span class="line">        v(mutex)； </span><br><span class="line">        v(sb)； </span><br><span class="line">        消费一个产品； </span><br><span class="line">        M</span><br></pre></td></tr></table></figure></p>
<h3 id="理发师睡觉问题"><a href="#理发师睡觉问题" class="headerlink" title="理发师睡觉问题"></a>理发师睡觉问题</h3><p>理发店里有一位理发师、一把理发椅和n把供等候理发的顾客坐的椅子。如果没有顾客，则理发师便在理发椅上睡觉。当一个顾客到来时，他必须先叫醒理发师，如果理发师正在理发时又有顾客来到，则如果有空椅子可坐，他们就坐下来等。如果没有空椅子，他就离开。</p>
<ul>
<li><p>一个理发师，一把理发椅，n把等候理发的顾客椅子。 </p>
<ul>
<li>如果没有顾客，则理发师在理发椅上睡觉；</li>
<li>当有一个顾客到达时，首先看理发师在干什么， 如果理发师在睡觉，则唤醒理发师理发； 如果理发师正在理发，则查看是否有空的顾客椅子可 坐； 如果有顾客椅子可坐，则坐下等待，如果没有，则 离开。 </li>
<li>理发师为一位顾客理完发后，查看是否有人在等待， 如果有则唤醒下一位顾客理发，没有则理发师去睡觉。</li>
</ul>
</li>
<li><p>理发师和顾客之间的同步关系<br> 当理发师睡觉时，顾客进来需要唤醒理发师为其理发；<br> 当有顾客时理发师为其理发，没有的时候理发师睡觉。</p>
</li>
<li>理发师与顾客、顾客与顾客之间的互斥关系<br> 由于每次理发师只能为1个人理发，且可供等侯的椅子只有n把，即理发师和椅子是临界资源，顾客之间是互斥的关系。</li>
</ul>
<p>信号灯设置<br>引入3个信号量和一个控制变量： </p>
<ul>
<li>控制变量waiting用来记录等候理发的顾客数，初值均为0; 进入理发店的顾客必须先看等候的顾客数，如果少于椅子数， 他留下来等，否则他就离开。</li>
<li>信号量customers用来记录等候理发的顾客数，并用作阻塞理发师进程，初值为0; </li>
<li>信号量barbers用来记录正在等候顾客的理发师数，并用作 阻塞顾客进程，初值为0; </li>
<li>信号量mutex用于互斥，初值为1. </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> CHAIRS 5 <span class="comment">/*为等待的顾客准备的椅子数*/</span> </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphone ; <span class="comment">/*信号灯类型*/</span> </span><br><span class="line">semaphore customers=<span class="number">0</span>; <span class="comment">/*等待服务的顾客数*/</span> </span><br><span class="line">semaphore barbers=<span class="number">0</span>; <span class="comment">/*等待顾客的理发师数*/</span> </span><br><span class="line">semaphore mutex=<span class="number">1</span>; <span class="comment">/*用于互斥*/</span></span><br><span class="line"><span class="keyword">int</span> waiting=<span class="number">0</span>; <span class="comment">/*等待的顾客(还没理发的)，waiting是一个共享变量，对它操作时必须加锁，用mutex加以保护*/</span></span><br><span class="line"></span><br><span class="line">main() </span><br><span class="line">&#123;   </span><br><span class="line">   …… </span><br><span class="line">   cobegin </span><br><span class="line">      barber（）； </span><br><span class="line">      customers（）； </span><br><span class="line">   coend </span><br><span class="line">   …… </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">barber</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="keyword">while</span>(TRUE) <span class="comment">/*理完1人,还有顾客吗?*/</span> </span><br><span class="line">   &#123; </span><br><span class="line">      p(customers); <span class="comment">/*如果顾客数是0，则理发师睡眠*/</span> </span><br><span class="line">      p(mutex); <span class="comment">/*要求进程等待*/</span> </span><br><span class="line">         waiting=waiting<span class="number">-1</span>; <span class="comment">/*等待顾客数减1*/</span> </span><br><span class="line">      v(barbers); <span class="comment">/*一个理发师现在开始理发了*/</span> </span><br><span class="line">      v(mutex); <span class="comment">/*释放等待*/</span> </span><br><span class="line">      cut_hair(); <span class="comment">/*理发(非临界区操作)*/</span> </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customers</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">   p(mutex);<span class="comment">/*进入临界区*/</span> </span><br><span class="line">   <span class="keyword">if</span> (waiting &lt; CHAIRS) </span><br><span class="line">   &#123;<span class="comment">/*如果没有空椅子，就离开*/</span> </span><br><span class="line">      waiting = waiting + <span class="number">1</span>;<span class="comment">/*等待顾客数加1*/</span> </span><br><span class="line">      v(customers); <span class="comment">/*如果必要的话，唤醒理发师*/</span> </span><br><span class="line">      v(mutex); <span class="comment">/*释放访问等待*/</span> </span><br><span class="line">      p(barbers); <span class="comment">/*无理发师, 顾客坐着养神*/</span> </span><br><span class="line">      get_haircut();<span class="comment">/*一个顾客坐下等理发*/</span> </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      v(mutex); <span class="comment">/*店里人满了，走吧*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程通信(Interprocess Communication, IPC)是指进程之间直 接以较高的效率传递较多数据的信息交互方式。</p>
<p>IPC机制：指消息（message）从一个进程的地址空间拷贝到另一个进程 的地址空间的过程，而不使用共享存储器。</p>
<p><img src="/2020/01/04/进程及进程管理/image-20200104202215510.png" alt="image-20200104202215510"></p>
<h3 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h3><p>消息缓冲通信 </p>
<ul>
<li>在消息通信中，接收方和发送方之间有明确的协议和消息格式 。<ul>
<li>大多数使用消息头：发送/接收进程的ID、被传消息的字节数……</li>
</ul>
</li>
<li>消息缓冲通信方式包括消息缓冲、发送原语和接收原语。<ul>
<li>发送进程先形成一个消息缓冲区（含消息头和消息内容），然后用发送原语发出。</li>
<li>接收进程在接收前，在本进程的主存空间设置一个接收区，然后用接收原语接收。</li>
</ul>
</li>
</ul>
<p>信箱通信</p>
<ul>
<li>在信箱通信中，需要定义信箱结构，还包括消息发送和接收功能模块，提供发送原语和接收原语。</li>
<li>信箱通信中，所使用的信箱可以位于用户空间中，是接收进程地址空间的一部分；也可以放置在操作系统的空间中。</li>
</ul>
<p>使用用户空间中的信箱实现消息传递<br>信箱由用户管理，进程可以直接访问信息<br><img src="/2020/01/04/进程及进程管理/image-20200104202506290.png" alt="image-20200104202506290"><br>缺点：</p>
<ul>
<li>编译器和加载程序必须为每一个进程分配信箱空间 ；</li>
<li>接收进程有可能覆盖信息的部分内容，从而造成错误。</li>
</ul>
<p>使用系统空间中的信箱实现消息传递<br>信箱由OS管理，任何进程不能直接访问<br><img src="/2020/01/04/进程及进程管理/image-20200104202546621.png" alt="image-20200104202546621"><br>缺点：要求OS为所有的进程分配主存信箱，受系统限制，可 能对通信进程数限制。</p>
<h2 id="线程概念及特点"><a href="#线程概念及特点" class="headerlink" title="线程概念及特点"></a>线程概念及特点</h2><p>为什么引入线程？</p>
<ul>
<li>为了避免多处理机系统在进行远程访问期间的等待现象。</li>
<li>线程就是进程的一个执行路径，一个进程可以有多条执行路径。这样，一个进程内部就有多个可 以独立活动的单位，可以加快进程处理的速度， 进一步提升并行处理能力。</li>
</ul>
<p>线程 定义：线程是比进程更小的活动单位，它是进程中的一个执行路径。</p>
<p>线程可以这样来描述</p>
<ul>
<li>进程中的一条执行路径；</li>
<li>它有自己私用的堆栈和处理机执行环境 ；</li>
<li>它与父进程共享分配给父进程的主存；</li>
<li>它是单个进程所创建的许多个同时存在的线程中的一个。</li>
</ul>
<p>线程的特点</p>
<ul>
<li>线程是比进程更小的活动单位，它是进程中的一个执 行路径。创建一个线程比创建一个进程开销要小得多。</li>
<li>实现线程间通信十分方便，因为一个进程创建的多个 线程可以共享地址区域和数据。</li>
<li>线程是一个动态的概念。</li>
<li>在进程内创建多线程，可以提高系统的并行处理能力， 加快进程的处理速度。</li>
</ul>
<p>进程是任务调度的单位，也是系统资源的分配单位；而线程是进程中的一条执行路径，当系统支持多线程处理时，线程是任务调度的单位，但不是系统资源的分配单位。线程完全继承父进程占有的资源，当它活动时，具有自己的运行现场。</p>
<p><img src="/2020/01/04/进程及进程管理/image-20200104203133664.png" alt="image-20200104203133664"></p>
<p>用户线程和内核线程</p>
<ul>
<li>用户线程 <ul>
<li>在内核的支持下，在用户层通过线程库实现 </li>
<li>创建和调度在用户空间进行，无需内核干预 </li>
<li>优点：能快速创建和管理 </li>
<li>缺点：如果内核是单线程的，一旦一个用户线程执行了等待的系统调用，则整个进程阻塞 </li>
</ul>
</li>
<li>内核线程 <ul>
<li>由OS管理，创建和调度在OS主存空间内完成 </li>
<li>当一个线程执行时阻塞，内核能调度另一个线 程运行</li>
</ul>
</li>
</ul>
<h2 id="操作系统的并发机制实例"><a href="#操作系统的并发机制实例" class="headerlink" title="操作系统的并发机制实例"></a>操作系统的并发机制实例</h2><h3 id="创建进程及应用实例"><a href="#创建进程及应用实例" class="headerlink" title="创建进程及应用实例"></a>创建进程及应用实例</h3><p>调用形式 （UNIX/LINUX系统）：pid=fork();<br>功能：创建一个子进程，被创建的子进程是父进程的进程映像的一个副本 (除proc结构外)，在UNIX系统中，除了0#进程外，其它进程都是通过调用进程创建系统调用创建的。</p>
<p>系统调用 fork 完成的操作<br>UNIX/Linux系统的核心为系统调用fork 完成下列操作：<br>① 为新进程分配一个新的pcb结构；<br>② 为子进程赋一个唯一的进程标识号 (PID)；<br>③ 做一个父进程上下文的逻辑副本。由于进程的正文区 (代码段)可被几个进程所共享，所以核心只要增加某个正文区的引用数即可，而不是真的将该区拷贝到一个新的内存物理区。这就意味着父子进程将执行相同的代码。数据段和堆栈段属于进程的私有数据，需要拷贝到 新的内存区中。<br>④ 增加d与该进程相关联的文件表和索引节点表的引用数。这就意味 着父进程打开的文件子进程可以继续使用。<br>⑤ 对父进程返回子进程的进程号，对子进程返回零。</p>
<p>如何启动一个新的程序的执行？</p>
<ul>
<li>父进程为了启动一个新的程序的执行，在 UNIX/LINUX系统中需要用到exec()类函数</li>
<li>Exec()类函数很多 作用是根据参数指定的文件名找到可执行文件 ，并用它来取代调用进程的内容，即在调用进 程内部执行一个可执行文件。</li>
</ul>
<h3 id="创建线程及应用实例"><a href="#创建线程及应用实例" class="headerlink" title="创建线程及应用实例"></a>创建线程及应用实例</h3><ul>
<li>LINUX下的多线程程序，需要使用pthread.h，连接时需要使用库libpthread.a。</li>
<li>Clone( )是LINUX特有的系统调用，用来实现 pthread。与fork( )类似。</li>
</ul>
<p>调用形式 ：<code>pthread_create(pthread_t *thread, pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);</code></p>
<p>等待进程终止 wait(); waitpid();<br>① wait() 语法格式<br>pid=wait(stat_addr);<br>wait()函数使父进程暂停执行，直到它的一个子进程结束为止，该函数的返回值是终止运行的子进程的PID。参数status所指向的变量存放子进程的退出码，即从子进程的main函数返回的值或子进程中exit()函数的参数。如果status不是一个空指针，状态信息将被写入它指向的变量。<br>② waitpid() 语法格式<br>pid=wait(stat_addr);<br>waitpid(pid_t pid,int * status,int options)<br>用来等待子进程的结束，但它用于等待某个特定进程结束。参数pid指明要等待的子进程的PID，参数status的含义与wait()函数中的status相同。</p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="进程调度的功能"><a href="#进程调度的功能" class="headerlink" title="进程调度的功能"></a>进程调度的功能</h3><p>调度：在众多处于就绪状态的进程中，按一定的原则选择一个进程。</p>
<p>分派：当处理机空闲时，移出就绪队列中第一个进程，并赋予它使用处理机的权利。</p>
<p><img src="/2020/01/04/进程及进程管理/image-20200104204241996.png" alt="image-20200104204241996"></p>
<p>进程调度的功能</p>
<ul>
<li>记录进程的有关情况</li>
<li>决定调度策略<ul>
<li>优先调度<br>就绪队列按进程优先级高低排序</li>
<li>先来先服务<br>就绪队列按进程来到的先后次序排序</li>
</ul>
</li>
<li>实施处理机的分配和回收</li>
</ul>
<p>进程调度的方式</p>
<ul>
<li>什么是调度方式：当一进程正在处理机上执行时，若有某个更为“重要而紧迫” 的进程需要运行，系统如何分配处理机。</li>
<li>非剥夺方式：当“重要而紧迫”的进程来到时，让正在执行的进程继续执行，直到该进程完成或发生某事件而进入“完成”或“阻塞” 状态时，才把处理机分配给“重要而紧迫”的进程。 </li>
<li>剥夺方式 当“重要而紧迫”的进程来到时，便暂停正在执行的进程， 立即把处理机分配给优先级更高的进程。</li>
</ul>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><h4 id="进程优先数调度算法"><a href="#进程优先数调度算法" class="headerlink" title="进程优先数调度算法"></a>进程优先数调度算法</h4><p>什么是进程优先数调度算法<br>预先确定各进程的优先数，系统把处理机的使用权赋予就绪队列中具备最高优先权 (优先数和一定的优先级相对应) 的就绪进程。</p>
<p>优先数的分类及确定</p>
<ul>
<li>静态优先数<br>在进程被创建时确定，且一经确定后在整个进程运行 期间不再改变。</li>
<li>静态优先数的确定<ul>
<li>优先数根据进程所需使用的资源来计算</li>
<li>优先数基于程序运行时间的估计</li>
<li>优先数基于进程的类型</li>
</ul>
</li>
<li>动态优先数<br>进程优先数在进程运行期间可以改变。</li>
<li>动态优先数的确定<ul>
<li>进程使用CPU超过一定数值时，降低优先数</li>
<li>进程I/O操作后，增加优先数</li>
<li>进程等待时间超过一定数值时，提高优先数</li>
</ul>
</li>
</ul>
<h4 id="循环轮转调度算法"><a href="#循环轮转调度算法" class="headerlink" title="循环轮转调度算法"></a>循环轮转调度算法</h4><p>什么是循环轮转调度算法<br>当CPU空闲时，选取就绪队列首元素，赋予一个时间片，当时间片用完时，该进程转为就绪态并进入就绪队列末端。</p>
<p><img src="/2020/01/04/进程及进程管理/image-20200104204715905.png" alt="image-20200104204715905"></p>
<p>简单循环轮转调度算法<br>就绪队列中的所有进程以等速度向前进展。<br>q = t/n<br>t 为用户所能接受的响应时间，n为进入系统的进程数目。</p>
<p>循环轮转调度算法的发展</p>
<ul>
<li>可变时间片轮转调度</li>
<li>多重时间片循环调度</li>
</ul>
<h3 id="调度用的进程状态变迁图"><a href="#调度用的进程状态变迁图" class="headerlink" title="调度用的进程状态变迁图"></a>调度用的进程状态变迁图</h3><p><img src="/2020/01/04/进程及进程管理/image-20200104204758996.png" alt="image-20200104204758996"></p>
<ul>
<li>进程状态<ul>
<li>运行状态</li>
<li>低优先就绪状态</li>
<li>高优先就绪状态</li>
<li>因I/O而等待状态</li>
</ul>
</li>
<li>队列结构<ul>
<li>低优先就绪队列</li>
<li>高优先就绪队列</li>
<li>因I/O而等待队列</li>
</ul>
</li>
<li>进程调度算法<br> 优先调度与时间片调度相结合的调度算法<ul>
<li>当CPU空闲时，若高优先就绪队列非空，则从高优先就绪队列中选择一个进程运行，分配时间片为100ms。</li>
<li>当CPU空闲时，若高优先就绪队列为空，则从低优先就绪队列中选择一个进程运行，分配时间片为500ms。</li>
</ul>
</li>
<li>调度效果<br>优先照顾I∕O量大的进程；适当照顾计算量大的进程。</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>CH1 算法</title>
    <url>/2020/01/02/CH1-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="算法导论"><a href="#算法导论" class="headerlink" title="算法导论"></a>算法导论</h2><h3 id="What-are-algorithms"><a href="#What-are-algorithms" class="headerlink" title="What are algorithms?"></a>What are algorithms?</h3><p>非形式地说，算法就是任何良定义（well-defined）的计算过程，该过程取某个值或值的集合作为输入（input），并产生某个值或者值的集合作为输出（output）。 <a id="more"></a></p>
<ul>
<li>算法就是把输入转换成输出的计算步骤。     </li>
<li>在计算机科学中，算法是使用计算机解一类问题的精确、有效方法的代名词；        </li>
<li>算法是一组有穷的规则，它规定了解决某一特定类型问题 的一系列运算。 （选自《计算机算法基础》） </li>
</ul>
<ul>
<li>算法由运算组成 <ul>
<li>算术运算、逻辑运算、关系运算、赋值运算、过程调用 </li>
</ul>
</li>
<li>算法有其特殊性 <ul>
<li>解决不同问题的算法是不相同的，没有万能的算法 </li>
</ul>
</li>
<li>算法是有穷的计算过程 <ul>
<li>静态上：规则/运算/语句的数量有穷 </li>
<li>动态上：计算过程/计算时间有限 </li>
</ul>
</li>
</ul>
<h3 id="作为一种技术的算法"><a href="#作为一种技术的算法" class="headerlink" title="作为一种技术的算法"></a>作为一种技术的算法</h3><ul>
<li>算法不仅强调其正确性 </li>
<li>算法也有好坏之分    <ul>
<li>效率（Efficiency）对于算法的有效性有非常重要的影响。     </li>
<li>现实应用中，时间和空间都是有限的资源，因此我们应选择时间和空间方面有效的算法来求解问题 </li>
</ul>
</li>
</ul>
<h2 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h2><h3 id="循环不变式"><a href="#循环不变式" class="headerlink" title="循环不变式"></a>循环不变式</h3><p>INSERTION-SORT 的for循环中，循环变量为j（j代表当前正要被插入到<br>序列中的元素的下标）。循环过程具有以下性质：<br>        <strong>子数组A[1~j-1]是已经被排好序的子序列。 </strong><br>这一性质，在j被赋予初值2，首次进入循环之前成立，而且每次循环之<br>后（j加了1）、进入下一次循环之前也成立。<br>   ——把这种在第一次进入循环之前成立、每次循环之后还成立的关系称为“循环不变式”或“循环不变性质” 。  </p>
<ul>
<li>插入排序for循环的循环不变式可以描述为：在第1~8行的for循环的每次迭代开始时，子数组A[1~j-1]由原来在 A[1~j-1]中的元素组成，且已按序排列。 </li>
</ul>
<p>可以利用循环不变关系证明循环的正确性。<br>分三步走：<br>1）初始化：证明初始状态时循环不变式成立，即证明循环不变式在循 环开始之前为真；<br>2）保持：证明每次循环之后、下一次循环开始之前循环不变式仍为真；<br>3）终止：证明循环可以在有限次循环之后终止。<br>证明循环正确性的思路：<br>第1）和2）步类似于数学归纳法的证明策略<br>第3）步保证算法可以终止<br>如果1）~3）都满足，则说明循环过程正确 </p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法导论</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>一些讨论</title>
    <url>/2019/12/26/%E4%B8%80%E4%BA%9B%E8%AE%A8%E8%AE%BA/</url>
    <content><![CDATA[<p>计算机系统的性能能被准确测量吗？</p>
<p>不能，计算机的性能与很多因素有关，比如指令集、程序自身等，是一个综合的考量。所以是没法用一个统一的指标来描述计算机系统的性能，这是不够全面不够客观的。<a id="more"></a>且各种测量的标准，比如MIPS、MFLOPS等等，都是针对某一个或者某一类测试程序而言，但实际上，每一个计算机系统进行的工作都不一样，很难出现像测试程序中设想的样子，所以测试的结果并不能准确衡量一个实际应用中的计算机系统的性能。</p>
<hr>
<p>浮点数零与浮点数溢出之间的关系</p>
<p>浮点数零是阶位E为0且小数位M为0的情况。浮点数溢出有两种情况：上溢和下溢。上溢是指数据绝对值太大，机器无法表示；下溢是指数据绝对值太小，机器无法表示。如果运算结果落在上溢区，则产生溢出错误，机器停止运算；如果运算结果落在下溢区，由于数据绝对值很小，常作零处理。</p>
<hr>
<p>什么条件下对CRC检测出的错误可以按照CRC的纠错原理进行纠错</p>
<p>如果没有总校验位的，CRC至多能检测出一位错，并可以进行纠正。如果增设总校验位，可以判断出一位错和两位错，对于判断出两位错的情况，选择丢弃当前数据，发送送重传信号给传输方。</p>
<hr>
<p>如何检测程序运行中的数据溢出错误</p>
<p>无符号数根据最高进位是否溢出进行判断，具体说来，加法看进位是为1，减法看是否为0<br>有符号数有三种方法：<br>1.两个操作数的符号位相同时判断结果的符号是否与操作数相同<br>2.次高位和最高位进位异或<br>3.利用双符号运算，10负溢出，01正溢出</p>
<hr>
<p>为什么计算机采用二进制？</p>
<p>1.对于计算机而言，数据表示方便使用高低电平表示1,0<br>2.运算规则简单<br>3.利于数据纠错，只需要找出是哪一位错了就能纠错<br>4.可以使用逻辑门进行算数运算</p>
<hr>
<p>数据存放的大、小端方式对程序设计有何影响？</p>
<p>数据存放的大小端方式对程序员透明。一般来说，在同一机器，程序员不用考虑这一问题（因为在统一要么大端要么小端）。而且原则上，不同机器在传输过程中一定会考虑大小端问题（网络的表示层进行转化），但是也有可能会在传输过程中有的机器做的不够好，产生高低字节反转或者未识别大小端的情况。</p>
<hr>
<p>为什么动态存储器比精态存储器慢</p>
<p>DRAM读之前需要预充电<br>DRAM需要每隔一段时间进行刷新<br>DRAM存储体的行列地址线复用，导致每次需要分时传送</p>
<hr>
<p>为什么计算机需要使用多种数据寻址方式</p>
<p>从数据的存放特点上看，计算机需要处理的数据的存储方式是多种多样的，可以是存储在寄存器中的一些中间结果，可以是调入到内存中的一些变量，也可以是存放在主存设备中的数据，要将这些不同存储方式的数据调入CPU内进行运算，仅采用单一的寻址方式是很难实现的；<br>从程序设计的角度上看，多种的数据寻址方式能为程序设计很高的灵活性，例如对数组或结构成员的访问，可采用基址寻址，对指针对象进行访问可以用寄存器间接寻址，等等；<br>从执行的效率角度上看，寄存器寻址速度很快，但不能访问主存，寄存器间接寻址速度较慢，但可以访问主存，立即寻址较快，但寻址范围受限，为了使程序能够获得较高的性能但又不失方便性，多种的数据寻址方式能够均衡这两个矛盾。</p>
<hr>
<p>系统总线能否用作存储总线</p>
<p>原理上可以，但会降低系统并行性，增加复杂度</p>
<hr>
<p>总线性能分析 试从总线的性能指标分析，为什么目前串行总线比较流行。</p>
<p>串行传输所需要的传输线少，成本低，适合远距离传输。缺点：每次只能传输一位数据，所以传输速度很慢。并行传输的需要的传输线与信息位有关，所有位同时传输，传输速度非常快，但是要求的线路多，成本很高，适用于短距离传输。实际使用过程中，使用串行传输，用户基本感觉不到太大的延迟，所以串行传输在成本上比较占据优势。</p>
<hr>
<p>单级总线结构 为什么嵌入式处理器系统通常采用单级总线结构？</p>
<p>程序和数据共同使用一个存储空间，程序指令存储器地址和数据存储地址指向同一个存储器的不同物理位置。该结构的程序指令宽度相同，采用单一的地址及数据总线，比较典型的例子就是MIPS</p>
<hr>
<p>总线仲裁 试分析什么情况下需要进行总线仲裁。</p>
<p>系统中多个设备或模块可能同时申请对总线的使用权，为避免产生总线冲突，需由总线仲裁机构合理地控制和管理系统中需要占用总线的申请者，在多个申请者同时提出总线请求时，以一定的优先算法仲裁哪个应获得对总线的使用权。</p>
<hr>
<p>总线标准  能否预测一下，下一代总线标准会是怎样的。</p>
<p>1、面向存储器的双总线结构信息传送效率较高，这是它的主要优点。但CPU与I/O接口都要访问存储器时，仍会产生冲突。所以下一步是解决或减少这样的冲突。<br>2、CPU与高速的局部存储器和局部I/O接口通过高传输速率的局部总线连接，速度较慢的全局存储器和全局I/O接口与较慢的全局总线连接，从而兼顾了高速设备和慢速设备，使它们之间不互相牵扯。<br>3、简化了硬件的设计。便于采用模块化结构设计方法，面向总线的微型计算机设计只要按照这些规定制作cpu插件、存储器插件以及I/O插件等，将它们连入总线就可工作，而不必考虑总线的详细操作。<br>4、简化了系统结构。整个系统结构清晰。连线少，底板连线可以印制化。<br>5、系统扩充性好。一是规模扩充，规模扩充仅仅需要多插一些同类型的插件。二是功能扩充，功能扩充仅仅需要按照总线标准设计新插件，插件插入机器的位置往往没有严格的限制。<br>6、系统更新性能好。因为cpu、存储器、I/O接口等都是按总线规约挂到总线上的，因而只要总线设计恰当，可以随时随着处理器的芯片以及其他有关芯片的进展设计新的插件，新的插件插到底板上对系统进行更新，其他插件和底板连线一般不需要改。<br>7、便于故障诊断和维修。用主板测试卡可以很方便找到出现故障的部位，以及总线类型。</p>
<hr>
<p>存储IO和通信IO  举例分析存储IO和通信IO的异同。</p>
<p>存储IO是在缓存与磁盘阵列之间进行数据交换的过程，涉及IO接口和读写性能，存储IO的速度取决于磁盘的速度。<br>通信IO是通过网络进行数据交换，比如socket，执行阻塞IO，通过应用层，运输层，网络层，数据链路层，物理层的五级网络架构进行数据的封装和交换。</p>
<hr>
<p>中断IO方式  为什么中断IO方式的应用最广泛。</p>
<p>可以让CPU避免忙于查询各个外部设备的状态，提高CPU利用率;<br>中断除了传输数据还可以处理异常;<br>软硬件结合的方式也让使用成本变得不是那么高。<br>因而应用广泛。</p>
<p>由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。 同步IO模式，程序暂停执行后续代码，等待数据写入磁盘，再接着往下执行； 异步IO模式，CPU不等待，只是告诉磁盘继续读写，后续代码可以立刻接着执行。 当有新的IO请求时，设备发出中断请求，CPU收到请求后，进行IO请求中断响应，完成响应后恢复现场，回到原来的地方继续执行。 当IO完成时，设备发出完成IO的中断信号，CPU进入中断处理读写完成的数据和缓存。 采用中断IO的方式，大大提高了有IO需求时，CPU的工作效率</p>
<hr>
<p>中断优先级  中断优先级低的中断请求能否优先处理完成，为什么？</p>
<p>在中断处理程序中设置新的中断屏蔽字。为了能根据需要，改变实际的中断处理次序，很多机器都设置了中断屏蔽寄存器硬件，以决定是否让某级中断请求进入中断优先权电路进行优先权比较。级别高的中断请求优先得到响应。只要将每一类中断处理程序的各级中断屏蔽位设置成不同的状态，就可以得到所希望的中断处理次序。因此，可以通过设置中断屏蔽字实现低优先级的中断先处理，实际上，可以任意改变处理次序，这为中断处理带来了灵活性。</p>
<hr>
<p>DMA传输模式  你觉得DMA传输模式的控制可由什么部件来实现的。</p>
<p>当外围设备要求传送一批数据时，由<strong>DMA控制器</strong>发一个停止信号给CPU，要求CPU放弃对地址总线、数据总线和有关控制总线的使用权。DMA控制器获得总线控制权以后，开始进行数据传送。在一批数据传送完毕后，DMA控制器通知CPU可以使用内存，并把总线控制权交还给CPU在这种DMA传送过程中，CPU基本处于不工作状态或者说保持状态。DMA传输方式无需CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件为RAM与I/O设备开辟一条直接传送数据的通路，使CPU的效率大为提高。</p>
<hr>
<p>实验中的所选用的生成多项式对编码求余数的循环周期是多少？为什么？</p>
<p>CRC-5，余数为5位，只有全为0时表示正确，剩余31种状态表示错误，也就是出错的状态有31种。</p>
<hr>
<p>Logisim中的毛刺如何消除？</p>
<p>增加冗余项、增加惯性延时环节（logisim中可以增加缓冲器），选通法</p>
<hr>
<p>逻辑门组件最多可以有32个输入，实际电路中有这样的逻辑门吗？</p>
<p>理论上有，但是实际实验时输入太多会使逻辑变得非常复杂，而且输入增多, 门电路里的晶体管也会增多, 本身即会增大门电路时延, 同时多晶体管也不利于电平的稳定控制，需要更大的电压。</p>
<hr>
<p>如果合并LW，SW指令第三个状态，微程序控制器需要如何修改？<br>本次实验中，LW指令，SW指令的第三个时钟周期的状态进行了分离，简化了设计，如果不进行状态分离，微程序控制器需要做什么修改？给出你的方案。</p>
<p>增加一个判断位，假设判断位不为00时使用下址字段给出的地址，判断位为其他值时使用地址转移逻辑给出的地址（判断位为01表示计算地址状态），更改地址转移逻辑，增加判断位为地址转移逻辑输入，当判断位为01时，地址转移逻辑根据指令的不同给出不同的下址</p>
<hr>
<p>硬件cache机制设计实验研讨<br>1）如果采用软件程序来实现cache，哪种映射方法更有效？<br>2）如果采用软件程序实现cache，LRU算法采用什么数据结构实现更加方便？<br>3）软件实现中不可能实现全相联查找的并发查找机制，如何提升查找速度？</p>
<p>我个人回答：全相连，哈希链表，哈希</p>
<hr>
<p>MIPS 寄存器文件设计实验研讨  零号寄存器的值为什么要恒零，这样做有什么好处？</p>
<p>汇编代码中有大量赋值为0或者与0比较的指令，设置一个恒0的寄存器可以避免这类指令中装载立即数0的过程，可以提高效率</p>
<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>输入输出系统</title>
    <url>/2019/12/26/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="输入输出接口概述"><a href="#输入输出接口概述" class="headerlink" title="输入输出接口概述"></a>输入输出接口概述</h2><p>输入/输出系统组成：外部设备、接口部件、总线以及相应的管理软件统称为计算机的 输入/输出系统，简称I/O系统。<a id="more"></a><br><img src="/2019/12/26/输入输出系统/image-20191226193057280.png" alt="image-20191226193057280"></p>
<p>I/O系统基本功能：</p>
<ul>
<li>完成计算机内部二进制信息与外部多种信息形式间的交流；</li>
<li>保证CPU能够正确选择输入输出设备并实现对其控制，传输大量数据、 避免数据出错；</li>
<li>利用数据缓冲、选择合适的数据传送方式等，实现主机与外设间 速度的匹配。</li>
</ul>
<p>I/O系统特点：</p>
<ul>
<li>异步性：外围设备相对于处理机通常是异步工作的；</li>
<li>实时性：当外围设备与处理机交互时，由于设备的类型不同，它们的工 作步调是不同的，处理机必须按照不同设备所要求传送方式和传输速率 不失时机地为设备提供服务，这就要求实时性控制；</li>
<li>与设备无关性：各种外部设备必须根据其特点和要求选择一种标准接口 和处理机进行连接，它们之间的差别必须由设备本身的控制器通过硬件 和软件来填补；这样，处理机本身无须了解外设的具体细节，可以采用 统一的硬件和软件对其管理。</li>
</ul>
<h3 id="输入-输出设备同CPU交换数据的过程"><a href="#输入-输出设备同CPU交换数据的过程" class="headerlink" title="输入/输出设备同CPU交换数据的过程"></a>输入/输出设备同CPU交换数据的过程</h3><p>输入过程：</p>
<ul>
<li>CPU把一个地址值放在地址总线上，这一步将选择某一输入设备；</li>
<li>CPU等候输入设备的数据成为有效；</li>
<li>CPU从数据总线读入数据，并放在一个相应的寄存器中</li>
</ul>
<p>输出过程：</p>
<ul>
<li>CPU把一个地址值放在地址总线上，选择输出设备</li>
<li>CPU把数据放在数据总线上；</li>
<li>输出设备认为数据有效，从而把数据取走</li>
</ul>
<h3 id="I-O系统性能"><a href="#I-O系统性能" class="headerlink" title="I/O系统性能"></a>I/O系统性能</h3><p>按照主要完成的工作可以分为以下二类：存储 I/O  通信 I/O</p>
<p>I/O系统的性能对CPU的性能有很大的影响，若两者的性能不匹配，I/O系统就有可能成为整个系统的瓶颈。</p>
<p>评价I/O系统性能的主要参数：</p>
<ul>
<li>连接特性：哪些I/O设备可以和计算机系统相连接</li>
<li>I/O系统的容量：I/O系统可以容纳的I/O设备数 </li>
<li>响应时间和吞吐率等</li>
<li>系统的响应时间：从用户输入命令开始，到得到结果所花费的时间； 由I/O系统的响应时间和CPU的处理时间两部分构成，单位通常用秒（s）表示。</li>
<li>I/O的吞吐率：单位时间完成的I/O操作次数，单位通常用IOP表示。</li>
</ul>
<h2 id="输入输出方式"><a href="#输入输出方式" class="headerlink" title="输入输出方式"></a>输入输出方式</h2><p>输入/输出方式：</p>
<ul>
<li>无条件I/O方式</li>
<li>程序控制I/O方式</li>
<li>中断I/O方式</li>
<li>DMA（Direct Memory Access）方式</li>
<li>通道方式</li>
<li>I/O处理机方式</li>
</ul>
<h3 id="无条件I-O方式"><a href="#无条件I-O方式" class="headerlink" title="无条件I/O方式"></a>无条件I/O方式</h3><ul>
<li>在程序的适当位置直接安排 I/O指令，当程序执行到这些 I/O指令时，CPU默认外设始终是准备就绪的（I/O总是准备好接收CPU的输出数据，或 总是准备好向CPU输入数据）， 无需检查I/O的状态，就进行数据的传输；</li>
<li>硬件接口电路和软件控制程序都比较简单。输入时，必须确保CPU执行 I/O指令读取数据时，外设已将数据 准备好；输出时，必须确保外部设备 的数据锁存器为空，即外设已将上次 的数据取走，等待接收新的数据，否 则会导致数据传送出错，但一般的外设难以满足这种要求。</li>
</ul>
<h3 id="程序控制方式"><a href="#程序控制方式" class="headerlink" title="程序控制方式"></a>程序控制方式</h3><p>一种早期计算机采用的输入/输出方式，数据在计算机和外设之 间的传送全部靠计算机程序控制；计算机执行I/O指令时，先获取外设状态，并根据外设的状态决定下一步操作。</p>
<p>程序查询的I/O原理：</p>
<ul>
<li>程序先向I/O设备发出I/O命令字； </li>
<li>读取I/O设备工作状态信息； </li>
<li>检查状态字中的标志，看是否可以进行数据交换； </li>
<li>若设备未准备就绪，则返回到上步，重复查询；否则，发出设备准备就绪信号； </li>
<li>CPU与I/O接口的数据缓冲寄存器进行数据交换，与此同时，将接口中的状态标志复位<br><img src="/2019/12/26/输入输出系统/image-20191226194626791.png" alt="image-20191226194626791"></li>
</ul>
<p>设备状态字寄存器：</p>
<ul>
<li>用来标志设备的工作状态，以便接口对外部设备进行监视。 </li>
<li>CPU通过程序查询设备状态位来判断设备的状态。 </li>
<li>因此，设备状态寄存器是设备对主机的窗口，主机通过它了解设备的 状态，并对设备设置操作方式。 </li>
<li>设备状态寄存器又叫设备状态字（DSW）是设备所有状态的集合，每 种状态均用一个触发器来表示。</li>
</ul>
<p>特点：何时对何设备进行输入输出操作完全受CPU控制， 外围设备与CPU处于异步工作关系，数据的输入/输出都要经过CPU。<br>优点：计算机和外设之间能够同步，控制简单，硬件简单。<br>缺点：CPU的大量时间用来查询外设的状态</p>
<h3 id="中断I-O方式"><a href="#中断I-O方式" class="headerlink" title="中断I/O方式"></a>中断I/O方式</h3><ul>
<li>当外设准备好后，主动通知CPU并进行接收或输出数据的方法；</li>
<li>CPU接到外设的通知后暂停现行的工作，转入中断服务程序，和外设交换数据， 等中断程序处理完毕后，再返回到被中断的原程序中继续以前被暂停的工作。</li>
</ul>
<p>优点：节约CPU时间，实时性好。<br>缺点：控制电路相对复杂，服务开销较大（现场和断点的保护）。<br>应用场合：实时性要求高，且数据传输量又不大的场合</p>
<h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><ul>
<li>是一种完全由硬件执行的I/O交换方式</li>
<li>当外设准备好后，通知DMA控制器，DMA控制器从CPU接管总线，并完成外 设和内存之间的大量数据传输；传输完成后DMA控制器将总线控制权交还给 CPU，整个数据交换的过程不需要CPU参与。</li>
</ul>
<p>优点：既有中断的优点，同时又降低了服务开销。<br>缺点：控制电路更加复杂。<br>应用场合：高速、大批量数据传输。</p>
<h3 id="通道和I-O处理机方式"><a href="#通道和I-O处理机方式" class="headerlink" title="通道和I/O处理机方式"></a>通道和I/O处理机方式</h3><ul>
<li>复杂的计算机系统中，外围设备的台数一般比较多，设备的种类、工作方式 和工作速度的差别很大，为了把对外围设备的管理工作从CPU中分离出来，采 用通道或I/O处理机方式。</li>
<li>通道是能够专门执行I/O指令的处理机，它可以实现对外围设备的统一管理， 以及外设与主存之间的数据传输。</li>
<li>I/O处理机是通道方式的进一步发展，它的结构更接近于一般处理机。</li>
</ul>
<h2 id="中断请求与响应"><a href="#中断请求与响应" class="headerlink" title="中断请求与响应"></a>中断请求与响应</h2><p>中断：是指CPU在正常运行程序时，由于内部/外部事 件（或由程序）引起CPU中断正在运行的程序，而转到 为中断事件服务的程序中去，服务完毕，再返回执行原 程序的这一过程。<br>中断的特征：具有随机性。</p>
<p>中断的作用：</p>
<ul>
<li>实现主机与外设之间的并行工作</li>
<li>故障处理：中断系统能使计算机在运行过程中出现故障的时候， 调用相应的中断服务程序处理故障。</li>
<li><p>实时处理<br><img src="/2019/12/26/输入输出系统/image-20191226200348777.png" alt="image-20191226200348777"></p>
<h3 id="中断的类型"><a href="#中断的类型" class="headerlink" title="中断的类型"></a>中断的类型</h3><ul>
<li>内部中断</li>
<li>软件中断</li>
<li>异常<ul>
<li>故障(Fault)</li>
<li>自陷(Trap)</li>
<li>终止(Abort)</li>
</ul>
</li>
</ul>
</li>
<li><p>外部中断</p>
<ul>
<li>可屏蔽中断INTR</li>
<li>不可屏蔽中断NMI</li>
</ul>
</li>
<li><p>内部中断：来自于CPU内部的指令中断请求，分为软件中断和异常。</p>
</li>
<li>外部中断：中断请求来自CPU外部，又分为可屏蔽和不可屏蔽中断。</li>
<li>不可屏蔽中断NMI：由系统内部硬件引发的中断，优先级高于外部硬 件中断，且不受中断允许标志位的影响，所以是不可屏蔽中断。</li>
<li>可屏蔽中断：由外设通过中断请求线向处理器申请而产生的中断，处 理器可以用指令来屏蔽（禁止），即不响应它的中断请求。</li>
</ul>
<h3 id="中断系统的基本功能"><a href="#中断系统的基本功能" class="headerlink" title="中断系统的基本功能"></a>中断系统的基本功能</h3><ul>
<li>中断请求信号保持与清楚</li>
<li>中断优先级</li>
<li>中断源识别</li>
<li>中断的处理</li>
<li>中断控制</li>
</ul>
<h4 id="中断请求信号保持与清除"><a href="#中断请求信号保持与清除" class="headerlink" title="中断请求信号保持与清除"></a>中断请求信号保持与清除</h4><ul>
<li>中断号：是系统分配给每个中断源的代号，以便识别和处理。中断号在中断处理过程中起到很重要的作用。</li>
<li>中断号的获取：CPU对系统中不同类型的中断源，获取它们的中断号 的方法是不同的。</li>
</ul>
<p><img src="/2019/12/26/输入输出系统/image-20191226200930087.png" alt="image-20191226200930087"></p>
<h4 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h4><p>中断触发方式：是指外设以什么逻辑信号去申请中断，即边沿触发和电 平触发两种方式。<br>中断排队方式：当系统有多个中断源时，就可能出现同时有几个中断源 都申请中断，而处理器在一个时刻只能响应并处理一个中断请求；为此， 要进行中断排队。处理器按“优先级高的先服务”的原则提供服务。</p>
<ul>
<li>按优先级排队：根据任务的轻重缓急，给每个中断源指定CPU响应的 优先级，任务紧急的先响应，可以暂缓的后响应。 </li>
<li>循环轮流排队：不分级别高低，CPU轮流响应各个中断源的中断请求。</li>
</ul>
<p>中断嵌套：</p>
<ul>
<li>当CPU正在处理某个中断时，会出现优先级更高的 中断源申请中断；为了使更紧急的、级别更高的中断源及时得到服务，需要暂时打断（挂起）当前正 在执行的中断服务程序，去处理级别更高的中断请 求，处理完成后再返回被打断了的中断服务程序继 续执行。 </li>
<li>但级别相同或级别低的中断源不能打断级别高的中 断服务，这就是所谓的中断嵌套。 </li>
<li>可屏蔽中断可以进行中断嵌套。NMI不可以进行中断嵌套。</li>
</ul>
<p>中断屏蔽：</p>
<ul>
<li>处理器用指令来控制中断屏蔽触 发器的状态，从而控制是否接受 某个特殊外设的中断请求。</li>
<li>处理器内部也有一个中断允许触 发器，只有当其为“1”（即开中 断），CPU才能响应外部中断。</li>
</ul>
<p>中断优先级：是指CPU响应和处理中断请求的先后次序<br>为了兼顾中断响应的时效与配置的灵活，通常采用两套机制结合组成 中断优先序管理体系：</p>
<ul>
<li>硬件响应优先序：未被屏蔽的几个中断源同时提出申请时， CPU选择服务对象的顺序由硬件电路实现，用户不能修改。 </li>
<li>软件服务优先序：在各中断服务程序开头，用软件设置自己 的中断屏蔽字，以此改变实际服务顺序。</li>
</ul>
<h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><ul>
<li>中断响应周期：当CPU收到外设的中断请求后，如果当前一条指令已执行完，且允许中断， CPU进入中断响应周期，发出中断应 答信号完成一个中断响应周期。</li>
<li>中断响应：读取中断源的中断号，完成中断申请与中断响应的握手过程。</li>
</ul>
<p>中断处理：</p>
<ul>
<li>标志位的处理与断点保存<br>处理器获得外部中断源的中断号后，保存断点（返回地址），关闭中断，保护现场。</li>
<li>向中断服务程序转移并执行中断服务程序</li>
<li><p>返回断点<br>中断服务程序执行完毕后，恢复断点和现场， 要返回主程序。</p>
<p>单级中断处理流程：<br><img src="/2019/12/26/输入输出系统/image-20191226201407259.png" alt="image-20191226201407259"></p>
<p>多级中断处理流程：<br><img src="/2019/12/26/输入输出系统/image-20191226201438871.png" alt="image-20191226201438871"></p>
<h2 id="DMA方式-1"><a href="#DMA方式-1" class="headerlink" title="DMA方式"></a>DMA方式</h2></li>
</ul>
<p>DMA方式的基本原理：数据的传送不经过CPU，由DMA控制器实现内存和外设、外设和外 设之间的直接快速传送。<br>用于需要高速大批量数据传送的系统中。<br><img src="/2019/12/26/输入输出系统/image-20191226202606347.png" alt="image-20191226202606347"></p>
<p>DMA传输计算机系统构成：</p>
<ul>
<li>DMA控制器作为主设备之一<br><img src="/2019/12/26/输入输出系统/image-20191226202653346.png" alt="image-20191226202653346"></li>
<li>DMA控制器与I0接口集成<br><img src="/2019/12/26/输入输出系统/image-20191226202732946.png" alt="image-20191226202732946"></li>
<li>DMA控制器提供专门I/O中间<br><img src="/2019/12/26/输入输出系统/image-20191226202757677.png" alt="image-20191226202757677"></li>
</ul>
<p>DMA控制器(DMAC)：<br>DMA控制器的两种工作状态</p>
<ul>
<li>被动态（受控器）：未取得总线控制权，受CPU的控制。</li>
<li>主动态（主控器）：接管并取得总线控制权，取代CPU而成为系统的主控者。</li>
</ul>
<h3 id="DMA传输步骤"><a href="#DMA传输步骤" class="headerlink" title="DMA传输步骤"></a>DMA传输步骤</h3><ul>
<li>申请阶段：一个设备接口试图通过总线直接向另一个设备发送数据(一般是大批量的数据)，它会先向 CPU发送DMA请求信号；</li>
<li>响应阶段：CPU收到DMA请求信号后，在当前的总线周期结束后，会按DMA信号的优先级和提出 DMA请求的先后顺序响应DMA信号；</li>
<li>数据传送阶段 CPU对某个设备接口响应DMA请求时，会让出总线控制权；于是在DMA控制器的管理下，外设和存储器直接进行数据交换，而不需CPU干预；</li>
<li>传送结束阶段 ：数据传送完毕后，设备接口会向CPU发送DMA结 束信号，交还总线控制权。</li>
</ul>
<h3 id="DMA操作类型"><a href="#DMA操作类型" class="headerlink" title="DMA操作类型"></a>DMA操作类型</h3><ul>
<li>数据传送：把源地址的数据传输到目的地址去（存储器或I/O）。</li>
<li>数据校验：不进行数据传输，只对数据块内部的每个字节进行某种校验； 这种数据校验一般安排在读数据块之后，以便校验所读的数据是否有效。</li>
<li>数据检索：不进行数据传输，只是在指定的内存区域内查找某个关键字节 或某几个数据位是否存在</li>
</ul>
<h3 id="DMA操作方式"><a href="#DMA操作方式" class="headerlink" title="DMA操作方式"></a>DMA操作方式</h3><ul>
<li>单字节传输模式：每次DMA操作传送一个字节后，接着释放总线。</li>
<li>块传输模式：连续传送多个字节，每传输一个字节，当前字节计数器 减1，当前地址寄存器加1或减1，直到所要求的字节数传输完（当前 字节计数器减至0），然后释放总线。</li>
<li>请求传输模式：DMA控制器要询问外设，当外设请求信号无效时， 暂停传输（不释放总线）；当请求信号再次有效后，继续进行传输。</li>
<li>级联传输模式：多片DMA控制器级联，构成主从式DMA系统。</li>
</ul>
<h3 id="DMA传输模式"><a href="#DMA传输模式" class="headerlink" title="DMA传输模式"></a>DMA传输模式</h3><h4 id="停止CPU访问内存"><a href="#停止CPU访问内存" class="headerlink" title="停止CPU访问内存"></a>停止CPU访问内存</h4><p>当需要传送一批数据时，DMA控制器首先要求CPU放弃对总线的控制权；然后开始进行数据传送。在一批数据传送完毕后，DMA控制器通知CPU可以使用内存，并把总线控制权交还给CPU。<br>在这种DMA传送过程中，CPU基本处于不工作状态或者说保持状态。<br>优点：控制简单，它适用于数据传输率很高的设备进行成组传送。<br>缺点：在DMA控制器访内存阶段，内存的效能没有充分发挥，相当一部分内存 工作周期是空闲的。这是因为，传送两个数据之间的间隔一般总是大于内 存存储周期，即使高速I/O设备也是如此。 </p>
<h4 id="请求传输模式——周期挪用"><a href="#请求传输模式——周期挪用" class="headerlink" title="请求传输模式——周期挪用"></a>请求传输模式——周期挪用</h4><p>当I/O设备没有DMA请求时，CPU按程序要求访问内存；一旦I/O设备有DMA请求，则由I/O设备挪用一个或几个内存周期。<br>I/O设备要求DMA传送时可能遇到两种情况： </p>
<ul>
<li>当CPU不需要访内时，此时I/O访内与CPU访内没有冲突，即 I/O设备挪用一二个内存周期对CPU执行程序没有任何影响； </li>
<li>CPU也同时要求访问内存，这就产生了访存冲突，在这种情况 下I/O设备访存优先。<br>优点：既实现了I/O传送，又较好地发挥了内存和CPU的效率，是一种广泛采 用的方法。<br>缺点：I/O设备每一次周期挪用都有申请、建立、归还总线控制权的过程，所 以传送一个字对内存来说要占用一个周期，但对DMA控制器来说一般要2-5个内存周期；因此，周期挪用方法适用于I/O设备读写周期大于内存存储周期的 情况。</li>
</ul>
<h4 id="请求传输模式——DMA与CPU交替访存"><a href="#请求传输模式——DMA与CPU交替访存" class="headerlink" title="请求传输模式——DMA与CPU交替访存"></a>请求传输模式——DMA与CPU交替访存</h4><p>如果CPU的工作周期比内存存取周期长很多，此时采用交替访存的方法，可以使DMA传送和CPU同时发挥最高的效率。<br>这种方式不需要总线使用权的申请、建立和归还过 程，总线使用权是通过分 时进行的，这种总线控制权的转移几乎不需要什么时间，所以对DMA传送来讲效率是很高的。<br>这种传送方式又称为”透明的DMA”方式，在透 明的DMA方式下工作，CPU既不停止主程序的 运行，也不进入等待状态，同样是一种高效率的 工作方式。<br>缺点：相应的硬件逻辑也就更加复杂。 </p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>采用DMA方式传送数据时，每传送一个数据就要用一个（<strong>存储周期</strong>）时间。</p>
<hr>
<p>通道对CPU的请求形式是(<strong>中断</strong>)</p>
<hr>
<p>描述PCI总线中基本概念正确的句子是（<strong>ACD</strong>）。<br>A.HOST 总线不仅连接主存，还可以连接多个CPU<br>B.以桥连接实现的PCI总线结构不允许许多条总线并行工作<br>C.PCI 总线体系中有三种桥，它们都是PCI 设备<br>D.桥的作用可使所有的存取都按CPU 的需要出现在总线上</p>
<hr>
<p>中断向量地址是<strong>中断服务例行程序入口地址的指示器</strong></p>
<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>系统总线</title>
    <url>/2019/12/26/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="总线的特性及其应用"><a href="#总线的特性及其应用" class="headerlink" title="总线的特性及其应用"></a>总线的特性及其应用</h2><p>总线的概念：是计算机体系结构的重要组成部分，通过它可以将计算机系统中各个功能部件连接起来，构成一个完整的系统。<br><a id="more"></a><br>总线的作用：</p>
<ul>
<li>是各功能部件间传递各类信息的通道；</li>
<li>是系统中各部件间的物理接口，能够减少各部件通信的复杂程度； </li>
<li>提供信息交换时所需的数据、地址、时序和控制信息； </li>
<li>提供一个共同遵循的协议或标准； </li>
<li>不应成为整个计算机性能的瓶颈； </li>
<li>方便计算机系统的集成、扩展和进化。</li>
</ul>
<p>总线的分类：总线分类的方式有很多，如被分为外部总线和内部 总线、系统总线和非系统总线、片内总线和PCB板级总线、串行总线 和并行总线、高速总线和低速总线、同步总线和异步总线，专用总线 和通用总线等等。</p>
<h3 id="按用途分"><a href="#按用途分" class="headerlink" title="按用途分"></a>按用途分</h3><ul>
<li>存储总线：短距离、 高速总线，与存储器 的特性相匹配，尽最 大可能提高处理器与 存储器之间的数据带 宽，针对Cache块数 据传输进行性能优化；</li>
<li>系统总线：又称内 部总线或板级总线， 是计算机系统中最 重要的总线，也是 连接存储总线和I/O 总线的中间总线；</li>
<li>I/O总线：通常连 接距离较远、速度 相对较慢，用于连 接多种外部设备， 同时与系统总线或 存储总线连接。</li>
</ul>
<h3 id="按位置分"><a href="#按位置分" class="headerlink" title="按位置分"></a>按位置分</h3><p>按照总线所在的位置，总线可以分为：</p>
<ul>
<li>外部总线：USB、火线（IEEE-1394）等</li>
<li>内部总线：PCI、AGP等</li>
<li>片内总线：AMBA</li>
</ul>
<h3 id="总线的组成"><a href="#总线的组成" class="headerlink" title="总线的组成"></a>总线的组成</h3><ul>
<li>数据总线：用于传送数据信息，通常是双向三态形式的总线；</li>
<li>地址总线：专门用来传送地址，地址总线总是单向三态的;</li>
<li>控制总线：用来传送控制信号和时序信号。</li>
<li>电源线和地</li>
</ul>
<h2 id="总线性能和总线事物"><a href="#总线性能和总线事物" class="headerlink" title="总线性能和总线事物"></a>总线性能和总线事物</h2><h3 id="总线性能参数："><a href="#总线性能参数：" class="headerlink" title="总线性能参数："></a>总线性能参数：</h3><p>总线性能参数：</p>
<ul>
<li>总线频率：反映总线工作的速率（f），通常单位是MHz； </li>
<li>总线宽度：数据总线的位数（w），单位是b（位）， 是微型计算机的一个重要指标，通常与处理器的字长相一致； </li>
<li>总线传输速率：总线上可传输的数据总量（BW），单位是MB/s； 总线传输速率＝（总线宽度÷8位）×总线频率 BW = （w÷8）× f </li>
<li>同步方式：同步、异步</li>
<li>多路复用：地址线和数据线能否共用一条物理线；</li>
<li>信号线数量：数据线、控制线和地址线的总和；</li>
<li>总线控制方式：传输方式、配置方式、中断分配和仲裁方式等。</li>
</ul>
<h3 id="总线事物"><a href="#总线事物" class="headerlink" title="总线事物"></a>总线事物</h3><ul>
<li>总线事务：从请求总线到完成总线使用的操作序列称 为总线事务（Bus Transaction），它是在一个总线周 期中发生的一系列活动。</li>
<li>典型的总线事务包括：请求操作、裁决操作、地址传 输、数据传输和总线释放。</li>
</ul>
<p>主设备（master）：能够提出申请并获得总线控制权的设备；<br>从设备（slave）   ：只能被动接受总线控制传送数据的设备。</p>
<p><img src="/2019/12/26/系统总线/image-20191226170508498.png" alt="image-20191226170508498"></p>
<h3 id="总线传输过程"><a href="#总线传输过程" class="headerlink" title="总线传输过程"></a>总线传输过程</h3><ul>
<li>总线传输：在主设备（如CPU、DMA控制器等）控制 下通过总线进行的信息传送（数据读写）操作。 </li>
<li>总线完成一次数据传输操作，一般经过如下四个阶段：<ul>
<li>申请与仲裁阶段</li>
<li>寻址阶段</li>
<li>传输阶段</li>
<li>结束阶段</li>
</ul>
</li>
</ul>
<p>常见总线操作：</p>
<ul>
<li>读操作（Read）</li>
<li>写操作（Write）</li>
<li>读修改写操作（Read-modify-Write）</li>
<li>写后读操作（Read-after-Write）</li>
<li>块操作（Block）等</li>
</ul>
<h2 id="总线连接方式"><a href="#总线连接方式" class="headerlink" title="总线连接方式"></a>总线连接方式</h2><h3 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h3><ul>
<li>访问存储器和访问外设指令相同，由地址来区分；</li>
<li>总线简单，使用灵活，易于扩展；</li>
<li>任意两设备之间理论上都可以直接交换信息；</li>
<li>所有设备分时工作，仅适用于慢速的计算机系统中。</li>
</ul>
<p><img src="/2019/12/26/系统总线/image-20191226171940833.png" alt="image-20191226171940833"></p>
<h3 id="双级总线结构"><a href="#双级总线结构" class="headerlink" title="双级总线结构"></a>双级总线结构</h3><ul>
<li>由于外设和内存分处于不同的总线，需要增加I/O指令；</li>
<li>存储总线的增加减轻了系统总线的负担，提高了并行性； </li>
<li>仍然保持了单总线结构的系统简单、易于扩充的优点。</li>
</ul>
<p><img src="/2019/12/26/系统总线/image-20191226172026248.png" alt="image-20191226172026248"></p>
<h3 id="多级总线结构"><a href="#多级总线结构" class="headerlink" title="多级总线结构"></a>多级总线结构</h3><ul>
<li>在双级总线结构的基础上增加I/O总线构成； </li>
<li>并行性进一步提高，并可以通过增加通道或IO处理机来分担部分CPU 的I/O功能，但是总线结构得越来越复杂。</li>
</ul>
<p><img src="/2019/12/26/系统总线/image-20191226172053836.png" alt="image-20191226172053836"></p>
<h3 id="总线示例"><a href="#总线示例" class="headerlink" title="总线示例"></a>总线示例</h3><h4 id="多级总线示例"><a href="#多级总线示例" class="headerlink" title="多级总线示例"></a>多级总线示例</h4><p>总线桥：是不同速率总线 之间的连接器件，起信号 速度缓冲、电平转换、控 制协议转换等作用。</p>
<p><img src="/2019/12/26/系统总线/image-20191226172131126.png" alt="image-20191226172131126"></p>
<h4 id="单级总线示例"><a href="#单级总线示例" class="headerlink" title="单级总线示例"></a>单级总线示例</h4><p><img src="/2019/12/26/系统总线/image-20191226172214936.png" alt="image-20191226172214936"></p>
<h3 id="总线结构对计算机系统性能的影响"><a href="#总线结构对计算机系统性能的影响" class="headerlink" title="总线结构对计算机系统性能的影响"></a>总线结构对计算机系统性能的影响</h3><ul>
<li>对最大存储容量的影响：单总线结构有影响，双总线和多总线结构没有；</li>
<li>对指令系统的影响：双总线和多总线结构需要增加IO指令；</li>
<li>吞吐量：单总线结构的吞吐量小，多总线结构的吞吐量大，双总线结 构的吞吐量居中</li>
</ul>
<h2 id="总线仲裁和数据传输方式"><a href="#总线仲裁和数据传输方式" class="headerlink" title="总线仲裁和数据传输方式"></a>总线仲裁和数据传输方式</h2><h3 id="菊花链式串行总线仲裁"><a href="#菊花链式串行总线仲裁" class="headerlink" title="菊花链式串行总线仲裁"></a>菊花链式串行总线仲裁</h3><p><img src="/2019/12/26/系统总线/image-20191226173643508.png" alt="image-20191226173643508"></p>
<h3 id="集中式并行总线仲裁"><a href="#集中式并行总线仲裁" class="headerlink" title="集中式并行总线仲裁"></a>集中式并行总线仲裁</h3><p><img src="/2019/12/26/系统总线/image-20191226173726362.png" alt="image-20191226173726362"></p>
<h3 id="常见总线仲裁策略"><a href="#常见总线仲裁策略" class="headerlink" title="常见总线仲裁策略"></a>常见总线仲裁策略</h3><ul>
<li>固定优先级总线仲裁</li>
<li>轮叫式总线仲裁（Round Robin）</li>
<li>LRG总线仲裁（Least Recently Granted）</li>
<li>混合式总线仲裁</li>
</ul>
<h3 id="总线时序"><a href="#总线时序" class="headerlink" title="总线时序"></a>总线时序</h3><h4 id="同步定时"><a href="#同步定时" class="headerlink" title="同步定时"></a>同步定时</h4><p>同步定时：信息传送由公共时钟控制，总线中包含时钟线。</p>
<p><img src="/2019/12/26/系统总线/image-20191226173902376.png" alt="image-20191226173902376"></p>
<ul>
<li>优点：时序关系简单，实现简单。</li>
<li>缺点：在设备速度不一致时按最坏情况确定， 传输线不能太长（时钟相移）。 </li>
</ul>
<h4 id="异步定时"><a href="#异步定时" class="headerlink" title="异步定时"></a>异步定时</h4><p>异步定时：信息传送的每一个操作都是由主设备或从设备特定信号的 跳变所确定，总线上每一个事件的发生取决于前一个事件的发生。</p>
<p><img src="/2019/12/26/系统总线/image-20191226174007685.png" alt="image-20191226174007685"></p>
<ul>
<li>优点：数据传输可靠，适用于传输周期不同的设备， 对通讯线的长度没有严格的要求。 </li>
<li>缺点：速度较慢。</li>
</ul>
<h4 id="半同步定时"><a href="#半同步定时" class="headerlink" title="半同步定时"></a>半同步定时</h4><p>半同步定时：总线上各操作之间的时间间隔可以变化，但仅允许为公 共时钟周期的整数倍。信号的出现、采样和结束仍以公共时钟为基准。</p>
<p><img src="/2019/12/26/系统总线/image-20191226174058360.png" alt="image-20191226174058360"></p>
<h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><h4 id="并行传送"><a href="#并行传送" class="headerlink" title="并行传送"></a>并行传送</h4><ul>
<li>同时并行传送的二进位数就是数据宽度；</li>
<li>通常采用应答式的联络信号来协调双方的数据传送操作。</li>
</ul>
<h4 id="串行传送"><a href="#串行传送" class="headerlink" title="串行传送"></a>串行传送</h4><ul>
<li>只使用一根传输线，采用脉冲方式传送信息；</li>
<li>每次传送1位信息；</li>
<li>一次新的传送，一定是以一个电平的跳变开始。</li>
</ul>
<h4 id="串并传送"><a href="#串并传送" class="headerlink" title="串并传送"></a>串并传送</h4><ul>
<li>一次传送多个二进制位，但是同时传送的二进制位数小于数据宽度；</li>
<li>按照串行的方式将整个数据宽度传送完。</li>
</ul>
<h2 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h2><p>总线标准：计算机系统的各部件之间利用总线进行信 息传输时应遵守的协议和规范，包括硬件 和软件两个方面。</p>
<h3 id="常见总线标准"><a href="#常见总线标准" class="headerlink" title="常见总线标准"></a>常见总线标准</h3><ul>
<li>ISA（Industrial Standard Architecture）：最早制定的总线技术标 准，总线宽度8/16位，总线频率5~8MHz，总线带宽5~8MB/s。<br><img src="/2019/12/26/系统总线/image-20191226180444002.png" alt="image-20191226180444002"></li>
<li>EISA（Extended Industry Standard Architecture）总线：在ISA总 线的基础上为32位微机开发。</li>
<li>VESA（Video Electronics Standard Association)总线：1992年推， 它的推出为微机系统总线体系结构的革新奠定了基础，该总线系统考 虑到CPU与主存和Cache的直接相连。标准定义了32位数据线，且可 通过扩展槽扩展到64位，使用33MHz时钟频率，最大传输率为 128MB/s~132MB/s。</li>
<li>PCI（Peripheral Component Interconnect）总线：PCI是由Intel 公司1991年推出的总线规范，用于取代ISA；不同于ISA总线，PCI总 线的地址总线与数据总线是分时复用的，支持插即用。<ul>
<li>PCI总线支持10台外设，总线宽度32/64位，总线时钟 频率33.3MHz/66MHz，最大数据传输速率 133/264 MB/s，时钟同步方式，且与CPU的时钟频率无关。</li>
<li>插即用：是指当板卡插入系统时，系统会自动对板卡所需资源进行分 配，如基地址、中断号等，并自动寻找相应的驱动程序；而不象旧的 ISA板卡，需要进行复杂的手动配置。<br><img src="/2019/12/26/系统总线/image-20191226180527801.png" alt="image-20191226180527801"></li>
</ul>
</li>
<li>AGP（Accelerated Graphics Port）总线：是Intel公司1997年推出 的一种3D标准图像接口， 基于PCI2.1版规范并进 行扩充修改而成，它采 用点对点通道方式，能 够提供四倍于PCI的传输 速度。<br><img src="/2019/12/26/系统总线/image-20191226180559822.png" alt="image-20191226180559822"></li>
<li>PCIe（Peripheral Component Interconnect Express）总线：是 Intel公司2001年推出的一种高速串行计算机扩展总线标准，用于替 代PCI、PCI-X和AGP总线。<ul>
<li>PCIe相比以前的标准，有许多改进之外，包括：更高的最大 系统总线吞吐量，更低的I/O引脚数量和更小的物理尺寸，更 好的总线设备性能缩放，更详细的错误检测和报告机制； PCIe标准的更新版本为I/O虚拟化提供了硬件支持。</li>
<li>PCIe有多种不同速度的接口模式，包括：1X、2X、4X、8X、 16X 以及更高速的32X；PCIe 1X 模式的传输速率可以达到 250MB/s，PCIe 2.0 X16 接口能够提供8GB/s的总线带宽。<br><img src="/2019/12/26/系统总线/image-20191226180630424.png" alt="image-20191226180630424"></li>
</ul>
</li>
<li>USB（Universal Serial Bus）总线：是由Intel、Compaq、IBM、 Microsoft等多家公司1994年联合提出的一种通用串行总线。<ul>
<li>采用四线电缆，其中两根是用来传送数据的串行通道，另两根 为下游设备提供电源<br><img src="/2019/12/26/系统总线/image-20191226180817639.png" alt="image-20191226180817639"> </li>
<li>采用级联星型拓扑，由三个基本部分组成：主机（Host），集 线器（Hub）和功能设备<br><img src="/2019/12/26/系统总线/image-20191226180907659.png" alt="image-20191226180907659"></li>
<li>USB 1.1 总线带宽为12Mbps（1.5MB/s），可接入多达127 个设备。</li>
<li>USB 3.1 Gen2 最大传输速率可达10Gbps（1280MB/s）。</li>
<li>USB自推出后，已成功替代串口和并口，并成为个人电脑和大 量智能设备的必配的接口之一。</li>
</ul>
</li>
<li>AMBA（Advanced Microcontroller Bus Architecture）总线：是 ARM公司推出的片上总线；AMBA提供了一种特殊的机制，可将RISC 处理器集成在其它IP核和外设中。<br>AMBA 2.0 标准定义了三组总线<ul>
<li>AHB（Advanced High-Performance Bus）：AMBA高性能总线<br>AHB总线：属于高性能、高时钟频率的系统总线，主要特点包括流水 线操作、数据突发传输（Burst Transfer）、可支持多个总线主设备 （最多16个）、单时钟沿触发操作、总线宽度32、64、128位（最高 可达1024位，但推荐不要超过256位)。</li>
<li>ASB（Advanced System Bus）：AMBA系统总线<br>ASB总线：与AHB相比数据宽度要小一些，支持8、16、32位，且为三 态、双向总线。</li>
<li>APB（Advanced Peripheral Bus）：AMBA外设总线<br>APB总线：是本地二级总线，通过桥和AHB/ASB相连。它主要是为了满 足不需要高性能流水线接口或不需要高带宽接口的设备的互连。<br>AMBA总线结构：<br><img src="/2019/12/26/系统总线/image-20191226181128289.png" alt="image-20191226181128289"></li>
</ul>
</li>
<li>AMBA 4.0 是最新增添到AMBA系列中的规范，增加了三个新接口 协议（Advanced eXtensible Interface）：AXI4有助于最大化性 能和能效、AXI4-Lite和AXI4-Stream是 FPGA中实现的理想选择。<img src="/2019/12/26/系统总线/image-20191226181323636.png" alt="image-20191226181323636"></li>
</ul>
<p>特点：</p>
<ul>
<li>独立的读地址、写地址、读数据、写数据和写确认5个通道</li>
<li>支持乱序传输</li>
<li>支持固定模式突发传输， 主要用于I/O接口</li>
<li>支持系统高速缓存</li>
<li>持增强保护功能</li>
<li>互斥访问（用于semaphore操作</li>
<li>寄存器分片以便于高频操<br>AXI4总线结构：<br><img src="/2019/12/26/系统总线/image-20191226181340500.png" alt="image-20191226181340500"><ul>
<li>InfiniBand总线：是由InfiniBand行业协会推出的，该协会的主要成员 包括Compaq、Dell、HP、IBM、Intel、Microsoft和Sun等公司。</li>
</ul>
</li>
<li>InfiniBand是PCI总线的替代品，采用了与PCI完全不同的架构， 具有极高带宽和灵活的扩展能力，理论带宽分别可以达到 500MB/s、2GB/s和6GB/s。</li>
<li>InfiniBand解决了PCI总线中设备的距离问题，外部设备可以放 到距离服务器很远的地方工作（如果使用的是光缆，最远距离 可以达到0.3~10千米）。</li>
</ul>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>系统总线地址的功能是（<strong>指定主存和I / O设备接口电路的地址</strong>）。</p>
<hr>
<p>异步控制常用于（<strong>在单总线结构计算机中访问主存与外围设备时 </strong>）作为其主要控制方式。</p>
<hr>
<p>描述PCI总线中基本概念正确的句子是（<strong>BCD</strong>）。<br>A.PCI设备一定是主设备<br>B.PCI总线的基本传输机制是猝发式（Burst）传送<br>C.PCI总线是一个与处理器无关的高速外围总线<br>D.系统中可以有多条PCI总线</p>
<hr>
<p>下面叙述中，不正确的是（<strong>ABD</strong>）。<br>A.总线一定要和接口相连<br>B.总线始终由CPU控制和管理<br>C.接口一定要和总线相连<br>D.通道可以替代接口</p>
<hr>
<p>计算机使用总线结构的主要优点是便于实现积木化，同时（<strong>减少了信息传输线的条数</strong>）</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>中央处理器</title>
    <url>/2019/12/25/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h2 id="CPU组成与功能"><a href="#CPU组成与功能" class="headerlink" title="CPU组成与功能"></a>CPU组成与功能</h2><h3 id="CPU概述"><a href="#CPU概述" class="headerlink" title="CPU概述"></a>CPU概述</h3><a id="more"></a>
<p><img src="/2019/12/25/中央处理器/image-20191225231349628.png" alt="image-20191225231349628"></p>
<h3 id="CPU基本组成"><a href="#CPU基本组成" class="headerlink" title="CPU基本组成"></a>CPU基本组成</h3><ul>
<li>运算器 数据加工</li>
<li>控制器 程序执行/执行执行<ul>
<li>取指令 Mem[PC++] -&gt; IR</li>
<li>执行指令 <ul>
<li>指令字 -&gt; 控制信号序列</li>
<li>信号序列 -&gt; 数据通路</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2019/12/25/中央处理器/image-20191225231525021.png" alt="image-20191225231525021"></p>
<h3 id="CPU主要功能"><a href="#CPU主要功能" class="headerlink" title="CPU主要功能"></a>CPU主要功能</h3><p>取指令并执行指令的部件———CPU</p>
<ul>
<li>数据加工:  算术/逻辑运算  运算器</li>
<li>程序控制:  程序中指令执行顺序控制</li>
<li>操作控制:  将机器指令翻译成执行部件所需的操作控制信号</li>
<li>时序控制:  控制操作信号的产生时间、持续时间</li>
<li>异常控制:  异常处理，外设交互<br>后4个为控制器功能</li>
</ul>
<h3 id="主要寄存器"><a href="#主要寄存器" class="headerlink" title="主要寄存器"></a>主要寄存器</h3><ul>
<li>PC (Program Counter)———程序计数器 X86：EIP MIPS：PC</li>
<li>IR  (Instruction Register)———指令寄存器 [可选]</li>
<li>AR  (Address Register)———地址寄存器 MAR [可选]</li>
<li>DR  (Data Register)———数据缓冲寄存器 MDR [可选]</li>
<li>AC  (Accumulate Count)———累加寄存器 [可选]</li>
<li>PSW (Program Status Word)———程序状态字 [可选]<ul>
<li>X86 EFLAGS   MIPS：无</li>
</ul>
</li>
</ul>
<h3 id="操作控制器"><a href="#操作控制器" class="headerlink" title="操作控制器"></a>操作控制器</h3><p>取指令，将机器指令译码并生成执行部件控制信号序列 ，建立正确的数据 通路，从而完成指令的正确执行。</p>
<ul>
<li>硬布线控制器 (时序逻辑型)  (硬件实现)</li>
<li>微程序控制器 (存储程序型)  (软件实现)</li>
</ul>
<h2 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h2><p>数据通路———执行部件间传送信息的路径。</p>
<ul>
<li>通路的建立由控制信号控制，受时钟驱动；</li>
<li>不同指令、同一指令在执行的不同阶段的数据通路不同；</li>
<li>数据通路分类：共享通路（总线）、专用通路<ul>
<li>指令执行流程、执行效率</li>
<li>微操作控制信号的时序安排</li>
</ul>
</li>
</ul>
<h2 id="数据通路与总线结构"><a href="#数据通路与总线结构" class="headerlink" title="数据通路与总线结构"></a>数据通路与总线结构</h2><p>数据通路分类：</p>
<ul>
<li>共享通路（总线型）<ul>
<li>主要部件都连接在公共总线上，各部件间通过总线进行数据传输</li>
<li>结构简单，实现容易，但并发性较差，需分时使用总线，效率低</li>
</ul>
</li>
<li>专用通路<ul>
<li>并发度高，性能佳，设计复杂，成本高</li>
<li>可以看做多总线结构</li>
</ul>
</li>
</ul>
<p>单总线数据通路：<br><img src="/2019/12/25/中央处理器/image-20191225233819137.png" alt="image-20191225233819137"></p>
<p>双总线数据通路：<br><img src="/2019/12/25/中央处理器/image-20191225233848478.png" alt="image-20191225233848478"></p>
<p>三总线数据通路：<br><img src="/2019/12/25/中央处理器/image-20191225233919390.png" alt="image-20191225233919390"></p>
<h2 id="数据通路实例"><a href="#数据通路实例" class="headerlink" title="数据通路实例"></a>数据通路实例</h2><p>单总线CPU：<br><img src="/2019/12/25/中央处理器/image-20191225235209491.png" alt="image-20191225235209491"></p>
<p>多总线CPU：<br><img src="/2019/12/25/中央处理器/image-20191225235241019.png" alt="image-20191225235241019"></p>
<p>专用通路 单周期MIPS：<br><img src="/2019/12/25/中央处理器/image-20191225235310044.png" alt="image-20191225235310044"></p>
<h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><p>指令执行一般流程：<br><img src="/2019/12/25/中央处理器/image-20191226001010996.png" alt="image-20191226001010996"></p>
<p>指令周期基本概念：<br><img src="/2019/12/25/中央处理器/image-20191226001033946.png" alt="image-20191226001033946"></p>
<p>指令控制同步：<br>不同指令功能不同，复杂度不同，如何进行时间控制？</p>
<ul>
<li>定长指令周期：早期三级时序系统<ul>
<li>机器周期数固定，节拍数固定，按机器周期同步，mips单周期</li>
</ul>
</li>
<li>变长指令周期：现代时序系统<ul>
<li>机器周期数可变，节拍数可变，按时钟周期同步，mips多周期</li>
</ul>
</li>
</ul>
<p>早期三级时序系统<br><img src="/2019/12/25/中央处理器/image-20191226001138799.png" alt="image-20191226001138799"></p>
<p>时序产生与控制器：<br><img src="/2019/12/25/中央处理器/image-20191226001211781.png" alt="image-20191226001211781"></p>
<p>现代时序系统：<br><img src="/2019/12/25/中央处理器/image-20191226001239185.png" alt="image-20191226001239185"></p>
<h2 id="总线结构与CPU指令周期"><a href="#总线结构与CPU指令周期" class="headerlink" title="总线结构与CPU指令周期"></a>总线结构与CPU指令周期</h2><p><img src="/2019/12/25/中央处理器/image-20191226002209956.png" alt="image-20191226002209956"></p>
<h3 id="取指令数据通路"><a href="#取指令数据通路" class="headerlink" title="取指令数据通路"></a>取指令数据通路</h3><p><img src="/2019/12/25/中央处理器/image-20191226002222707.png" alt="image-20191226002222707"></p>
<h3 id="LOAD指令执行数据通路"><a href="#LOAD指令执行数据通路" class="headerlink" title="LOAD指令执行数据通路"></a>LOAD指令执行数据通路</h3><p><img src="/2019/12/25/中央处理器/image-20191226002311808.png" alt="image-20191226002311808"></p>
<h3 id="MOVE指令执行数据通路"><a href="#MOVE指令执行数据通路" class="headerlink" title="MOVE指令执行数据通路"></a>MOVE指令执行数据通路</h3><p><img src="/2019/12/25/中央处理器/image-20191226003023840.png" alt="image-20191226003023840"></p>
<h3 id="ADD指令执行数据通路"><a href="#ADD指令执行数据通路" class="headerlink" title="ADD指令执行数据通路"></a>ADD指令执行数据通路</h3><p><img src="/2019/12/25/中央处理器/image-20191226003041973.png" alt="image-20191226003041973"></p>
<h3 id="STORE指令执行数据通路"><a href="#STORE指令执行数据通路" class="headerlink" title="STORE指令执行数据通路"></a>STORE指令执行数据通路</h3><p><img src="/2019/12/25/中央处理器/image-20191226003103363.png" alt="image-20191226003103363"></p>
<h3 id="JMP指令执行数据通路"><a href="#JMP指令执行数据通路" class="headerlink" title="JMP指令执行数据通路"></a>JMP指令执行数据通路</h3><p><img src="/2019/12/25/中央处理器/image-20191226003124517.png" alt="image-20191226003124517"></p>
<h2 id="硬布线控制器设计I"><a href="#硬布线控制器设计I" class="headerlink" title="硬布线控制器设计I"></a>硬布线控制器设计I</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul>
<li>将控制器看成产生固定时序控制信号的逻辑电路</li>
<li>输入信号：指令译码，时钟信号，反馈信号</li>
<li>输出信号：功能部件控制信号序列</li>
<li>设计目标：最少元件，最快速度</li>
<li>理论基础：布尔代数</li>
<li>组成器件：门电路，触发器</li>
</ul>
<p><img src="/2019/12/25/中央处理器/image-20191226004240269.png" alt="image-20191226004240269"></p>
<h3 id="单总线结构CPU指令周期"><a href="#单总线结构CPU指令周期" class="headerlink" title="单总线结构CPU指令周期"></a>单总线结构CPU指令周期</h3><p><img src="/2019/12/25/中央处理器/image-20191226004314609.png" alt="image-20191226004314609"></p>
<p><img src="/2019/12/25/中央处理器/image-20191226004328026.png" alt="image-20191226004328026"></p>
<h3 id="时序产生器状态机与控制器基本架构"><a href="#时序产生器状态机与控制器基本架构" class="headerlink" title="时序产生器状态机与控制器基本架构"></a>时序产生器状态机与控制器基本架构</h3><p><img src="/2019/12/25/中央处理器/image-20191226004422271.png" alt="image-20191226004422271"></p>
<p><img src="/2019/12/25/中央处理器/image-20191226004440469.png" alt="image-20191226004440469"></p>
<p><img src="/2019/12/25/中央处理器/image-20191226004449528.png" alt="image-20191226004449528"></p>
<p>固定指令周期硬布线控制器设计过程</p>
<ol>
<li>设计三级时序产生器： 所有指令固定机器周期数，节拍数，</li>
<li>列出所有机器指令的指令周期流程图，明确每个节拍的控制信号；</li>
<li>找出产生同一微操作控制信号的条件；</li>
<li>写出各微操作控制信号的布尔表达式；</li>
<li>化简各表达式；</li>
<li>利用组合逻辑电路实现。</li>
</ol>
<h2 id="硬布线控制器设计II"><a href="#硬布线控制器设计II" class="headerlink" title="硬布线控制器设计II"></a>硬布线控制器设计II</h2><p>多周期</p>
<p><img src="/2019/12/25/中央处理器/image-20191226005355693.png" alt="image-20191226005355693"></p>
<p><img src="/2019/12/25/中央处理器/image-20191226005414350.png" alt="image-20191226005414350"></p>
<p>有限状态机真值表：<br><img src="/2019/12/25/中央处理器/image-20191226005443176.png" alt="image-20191226005443176"></p>
<p>可变周期硬布线控制器设计步骤</p>
<ol>
<li>列出所有机器指令的指令周 期流程图，明确每个节拍的 控制信号；</li>
<li>绘制指令执行状态转换图</li>
<li>根据状态转换图构建状态机 真值表，实现有限状态机组 合逻辑</li>
<li>实现控制器组合逻辑电路</li>
</ol>
<h2 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h2><p><img src="/2019/12/25/中央处理器/image-20191226141854193.png" alt="image-20191226141854193"></p>
<p>工作原理：</p>
<ul>
<li>微程序是利用软件方法来设计硬件的技术</li>
<li>将完成指令所需的控制信号按格式编写成微指令，存放到控制存储器<ul>
<li>一条机器指令对应一段微程序（多条微指令）</li>
<li>指令取指执行 -&gt; 微程序的执行 -&gt; 执行多条微指令 -&gt; 依次生成控制信号</li>
</ul>
</li>
<li>存储技术和程序设计相结合，回避复杂的同步时序逻辑设计</li>
</ul>
<p>单总线CPU微指令构造</p>
<ul>
<li>操作控制字段： 存储操作控制信号<ul>
<li>每一位对应一个控制信号，也称微命令，可同时给出多个操作信号</li>
</ul>
</li>
<li>顺序控制字段： 用于控制微程序的执行顺序<ul>
<li>判别逻辑为零，下一条微指令地址从下址字段获取，否则按约定规则生成</li>
</ul>
</li>
</ul>
<p><img src="/2019/12/25/中央处理器/image-20191226142125377.png" alt="image-20191226142125377"></p>
<p><img src="/2019/12/25/中央处理器/image-20191226142140226.png" alt="image-20191226142140226"></p>
<p>优劣：</p>
<ul>
<li>速度慢 访存频繁、成本低廉</li>
<li>设计规整，设计简单，易于修改、扩展指令系统功能<ul>
<li>适合CISC等功能较复杂的系列机 X86、IBM S/360、 DEC VAX</li>
<li>可写控存方便修复出厂故障 Intel Core 2 、Intel Xeon</li>
</ul>
</li>
<li>硬布线控制器执行速度快，但设计复杂，代价昂贵，不便于修改<ul>
<li>适合RISC计算机，如MIPS，ARM</li>
</ul>
</li>
</ul>
<h2 id="微程序设计"><a href="#微程序设计" class="headerlink" title="微程序设计"></a>微程序设计</h2><ul>
<li>一条微指令对应一个时钟周期</li>
<li>微指令操作控制字段的信号在该时钟周期内有效</li>
<li>指令需要多少时钟周期就包括多少微指令</li>
</ul>
<p><img src="/2019/12/25/中央处理器/image-20191226143130682.png" alt="image-20191226143130682"></p>
<h2 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h2><p>设计原则：</p>
<ul>
<li>有利于缩短微指令字长度</li>
<li>有利于减少控制存储器容量</li>
<li>有利于提高微程序执行速度</li>
<li>有利于对微指令进行修改</li>
<li>有利于提高微程序设计的灵活性</li>
</ul>
<p>直接表示简单直观，便于输出控制，微指令长度太长，控存容量大，如何压缩微指令长度？</p>
<ul>
<li>改直接表示为编码表示 （压缩互斥性微指令）</li>
<li>去掉下址字段，采用 μPC = μPC +1 的方式生成微指令地址</li>
<li>改水平型微指令为垂直型微指令 （牺牲并行性）</li>
</ul>
<p><img src="/2019/12/25/中央处理器/image-20191226144718065.png" alt="image-20191226144718065"></p>
<p>如果互斥的输出控制信号8个，编码后长度多少？<br>至少为4，预留一个状态表示所有状态输出为0</p>
<p><img src="/2019/12/25/中央处理器/image-20191226145046465.png" alt="image-20191226145046465"></p>
<p>垂直型微指令：<br><img src="/2019/12/25/中央处理器/image-20191226145128307.png" alt="image-20191226145128307"></p>
<ul>
<li>水平型微指令<ul>
<li>并行操作能力强，效率高，灵活性强，</li>
<li>微指令字较长，微程序短，控存容量大，性能佳</li>
</ul>
</li>
<li>垂直型微指令<ul>
<li>字长短，微程序长，控存容量小，性能差</li>
<li>垂直型与指令相似，易于掌握</li>
<li>基本被淘汰</li>
</ul>
</li>
</ul>
<h2 id="单周期MIPS-CPU"><a href="#单周期MIPS-CPU" class="headerlink" title="单周期MIPS CPU"></a>单周期MIPS CPU</h2><p>MIPS CPU控制器设计：</p>
<ul>
<li>定长指令周期：单周期实现<ul>
<li>所有指令均在一个时钟周期内完成， CPI=1</li>
<li>性能取决于最慢的指令，时钟周期过长</li>
</ul>
</li>
<li>变长指令周期：多周期实现<ul>
<li>缩短时钟周期，复用器件或数据通路</li>
<li>可支持流水操作，提升性能</li>
</ul>
</li>
</ul>
<p>R型指令格式<br><img src="/2019/12/25/中央处理器/image-20191226151355789.png" alt="image-20191226151355789"></p>
<p>I型指令格式<br><img src="/2019/12/25/中央处理器/image-20191226151416087.png" alt="image-20191226151416087"></p>
<p>数据通路：<br><img src="/2019/12/25/中央处理器/image-20191226151503460.png" alt="image-20191226151503460"></p>
<p> R型指令数据通路建立过程<br><img src="/2019/12/25/中央处理器/image-20191226151635760.png" alt="image-20191226151635760"></p>
<p>LW指令数据通路建立过程<br><img src="/2019/12/25/中央处理器/image-20191226151658900.png" alt="image-20191226151658900"></p>
<p>SW指令数据通路建立过程<br><img src="/2019/12/25/中央处理器/image-20191226151719963.png" alt="image-20191226151719963"></p>
<p>BEQ指令数据通路建立过程<br><img src="/2019/12/25/中央处理器/image-20191226151736211.png" alt="image-20191226151736211"></p>
<p>MIPS控制器设计：</p>
<ul>
<li>单周期控制器无时序逻辑，纯组合逻辑电路</li>
<li>输入信号<ul>
<li>指令字Opcode，Func字段（12位）</li>
</ul>
</li>
<li>输出信号<ul>
<li>多路选择器选择信号</li>
<li>内存访问控制信号</li>
<li>寄存器写使能信号</li>
</ul>
</li>
</ul>
<p><img src="/2019/12/25/中央处理器/image-20191226151829362.png" alt="image-20191226151829362"></p>
<h2 id="多周期MIPS-CPU"><a href="#多周期MIPS-CPU" class="headerlink" title="多周期MIPS CPU"></a>多周期MIPS CPU</h2><p>多周期MIPS数据通路特点</p>
<ul>
<li>不再区分指令存储器和数据存储器，分时使用部分功能部件</li>
<li>主要功能单元输出端增加寄存器锁存数据</li>
<li>传输通路延迟变小，时钟周期变短</li>
</ul>
<p>多周期MIPS CPU数据通路：<br><img src="/2019/12/25/中央处理器/image-20191226153829403.png" alt="image-20191226153829403"></p>
<p>多周期MIPS取指令阶段T1<br><img src="/2019/12/25/中央处理器/image-20191226153856881.png" alt="image-20191226153856881"></p>
<p>多周期MIPS取指令阶段T2<br><img src="/2019/12/25/中央处理器/image-20191226153913682.png" alt="image-20191226153913682"></p>
<p>R型指令执行状态周期T3~T4<br><img src="/2019/12/25/中央处理器/image-20191226154005989.png" alt="image-20191226154005989"></p>
<p>LW指令执行状态周期T3~T5<br><img src="/2019/12/25/中央处理器/image-20191226154026467.png" alt="image-20191226154026467"></p>
<p>Beq指令执行状态周期T3<br><img src="/2019/12/25/中央处理器/image-20191226154040788.png" alt="image-20191226154040788"></p>
<p>多周期状态转换图<br><img src="/2019/12/25/中央处理器/image-20191226154127994.png" alt="image-20191226154127994"></p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>冯•诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU依据（<strong>指令和数据的访问时间不同</strong> ）来区分它们</p>
<p>虽然指令和数据都是以二进制形式存放在存储器中，但 CPU 可以根据指令周期的不同阶段来区分是指令还是数据，通常在取指阶段取出的是指令，在执行阶段取出的是数据。本题容易误选 A ，需要清楚的是， CPU 只有在确定取出的是指令之后，才会将其操作码送去译码，因此，不可能依据译码的结果来区分指令和数据。</p>
<hr>
<p>某计算机指令集中包含有RR型运算指令、访存指令Load、Store、分支指令Branch和跳转指令Jump。若采用单周期数据通路实现该指令系统，若指令存储器和数据存储器的时延都是3ns;ALU时延为2ns;寄存器文件读写时延都是1ns。在不考虑多路复用器、控制单元、PC、符号扩展单元和传输线路等延迟的情况下，该计算机时钟周期至少为<strong>10ns</strong></p>
<p>单周期取指令3ns，访问寄存器文件1ns，计算需要ALU2ns，然后写入数据存储器3ns，然后在写回寄存器1ns</p>
<hr>
<p>下列有关指令周期的叙述中，正确的是（<strong>ACD</strong>）。（多选）<br>A.单周期CPU中的指令周期就是一个时钟周期<br>B.乘法指令和加法指令的指令周期总是一样长<br>C.指令周期的第一个阶段一定是取指令阶段<br>D.一个指令周期可由若干个机器周期或时钟周期组成</p>
<hr>
<p>下列寄存器中，对汇编语言程序员不透明的是（<strong>C</strong>）（单选）<br>A.程序计数器(PC)<br>B.存储器地址寄存器(MAR)<br>C.条件状态寄存器<br>D.存储器数据寄存器(MDR)</p>
<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>指令系统</title>
    <url>/2019/12/25/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="指令系统概述及指令格式"><a href="#指令系统概述及指令格式" class="headerlink" title="指令系统概述及指令格式"></a>指令系统概述及指令格式</h2><h3 id="指令的基本概念"><a href="#指令的基本概念" class="headerlink" title="指令的基本概念"></a>指令的基本概念</h3><ul>
<li>指令<ul>
<li>计算机能直接识别、执行的操作命令（机器指令）；</li>
<li>冯诺依曼结构计算机 “程序控制”原理实现的载体；</li>
</ul>
</li>
<li>指令系统（指令集）<a id="more"></a><ul>
<li>一台计算机中所有机器指令的集合；</li>
<li>系列机：同一公司不同时期生产，基本系统结构和指令系统相同的计算机。 如IBM，PDP-11，VAX-11，Intel-x86</li>
<li>兼容机：不同公司生产，基本系统结构和指令系统相同的计算机。 如IBM兼容机</li>
</ul>
</li>
<li>指令字长<ul>
<li>指令中包含的二进制位数 </li>
<li>与机器字长相比:   单字长、双字长、半字长等长度指令 </li>
<li>多字长指令：<ul>
<li>解决寻址较大存储空间的问题 </li>
<li>取指多次访问内存，影响速度，占用空间大</li>
</ul>
</li>
<li>等长指令: 指令字长度固定。</li>
<li>变长指令: 指令字长度根据需要可变</li>
</ul>
</li>
</ul>
<h3 id="指令分类"><a href="#指令分类" class="headerlink" title="指令分类"></a>指令分类</h3><p><img src="/2019/12/25/指令系统/image-20191225115956648.png" alt="image-20191225115956648"></p>
<p><img src="/2019/12/25/指令系统/image-20191225120008896.png" alt="image-20191225120008896"></p>
<p>根据指令中操作数的物理位置分类:</p>
<ul>
<li>存储器－存储器（SS）型</li>
<li>寄存器－寄存器（RR）型 </li>
<li>寄存器－存储器（RS）型</li>
</ul>
<p>根据指令功能分类：</p>
<ul>
<li>传送指令 MOV 、PUSH/POP、 IN/OUT等 </li>
<li>定点算术运算指令 ADD、SUB、INC、CMP、MUL等 </li>
<li>位运算指令 NOT、AND、OR、SHL、SAL等 </li>
<li>控制转移指令 JMP 、JNE、CALL、RET等</li>
</ul>
<h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><p><img src="/2019/12/25/指令系统/image-20191225120247603.png" alt="image-20191225120247603"></p>
<ul>
<li>操作码字段的位数与支持的最大指令数量有关 <ul>
<li>对于定长操作码而言，LengthOP =⌈log2 n⌉</li>
<li>支持变长操作码时，操作码向不用的地址码字段扩展</li>
</ul>
</li>
<li>寻址方式字段的位数与支持的寻址方式种类有关 </li>
<li>地址码字段的作用及影响与其位数和寻址方式有关</li>
</ul>
<h2 id="寻址方式及指令寻址"><a href="#寻址方式及指令寻址" class="headerlink" title="寻址方式及指令寻址"></a>寻址方式及指令寻址</h2><p>指令的顺序寻址</p>
<ul>
<li>程序的指令序列在主存顺序存放。执行时从第一条指令开始(!)，逐 条取出并执行，这种程序的顺序执行过程，称为顺序寻址方式。</li>
<li>CPU中设置程序计数器（PC）对指令的顺序号进行计数。PC开始时存 放程序的首地址，每执行一条指令，PC 加”1”，指出下条指令的地址， 直到程序结束。<ul>
<li>存储1条指令占用的字节单元数与存储字长有关！</li>
</ul>
</li>
</ul>
<p>跳跃寻址：<br><img src="/2019/12/25/指令系统/image-20191225123815326.png" alt="image-20191225123815326"></p>
<h2 id="操作数寻址方式"><a href="#操作数寻址方式" class="headerlink" title="操作数寻址方式"></a>操作数寻址方式</h2><h3 id="立即数寻址"><a href="#立即数寻址" class="headerlink" title="立即数寻址"></a>立即数寻址</h3><p>地址码字段是操作数本身<br>例 MOV  AX,200H    （ AX &lt;-  200H）<br>特点：</p>
<ul>
<li>取指操作将数据与指令一并读入CPU内部的寄存器，指令执行速度快 </li>
<li>便于程序设计（变量赋初值） </li>
<li>数据大小受字段位数限制</li>
</ul>
<h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>操作数在CPU内部的寄存器中<br>例 MOV  AX, BX    （ AX &lt;-  ( BX）)<br>特点： </p>
<ul>
<li>操作数在寄存器中，指令执行速度快 </li>
<li>能访问的数据大小一般与计算机字长有关 </li>
<li>地址字段的位数与计算机通用寄存器数量相关</li>
</ul>
<h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>地址码字段直接给出操作数在内存的地址.  E=D, S=(D)<br>例 MOV  AX, [200H]<br>特点：</p>
<ul>
<li>提供访问主存的操作 </li>
<li>获得数据要访问主存，指令执行速度慢 </li>
<li>地址字段的位数决定了访存空间大小</li>
</ul>
<h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>地址码字段给出的是操作数主存地址的地址.  E=(D), S= ((D))<br>例 MOV  AX, I[200H]<br>特点：</p>
<ul>
<li>获得数据要访问主存2次，指令执行速度太慢 </li>
<li>解决了直接寻址方式下地址字段的位数限制访存范围大小的问题</li>
</ul>
<h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p>地址码字段给出的是寄存器编号R.  E=(R), S= ((R))<br>例 MOV  AX, [BX]<br>特点：</p>
<ul>
<li>获得数据只需访问主存1次 </li>
<li>解决了直接寻址方式下地址字段的位数限制访存范围大小的问题</li>
</ul>
<h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><p>E=D + (PC), D为指令中地址字段的值特点：</p>
<p><img src="/2019/12/25/指令系统/image-20191225130335074.png" alt="image-20191225130335074"></p>
<ul>
<li>注意PC的改变对计算E的影响，如 本例中E = 200 + 2000 + 2 </li>
<li>可节省指令中的地址位数，便于程序在内存中成块移动</li>
</ul>
<p>例 某计算机采用双字节长指令,内存基于字节寻址,指令中的数据采用补码表示,且PC 的值在取指阶段完成修改。<br>1)若某采用相对寻址指令的当前地址为2003H,且要求转移后的目标地址为200AH, 则该指令形式地址字段的值为多少?<br>2)2)若某采用相对寻址的指令的当前地址为2008H,且要求转移后的目标地址为2001H, 则该指令的形式地址字段的值为多少?<br>解: 1)200AH – (2003H +2) = 5 (0000 0101)<br>2)2001H – (2008H +2) = -9 (1111 0111 即F7H)<br>若计算机字长32位, 且PC的值在取指阶段修改,情况如何?<br>+2变为+4</p>
<h3 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h3><p>指定一个基址寄存器B，与本指令地址无关 E= D + (B), D为指令中地址字段的值<br>MOV AX, 32[B]<br>特点：</p>
<ul>
<li>对某一程序而言，基址值设定后不变，故要访问不同数据需修改D </li>
<li>使用基址寄存器可以访问更大的主存空间</li>
</ul>
<h3 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h3><p>指定一个变址寄存器X，与本指令地址无关, 内容可随要求改变， E= D + (X), D为指令中地址字段的值<br>MOV AX, 32[SI]                 SI,DI 都称为变址寄存器<br>特点： </p>
<ul>
<li>不改变指令即可改变数据的有效地址，可在循环中使用 </li>
<li>在字符串处理，向量运算等等成批数据处理中非常有用</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2019/12/25/指令系统/image-20191225130635792.png" alt="image-20191225130635792"></p>
<h2 id="指令格式设计"><a href="#指令格式设计" class="headerlink" title="指令格式设计"></a>指令格式设计</h2><h3 id="指令格式设计主要内容"><a href="#指令格式设计主要内容" class="headerlink" title="指令格式设计主要内容"></a>指令格式设计主要内容</h3><ul>
<li>根据指令数量的要求及是否支持操作码扩展，确定操作码字段的位数</li>
<li>根据对操作数的要求确定地址码字段的个数 </li>
<li>根据寻址方式的要求，为每个地址码字段确定寻址方式字段位数 </li>
<li>确定采用定长指令还是变长指令</li>
</ul>
<h3 id="指令格式设计举例"><a href="#指令格式设计举例" class="headerlink" title="指令格式设计举例"></a>指令格式设计举例</h3><p>某机字长32位，采用三地址指令，支持8种寻址操作，完成60种操作，各 寻址方式均可在2K主存范围内取得操作数，并可在1K范围内保存运算结果。 问应采用什么样的指令格式？指令字长最少应为多少位？执行一条指令最多要 访问多少次主存？</p>
<p><img src="/2019/12/25/指令系统/image-20191225131913595.png" alt="image-20191225131913595"></p>
<hr>
<p>字长16位，主存64K，指令单字长单地址，80条指令。寻址方式有直接、 间接、相对、变址。请设计指令格式</p>
<p><img src="/2019/12/25/指令系统/image-20191225131937862.png" alt="image-20191225131937862"></p>
<p><img src="/2019/12/25/指令系统/image-20191225132001888.png" alt="image-20191225132001888"></p>
<hr>
<p>设某指令系统指令字长16位，每个地址码为6位。若要求设计二地址指令15 条、一地址指令34条，问最多还可设计多少条零地址指令？<br>解: OP(4) A1(6) A2(6)<br>操作码按从短码到长码进行扩展编码<br>假定二地址指令编码: (0000 – 1110)  共15条，1111作为扩展标识； 则一地址指令编码的全集可表示为: 1111 000000 – 111111(假定扩向A1)； 因一地址指令只需34条，可将全集中多余的30种编码作为向零地址指 令扩展的标识，假定为: 100010 – 111111 故最多可支持的故零地址指令数为： 30*2^6 条</p>
<h2 id="MIPS-指令概述"><a href="#MIPS-指令概述" class="headerlink" title="MIPS 指令概述"></a>MIPS 指令概述</h2><h3 id="MIPS-指令概述-1"><a href="#MIPS-指令概述-1" class="headerlink" title="MIPS 指令概述"></a>MIPS 指令概述</h3><ul>
<li>MIPS (Microprocessor without Intellocked Pipleline Stages)是80年代初期由斯 坦福大学Hennessy教授领导的研究小组研制成功； Million Instructions Per Second </li>
<li>属于精简指令集计算机RISC(Reduced Instruction Set Computer)；-&gt; 复杂指令集计算机CISC(Complex Instruction Set Computer )；</li>
<li>MIPS指令集有MIPS I，MIPS II，MIPS III，MIPS IV，MIPS V，MIPS32，和 MIPS64多个版本;</li>
<li>早期主要用于嵌入式系统，如Windows CE的设备，路由器，家用网关和视频游 戏机，现在已经在PC机、服务器中得到广泛应用</li>
</ul>
<p>MIPS指令集有以下特点： </p>
<ul>
<li>简单的Load/Store结构 </li>
<li>易于流水线CPU设计 </li>
<li>易于编译器开发 </li>
<li>MIPS指令的寻址方式非常简单，每条指令的操作也非常简单</li>
</ul>
<h3 id="MIPS指令格式概述"><a href="#MIPS指令格式概述" class="headerlink" title="MIPS指令格式概述"></a>MIPS指令格式概述</h3><p><img src="/2019/12/25/指令系统/image-20191225143633747.png" alt="image-20191225143633747"></p>
<h3 id="MIPS-寄存器"><a href="#MIPS-寄存器" class="headerlink" title="MIPS 寄存器"></a>MIPS 寄存器</h3><p><img src="/2019/12/25/指令系统/image-20191225143652075.png" alt="image-20191225143652075"></p>
<h3 id="MIPS-寻址方式"><a href="#MIPS-寻址方式" class="headerlink" title="MIPS 寻址方式"></a>MIPS 寻址方式</h3><ul>
<li>在MIPS32指令集中，不单设寻址方式说明字段<br><img src="/2019/12/25/指令系统/image-20191225143724205.png" alt="image-20191225143724205"></li>
<li>立即数寻址 ( Immediate addressing)<br><img src="/2019/12/25/指令系统/image-20191225143754663.png" alt="image-20191225143754663"></li>
<li>寄存器直接寻址(Register Addressing)<br><img src="/2019/12/25/指令系统/image-20191225143826805.png" alt="image-20191225143826805"></li>
<li>基址寻址(Basic Addressing)<br><img src="/2019/12/25/指令系统/image-20191225143858053.png" alt="image-20191225143858053"><br>使用基址寻址的指令：lw ,sw, lh, sh, lb, lbu等<br>LB rt , offset (base)</li>
<li>相对寻址<br><img src="/2019/12/25/指令系统/image-20191225143956018.png" alt="image-20191225143956018"><br>使用相对寻址的指令：beq, bne<br>if (GRP[rs] == GPR[rt]) PC = PC + 4 + BranchAddr</li>
<li>伪直接寻址(页面寻址)<br><img src="/2019/12/25/指令系统/image-20191225144037090.png" alt="image-20191225144037090"><br>使用伪直接寻址的指令：j, jal</li>
</ul>
<h2 id="MIPS指令详解"><a href="#MIPS指令详解" class="headerlink" title="MIPS指令详解"></a>MIPS指令详解</h2><h3 id="R型指令"><a href="#R型指令" class="headerlink" title="R型指令"></a>R型指令</h3><p><img src="/2019/12/25/指令系统/image-20191225145613421.png" alt="image-20191225145613421"></p>
<p>操作数和保存结果均通过寄存器进行； </p>
<ul>
<li>op：操作码，所有R型指令中都全为0； </li>
<li>rs：寄存器编号，对应第1个源操作数； </li>
<li>rt：寄存器编号，对应第2个源操作数； </li>
<li>rd：寄存器编号，据此保存结果； </li>
<li>shamt：常数，在移位指令中使用； </li>
<li>funct：功能码，指定指令的具体功能；</li>
</ul>
<p><img src="/2019/12/25/指令系统/image-20191225145707263.png" alt="image-20191225145707263"></p>
<h4 id="3寄存器R型指令"><a href="#3寄存器R型指令" class="headerlink" title="3寄存器R型指令"></a>3寄存器R型指令</h4><p><img src="/2019/12/25/指令系统/image-20191225145743811.png" alt="image-20191225145743811"></p>
<h4 id="2寄存器R型指令"><a href="#2寄存器R型指令" class="headerlink" title="2寄存器R型指令"></a>2寄存器R型指令</h4><p><img src="/2019/12/25/指令系统/image-20191225145805858.png" alt="image-20191225145805858"></p>
<h4 id="1寄存器R型指令"><a href="#1寄存器R型指令" class="headerlink" title="1寄存器R型指令"></a>1寄存器R型指令</h4><p><img src="/2019/12/25/指令系统/image-20191225145825365.png" alt="image-20191225145825365"></p>
<h3 id="I型指令"><a href="#I型指令" class="headerlink" title="I型指令"></a>I型指令</h3><p><img src="/2019/12/25/指令系统/image-20191225145843032.png" alt="image-20191225145843032"></p>
<p>操作数中涉及立即数，结果保存到寄存器； </p>
<ul>
<li>op：标识指令的操作功能； </li>
<li>rs：第1个源操作数，是寄存器操作数；</li>
<li>rt：目的寄存器编号，用来保存运算结果； </li>
<li>imm：第2个源操作数，立即数；</li>
</ul>
<p><img src="/2019/12/25/指令系统/image-20191225145942182.png" alt="image-20191225145942182"></p>
<h4 id="面向运算的I型指令"><a href="#面向运算的I型指令" class="headerlink" title="面向运算的I型指令"></a>面向运算的I型指令</h4><p><img src="/2019/12/25/指令系统/image-20191225150005890.png" alt="image-20191225150005890"></p>
<h4 id="面向访存的I型指令"><a href="#面向访存的I型指令" class="headerlink" title="面向访存的I型指令"></a>面向访存的I型指令</h4><p><img src="/2019/12/25/指令系统/image-20191225150028541.png" alt="image-20191225150028541"></p>
<h4 id="面向数位设置的I型指令"><a href="#面向数位设置的I型指令" class="headerlink" title="面向数位设置的I型指令"></a>面向数位设置的I型指令</h4><p><img src="/2019/12/25/指令系统/image-20191225150115338.png" alt="image-20191225150115338"></p>
<h4 id="面向条件转移-分支-的I型指令"><a href="#面向条件转移-分支-的I型指令" class="headerlink" title="面向条件转移(分支)的I型指令"></a>面向条件转移(分支)的I型指令</h4><p><img src="/2019/12/25/指令系统/image-20191225150151595.png" alt="image-20191225150151595"></p>
<h3 id="J型指令"><a href="#J型指令" class="headerlink" title="J型指令"></a>J型指令</h3><p><img src="/2019/12/25/指令系统/image-20191225150223733.png" alt="image-20191225150223733"></p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>存储系统II</title>
    <url>/2019/12/24/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FII/</url>
    <content><![CDATA[<h2 id="多体交叉存储器"><a href="#多体交叉存储器" class="headerlink" title="多体交叉存储器"></a>多体交叉存储器</h2><a id="more"></a>
<p><img src="/2019/12/24/存储系统II/image-20191224210559403.png" alt="image-20191224210559403"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224210607265.png" alt="image-20191224210607265"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224210614243.png" alt="image-20191224210614243"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224210623500.png" alt="image-20191224210623500"></p>
<h2 id="Cache的基本原理"><a href="#Cache的基本原理" class="headerlink" title="Cache的基本原理"></a>Cache的基本原理</h2><p><img src="/2019/12/24/存储系统II/image-20191224212037889.png" alt="image-20191224212037889"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224212100127.png" alt="image-20191224212100127"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224212112439.png" alt="image-20191224212112439"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224212119403.png" alt="image-20191224212119403"></p>
<h2 id="组相联存储器"><a href="#组相联存储器" class="headerlink" title="组相联存储器"></a>组相联存储器</h2><p><img src="/2019/12/24/存储系统II/image-20191224212557005.png" alt="image-20191224212557005"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224212604189.png" alt="image-20191224212604189"></p>
<h2 id="Cache地址映射与变换方法"><a href="#Cache地址映射与变换方法" class="headerlink" title="Cache地址映射与变换方法"></a>Cache地址映射与变换方法</h2><h3 id="全相联"><a href="#全相联" class="headerlink" title="全相联"></a>全相联</h3><p><img src="/2019/12/24/存储系统II/image-20191224215252084.png" alt="image-20191224215252084"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224215303023.png" alt="image-20191224215303023"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224215314152.png" alt="image-20191224215314152"></p>
<p>特点：</p>
<ul>
<li>Cache利用率高</li>
<li>块冲突率低</li>
<li>淘汰算法复杂<br>应用场合：小容量Cache</li>
</ul>
<h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p><img src="/2019/12/24/存储系统II/image-20191224215413222.png" alt="image-20191224215413222"><img src="/2019/12/24/存储系统II/image-20191224215413308.png" alt="image-20191224215413308"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224215420100.png" alt="image-20191224215420100"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224215430954.png" alt="image-20191224215430954"></p>
<p>特点：<br>特点：</p>
<ul>
<li>Cache利用率低</li>
<li>块冲突率高</li>
<li>淘汰算法简单<br>应用场合：大容量Cache</li>
</ul>
<h3 id="组相联"><a href="#组相联" class="headerlink" title="组相联"></a>组相联</h3><p><img src="/2019/12/24/存储系统II/image-20191224215513463.png" alt="image-20191224215513463"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224215520381.png" alt="image-20191224215520381"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224215526406.png" alt="image-20191224215526406"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224215532554.png" alt="image-20191224215532554"></p>
<h2 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h2><h3 id="先进先出-（First-in-First-out）"><a href="#先进先出-（First-in-First-out）" class="headerlink" title="先进先出-（First in First out）"></a>先进先出-（First in First out）</h3><p><img src="/2019/12/24/存储系统II/image-20191224221407980.png" alt="image-20191224221407980"></p>
<h3 id="最不经常使用法-LFU-（Least-Frequently-Used"><a href="#最不经常使用法-LFU-（Least-Frequently-Used" class="headerlink" title="最不经常使用法-LFU （Least Frequently Used )"></a>最不经常使用法-LFU （Least Frequently Used )</h3><p><img src="/2019/12/24/存储系统II/image-20191224221454348.png" alt="image-20191224221454348"></p>
<h3 id="近期最少使用法—-LRU-Least-recently-used"><a href="#近期最少使用法—-LRU-Least-recently-used" class="headerlink" title="近期最少使用法—- LRU(Least recently used )"></a>近期最少使用法—- LRU(Least recently used )</h3><p><img src="/2019/12/24/存储系统II/image-20191224221523084.png" alt="image-20191224221523084"></p>
<h2 id="Cache例题选讲"><a href="#Cache例题选讲" class="headerlink" title="Cache例题选讲"></a>Cache例题选讲</h2><p>假定主存和Cache之间采用直接映射方式，块大小为16B。Cache数据区容量 为64KB，主存地址为32位，按字节编址，数据字长32位。要求 1)给出直接映射方式下主存地址划分 2)完成Cache访问的硬件实现 3)计算Cache容量<br>解：1)由题目条件知：<br>数据块大小16B  -&gt;   块内偏移地址4位；<br>Cache数据区容量为64KB -&gt;  64KB/16B = 4096行Cache）；-&gt; Index字段12位<br>Tag字段的位数为 32- 12 - 4 =16位（Tag）<br>由第一问的解答可知：Tag 为16 bit<br>由题目条件及Cache的工作原理知： Cache每行数据存储体容量为 16<em>8 = 128 bit<br>Cache 每行的总存储容量为： 1+ 16 + 128 = 145 bit<br>Cache 总容量为：4096 \</em>（1+16 +128）= 580Kbit<br><img src="/2019/12/24/存储系统II/image-20191224224643640.png" alt="image-20191224224643640"></p>
<p>设某机内存容量为16MB,Cache的容量16KB,每块8个字,每个字32位.设计一个四 路组相联映射(即Cache内每组包含4个字块)的Cache组织方式。<br>1）求满足组相联映射的主存地址字段中各字段的位数<br>2)设Cache的初态为空,CPU从主存第0号单元开始连续访问100个字(主存一次读出一 个字),重复此次序读8次,求存储访问的命中率<br>3)若Cache的速度是主存速度的6倍,求存储系统访问加速比</p>
<p><img src="/2019/12/24/存储系统II/image-20191224224843910.png" alt="image-20191224224843910"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224224850389.png" alt="image-20191224224850389"><br>3）设Cache的存取周期为t，则主存存取周期为6t<br>直接从内存读取所有数据所需时间为: Tnc = 800*6t = 4800t<br>通过Cache访问800个数据的时间为: Tc = 13*6t +(800-13)*t = 865t<br>存储系统访问的加速比 S = Tnc/Tc =( 4800t/865t) = 5.5</p>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><ul>
<li>处于主存 –辅存存储层次</li>
<li>解决主存容量不足的问题，为程序设计者提供比主存空间大的编程空间</li>
<li>分类：页式虚拟存储器、段式虚拟存储器 、段页式虚拟存储器</li>
</ul>
<p>采用MMU(Memory Management Unit):管理虚拟存储器与物理存储器<br>采用页表来判断CPU要访问的内容是否在主存，并与MMU配合实现 逻辑地址与物理地址之间的转换？</p>
<p><img src="/2019/12/24/存储系统II/image-20191224231716146.png" alt="image-20191224231716146"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224231728581.png" alt="image-20191224231728581"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224231739198.png" alt="image-20191224231739198"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224232305422.png" alt="image-20191224232305422"></p>
<h2 id="TLB-Translation-Lookaside-Buffer"><a href="#TLB-Translation-Lookaside-Buffer" class="headerlink" title="TLB (Translation Lookaside Buffer)"></a>TLB (Translation Lookaside Buffer)</h2><p>虚实地址转换过程中存在的问题</p>
<p><img src="/2019/12/24/存储系统II/image-20191224233435375.png" alt="image-20191224233435375"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224233447289.png" alt="image-20191224233447289"></p>
<h3 id="TLB工作原理"><a href="#TLB工作原理" class="headerlink" title="TLB工作原理"></a>TLB工作原理</h3><ul>
<li><p>根据局部性原理，增加一个小容量、高速存储部件存放当前访问页表地址变换条 目，该存储部件称为TLB(Translation Lookaside Buffer:地址转换后备缓冲器)。</p>
</li>
<li><p>TLB类似页表，也是PTE的集合。为实现对TLB的快速访问，类似于Cache中的映射方法， 对来自于CPU的虚页号进行逻辑划分，得到相应的标记和索引字段。</p>
</li>
</ul>
<p><img src="/2019/12/24/存储系统II/image-20191224233533276.png" alt="image-20191224233533276"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224233543726.png" alt="image-20191224233543726"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224233559705.png" alt="image-20191224233559705"></p>
<h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><p>Redundant Arrays of Independent Disks：独立磁盘冗余阵列<br>核心技术：</p>
<ul>
<li>将数据条带化后的存放在不同磁盘上，通过多磁盘的并行操作提高磁 盘系统的读写速率；</li>
<li>使用基于异或运算为基础的校验技术恢复损坏的数据</li>
</ul>
<p><img src="/2019/12/24/存储系统II/image-20191224235157669.png" alt="image-20191224235157669"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224235206899.png" alt="image-20191224235206899"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224235212960.png" alt="image-20191224235212960"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224235218656.png" alt="image-20191224235218656"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224235224206.png" alt="image-20191224235224206"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224235229473.png" alt="image-20191224235229473"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224235234864.png" alt="image-20191224235234864"></p>
<p><img src="/2019/12/24/存储系统II/image-20191224235241651.png" alt="image-20191224235241651"></p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>以下关于虚拟存储管理地址转换的叙述中错误的是（<strong>C</strong>）<br>A.MMU在地址转换过程中要访问页表项<br>B.地址转换过程中可能会发生“缺页”<br>C.一般来说，逻辑地址比物理地址的位数少<br>D.地址转换是指把逻辑地址转换为物理地址</p>
<p>假定主存按字节编址，cache共有64行，采用4路组相联映射方式，主存块大小为32字节，所有编号都从0开始。问主存第3000号单元所在主存块对应的cache组号是<strong>13</strong></p>
<p>主存第3000号单元，一个主存块为32字节，故有3000/32 = 93余24，因此在第94块上，又因为编号从0开始，因此在编号为93的块中，因为 Cache有64行，一组有4行，因此 C =16 组，所以i =93mod16 = 13</p>
<p>下列关于CaChe的说法中，错误的是（ <strong>C</strong>    ）<br>A.CaChe行大小与主存块大小一致<br>B.<strong>分离CaChe(也称哈佛结构)是指存放指令的CaChe与存放数据CaChe分开设置</strong><br>C.读操作也要考虑CaChe与主存的一致性问题<br>D.CaChe对程序员透明</p>
<p>下列关于命中组合的情况中，一次访存过程中可能发生的是(<strong>acd</strong>)。</p>
<p>A．TLB未命中，CaChe命中，Page未命中<br>B．TLB未命中，CaChe未命中，Page命中<br>C．TLB命中，CaChe命中，Page未命中<br>D．TLB命中，CaChe未命中，Page未命中</p>
<p>因此，TLB命中，页表一定命中；TLB不命中，页表可能命中可能不命中；页表命中，TLB可能命中也可能不命中；页表不命中，TLB一定不命中。<br>TLB和页表命中与否与Cache无关。</p>
<p>虚拟存储器中， 程序执行过程中实现虚拟地址到物理地址映射部件（系统）是 <strong>操作系统和MMU配合完成</strong></p>
<p>相联存储器是按(<strong>内容指定方式</strong> )进行寻址的存储器。</p>
<p>关于cache存储器，下面的叙述中正确的是 (<strong>D</strong>) 。</p>
<p>A．cache存储器是内存中的一个特定区域<br>B．cache存储器的存取速度介于内存和磁盘之间<br>C．cache存储器中存放的内容是内存的备份<br>D．<strong>cache存储器存放正在处理的部分指令和数据</strong>/</p>
<p>一个组相联高速缓存由64个字块组成，每个字块有256字节，分为8组，主存有4096个字块。请问：<br>1）主存地址有多少位<br>2）请写出主存地址的格式。</p>
<p>解答：<br>1）主存容量为4096块*256字=2^20字，故主存地址为20位<br>Cache容量为64块*256字<br>共有4096/8 = 512 = 2^9个组群<br>即2^20=2^9 * 2^3 * 2^8<br>2）Cache3，字块为256字节=2^8，所以主存地址的格式为：</p>
<p><img src="/2019/12/24/存储系统II/view.jfif" alt="cache练习及答案"></p>
<p>在请求分页存储管理方案中，若某用户空间为16个页面，页长1KB，现有页表如下，则逻辑地址102B（H）所对应的物理地址为（<strong>082BH</strong> ）。<br>页号    块号<br>0    1<br>1    5<br>2    3<br>3    7<br>4    2</p>
<p>16个页面，2的4次方=16，可知页号部分占4位，页长为1k，2的10次方=1k，页面大小（偏移）占10位<br>102B（H）十六进制表示法，B=11，所以102B（H）=0001 0000 0010 1011<br>页内地址为：00 0010 1011<br>页号为：0100=4.查表可知页号4对应的块号为2，<br>物理地址=物理块号*物理块号大小+页面位移<br>页号=（int）（逻辑地址/页面大小）<br>页面位移=逻辑地址%页面大小=0001 0000 0010 1011%100 0000 0000=0010 1011<br>所以逻辑地址102B（H）所对应的物理地址=2*1k +0010 1011=1000 0010 1011<br>转化为16进制082B（H） </p>
<p>计算机主存容量8MB，分为4096个主存块，cache有64KB，请问若按照采用直接映射方式。<br>1)cache有多少字块？<br>2)Cache的字块内地址为多少位<br>3)Cache的字块地址为多少位<br>4)请写出该主存的地址格式<br>5）若按照全相联映射方式请写出该主存的地址格式</p>
<p>解答：<br>1）每字块大小为8MB/4096= 2KB ,cache有64KB，cache块的大小与主存的块大小一样，都为2KB，所以有64KB/2KB=32个块<br>2）Cache的字块与主存的字块一样大小都为2KB=211B，所以cache的字块内地址为11位3）Cache有32块=25，所以Cache的字块地址为5位<br>4）主存容量23<br><img src="/2019/12/24/存储系统II/view-1577207603980.jfif" alt="cache练习及答案"><br>5<br><img src="/2019/12/24/存储系统II/view-1577207604012.jfif" alt="cache练习及答案"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>存储系统I</title>
    <url>/2019/12/24/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E4%B8%80/</url>
    <content><![CDATA[<h2 id="存储系统层次结构"><a href="#存储系统层次结构" class="headerlink" title="存储系统层次结构"></a>存储系统层次结构</h2><h3 id="基本存储体系"><a href="#基本存储体系" class="headerlink" title="基本存储体系"></a>基本存储体系</h3><p>存储程序                                                  —-&gt; 内存<br>1) 输入设备将程序与数据写入主存；   ^<br>2) CPU取指令;                                           |<br>3) CPU执行指令期间读数据；                |<br>4) CPU写回运算结果；                            |<br>5)  输出设备输出结果；                           |<br>程序控制                                                    —-&gt; CPU<br><a id="more"></a></p>
<p>主存容量不足的原因：</p>
<ul>
<li>存在制约主存容量的技术因素</li>
<li>应用对主存的需求不断扩大</li>
</ul>
<p><img src="/2019/12/24/存储系统一/image-20191224143440462.png" alt="image-20191224143440462"></p>
<p>哈佛结构：是一种将指令储存和数据储存分开的存储器结构，可支持：数据和指令并行储存、指令 预取，提高处理器的执行效率；另外，指令和数据可有不同的数据宽度，如Microchip 公司的PIC16芯片的程序指令是14位宽度，而数据是8位宽度。<br>目前使用哈佛结构的：PIC系列、摩托罗拉公司的MC68系列、Zilog公司的Z8系列、 ATMEL公司的AVR系列和ARM公司的ARM9、ARM10和ARM11。</p>
<p><img src="/2019/12/24/存储系统一/image-20191227012511278.png" alt="image-20191227012511278"></p>
<h3 id="存储体系层次化结构的理论基础"><a href="#存储体系层次化结构的理论基础" class="headerlink" title="存储体系层次化结构的理论基础"></a>存储体系层次化结构的理论基础</h3><p>局部性原理 </p>
<ul>
<li>时间局部性: <ul>
<li>现在被访问的信息2在不久的将来还将再次被访问;</li>
<li>时间局部性的程序结构体现：循环结构 </li>
</ul>
</li>
<li>空间局部性： <ul>
<li>现访问信息2 ，下一次访问2附近的信息。</li>
<li>空间局部性的程序结构体现：顺序结构</li>
</ul>
</li>
</ul>
<h2 id="主存中的数据组织"><a href="#主存中的数据组织" class="headerlink" title="主存中的数据组织"></a>主存中的数据组织</h2><p>存储字长：</p>
<ul>
<li>主存的一个存储单元所包含的二进制位数；</li>
<li>目前大多数计算机的主存按字节编址，存储字长也不断加大,如16位字长、 32位字长和64位字长；</li>
<li>ISA设计时要考虑的两个问题：<ul>
<li>a)如何根据字节地址读取一个32位的字？ </li>
<li>b)一个字能否存放在主存的任何字节边界？ - 字的存放问题 - 字的边界对齐问题</li>
</ul>
</li>
</ul>
<p><img src="/2019/12/24/存储系统一/image-20191224151529700.png" alt="image-20191224151529700"></p>
<p><img src="/2019/12/24/存储系统一/image-20191224151536995.png" alt="image-20191224151536995"></p>
<p>边界对齐与存储地址的关系（以32位为例）</p>
<ul>
<li>双字长数据边界对齐的起始地址的最末三位为000(8字节整数倍；</li>
<li>单字长边界对齐的起始地址的末二位为00(4字节整数倍)；</li>
<li>半字长边界对齐的起始地址的最末一位为0(２字节整数倍)。</li>
</ul>
<p><img src="/2019/12/24/存储系统一/image-20191224151700729.png" alt="image-20191224151700729"></p>
<p><img src="/2019/12/24/存储系统一/image-20191224151728347.png" alt="image-20191224151728347"></p>
<h2 id="静态存储器工作原理"><a href="#静态存储器工作原理" class="headerlink" title="静态存储器工作原理"></a>静态存储器工作原理</h2><p><img src="/2019/12/24/存储系统一/image-20191224154646533.png" alt="image-20191224154646533"></p>
<p><img src="/2019/12/24/存储系统一/image-20191224154652629.png" alt="image-20191224154652629"></p>
<p><img src="/2019/12/24/存储系统一/image-20191224154658914.png" alt="image-20191224154658914"></p>
<p><img src="/2019/12/24/存储系统一/image-20191224154704558.png" alt="image-20191224154704558"></p>
<p><img src="/2019/12/24/存储系统一/image-20191224154711826.png" alt="image-20191224154711826"></p>
<p><img src="/2019/12/24/存储系统一/image-20191224154729278.png" alt="image-20191224154729278"></p>
<p><img src="/2019/12/24/存储系统一/image-20191224154739209.png" alt="image-20191224154739209"></p>
<h2 id="动态存储器工作原理"><a href="#动态存储器工作原理" class="headerlink" title="动态存储器工作原理"></a>动态存储器工作原理</h2><p>SRAM存储单元不足：</p>
<ul>
<li>晶体管过多</li>
<li>存储密度低</li>
<li>功耗大</li>
</ul>
<p><img src="/2019/12/24/存储系统一/image-20191224162301973.png" alt="image-20191224162301973"></p>
<p><img src="/2019/12/24/存储系统一/image-20191224162316869.png" alt="image-20191224162316869"></p>
<p><img src="/2019/12/24/存储系统一/image-20191224162327920.png" alt="image-20191224162327920"></p>
<p><img src="/2019/12/24/存储系统一/image-20191224162336607.png" alt="image-20191224162336607"></p>
<p><img src="/2019/12/24/存储系统一/image-20191224162343371.png" alt="image-20191224162343371"></p>
<p><img src="/2019/12/24/存储系统一/image-20191224162351879.png" alt="image-20191224162351879"></p>
<p><img src="/2019/12/24/存储系统一/image-20191224162357494.png" alt="image-20191224162357494"></p>
<p><img src="/2019/12/24/存储系统一/image-20191224162402845.png" alt="image-20191224162402845"></p>
<p><img src="/2019/12/24/存储系统一/image-20191224162410001.png" alt="image-20191224162410001"></p>
<h2 id="存储拓展"><a href="#存储拓展" class="headerlink" title="存储拓展"></a>存储拓展</h2><p><img src="/2019/12/24/存储系统一/image-20191224161733688.png" alt="image-20191224161733688"></p>
<p>位拓展举例： 用16K * 8 的存储芯片构建16K * 32的存储器</p>
<p>所需芯片数量： 16K*32/(16K*8) = 4<br>所有存储芯片并行工作，贡献32位数据中的不同8位</p>
<p><img src="/2019/12/24/存储系统一/image-20191227012839226.png" alt="image-20191227012839226"></p>
<hr>
<p>字扩展举例:  用16K* 8 的存储芯片构建128k* 8的存储器</p>
<p>所需芯片数量： 128K * 8/ (16K*8) = 8<br>128k存储器 -&gt; 17根地址线<br>16K的存储 -&gt; 14根地址线<br>多余的3根地址线 作为片选译码输入</p>
<p><img src="/2019/12/24/存储系统一/image-20191227012958630.png" alt="image-20191227012958630"></p>
<hr>
<p>用16K* 8 的存储芯片构建128K*  8的存储器，其中08000H~0BFFFH存储空间保留不用</p>
<p>所需芯片数量： (128K-16k )* 8/ (16K*8) = 7<br><img src="/2019/12/24/存储系统一/image-20191227013302066.png" alt="image-20191227013302066"></p>
<hr>
<p><img src="/2019/12/24/存储系统一/image-20191224162032635.png" alt="image-20191224162032635"></p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>字位结构为256Kｘ4位SRAM存储芯片，其地址引脚与数据引脚之和为：22</p>
<p>256K 需要18根，4位4根</p>
<hr>
<p>假定用若干块4K <em>4位的存储芯片组成一个8K</em>8位的存储器，则地址0B1F所在芯片的最小地址是<strong>0000H</strong></p>
<hr>
<p>用若干片2K´4位的存储芯片组成一个8K´8位的存储器，则地址0B1FH所在的芯片在全局的最大地址是<strong>0FFFH</strong></p>
<hr>
<p>下列存储器类型中，速度最快的是 <strong>B</strong><br>A.Flash Memory    B.SRAM    C.DRAM    D.EPROM</p>
<p>SRAM是cache</p>
<hr>
<p>关于内存的下列说法中，错误的是<strong>AD</strong><br>A.内存的存取速度不能低于CPU速度，否则会造成数据丢失<br>B.某计算机内存容量为8GB，按字节编址，那么它的地址总线为33位<br>C.程序只有在数据和代码等被调入内存后才能运行<br>D.采用虚拟内存技术后程序可以在硬盘上直接运行</p>
<hr>
<p>DRAM比SRAM慢，可能的原因包括<strong>ABCD</strong><br>A.DRAM读之前需要预充电<br>B.DRAM存储体行列地址线复用<br>C.DRAM需要刷新<br>D.DRAM存储单元采用了双译码结构</p>
<hr>
<p>不需要定时刷新的半导体存储器芯片是<strong>ACD</strong><br>A.SRAM    B.DRAM    C.Flash Memory    D.EPROM</p>
<hr>
<p>某计算机存储器按字节变址，采用小端方式存放数据。假定编译器规定int 型和 short 型长度分别为 32 位和 16 位，并且数据按边界对齐存储。某 C 语言程序段如下：</p>
<p><img src="/2019/12/24/存储系统一/3814779_1478420350406_9D7738A42D1C889AE8A3BA51F1DEF7AC.png" alt="img"></p>
<p>若record 变量的首地址为 0xC008，则地址 0xC008 中内容及 record.c 的地址是0x11 0xC00E</p>
<hr>
<p>计算机字长32位，主存容量为128MB，按<strong>字</strong>编址，其寻址范围为<strong>0~128M-1</strong></p>
<hr>
<p>某计算机内存容量为8GB，按字节编址，那么它的地址总线为33位 <strong>错</strong><br>要大于33根</p>
<hr>
<p>下列关于RAM和ROM的叙述中，正确的是<strong>BD</strong><br>A.ROM和RAM都不需要刷新<br>B.RAM是易失性存储器，ROM是非失性存储器<br>C.Cache可选RAM、ROM做数据存储体<br>D. RAM和ROM都采用随机存取的方式进行访问</p>
<hr>
<p>一般Cache采用高速的SRAM制作，比ROM速度快很多，因此Ⅲ是错误的，排除法即可选A。动态RAM是靠MOS电路中的栅极电容来记忆信息的。由于电容上的电荷会泄漏,需要定时给与补充,所以动态 RAM需要 设置 刷新 电路。RAM需要刷新，而ROM不需要刷新。<br>ROM与RAM两者的差别：<br>(1) RAM是随机存取存储器; ROM是只读存储器；<br>(2) RAM是易失性的，一旦掉电，则所有信息全部丢失；ROM是非易失性的，其信息可以长期保存，常用于存放一些固定用的数据和程序，如计算机的自检程序、BIOS、游戏卡中的游戏，等等。</p>
<hr>
<p>下列属于衡量存储器技术指标的是：<strong>存储容量、存取时间、存储周期和存储器带宽</strong></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>运算器</title>
    <url>/2019/12/23/%E8%BF%90%E7%AE%97%E5%99%A8/</url>
    <content><![CDATA[<h2 id="定点数运算及溢出检测"><a href="#定点数运算及溢出检测" class="headerlink" title="定点数运算及溢出检测"></a>定点数运算及溢出检测</h2><ul>
<li>补码加法：[X＋Y]补 = [X]补＋ [Y]补<ul>
<li>和的补码 = 补码的和</li>
</ul>
</li>
<li>补码减法：[X−Y]补 = [X]补＋ [−Y]补 = [X]补−[Y]补<ul>
<li>差的补码 = 补码的差<a id="more"></a></li>
<li>减法变加法，关键是求[−Y]补</li>
</ul>
</li>
<li>求补公式：[−Y]补= [ [Y]补 ]补<ul>
<li><strong>对 [Y]补逐位取反, 再在最低位加 1</strong></li>
</ul>
</li>
</ul>
<p><img src="/2019/12/23/运算器/image-20191223010219114.png" alt="image-20191223010219114"></p>
<h3 id="单符号数溢出检测"><a href="#单符号数溢出检测" class="headerlink" title="单符号数溢出检测"></a>单符号数溢出检测</h3><h4 id="方法I"><a href="#方法I" class="headerlink" title="方法I"></a>方法I</h4><p>溢出只可能发生在同符号数相加时，包括[X]补与[Y]补； [X]补与[-Y]同号；<br>方法1：对操作数和运算结果的符号位进行检测 当结果的符号位与操作数的符号不相同时就表明发生了溢出 </p>
<ul>
<li>正正得负  负负得正</li>
<li>设两数符号位为 f0 f1 ，和数符号位 fs</li>
<li>溢出检测信号Overflow   (OF)<br>OF = !f0·!f1·fs + f0·f1·!fs</li>
</ul>
<h4 id="方法II"><a href="#方法II" class="headerlink" title="方法II"></a>方法II</h4><p>方法2：对最高数据位进位和符号进位进行检测 •设运算时最高数据位产生的进位为C1，符号位产生的进位为C0， 溢出检测电路为： V= C0 ^ C 1</p>
<p><img src="/2019/12/23/运算器/image-20191226234848895.png" alt="image-20191226234848895"></p>
<h4 id="方法III"><a href="#方法III" class="headerlink" title="方法III"></a>方法III</h4><p>方法3：用变型补码 [X]补 = Xf1Xf2. X1X2X3…Xn mod  2^n+2 溢出的判断:  V= Xf1 ^ Xf2</p>
<p>例6 已知 X=- 10010  Y= -10101  求X+Y<br>解:   [X]补=1101110   [Y]补= 1101011<br>[X+Y]补=[X]补+[Y]补= 1101110  + 1101011 =1 10 10001<br>V= 1 ^ 0 =1 故发生溢出！</p>
<h4 id="无符号数运算的溢出判断"><a href="#无符号数运算的溢出判断" class="headerlink" title="无符号数运算的溢出判断"></a>无符号数运算的溢出判断</h4><ul>
<li>无符号数加法的溢出可用ALU的进位表示</li>
<li>无符号数减法的溢出也可用带加/减功能的ALU的进位取反后表示。</li>
</ul>
<h2 id="定点数补码加减运算器设计"><a href="#定点数补码加减运算器设计" class="headerlink" title="定点数补码加减运算器设计"></a>定点数补码加减运算器设计</h2><h3 id="带进位链的一位全加器"><a href="#带进位链的一位全加器" class="headerlink" title="带进位链的一位全加器"></a>带进位链的一位全加器</h3><p>Si  =  Xi ⊕ Yi ⊕ Ci<br>Ci+1  =  Xi Yi  + (Xi ⊕ Yi )Ci</p>
<p><img src="/2019/12/23/运算器/image-20191226235525221.png" alt="image-20191226235525221"></p>
<ul>
<li>n位加法器包含n个全加器</li>
<li>将n个一位全加器串联</li>
<li>低位进位输出连接到高位进位输入</li>
</ul>
<h4 id="串行加法器时间延迟"><a href="#串行加法器时间延迟" class="headerlink" title="串行加法器时间延迟"></a>串行加法器时间延迟</h4><p>n个全加器延迟，3n个门电路延迟？<br>考虑片内并行性，2n+1个门电路延迟</p>
<h3 id="四位串行加-减法器设计"><a href="#四位串行加-减法器设计" class="headerlink" title="四位串行加/减法器设计"></a>四位串行加/减法器设计</h3><p>补码减法可以变加法<br>         [X]补 − [Y]补 = [X]补 + [−Y]补<br>关键是求[−Y]补<br>方法：将Y补连同符号位一起逐位取反末位加一<br>         [−Y]补= [ [Y]补 ]补             注意补码区间不对称？</p>
<ul>
<li>引入运算控制位 Sub<ul>
<li>Sub=0 时作加法，送入加法器的是Y补    </li>
<li>Sub=1 时作减法，送入加法器的是[−Y]补   <ul>
<li>对 Y补 逐位取反，末位加一</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>[−Y]补= [ [Y]补 ]补<br>Input = Yi ^ Sub</p>
<p><img src="/2019/12/23/运算器/image-20191223011539952.png" alt="image-20191223011539952"></p>
<p><img src="/2019/12/23/运算器/image-20191223011546598.png" alt="image-20191223011546598"></p>
<p><img src="/2019/12/23/运算器/image-20191223011554683.png" alt="image-20191223011554683"></p>
<p><img src="/2019/12/23/运算器/image-20191223011604477.png" alt="image-20191223011604477"></p>
<h3 id="并行加法器进位链-carry-lookahead"><a href="#并行加法器进位链-carry-lookahead" class="headerlink" title="并行加法器进位链(carry-lookahead)"></a>并行加法器进位链(carry-lookahead)</h3><p>Si = Xi⊕Yi⊕Ci-1<br>Ci = XiYi+(Xi⊕Yi)Ci-1<br>Gi = XiYi    进位生成函数 Generate<br>Pi = Xi⊕Yi    进位传递函数 Propagate<br>Ci = Gi + Pi·Ci-1<br>高位运算依赖于低位进位 -&gt; 计算不能并行</p>
<p>Cn = Gn＋PnGn-1＋PnPn-1Gn-2＋PnPn-1Pn-2Gn-3 …＋PnPn-1…P1C0</p>
<ul>
<li>进位输出仅与最低位进位输入C0有关</li>
<li>位数越长，进位链电路复杂度越高</li>
<li>通常按照4位一组进行分组运算</li>
</ul>
<p><img src="/2019/12/23/运算器/image-20191223011617449.png" alt="image-20191223011617449"></p>
<p><img src="/2019/12/23/运算器/image-20191223011651720.png" alt="image-20191223011651720"><br>①生成P*，G*需3T  -&gt;  ②生成C3/C12需2T -&gt;  ③求和需3T</p>
<h2 id="原码一位乘法"><a href="#原码一位乘法" class="headerlink" title="原码一位乘法"></a>原码一位乘法</h2><ul>
<li>符号单独运算：直接异或</li>
<li>绝对值相乘：   仅需考虑数值部分的计算</li>
</ul>
<p><img src="/2019/12/23/运算器/image-20191223105629422.png" alt="image-20191223105629422"></p>
<p><img src="/2019/12/23/运算器/image-20191223105639405.png" alt="image-20191223105639405"></p>
<p><img src="/2019/12/23/运算器/image-20191223105649861.png" alt="image-20191223105649861"></p>
<p><img src="/2019/12/23/运算器/image-20191223105716737.png" alt="image-20191223105716737"></p>
<h2 id="补码一位乘法"><a href="#补码一位乘法" class="headerlink" title="补码一位乘法"></a>补码一位乘法</h2><p>设[X]补 = X0X1X2X3…Xn [Y]补 = Y0Y1Y2Y3…Yn<br>可证明：<br>   [X•Y]补 = [X]补•( 0.Y1Y2Y3…Yn ) –Y0• [X]补<br>进一步展开合并后可得：<br>   [x•y]补=[x] 补•Σ(yi+1 - yi)2^-i    ( 符号位参加运算 ) </p>
<p>补码一位乘法的运算规则如下:<br>(1)如果yn+1=yn,部分积加0，部分积算术右移1位；<br>(2)如果yn+1yn=10,部分积加[x]补，部分积算术右移1位；<br>(3)如果yn+1yn=01,部分积加[-x]补，部分积算术右移1位. 重复进行n＋1步，但最后一步不移位。<br>包括一位符号位，所得乘积为2n＋1位，其中n为数据位位数. </p>
<p>几个特殊问题的处理<br>(1) i=n时 ,yn+1= ？yn+1= 0<br>(2) yn+1 是哪个寄存器？在乘数寄存器Y后增加的一位<br>(3)算术右移的对象有哪些？   部分积和乘数寄存器均右移</p>
<p><img src="/2019/12/23/运算器/image-20191223110749473.png" alt="image-20191223110749473"></p>
<p><img src="/2019/12/23/运算器/image-20191223110759842.png" alt="image-20191223110759842"></p>
<h2 id="乘法运算器设计"><a href="#乘法运算器设计" class="headerlink" title="乘法运算器设计"></a>乘法运算器设计</h2><p><img src="/2019/12/23/运算器/image-20191223112447328.png" alt="image-20191223112447328"></p>
<h3 id="阵列乘法器"><a href="#阵列乘法器" class="headerlink" title="阵列乘法器"></a>阵列乘法器</h3><p>而对于相加数运算，就变成了一位乘法运算，一位乘法运算很简单，从真值表看，这就是一个简单的与逻辑，也就是逻辑与门就可以实现一位乘法，对于上一页的5*5的乘法运算，需要25个相加数，所以我们可以采用25个与门并发，如图所示，经过<strong>一级门电路延迟</strong>后，就可以得到所有的相加数，下面我们只需要考虑逐列相加的逻辑就可以实现乘法器</p>
<p><img src="/2019/12/23/运算器/image-20191227001319627.png" alt="image-20191227001319627"></p>
<ul>
<li>与门实现一位乘法</li>
<li>25个与门并发</li>
<li>一级门延迟，生成所有相加数</li>
</ul>
<p><img src="/2019/12/23/运算器/image-20191227001414909.png" alt="image-20191227001414909"></p>
<p>经过一级门电路延迟后，生成了所有相加数，这里X。。就是，将第二列用一个全加器进行相加，由于全加器有三个输入，所以这里进位位我们给一个零，当然大家也可以使用半加器完成，去掉进位输入，可以减少硬件成本，相加得到的结果就是乘积的P1位，进位输出横向向高位列传递，这就是所谓的横向进位阵列乘法器，将第三列的三个数用两个全加器串联进行运算，就可以得到P2，同样，全加器的进位输出都横向向左侧传递。，最后一个全加器进位输入为零，依次类推，得到P3，P4，P5，对于P6列，这个进位信号直接传递到下一层的全加器，同理得到P7，P。。。。。      如果采用斜向进位，就可以有另外一种连接方法。</p>
<p>前面我们给出了横向进位和斜向进位两种阵列乘法器，首先我们来看看横向进位阵列乘法器，5*5的横向阵列乘法器包括4行全加器，每行5个，需要20个全加器，进位信号横向传递，每一行都是一个5位串行进位加法器，串行加法器的特点就是性能差，各全加器之间存在着进位依赖，所以这个全加器运算完毕后，这个才能运算，然后是这个，第一行运算完毕后，第二行才能开始运算，所以看上去所有全加器都只能串行工作，整个运算需要20个全加器时延。</p>
<p>但仔细分析，这个横向进位阵列乘法器还存在这一定的并行性，首先是这个全加器运算，运算完毕后这个全加器运算，当第二个全加器运算完毕后，这两个全加器的输入就绪，两个全加器可以并发，当这两个全加器运算完毕后，这两个全加器运算，然后是这三个全加器并发，所以沿着对角线法线方向上的全加器是可以并发的，我们来看看乘法器的关键路径<br>(T是计算X1Y1，X0Y0的那个时延)</p>
<p><img src="/2019/12/23/运算器/image-20191227001634066.png" alt="image-20191227001634066"></p>
<p>斜向进位乘法器和横向进位乘法器结构有一些区别，加法器一共5行，每行4个全加器，横向进位是4行，每行5个，硬件电路成本相同，都是n。     由于斜向进位的引入，同一行的全加器可以并发，行与行之间有结果依赖，所以前面4行需要4个全加器延迟，也就是n-1个全加器延迟，最后一行由于采用的是横向进位，所以这部分如果不做优化，器时间延迟也是n-1个全加器延迟，电路运行的关键路径如下，一共需要。。。。。。。 斜式时间复杂度优于横向进位阵列乘法器，由3n个全加器延迟结标变成2n级别，性能明显由于横向进位阵列乘法器</p>
<p><img src="/2019/12/23/运算器/image-20191227002149154.png" alt="image-20191227002149154"></p>
<p>最后对比一下横向进位阵列乘法器，和斜向阵列乘法器，两个电路硬件成本都是n*n-1个全加器，只不过一个是4行5列，一个是5行4列但由于内部进位信号传递方式不同，直接导致性能差异加大，大约是1.5倍的差异， 不同结构硬件实现方式就和软件的算法一样，好的算法可以得到优秀的性能</p>
<p><img src="/2019/12/23/运算器/image-20191223112518818.png" alt="image-20191223112518818"></p>
<p><img src="/2019/12/23/运算器/image-20191223112531553.png" alt="image-20191223112531553"></p>
<h3 id="计算机中的流水线"><a href="#计算机中的流水线" class="headerlink" title="计算机中的流水线"></a>计算机中的流水线</h3><ul>
<li>流水思想：复杂问题分解成细粒度任务并发<ul>
<li>乘法流水线，浮点流水线，指令流水线</li>
<li>流水线 = 寄存器 + 组合逻辑 + 寄存器 + 组合逻辑 + 寄存器  …        数据通路串联</li>
<li>流水线时钟频率取决于组合逻辑的关键路径</li>
</ul>
</li>
</ul>
<p><img src="/2019/12/23/运算器/image-20191227003555284.png" alt="image-20191227003555284"></p>
<p>回到阵列乘法器上，如果简单的5*5将阵列乘法器看做4个5位串行加法器的级联，我们可以将运算过程细分为4个步骤，第一步计算Y+。。。。  得到部分积，为了简化设计，我们这里可以直接采用10位的加法器进行运算，不足的位补零即可， 第二部将第一步运算的结果累加上Y2X*4，*4是考虑权值对齐的问题，同理第三部。。。。第四部是。。。。。。完成第四部运算后10位加法器的运算结果就是最终的成绩，如果吧这里绿色的横线当做流水接口，实际上就可以演变成一个乘法流水线，这里流水接口本质上就是一堆寄存器，用于锁存当前步骤运算的部分积，，，以及后续步骤运算所需要的Yi*X。   后续我们实验中要求大家按照这个思路实现一个乘法流水线。</p>
<p><img src="/2019/12/23/运算器/image-20191227003638643.png" alt="image-20191227003638643"></p>
<p>刚刚我们给出的第一种流水线改造办法将乘法运算细分成了4部，实际上我们还可以按照横向进位阵列乘法器的关键路径进行流水细分，比如这里我们可以按照关键路径将乘法运算细分成11步，每一步中的全加器都可以完全并行，和刚刚介绍的方案1相比，这里流水线每一步的时间延迟更短，由10位全加器时延变成了一个全加器时延，流水线的时钟频率更高，流水线的性能更优。<br>这两种方法都是将乘法运算细分成若干更小的步骤，让后引入流水接口部件——寄存器锁存中间结果构成运算流水线，实际上浮点运算流水线也是采用了类似的方法。   真是计算机中的乘法器也是采用流水线实现的，目前大多采用布斯两位乘法+华莱士树的方式构成，如果你有兴趣可以研究一下。</p>
<p><img src="/2019/12/23/运算器/image-20191227003720937.png" alt="image-20191227003720937"></p>
<h3 id="变量与常数之间的乘法运算"><a href="#变量与常数之间的乘法运算" class="headerlink" title="变量与常数之间的乘法运算"></a>变量与常数之间的乘法运算</h3><ul>
<li>整数乘法比移位和加法运算慢很多</li>
<li>编译器在处理变量与常数相乘时，用其它快速运算指令代替乘法<pre><code>x\*20  -&gt;  (x&lt;&lt;4)+(x&lt;&lt;2)       乘法转换成了2次移位和1次加法
x\*15  -&gt;  (x&lt;&lt;4) – x               乘法转换成了1次移位和1次减法
</code></pre></li>
<li>移位加减组合运算和直接相乘结果一样的（包括溢出）</li>
<li>是否优化取决于组合运算周期数是否小于乘法开销</li>
</ul>
<h2 id="定点数除法"><a href="#定点数除法" class="headerlink" title="定点数除法"></a>定点数除法</h2><h3 id="恢复余数除法"><a href="#恢复余数除法" class="headerlink" title="恢复余数除法"></a>恢复余数除法</h3><ul>
<li>如何判断是否够减<ul>
<li>利用补码作减法，判断余数符号即可</li>
</ul>
</li>
<li>余数为负数时，必须恢复余数<ul>
<li>将余数加除数，恢复成原值</li>
</ul>
</li>
<li>求下一位商，必须将余数左移一位，再与除数比较<ul>
<li>手工运算将除数右移？</li>
<li>注意这里余数放大了，最后结果要缩小</li>
</ul>
</li>
<li>比较，上商（恢复），余数移位，再比较，<ul>
<li>直到商的位数足够</li>
</ul>
</li>
</ul>
<p><img src="/2019/12/23/运算器/image-20191223231843074.png" alt="image-20191223231843074"></p>
<p><img src="/2019/12/23/运算器/image-20191223231854975.png" alt="image-20191223231854975"></p>
<p><img src="/2019/12/23/运算器/image-20191223231901994.png" alt="image-20191223231901994"></p>
<p>问题：</p>
<ul>
<li>需要进行恢复余数的操作<ul>
<li>余数是负数，必须恢复余数</li>
<li>绝对值运算，余数不可能是负数</li>
</ul>
</li>
<li>恢复余数的操作次数不确定<ul>
<li>运算时间不固定</li>
<li>最慢除法（每次都不够除），拖慢除法速度</li>
</ul>
</li>
<li>实际应用通常采用<strong>不恢复余数除法</strong></li>
</ul>
<h3 id="不恢复余数除法"><a href="#不恢复余数除法" class="headerlink" title="不恢复余数除法"></a>不恢复余数除法</h3><ul>
<li>n设某次余数为Ri，求下位商需将Ri左移一位，再减去除数Y进行比较，此过程可表示为<br>2Ri - Y</li>
<li>余数Ri小于0时商上0，需要恢复余数，左移一位，再减除数Y比较<br>(2Ri - Y）+ Y = 2Ri<br>2*2Ri – Y =4Ri–Y = 2*(2Ri -Y) + Y</li>
<li>不恢复余数法：余数Ri小于0时商上0，左移一位，再<strong>加</strong>除数Y比较</li>
</ul>
<p><img src="/2019/12/23/运算器/image-20191223231927917.png" alt="image-20191223231927917"></p>
<p><img src="/2019/12/23/运算器/image-20191223232007762.png" alt="image-20191223232007762"></p>
<p><img src="/2019/12/23/运算器/image-20191223232026608.png" alt="image-20191223232026608"></p>
<ul>
<li>n*n个CAS单元</li>
<li>(n*n) ×4T</li>
</ul>
<p><img src="/2019/12/23/运算器/image-20191223232033420.png" alt="image-20191223232033420"></p>
<h2 id="浮点数加减运算"><a href="#浮点数加减运算" class="headerlink" title="浮点数加减运算"></a>浮点数加减运算</h2><h3 id="规格化浮点数概念"><a href="#规格化浮点数概念" class="headerlink" title="规格化浮点数概念"></a>规格化浮点数概念</h3><ul>
<li>由于浮点数是将数据的表示范围与精确度分别表示的数据表示方法，若不对浮点数的表示作出明确规定，同一个浮点数的表示就不唯一</li>
<li>规格化浮点数是指把一个浮点数按指定的格式进行转换，</li>
<li>由于浮点数是将数据的表示范围与精确度分别表示的数据表示方法，若不 对浮点数的表示作出明确规定，同一个浮点数的表示就不唯一，</li>
<li>以浮点数一般格式为例，规格化浮点数的尾数形式为: 00.1… 或 11.0…。</li>
</ul>
<h3 id="规格化浮点数方法"><a href="#规格化浮点数方法" class="headerlink" title="规格化浮点数方法"></a>规格化浮点数方法</h3><ul>
<li>当尾数结果为 00.0… 或 11.1，需要左规格化即将尾数向左移动， 每移动一次，阶码减1，直到尾数形式为 00.1… 或 11.0…。</li>
<li>当尾数的结果为 01.… 或 10.， 表明尾数求和的结果 &gt; 1,此时仅 需要执行一次右移规格化， 阶码加 1 ,尾数形式即为00.1… 或 11.0…</li>
</ul>
<h3 id="浮点数加减运算方法及其步骤"><a href="#浮点数加减运算方法及其步骤" class="headerlink" title="浮点数加减运算方法及其步骤"></a>浮点数加减运算方法及其步骤</h3><ul>
<li>对阶 <ul>
<li>求阶差；</li>
<li>右移阶码小的浮点数的尾数并同步增加其阶码，直至两数阶码相等。</li>
</ul>
</li>
<li><p>尾数加/减 </p>
<ul>
<li>尾数加/减运算 （用对阶后的尾数） </li>
</ul>
</li>
<li>结果规格化<ul>
<li>尾数非零时，要求绝对值≥0.5，尾数MSB=1</li>
<li>否则修改阶码并移动尾数，使其满足上述要求</li>
<li>目的：保证浮点数的编码唯一性</li>
<li>右移以实现规格化   向右规格化   右归   阶码+<ul>
<li>右归时连同符号位进位位一起右移，阶码作加法 </li>
</ul>
</li>
<li>左移以实现规格化   向左规格化   左归   阶码-<ul>
<li>左归时LSB位补0，阶码作减法</li>
</ul>
</li>
</ul>
</li>
<li>舍入<ul>
<li>右移规格化时可能丢失一些低位的数值位, 为提高精度,  可采取舍入的方法: </li>
<li>0 舍 1 入 : 若右移出的是1则在最低位加1;<br><img src="/2019/12/23/运算器/image-20191227005213203.png" alt="image-20191227005213203"></li>
<li>恒置 1 : 只要数字位1被移掉,就将最后一位恒置成1。</li>
</ul>
</li>
<li>溢出处理 <ul>
<li>浮点数的溢出标志:  阶码溢出 </li>
<li>阶码上溢 ： 阶码的符号位为 01 </li>
<li>阶码下溢 ： 阶码的符号位为 10</li>
<li>尾数上溢   右归</li>
<li>尾数下溢   左归</li>
</ul>
</li>
</ul>
<p>例1  两浮点数 x = 2^101×0.11011011，y = 2^111×(-0.10101100)。假设尾数在计算机中以补码表示，可存储10位尾数，2位符号位，阶码以补码表示，双符号位, 求 x + y。</p>
<p>解：将x , y转换成浮点格式<br>     [x]浮 = 00101, 00.11011011<br>     [Y]浮 = 00111, 11.01010100<br>步骤1：对阶，阶差为 Ex − Ey = [Ex]补 + [−Ey]补<br>     [−Ey]补=11001  Ex−Ey＝00101＋11001＝11110 = -2 &lt; 0<br>         小阶对大阶， X阶码加2， 尾数右移2位<br>     [x]浮 = 00111,00.0011011011   保留位<br>     [x]浮 = 00111, 00.0011011011   保留位<br>     [Y]浮 = 00111, 11.01010100<br>步骤2：尾数求和<br>     [X+Y]浮 = 00111, 11.1000101011   保留位参与运算<br>步骤3：结果规格化<br>     [X+Y]浮 = 00110, 11.000101011     非规数，左归1位, 阶码减1，保留位？<br>步骤4：舍入处理<br>     [X+Y]浮 = 00110, 11.00010110   (0舍1如法)<br>     [X+Y]浮 = 00110, 11.00010101   (截去法)<br>步骤5：溢出判断<br>    [X+Y]浮 = 2110 x (-0.11101011)   无溢出</p>
<p>特殊例子：<br>X=2^111 *  0.11111111，Y=2^111 * 0.10000001<br>                      [X]浮  =    0111, 0.1111 1111</p>
<pre><code>       +         [Y]浮  =    0111, 0.1000 0001
              [X+Y]浮  =    0111, 1.1000 0000
          尾数上溢，右归一位，连同符号位进位位一起右移1位，阶码加1
              [X+Y]浮 =    1000, 0.1100 0000     
        阶码正溢出，运算结果上溢  
</code></pre><p>X=2^-1000 * -0.11110000，Y=2^-1000 * 0.10000001<br>                     [X]浮  =    1000, 1.0001 0000</p>
<pre><code>      +         [Y]浮  =    1000, 0.1000 0001
            [X+Y]浮   =    1000, 1.1001 0001
        尾数下溢，左归一位， 左移一位，阶码减1
            [X+Y]浮  =    1000, 1.0010 0010     
               1000+1111=0111 =7  
        阶码负上溢，运算结果下溢
</code></pre><h2 id="浮点数乘法运算"><a href="#浮点数乘法运算" class="headerlink" title="浮点数乘法运算"></a>浮点数乘法运算</h2><p>X=2^m * Mx        Y=2^n * My<br>        X * Y = ( 2^m * Mx ) * ( 2^n * My ) = 2^m+n * (Mx * My)<br>(1) 阶码相加<br>阶码相加可能产生溢出，要进行溢出判断，如溢出计算机要进行处理<br>(2) 尾数相乘<br>尾数相乘可得积的尾数，可按定点乘法运算方法运算<br>(3) 结果规格化<br>可按浮点加/减法运算规格化方式处理，舍入方式也相同</p>
<h2 id="浮点数除法运算"><a href="#浮点数除法运算" class="headerlink" title="浮点数除法运算"></a>浮点数除法运算</h2><p>如：X=2^m * Mx        Y=2^n * My<br>        X / Y = ( 2^m * Mx ) / ( 2n * My ) = 2^m-n * (Mx / My)<br>尾数调整<br>如被除数尾数大于除数尾数 (绝对值)，则将被除数尾数右移一位，阶码+1<br>阶码求差<br>商的阶码等于被除数的阶码减去除数的阶码<br>尾数相除<br>以被除数的尾数除以除数的尾数以获得商的尾数，尾数相除与定点除法运算相同</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p><strong>单符号位补码表示的两个同号数相加或异号数相减时，所得结果的符号位SF和进位标志CF进行（D ）运算为1时，表示运算的结果产生溢出</strong><br>A.与非    B.与        C.或        D.异或</p>
<hr>
<p><strong>若采用双符号位补码运算，运算结果的符号位为10，下列结论中错误的是 AB</strong><br>A.产生了上溢    B.运算结果溢出，结果为正数    C.产生了下溢    D.运算结果溢出，结果为负数</p>
<p>计算机运算溢出检测机制，采用双符号位，00表示正号，11表示负号。如果进位将会导致符号位不一致，从而检测出溢出。结果的符号位为01时，称为上溢；为10时，称为下溢。</p>
<hr>
<p>以下说法正确的是<strong>ABCD</strong><br>A.n位小数的补码一位乘法（Booth算法），需做n+1次运算，第n+1次不移位<br>B.浮点运算可由阶码运算和尾数运算两个部分联合实现<br>C.补码加减交替法是一种不恢复余数法<br><strong>D.在定点小数补码一位除法中，为了避免溢出，被除数的绝对值一定要小于除数的绝对值</strong></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据表示</title>
    <url>/2019/12/19/%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><a id="more"></a>
<p><img src="/2019/12/19/数据表示/image-20191220003552325.png" alt="image-20191220003552325"></p>
<h2 id="机器数及其特点"><a href="#机器数及其特点" class="headerlink" title="机器数及其特点"></a>机器数及其特点</h2><p><img src="/2019/12/19/数据表示/image-20191219231153151.png" alt="image-20191219231153151"></p>
<p><strong>原码特性</strong></p>
<ul>
<li>直观易懂<ul>
<li>第一位为符号位</li>
<li>其他为数值位</li>
</ul>
</li>
<li>正零负零两个零</li>
<li>加、减运算方式不统一<ul>
<li>符号相异加法不能直接运算</li>
<li>特别当 a&lt;b时，实现 a-b比较困难</li>
</ul>
</li>
<li>从50年代开始，整数都采用补码来表示</li>
<li>但浮点数的尾数用原码定点小数表示</li>
</ul>
<p><strong>反码特性</strong></p>
<ul>
<li>两个零</li>
<li>求反用逻辑门容易实现</li>
<li>运算仍然很复杂<ul>
<li>相加时需要将符号位的进位位增加到LSB上</li>
</ul>
</li>
</ul>
<p><strong>补码特性</strong></p>
<ul>
<li>唯一的零</li>
<li>符号位可以直接参与运算</li>
<li>减法可以变成加法，运算电路统一</li>
<li>负数比整数多一个</li>
<li>不同位数的整数补码相加减时<ul>
<li>位数少的补码符号位向左扩展</li>
<li>一直扩展到符号位对齐</li>
</ul>
</li>
</ul>
<p><img src="/2019/12/19/数据表示/image-20191219231207351.png" alt="image-20191219231207351"></p>
<p><img src="/2019/12/19/数据表示/image-20191219232033377.png" alt="image-20191219232033377"></p>
<p><img src="/2019/12/19/数据表示/image-20191219232235893.png" alt="image-20191219232235893"></p>
<p>定点数机器码表示范围：<br><img src="/2019/12/19/数据表示/image-20191219232325487.png" alt="image-20191219232325487"></p>
<h3 id="双符号位补码"><a href="#双符号位补码" class="headerlink" title="双符号位补码"></a>双符号位补码</h3><p><img src="/2019/12/19/数据表示/image-20191220004143783.png" alt="image-20191220004143783"></p>
<h2 id="定点与浮点数据表示"><a href="#定点与浮点数据表示" class="headerlink" title="定点与浮点数据表示"></a>定点与浮点数据表示</h2><p><img src="/2019/12/19/数据表示/image-20191219233804226.png" alt="image-20191219233804226"></p>
<p><img src="/2019/12/19/数据表示/image-20191219233824924.png" alt="image-20191219233824924"></p>
<p><img src="/2019/12/19/数据表示/image-20191219233857085.png" alt="image-20191219233857085"></p>
<p><img src="/2019/12/19/数据表示/image-20191219233918638.png" alt="image-20191219233918638"></p>
<p><img src="/2019/12/19/数据表示/image-20191220005108307.png" alt="image-20191220005108307"></p>
<p><img src="/2019/12/19/数据表示/image-20191220005139118.png" alt="image-20191220005139118"></p>
<p><img src="/2019/12/19/数据表示/image-20191219233929847.png" alt="image-20191219233929847"></p>
<ul>
<li>机器字长一定时，阶码越长，表示范围越大</li>
<li>阶码相同，尾数越长，数据精度越高</li>
<li>浮点数表示范围比定点数大，精度高</li>
<li>阶码尾码长度应为多少合适？  </li>
<li>阶码越长，表示范围越大，精度越高 (规格化)</li>
<li>浮点数扩大了数值表示的范围， 未增加表示数值的个数</li>
<li>绝对值越大，浮点数分布越稀疏，浮点数是离散空间</li>
<li>浮点运算不满足结合律<ul>
<li>（2-126+1020）-1020 = ?       2-126 + (1020 - 1020) =?</li>
</ul>
</li>
</ul>
<h3 id="十进制数的表示-BCD码"><a href="#十进制数的表示-BCD码" class="headerlink" title="十进制数的表示 BCD码"></a>十进制数的表示 BCD码</h3><p><img src="/2019/12/19/数据表示/image-20191220005354101.png" alt="image-2019"></p>
<h2 id="数据校验的基本原理"><a href="#数据校验的基本原理" class="headerlink" title="数据校验的基本原理"></a>数据校验的基本原理</h2><p><img src="/2019/12/19/数据表示/image-20191219234631646.png" alt="image-20191219234631646"></p>
<p><img src="/2019/12/19/数据表示/image-20191219234643400.png" alt="image-20191219234643400"></p>
<p><img src="/2019/12/19/数据表示/image-20191219234654617.png" alt="image-20191219234654617"></p>
<h2 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h2><p><img src="/2019/12/19/数据表示/image-20191220005825812.png" alt="image-20191220005825812"></p>
<p><img src="/2019/12/19/数据表示/image-20191219235642154.png" alt="image-20191219235642154"></p>
<p><img src="/2019/12/19/数据表示/image-20191219235921834.png" alt="image-20191219235921834"></p>
<h2 id="CRC校验及其实现"><a href="#CRC校验及其实现" class="headerlink" title="CRC校验及其实现"></a>CRC校验及其实现</h2><p><img src="/2019/12/19/数据表示/image-20191220001405535.png" alt="image-20191220001405535"></p>
<ul>
<li><strong>生成多项式特征</strong><ul>
<li>任意位发生错误都应使余数不为0</li>
<li>不同位发生错误余数不同</li>
<li>余数左移一位继续作模2除，应使余数循环，循环周期 N=k+r  ？</li>
</ul>
</li>
<li><p><strong>如何产生生成多项式</strong></p>
<ul>
<li>(n,k)码，将Xn+1分解为若干质因子   （模2的运算）</li>
<li>根据码距要求选择其中的因式或多个因式的乘积为生成多项式</li>
</ul>
</li>
<li><p>码距：任意两个合法编码间不同的二进制位数    最小码距</p>
</li>
<li>码距越大，抗干扰能力、纠错能力越强，数据冗余越大，编码效率越低</li>
<li>选择码距应考虑信息出错概率和系统容错率<ul>
<li>奇偶校验  最小码距为2</li>
<li>海明码     最小码距为3</li>
</ul>
</li>
</ul>
<p><img src="/2019/12/19/数据表示/image-20191220001447447.png" alt="image-20191220001447447"></p>
<p><img src="/2019/12/19/数据表示/image-20191226232339760.png" alt="image-20191226232339760"></p>
<p><img src="/2019/12/19/数据表示/image-20191220001757864.png" alt="image-20191220001757864"></p>
<p>(7,3)码多位错余数情况</p>
<ul>
<li>两位数出错余数与一位错有重叠（见表）</li>
<li>三位错余数有可能为零   如 C1，C2，C4   （无法全部检错）</li>
</ul>
<p><img src="/2019/12/19/数据表示/image-20191226232647970.png" alt="image-20191226232647970"></p>
<p>CRC串行编码电路    (时序逻辑)</p>
<p><img src="/2019/12/19/数据表示/image-20191226233101210.png" alt="image-20191226233101210"></p>
<ul>
<li>有异或门的位置是生成多项式为1的位置，G(X)=X4+X+1    10011</li>
<li>触发器初始状态为0</li>
<li>Q4=0时，不够除，下一个时钟，数据左移一位</li>
<li>Q4=1时，够除，商上1， Q4Q3Q2Q1Serial_in ⊕ 生成多项式  结果左移<br>运算速度慢，高速设备普遍采用 并行CRC 编解码</li>
</ul>
<p>备注：<br>下面我们来看一看CRC串行编码电路，注意这个串行编码电路是一个同步时序逻辑，具有统一时钟。<br>从图中我们可以看到这个电路的包括若干个D触发器，Q4这Q3…..一共共4个D触发器，所有D触发器时钟同步，注意D触发器之间的链接，部分是直接串联，部分D触发器之间有一个异或门，异或门一个输入连接的是当前寄存器输出，另外一个是Q4的输出。这里有异或门的地方就是CRC编码电路生成多项式为1的位置，具体如红色文字所示，Q4位置是最高位，默认为1，所以生成多项式为10011，初始状态，所有触发器输出Q4Q3Q2Q1的值均为零，最高位Q4为零，按模2的除法不够除，Q4控制所有的异或门，因为Q4为零，所有异或门位置变成数据直通，Q1直接连接到Q2的D端。<br>四个D触发器直接串联，变成一个移位寄存器，时钟到来数据左移一位<br>这和模2除法的不够除的处理过程是完全一致的。根据这个运算规则，如果左移后Q4的值仍然还是0，则会继续左移，Q3，Q2，Q1初值都为零，所以只有串行输入数据中的第一个1传输到Q4时电路才会改变运行模式，当Q4为1时，所有异或门的地方要异或上1，相当于是Q4Q3Q2Q1串行输入这一组数据和生成多项式做异或，生成多项式为1的地方进行异或运算，为0的地方异或上零还是不变，还是原始数据，这里采用直连方式，计算后的结果下一时钟会左移一位，这个电路状态就是模2除法运时最高位为1，够除，商上1，被除数和除数进行异或运算，结果左移当串行输入的最后一位数据抵达进入电路后，各触发器输入端的值D4D3D2D1就是最终的余数这样一个电路，如果串行输入的数据越长，那么它需要的时钟就越多，所以它的运算速度非常慢的，目前在高速网络设备中必须采用并行的CRC编解码电路。</p>
<p>(7,3）编码电路</p>
<p><img src="/2019/12/19/数据表示/image-20191226233311840.png" alt="image-20191226233311840"></p>
<p>CRC   (N,k)码检错性能      r=N-k</p>
<ul>
<li>所有小于等于r长度的突发错<ul>
<li>通讯中常见，各出错位之间有因果关系</li>
<li>突发错长度：第一和最后一个错位之间的距离</li>
</ul>
</li>
<li>( 1−2^(–r+1))比例的r+1长度的突发错</li>
<li>( 1−2^–r )比例的大于r+1长度的突发错</li>
<li>所有小于最小码距的任意位数的错误</li>
<li>如果生成多项式中1的数目为偶数，可检测所有奇数错</li>
<li>广泛运用于通信传输领域，磁存储领域</li>
</ul>
<h2 id="海明校验及其实现"><a href="#海明校验及其实现" class="headerlink" title="海明校验及其实现"></a>海明校验及其实现</h2><ul>
<li>多个奇偶校验组</li>
<li>既能检错，也能纠错</li>
<li><p>最小码距为3</p>
</li>
<li><p>编码规则：分组交叉奇偶校验法</p>
<ul>
<li>待编码数据分成 r 个奇偶校验组，r&gt;1</li>
<li>r 位校验位（冗余），生成r位检错码</li>
<li>各数据位至少参加2个校验组</li>
<li>一个数据位出错，可导致多个检错码为1</li>
</ul>
</li>
<li>检错纠错：检错码值表示出错位置   （假设1位错）<ul>
<li>检错码全零， 数据大概率正常</li>
<li>可检错，也可纠错，将出错位取反即可</li>
</ul>
</li>
</ul>
<p><img src="/2019/12/19/数据表示/image-20191220003136644.png" alt="image-20191220003136644"></p>
<p><img src="/2019/12/19/数据表示/image-20191220003145152.png" alt="image-20191220003145152"></p>
<p>(4,3)码分组依据<br><img src="/2019/12/19/数据表示/image-20191226231723570.png" alt="image-20191226231723570"></p>
<p><img src="/2019/12/19/数据表示/image-20191220003206327.png" alt="image-20191220003206327"></p>
<p><img src="/2019/12/19/数据表示/image-20191220003218848.png" alt="image-20191220003218848"></p>
<p><img src="/2019/12/19/数据表示/image-20191220003228764.png" alt="image-20191220003228764"></p>
<p><img src="/2019/12/19/数据表示/image-20191220003246821.png" alt="image-20191220003246821"></p>
<ul>
<li>可检一位错<ul>
<li>检错码G3G2G1 !=000，具体值为出错位置，取反即可纠错</li>
</ul>
</li>
<li>可检两位错<ul>
<li>假设D1 ，D2同时出错，  G3G2G1=110  ？</li>
</ul>
</li>
<li>大多数三位错<ul>
<li>D1，D2，D3同时出错？G3G2G1=000  ？</li>
</ul>
</li>
<li>能否区分区分一位错，两位错？  <ul>
<li>假设没有3位错</li>
<li>引入总偶校验位 P4=H1⊕H2⊕H3⊕H4⊕H5⊕H6⊕H7</li>
<li>G4=P4⊕H1⊕H2⊕H3⊕H4⊕H5⊕H6⊕H7  区分一位两位错</li>
</ul>
</li>
</ul>
<p><img src="/2019/12/19/数据表示/image-20191226231946271.png" alt="image-20191226231946271"></p>
<p>海明码特点：</p>
<ul>
<li>编码效率高：数据增加一倍，校验位只增加一位</li>
<li>可纠正一位错</li>
<li>50年代发明时用于自动处理穿孔卡片的故障</li>
<li>现在普遍用于ECC  DRAM芯片</li>
<li>RAID2，卫星通讯</li>
</ul>
<h2 id="校验码总结"><a href="#校验码总结" class="headerlink" title="校验码总结"></a>校验码总结</h2><p><img src="/2019/12/19/数据表示/image-20191220010548069.png" alt="image-20191220010548069"></p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>下列对海明校验的描述中，正确的描述是  <strong>C</strong><br>A.在任何条件下，海明校验都无法检测到多位数据同时出错的情况<br>B.分成r组时，可以得到r位指误码，因此可以QU区分2^r种只有1位出错的情况<br>C.待编码数据长度为4位，再增加3位校验码就可以检测到仅1位数据出错的情况并纠错<br>D.海明校验码的码距与校验位的位数没有关系</p>
<hr>
<p>计算机字长16位，采用补码表示整数，下列关于其表示数据范围的描述中正确的是<strong>ABCD</strong><br>A.能表示的最小正数是1<br>B.能表示的最小负数是- (2 ^15)<br>C.能表示最大正数是(2^15) - 1<br>D.能表示的最大负数是-1</p>
<hr>
<p>列关于补码和移码关系的描述中，错误的是<strong>B</strong><br>A.一般用译码表示浮点数的阶码，而用补码表示定点数<br>B.零的补码和移码相同<br>C.同一个数的补码和移码，其数值部分相同，而符号相反<br>D.相同位数的补码和移码具有相同的数据表示范围</p>
<p>移码：X+2^n</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的右视图</title>
    <url>/2019/12/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<p>来源Leetcode第199题二叉树的右视图</p>
<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。<br><a id="more"></a><br><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">4</span>]</span><br><span class="line">输出: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>            &lt;---</span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span>         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  <span class="number">5</span>     <span class="number">4</span>       &lt;---</span><br></pre></td></tr></table></figure>
<h3 id="错误的遍历"><a href="#错误的遍历" class="headerlink" title="错误的遍历"></a>错误的遍历</h3><p>第一次提交忽略了当右子树比左子树短的情况下，要对左子树进行遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    helper(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>)</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">        helper(root.right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">        helper(root.left);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>既然要考虑所有情况，那么就进行层序遍历，然后保留最后一个进队列的节点即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> len = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == len - <span class="number">1</span>)</span><br><span class="line">                ans.add(queue.peek().val);</span><br><span class="line">            TreeNode tmp = queue.remove();</span><br><span class="line">            <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(tmp.left);</span><br><span class="line">            <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>来源<a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/solution/er-cha-shu-de-you-shi-tu-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<p><strong>直觉</strong></p>
<p>如果按正确的顺序访问每个节点，就可以有效地获得二叉树的右视图。</p>
<p><strong>算法</strong></p>
<p>上面提到的顺序之一可以由深度优先搜索定义。在深度优先搜索中，我们总是先访问右子树。这样就保证了当我们访问树的某个特定深度时，我们正在访问的节点总是该深度的最右侧节点。于是，可以存储在每个深度访问的第一个结点，一旦我们知道了树的层数，就可以得到最终的结果数组。</p>
<p><img src="/2019/12/19/二叉树的右视图/80f65d954842dc68509b516d563f846d1f02a31d099027d5a94b49b465e6030c-image.png" alt="image.png"></p>
<p>上图表示了问题的一个实例。红色结点自上而下组成答案，边缘以访问顺序标号。</p>
<p>题解通过维护两个栈（一个深度栈，一个节点栈）栈以及一个HashMap来填充每层的右视图。通过左子树入栈在右子树入栈的顺序保证出栈时是右子树先出栈，在将其对应深度填到HashMap里，最后按照深度对Map做一次遍历即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; rightmostValueAtDepth = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> max_depth = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* These two stacks are always synchronized, providing an implicit</span></span><br><span class="line"><span class="comment">         * association values with the same offset on each stack. */</span></span><br><span class="line">        Stack&lt;TreeNode&gt; nodeStack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; depthStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        nodeStack.push(root);</span><br><span class="line">        depthStack.push(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!nodeStack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = nodeStack.pop();</span><br><span class="line">            <span class="keyword">int</span> depth = depthStack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                max_depth = Math.max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* The first node that we encounter at a particular depth contains</span></span><br><span class="line"><span class="comment">                * the correct value. */</span></span><br><span class="line">                <span class="keyword">if</span> (!rightmostValueAtDepth.containsKey(depth)) &#123;</span><br><span class="line">                    rightmostValueAtDepth.put(depth, node.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                nodeStack.push(node.left);</span><br><span class="line">                nodeStack.push(node.right);</span><br><span class="line">                depthStack.push(depth+<span class="number">1</span>);</span><br><span class="line">                depthStack.push(depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Construct the solution based on the values that we end up with at the</span></span><br><span class="line"><span class="comment">         * end. */</span></span><br><span class="line">        List&lt;Integer&gt; rightView = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> depth = <span class="number">0</span>; depth &lt;= max_depth; depth++) &#123;</span><br><span class="line">            rightView.add(rightmostValueAtDepth.get(depth));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>既然题解里用深度标明了每层的元素，那么我也应该可以在递归时多传一个参数，记作是当前节点的深度值，按照右左的顺序递归即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    helper(root,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,<span class="keyword">int</span> deepth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(deepth == ans.size())</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">        helper(root.right,deepth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">        helper(root.left,deepth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>树</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>求根到叶子节点数字之和</title>
    <url>/2019/12/18/%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>来源Leetcode第129题求根到叶子节点数字之和</p>
<p>给定一个二叉树，它的每个结点都存放一个 <code>0-9</code> 的数字，每条从根到叶子节点的路径都代表一个数字。<br><a id="more"></a><br>例如，从根到叶子节点路径 <code>1-&gt;2-&gt;3</code> 代表数字 <code>123</code>。</p>
<p>计算从根到叶子节点生成的所有数字之和。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">输出: <span class="number">25</span></span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-&gt;<span class="number">2</span> 代表数字 <span class="number">12.</span></span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-&gt;<span class="number">3</span> 代表数字 <span class="number">13.</span></span><br><span class="line">因此，数字总和 = <span class="number">12</span> + <span class="number">13</span> = <span class="number">25.</span></span><br></pre></td></tr></table></figure>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>跟之前写的路径总和差不多，也是要注意DFS在返回时需要去掉最后一个加入的点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    helper(root,ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>)</span><br><span class="line">        sum = sum * <span class="number">10</span> + root.val;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">        ans += sum;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">        helper(root.left,sum);</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">        helper(root.right,sum);</span><br><span class="line">    sum /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>来源<a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/solution/3zhong-jie-fa-di-gui-xian-xu-fei-di-gui-xian-xu-ce/" target="_blank" rel="noopener">题解</a><br>通常还可以用 <code>stack</code> 的思路来解递归的题目。先序非递归的代码我们知道是用 <code>stack</code> 来保存遍历过的元素。而因为本题要记录到叶节点的数字，所以需要一个额外的 <code>stack</code> 来记录数字。每次出 <code>stack</code> 之后，如果是叶子节点，那么加和；如果不是，那么就看左右子树，入 <code>stack</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> sum;</span><br><span class="line">       Stack&lt;TreeNode&gt; nodeStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       Stack&lt;Integer&gt; numStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       nodeStack.add(root);</span><br><span class="line">       numStack.add(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">while</span> (!nodeStack.isEmpty()) &#123;</span><br><span class="line">           TreeNode current = nodeStack.pop();</span><br><span class="line">           Integer currentNum = numStack.pop() * <span class="number">10</span> + current.val;</span><br><span class="line">           <span class="keyword">if</span> (current.left == <span class="keyword">null</span> &amp;&amp; current.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">               sum += currentNum;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">               nodeStack.add(current.left);</span><br><span class="line">               numStack.add(currentNum);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">               nodeStack.add(current.right);</span><br><span class="line">               numStack.add(currentNum);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>树</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>复制带随机指针的链表</title>
    <url>/2019/12/18/%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>来源Leetcode第138题复制带随机指针的链表</p>
<p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p>
<p>要求返回这个链表的<strong><a href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin" target="_blank" rel="noopener">深拷贝</a></strong>。 <a id="more"></a></p>
<p><strong>示例：</strong></p>
<p><strong><img src="/2019/12/18/复制带随机指针的链表/1470150906153-2yxeznm.png" alt="img"></strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">&#123;<span class="string">"<span class="subst">$id</span>"</span>:<span class="string">"1"</span>,<span class="string">"next"</span>:&#123;<span class="string">"<span class="subst">$id</span>"</span>:<span class="string">"2"</span>,<span class="string">"next"</span>:<span class="keyword">null</span>,<span class="string">"random"</span>:&#123;<span class="string">"<span class="subst">$ref</span>"</span>:<span class="string">"2"</span>&#125;,<span class="string">"val"</span>:<span class="number">2</span>&#125;,<span class="string">"random"</span>:&#123;<span class="string">"<span class="subst">$ref</span>"</span>:<span class="string">"2"</span>&#125;,<span class="string">"val"</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">节点 <span class="number">1</span> 的值是 <span class="number">1</span>，它的下一个指针和随机指针都指向节点 <span class="number">2</span> 。</span><br><span class="line">节点 <span class="number">2</span> 的值是 <span class="number">2</span>，它的下一个指针指向 <span class="keyword">null</span>，随机指针指向它自己。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>你必须返回<strong>给定头的拷贝</strong>作为对克隆列表的引用。</li>
</ol>
<h3 id="哈希Map"><a href="#哈希Map" class="headerlink" title="哈希Map"></a>哈希Map</h3><p>利用一个哈希Map存储原链表结点和对应的拷贝结点，在原链表里遍历，但是要注意当原结点的随机结点为空时，不能将空结点及其拷贝放入哈希Map里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Map&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Node newHead = <span class="keyword">new</span> Node();</span><br><span class="line">    map.put(head,newHead);</span><br><span class="line">    Node p1 = newHead;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p1.val = head.val;</span><br><span class="line">        <span class="comment">//p1.next = head.next;</span></span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(head.random) &amp;&amp; head.random != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node tmp = <span class="keyword">new</span> Node();</span><br><span class="line">            map.put(head.random,tmp);</span><br><span class="line">            p1.random = tmp;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head.random != <span class="keyword">null</span>)</span><br><span class="line">            p1.random = map.get(head.random);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p1.random = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//map.put(head,p1);</span></span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(head))&#123;</span><br><span class="line">            p1.next = <span class="keyword">new</span> Node();</span><br><span class="line">            map.put(head,p1.next);</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p1.next = map.get(head);</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原结点后追加新结点"><a href="#原结点后追加新结点" class="headerlink" title="原结点后追加新结点"></a>原结点后追加新结点</h3><p> <code>HashMap</code> 额外需要 <code>O(n)</code> 的空间复杂度，现在考虑不需要额外空间的方法。</p>
<p>主要参考了<a href="https://leetcode.com/problems/copy-list-with-random-pointer/discuss/43491/A-solution-with-constant-space-complexity-O(1" target="_blank" rel="noopener">这里</a>-and-linear-time-complexity-O(N))。主要解决的问题就是我们生成节点以后，当更新它的 <code>random</code> 的时候，怎么找到之前生成的节点，前两种解法用了 <code>HashMap</code> 全部存起来，这里的话可以利用原来的链表的指针域。</p>
<p>主要需要三步。</p>
<ol>
<li>生成所有的节点，并且分别插入到原有节点的后边</li>
<li>更新插入节点的 <code>random</code></li>
<li>将新旧节点分离开来</li>
</ol>
<p>一图胜千言，大家看一下下边的图吧。</p>
<p><img src="https://pic.leetcode-cn.com/9bd4662fdbcb1e44f5ce208e29f3459d1adbf1e7ceb723e4bfc8ba2eff3bd186.jpg" alt="img"></p>
<p>代码对应如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node l1 = head;</span><br><span class="line">    Node l2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//生成所有的节点，并且分别插入到原有节点的后边</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        l2 = <span class="keyword">new</span> Node();</span><br><span class="line">        l2.val = l1.val;</span><br><span class="line">        l2.next = l1.next;</span><br><span class="line">        l1.next = l2;</span><br><span class="line">        l1 = l1.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新插入节点的 random</span></span><br><span class="line">    l1 = head;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">            l1.next.random = l1.random.next;</span><br><span class="line">        &#125;</span><br><span class="line">        l1 = l1.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l1 = head;</span><br><span class="line">    Node l2_head = l1.next;</span><br><span class="line">    <span class="comment">//将新旧节点分离开来</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        l2 = l1.next;</span><br><span class="line">        l1.next = l2.next;</span><br><span class="line">        <span class="keyword">if</span> (l2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            l2.next = l2.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l2_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用random保存新结点"><a href="#利用random保存新结点" class="headerlink" title="利用random保存新结点"></a>利用random保存新结点</h3><p>不利用额外的空间复杂度还有一种思路，参考 <a href="https://leetcode.com/problems/copy-list-with-random-pointer/discuss/43497/2-clean-C%2B%2B-algorithms-without-using-extra-arrayhash-table.-Algorithms-are-explained-step-by-step." target="_blank" rel="noopener">这里</a>。</p>
<p>上一个解法利用原链表的 <code>next</code> 域把新生成的节点保存了起来。类似的，我们还可以利用原链表的 <code>random</code> 域把新生成的节点保存起来。</p>
<p>主要还是三个步骤。</p>
<ol>
<li>生成所有的节点，将它们保存到原链表的 <code>random</code> 域，同时利用新生成的节点的 <code>next</code> 域保存原链表的 <code>random</code>。</li>
<li>更新新生成节点的 <code>random</code> 指针。</li>
<li>恢复原链表的 <code>random</code> 指针，同时更新新生成节点的 <code>next</code> 指针。</li>
</ol>
<p>一图胜千言。</p>
<p><img src="https://pic.leetcode-cn.com/9d18d01597f5ca7562c8dd3908082b13c27b989fcaebb37c163d6e7ced65f412.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node l1 = head;</span><br><span class="line">    Node l2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//生成所有的节点，讲它们保存到原链表的 random 域，</span></span><br><span class="line">    <span class="comment">//同时利用新生成的节点的 next 域保存原链表的 random。</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        l2 = <span class="keyword">new</span> Node();</span><br><span class="line">        l2.val = l1.val;</span><br><span class="line">        l2.next = l1.random;</span><br><span class="line">        l1.random = l2;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    l1 = head;</span><br><span class="line">    <span class="comment">//更新新生成节点的 random 指针。</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        l2 = l1.random;</span><br><span class="line">        l2.random = l2.next != <span class="keyword">null</span> ? l2.next.random : <span class="keyword">null</span>;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l1 = head;</span><br><span class="line">    Node l2_head = l1.random;</span><br><span class="line">    <span class="comment">//恢复原链表的 random 指针，同时更新新生成节点的 next 指针。</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        l2 = l1.random;</span><br><span class="line">        l1.random = l2.next;</span><br><span class="line">        l2.next = l1.next != <span class="keyword">null</span> ? l1.next.random : <span class="keyword">null</span>;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l2_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>路径总和II</title>
    <url>/2019/12/17/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/</url>
    <content><![CDATA[<p>来源Leetcode第113题路径总和II</p>
<p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。<a id="more"></a></p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">      <span class="number">5</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">4</span>   <span class="number">8</span></span><br><span class="line">   /   / \</span><br><span class="line">  <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></span><br><span class="line"> /  \    / \</span><br><span class="line"><span class="number">7</span>    <span class="number">2</span>  <span class="number">5</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>返回:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">   [<span class="number">5</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>],</span><br><span class="line">   [<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>在递归返回上一层的时候要删去最后一个加入的节点，这样是否就可以认为是址传递呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    helper(root,sum,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum,List&lt;Integer&gt; ss)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || sum &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//List&lt;Integer&gt; ss = new ArrayList&lt;&gt;(s);</span></span><br><span class="line">    ss.add(root.val);</span><br><span class="line">    sum -= root.val;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == <span class="number">0</span>)</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(ss));</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; sum &gt; <span class="number">0</span>)</span><br><span class="line">        helper(root.left,sum,ss);</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span> &amp;&amp; sum &gt; <span class="number">0</span>)</span><br><span class="line">        helper(root.right,sum,ss);</span><br><span class="line">    ss.remove(ss.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>printf缓冲区问题</title>
    <url>/2019/12/17/printf%E7%BC%93%E5%86%B2%E5%8C%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>这里就要区分一下标准库函数和系统调用了。</p>
<p> 系统调用是内核提供给上层程序的接口，能够实现内核和上层之间的交互，系统调用在内核中的实现是软中断的方式，通过相应的中断服务例程来实现，<a id="more"></a>而标准库函数是在系统调用的基础之上封装的应用程序，完全运行在用户态，在必要的时候调用系统调用。编写应用程序可以直接使用应用程序也可以使用库函数，那为什么还要有库函数呢。</p>
<p> 以printf为例，在printf的实现中，在调用write之前加入了IO缓冲区，这是一个用户空间的缓冲，首先要说明一点，系统调用是软中断，频繁调用，需要内核频繁陷入内核态，这样的效率不是很高，而printf实际是向用户空间的IO缓冲写，在满足条件的情况下（条件下面会说）才会调用write系统调用，这样也就提高了内核的效率。</p>
<p>  对于普通的文件操作，库函数因为IO缓冲区，效率高，其他方面与直接调用系统调用无异，但是对于一些特殊的文件，如串口终端以及网络设备。对于应用程序来将，我们更加希望的是每次的操作能够真真正正的反映在底层的硬件上，这时我们最好就不要使用类似与printf这样的带IO缓冲区的标准库函数了，而是直接使用系统调用，我上面就是犯了这个错误。</p>
<p>  说完标准库函数和系统调用的区别，我们就要具体的分析一下printf。</p>
<p>  printf是一个行缓冲函数，先写到缓冲区，满足条件后，才将缓冲区刷到对应文件中，刷缓冲区的条件如下：</p>
<p>  1 缓冲区填满</p>
<p>  2 写入的字符中有‘\n’ ‘\r’</p>
<p>  3 调用fflush手动刷新缓冲区</p>
<p>  4 调用scanf要从缓冲区中读取数据时，也会将缓冲区内的数据刷新</p>
<p> 满足上面4个条件之一缓冲区就会刷新，也就是printf会真正调用write来写入</p>
<p>  当我们执行printf的进程或者线程结束的时候会主动调用flush来刷新缓冲区，所以程序结束，也会刷新</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Crossing River</title>
    <url>/2019/12/14/Crossing-River/</url>
    <content><![CDATA[<p>来源POJ第1700题Crossing River</p>
<p><strong>Description</strong></p>
<p>A group of N people wishes to go across a river with only one boat, which can at most carry two persons. Therefore some sort of shuttle arrangement must be arranged in order to row the boat back and forth so that all people may cross.<a id="more"></a> Each person has a different rowing speed; the speed of a couple is determined by the speed of the slower one. Your job is to determine a strategy that minimizes the time for these people to get across.</p>
<p><strong>Input</strong></p>
<p>The first line of the input contains a single integer T (1 &lt;= T &lt;= 20), the number of test cases. Then T cases follow. The first line of each case contains N, and the second line contains N integers giving the time for each people to cross the river. Each case is preceded by a blank line. There won’t be more than 1000 people and nobody takes more than 100 seconds to cross.</p>
<p><strong>Output</strong></p>
<p>For each test case, print a line containing the total number of seconds required for all the N people to cross the river.</p>
<p>Sample Input</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">5</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure>
<p>思路比较简单，分情况讨论，1个人过河，时长取最短的，2个人，时长取nums[1]，3个人取nums[0] + nums[1] + nums[2],当人数增加到4个人以上时要讨论，最快的(即所用时间nums[0])和次快的过河,然后最快的将船划回来,再次慢的和最慢的过河,然后次快的将船划回来.即所需时间为:nums[0]+2<em>nums[1]+nums[n-1],最快的和最慢的过河,然后最快的将船划回来,再最快的和次慢的过河,然后最快的将船划回来.即所需时间为:2</em>nums[0]+nums[n-2]+nums[n-1]这样就将过河所需时间最大的两个人送过了河,而对于剩下的人,采用同样的处理方式,接下来做的就是判断怎样用的时间最少.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//public static int[] nums;</span></span><br><span class="line">	<span class="comment">//public static long mid;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> all = in.nextInt(), len, ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (all &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			ans = <span class="number">0</span>;</span><br><span class="line">			len = in.nextInt();</span><br><span class="line">			<span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">				nums[i] = in.nextInt();</span><br><span class="line">			Arrays.sort(nums);</span><br><span class="line">			<span class="keyword">int</span> times = len;</span><br><span class="line">			<span class="keyword">while</span>(times &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (times == <span class="number">1</span>) &#123;  <span class="comment">//特殊情况1</span></span><br><span class="line">					ans += nums[<span class="number">0</span>];</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (times == <span class="number">2</span>) &#123;  <span class="comment">//特殊情况2</span></span><br><span class="line">					ans += nums[<span class="number">1</span>];</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (times == <span class="number">3</span>) &#123;  <span class="comment">//特殊情况3</span></span><br><span class="line">					<span class="comment">//0 2 过河，0回来，0 1 过河</span></span><br><span class="line">					ans += nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					ans += Math.min(<span class="number">2</span> * nums[<span class="number">1</span>] + nums[<span class="number">0</span>] + nums[times - <span class="number">1</span>], nums[times - <span class="number">1</span>] + <span class="number">2</span> * nums[<span class="number">0</span>] + nums[times - <span class="number">2</span>]);</span><br><span class="line">					times -= <span class="number">2</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(ans);</span><br><span class="line">			all--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>POJ</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Median</title>
    <url>/2019/12/14/Median/</url>
    <content><![CDATA[<p>来源POJ第3579题Median</p>
<p><strong>Description</strong></p>
<p>Given <em>N</em> numbers, <em>X</em>1, <em>X</em>2, … , <em>XN</em>, let us calculate the difference of every pair of numbers: ∣<em>Xi</em> - <em>Xj</em>∣ (1 ≤ <em>i</em> ＜ <em>j</em> ≤ <em>N</em>). We can get <em>C(N,2)</em> differences through this work, <a id="more"></a>and now your task is to find the median of the differences as quickly as you can!</p>
<p>Note in this problem, the median is defined as the <em>(m/2)-th</em> smallest number if <em>m</em>,the amount of the differences, is even. For example, you have to find the third smallest one in the case of <em>m</em> = 6.</p>
<p><strong>Input</strong></p>
<p>The input consists of several test cases.<br>In each test case, <em>N</em> will be given in the first line. Then <em>N</em> numbers are given, representing <em>X</em>1, <em>X</em>2, … , <em>XN</em>, ( <em>Xi</em> ≤ 1,000,000,000 3 ≤ N ≤ 1,00,000 )</p>
<p><strong>Output</strong></p>
<p>For each test case, output the median in a separate line.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">10</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>一共有n*(n-1)/2种不同的配对，一一枚举的时间复杂度为O(n^2)，显然无法在1s内给出答案。在此使用二分法，先将数组排序，然后我们可以确定最大的距离为Xn-X1，那么我们只需要在0~|Xn-X1|，这些数之间寻找中位数即可。</p>
<p>  一共需要两次二分。第一次二分，是用来寻找（猜测）可能的中位数的大小，当我们选择了一个mid值，我们需要计算有多少组配对的距离是小于这个mid值，如果不到k/2，则需要增加mid值，反之亦然；第二次二分用于对特定的元素计算小于mid的距离点对有多少个。</p>
<p>  需要注意的是，在发现小于mid的点对刚好是一半的时候，并不能说明mid就是中位数，我们一定要找到满足这一性质最小的mid，才是最终的答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> Mid;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">			n = in.nextInt();</span><br><span class="line">			Mid = ((<span class="keyword">long</span>) n * (n - <span class="number">1</span>)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			Mid = (Mid + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">//中位数的位置</span></span><br><span class="line">			nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">				nums[i] = in.nextInt();</span><br><span class="line">			&#125;</span><br><span class="line">			Arrays.sort(nums);</span><br><span class="line">			<span class="keyword">int</span> left = -<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">int</span> right = nums[n - <span class="number">1</span>] - nums[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (right - left &gt; <span class="number">1</span>) &#123;<span class="comment">//二分搜索</span></span><br><span class="line">				<span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (test(mid,n)) &#123;</span><br><span class="line">					right = mid;</span><br><span class="line">				&#125; <span class="keyword">else</span></span><br><span class="line">					left = mid;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> mid, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (nums[i] - nums[j] &gt; mid)</span><br><span class="line">				j++;</span><br><span class="line">			count += (i - j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count &gt;= Mid;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>POJ</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>二分</tag>
        <tag>中位数</tag>
      </tags>
  </entry>
  <entry>
    <title>路径总和</title>
    <url>/2019/12/14/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<p>来自Leetcode第112题路径总和</p>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。<br><a id="more"></a><br><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">      <span class="number">5</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">4</span>   <span class="number">8</span></span><br><span class="line">   /   / \</span><br><span class="line">  <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></span><br><span class="line"> /  \      \</span><br><span class="line"><span class="number">7</span>    <span class="number">2</span>      <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>返回 <code>true</code>, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>利用两个栈分别保存到当前叶子节点走过的路径和总和，最后比对出栈换向.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; tree = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; val = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode tmp = root;</span><br><span class="line">    <span class="keyword">int</span> tmp_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tmp != <span class="keyword">null</span> || !tree.empty())&#123;</span><br><span class="line">        <span class="comment">//遍历完左子树</span></span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            tree.push(tmp);</span><br><span class="line">            tmp_sum += tmp.val;</span><br><span class="line">            val.push(tmp_sum);</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = tree.pop();</span><br><span class="line">        tmp_sum = val.pop();</span><br><span class="line">        <span class="comment">//依次遍历值</span></span><br><span class="line">        <span class="keyword">if</span>(tmp_sum == sum &amp;&amp; tmp.left == <span class="keyword">null</span> &amp;&amp; tmp.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//更改方向到右子树</span></span><br><span class="line">        tmp = tmp.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归来源于<a href="https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<p>最直接的方法就是利用递归，遍历整棵树：如果当前节点不是叶子，对它的所有孩子节点，递归调用 <code>hasPathSum</code> 函数，其中 sum 值减去当前节点的权值；如果当前节点是叶子，检查 sum 值是否为 0，也就是是否找到了给定的目标和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  sum -= root.val;</span><br><span class="line">  <span class="keyword">if</span> ((root.left == <span class="keyword">null</span>) &amp;&amp; (root.right == <span class="keyword">null</span>))</span><br><span class="line">    <span class="keyword">return</span> (sum == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> hasPathSum(root.left, sum) || hasPathSum(root.right, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>深度优先搜索</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>SOLDIERS</title>
    <url>/2019/12/14/SOLDIERS/</url>
    <content><![CDATA[<p>来源POJ第1723题SOLDIERS</p>
<p><strong>Description</strong></p>
<p>N soldiers of the land Gridland are randomly scattered around the country.<br>A position in Gridland is given by a pair (x,y) of integer coordinates.<a id="more"></a> Soldiers can move - in one move, one soldier can go one unit up, down, left or right (hence, he can change either his x or his y coordinate by 1 or -1).</p>
<p>The soldiers want to get into a horizontal line next to each other (so that their final positions are (x,y), (x+1,y), …, (x+N-1,y), for some x and y). Integers x and y, as well as the final order of soldiers along the horizontal line is arbitrary.</p>
<p>The goal is to minimise the total number of moves of all the soldiers that takes them into such configuration.</p>
<p>Two or more soldiers must never occupy the same position at the same time.</p>
<p><strong>Input</strong></p>
<p>The first line of the input contains the integer N, 1 &lt;= N &lt;= 10000, the number of soldiers.<br>The following N lines of the input contain initial positions of the soldiers : for each i, 1 &lt;= i &lt;= N, the (i+1)st line of the input file contains a pair of integers x[i] and y[i] separated by a single blank character, representing the coordinates of the ith soldier, -10000 &lt;= x[i],y[i] &lt;= 10000.</p>
<p><strong>Output</strong></p>
<p>The first and the only line of the output should contain the minimum total number of moves that takes the soldiers into a horizontal line next to each other.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span>-<span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>其实本题求的是距离，反映到数学上，就是求两点之间的绝对值吗。</p>
<p>对于一个数列，其各点到此数列的中位数处的距离之和是最短的。</p>
<p>因此，分别对两个数列进行排序对于纵坐标，直接求出各点到中位数处的距离即可。对于横坐标，首先先将其排序后减去自身的位置，即x[i] - i,这是因为最终要求是在同一横排上，因而当x[i] - i，一样的时候，说明他们本身就是相邻的，最后通过构建出的x[i]-i数组，取中位数d[mid]-d[i]求和即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">			Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">			<span class="keyword">int</span> len = in.nextInt();</span><br><span class="line">			<span class="keyword">int</span> [] dx = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">			<span class="keyword">int</span> [] dy = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">				dx[i] = in.nextInt();</span><br><span class="line">				dy[i] = in.nextInt();</span><br><span class="line">			&#125;</span><br><span class="line">			Arrays.sort(dx);</span><br><span class="line">			Arrays.sort(dy);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len ; i++)</span><br><span class="line">				dx[i - <span class="number">1</span>] -= i;</span><br><span class="line">			Arrays.sort(dx);</span><br><span class="line">			<span class="keyword">int</span> midx = dx[(len) / <span class="number">2</span> ];</span><br><span class="line">			<span class="keyword">int</span> midy = dy[(len) / <span class="number">2</span>];</span><br><span class="line">			<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">				ans += Math.abs(midx - dx[i]) + Math.abs(midy - dy[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(ans);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>POJ</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>中位数</tag>
      </tags>
  </entry>
  <entry>
    <title>Sacrament of the sum</title>
    <url>/2019/12/14/Sacrament-of-the-sum/</url>
    <content><![CDATA[<p>来源POJ第2366题Sacrament of the sum</p>
<p><strong>Description</strong></p>
<p>— The Brother of mine, the Head of Monastic Order wants to know tomorrow about the results long-term researches. He wants to see neither more nor less than the <a id="more"></a>Summering Machine! Even moreover, he wants our Machine — only a machine — to demonstrate its comprehension of the Sacrament of the Sum as deeply as it is possible. He wants our Machine to find two numbers that give the sum equal to the Sacred Number 10 000.<br>— Tsh-sh-sh! This is madness that borders on blasphemy! How can the Machine calculate the Sacred Number? Twenty seven years we work on it, but we’ve could teach it to tell if the sum of two introduced numbers greater or lower than 10 000. Can an ordinary mortal find two numbers that there sum will be equal to 10 000?<br>— But we’ll have to do it with the help of our Machine, even if it is not capable. Otherwise we’ll have… let’s say, big problems, if it is possible to call boiling oil like this. However, I have an idea. Do you remember, last week we’ve entered two numbers -7 and 13 into the Machine, and it answered that their sum is lower than 10 000. I don’t know how to check this, but nothing’s left for us than to believe to the fruit of our work. Let’s enter now a greater number than -7 and start up the Machine again. We’ll do like this again and again until we find a number that being added to 13 will give us 10 000. The only thing we are to do is to prepare an ascending list of numbers.<br>— I don’t believe in this… Let’s start with the sum that is obviously greater than the Sacred Number and we’ll decrease one of the summand. So we have more chances to avoid boilin… big problems.</p>
<p>Haven’t come to an agreement, the Brothers went away to their cells. By next day everyone of them has prepared a list of numbers that, to his opinion, could save them… Can both of the lists save them together?<br>Your program should decide, if it is possible to choose from two lists of integers such two numbers that their sum would be equal to 10 000.</p>
<p><strong>Input</strong></p>
<p>You are given both of these lists one by one. Format of each of these lists is as follows: in the first line of the list the quantity of numbers Ni of the i-th list is written. Further there is an i-th list of numbers each number in its line (Ni lines).The following conditions are satisfied: 1 &lt;= Ni &lt;= 50 000, each element of the lists lays in the range from -32768 to 32767. The first list is ascending and the second one is descending.</p>
<p><strong>Output</strong></p>
<p>You should write “YES” to the standard output if it is possible to choose from the two lists of integers such two numbers that their sum would be equal to 10 000. Otherwise you should write “NO”.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">-175</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">10424</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">8951</span></span><br><span class="line"><span class="number">-424</span></span><br><span class="line"><span class="number">-788</span></span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="literal">YES</span></span><br></pre></td></tr></table></figure>
<p><strong>Hint</strong></p>
<p>This problem has huge input data,use scanf() instead of cin to read data to avoid time limit exceed.</p>
<h3 id="空间换时间"><a href="#空间换时间" class="headerlink" title="空间换时间"></a>空间换时间</h3><p>由题目可知数据大小再-32768到32768之间，因而可以直接利用大数组来存输入的数据，输入的输入如果大于0，放在第一个数组对应的A[in]位置，否则放在B[-in]，输入第二个数组的值时，先求出1000-in的值，如果大于0且A[10000-in]的值存在，说明找到了，或者B[in - 10000]存在，否则继续输入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">int</span> temp;</span><br><span class="line">		<span class="keyword">int</span> len1 = in.nextInt();</span><br><span class="line">		<span class="keyword">int</span> [] A = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">65535</span>];</span><br><span class="line">		<span class="keyword">int</span> [] B = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">65535</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">			temp = in.nextInt();  <span class="comment">//数组A升序</span></span><br><span class="line">			<span class="keyword">if</span>(temp &gt;= <span class="number">0</span>)</span><br><span class="line">				A[temp] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				B[-temp] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> len2 = in.nextInt();</span><br><span class="line">		<span class="keyword">if</span>(len1 &lt;= <span class="number">0</span> || len2 &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">"NO"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len2;i++) &#123;</span><br><span class="line">			temp = in.nextInt();  <span class="comment">//数组B降序</span></span><br><span class="line">			temp = <span class="number">10000</span> - temp;</span><br><span class="line">			<span class="keyword">if</span>(temp &gt;= <span class="number">0</span> &amp;&amp; A[temp] == <span class="number">1</span>)&#123;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp &lt; <span class="number">0</span> &amp;&amp; B[-temp] == <span class="number">1</span>)&#123;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">			System.out.println(<span class="string">"YES"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			System.out.println(<span class="string">"NO"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="哈希Map"><a href="#哈希Map" class="headerlink" title="哈希Map"></a>哈希Map</h3><p>利用一个Map存放输入的值，和对应的数组标志，在数组B边输入时边查询即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">			Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">			<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">int</span> len1 = in.nextInt();</span><br><span class="line">			<span class="keyword">int</span>[] A = <span class="keyword">new</span> <span class="keyword">int</span>[len1];</span><br><span class="line">			Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">				A[i] = in.nextInt();  <span class="comment">//数组A升序</span></span><br><span class="line">				map.put(A[i],<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> len2 = in.nextInt();</span><br><span class="line">			<span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">65535</span>];</span><br><span class="line">			<span class="comment">//Arrays.setAll(B,a -&gt; -2147483647);</span></span><br><span class="line">			<span class="keyword">if</span> (len1 &lt;= <span class="number">0</span> || len2 &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				System.out.println(<span class="string">"NO"</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2 ; i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> complement;</span><br><span class="line">				B[i] = in.nextInt();</span><br><span class="line">				<span class="comment">//key = 1;</span></span><br><span class="line">				complement = <span class="number">10000</span> - B[i];</span><br><span class="line">			<span class="keyword">if</span>(map.containsKey(complement) &amp;&amp; (map.get(complement) == <span class="number">0</span>))&#123;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			map.put(B[i],<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="keyword">if</span> (flag)</span><br><span class="line">				System.out.println(<span class="string">"YES"</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				System.out.println(<span class="string">"NO"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>思路同上，对输入数组B的每一个数在数组A里进行二分查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">int</span> len1 = in.nextInt();</span><br><span class="line">		<span class="keyword">int</span> [] A = <span class="keyword">new</span> <span class="keyword">int</span>[len1];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">			A[i] = in.nextInt();  <span class="comment">//数组A升序</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> len2 = in.nextInt();</span><br><span class="line">		<span class="keyword">if</span>(len1 &lt;= <span class="number">0</span> || len2 &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">"NO"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> temp,left,right,mid,complement;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; len2 ; j++) &#123;</span><br><span class="line">			temp = in.nextInt();</span><br><span class="line">			complement = <span class="number">10000</span> - temp;</span><br><span class="line">			<span class="comment">//对数组a中的每个元素进行二分搜索</span></span><br><span class="line">			left = <span class="number">0</span>;</span><br><span class="line">			right = len1 - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">				mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span> (complement == A[mid]) &#123;</span><br><span class="line">					flag = <span class="keyword">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (complement &lt; A[mid]) &#123;</span><br><span class="line">					right = mid - <span class="number">1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span></span><br><span class="line">					left = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">			System.out.println(<span class="string">"YES"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			System.out.println(<span class="string">"NO"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>POJ</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>哈希</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Matrix Power Series</title>
    <url>/2019/12/14/Matrix-Power-Series/</url>
    <content><![CDATA[<p>来源POJ第3233题Matrix Power Series</p>
<p><strong>Description</strong></p>
<p>Given a <em>n</em> × <em>n</em> matrix <em>A</em> and a positive integer <em>k</em>, find the sum <em>S</em> = <em>A</em> + <em>A</em>2 + <em>A</em>3 + … + <em>Ak</em>.<br><a id="more"></a><br><strong>Input</strong></p>
<p>The input contains exactly one test case. The first line of input contains three positive integers <em>n</em> (<em>n</em> ≤ 30), <em>k</em> (<em>k</em> ≤ 109) and <em>m</em> (<em>m</em> &lt; 104). Then follow <em>n</em> lines each containing <em>n</em> nonnegative integers below 32,768, giving <em>A</em>’s elements in row-major order.</p>
<p><strong>Output</strong></p>
<p>Output the elements of <em>S</em> modulo <em>m</em> in the same way as <em>A</em> is given.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">2 </span><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>题目要求的是 A+A2+…+Ak，而不是单个矩阵的幂</p>
<p>　　那么我们可以构造一个分块的辅助矩阵 S，其中 A 为原矩阵，E 为单位矩阵，O 为0矩阵</p>
<p>　　<img src="/2019/12/14/Matrix-Power-Series/999549-20160924161629731-1694213740.png" alt="img"></p>
<p>　　我们将 S 取幂，会发现一个特性</p>
<p>　　<img src="/2019/12/14/Matrix-Power-Series/999549-20160924162453731-374268381.png" alt="img"></p>
<p>　　Sk 右上角那一块不正是我们要求的 A+A2+…+Ak 吗？</p>
<p>　　于是我们构造出 S 矩阵，然后对它求矩阵快速幂即可，最后别忘了减去一个单位阵</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		n = in.nextInt();  <span class="comment">//n阶矩阵</span></span><br><span class="line">		<span class="keyword">int</span> k = in.nextInt();  <span class="comment">//k次幂</span></span><br><span class="line">		<span class="keyword">int</span> m = in.nextInt();  <span class="comment">//mod m</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> [][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*n][<span class="number">2</span>*n];</span><br><span class="line">		<span class="keyword">int</span> [][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">				matrix[i][j] = in.nextInt();</span><br><span class="line">				<span class="comment">//ans[i][j] = matrix[i][j] % m;</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//构造右边的单位矩阵</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = n ; j &lt; <span class="number">2</span>*n; j++)</span><br><span class="line">				<span class="keyword">if</span>(j - i == n)</span><br><span class="line">					matrix[i][j] = <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//构造右下方单位矩阵</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; <span class="number">2</span>*n; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = n ; j &lt; <span class="number">2</span>*n ; j++)</span><br><span class="line">				<span class="keyword">if</span>(i == j)</span><br><span class="line">					matrix[i][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">				n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">				matrix = pow(matrix,k + <span class="number">1</span>,m);</span><br><span class="line">				n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//减去一个单位矩阵</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &lt; <span class="number">2</span>*n; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(j - i == n)</span><br><span class="line">						matrix[i][j] = (matrix[i][j] - <span class="number">1</span> + m) % m;</span><br><span class="line">					<span class="keyword">if</span>(j == <span class="number">2</span>*n - <span class="number">1</span>)</span><br><span class="line">					System.out.println(matrix[i][j]);</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						System.out.print(matrix[i][j] + <span class="string">" "</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//矩阵乘法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] matrixMul(<span class="keyword">int</span> [][] a, <span class="keyword">int</span> [][]b,<span class="keyword">int</span> mod)&#123;</span><br><span class="line">		<span class="keyword">int</span> [][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[a.length][a.length];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; n ; k++)&#123;</span><br><span class="line">					ans[i][j] += a[i][k] * b[k][j];</span><br><span class="line">					ans[i][j] %= mod;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//矩阵加法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> [][]a,<span class="keyword">int</span> [][]b,<span class="keyword">int</span> mod)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; a.length ; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; a.length ; j++)&#123;</span><br><span class="line">				a[i][j] += b[i][j];</span><br><span class="line">				a[i][j] %= mod;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//矩阵快速幂</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] pow(<span class="keyword">int</span> [][] a,<span class="keyword">int</span> n,<span class="keyword">int</span> mod)&#123;</span><br><span class="line">		<span class="keyword">int</span> [][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[a.length][a.length];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; a.length / <span class="number">2</span>; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; a.length / <span class="number">2</span>; j++)</span><br><span class="line">				<span class="keyword">if</span>(i == j)</span><br><span class="line">					ans[i][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">				ans = matrixMul(ans,a,mod);</span><br><span class="line">			a = matrixMul(a,a,mod);</span><br><span class="line">			n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>POJ</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>Babelfish</title>
    <url>/2019/12/14/Babelfish/</url>
    <content><![CDATA[<p>来源POJ第2503题</p>
<p><strong>Description</strong></p>
<p>You have just moved from Waterloo to a big city. The people here speak an incomprehensible dialect of a foreign language. Fortunately, <a id="more"></a>you have a dictionary to help you understand them.</p>
<p><strong>Input</strong></p>
<p>Input consists of up to 100,000 dictionary entries, followed by a blank line, followed by a message of up to 100,000 words. Each dictionary entry is a line containing an English word, followed by a space and a foreign language word. No foreign word appears more than once in the dictionary. The message is a sequence of words in the foreign language, one word on each line. Each word in the input is a sequence of at most 10 lowercase letters.</p>
<p><strong>Output</strong></p>
<p>Output is the message translated to English, one word per line. Foreign words not in the dictionary should be translated as “eh”.</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">dog</span> <span class="string">ogday</span></span><br><span class="line"><span class="attr">cat</span> <span class="string">atcay</span></span><br><span class="line"><span class="attr">pig</span> <span class="string">igpay</span></span><br><span class="line"><span class="attr">froot</span> <span class="string">ootfray</span></span><br><span class="line"><span class="attr">loops</span> <span class="string">oopslay</span></span><br><span class="line"></span><br><span class="line"><span class="attr">atcay</span></span><br><span class="line"><span class="attr">ittenkay</span></span><br><span class="line"><span class="attr">oopslay</span></span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cat</span></span><br><span class="line"><span class="attribute">eh</span></span><br><span class="line"><span class="attribute">loops</span></span><br></pre></td></tr></table></figure>
<p><strong>Hint</strong></p>
<p>Huge input and output,scanf and printf are recommended.</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>提示方案上说可用二分查找啥的，但是懒人直接当HashMap水题，直接过了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		String input;</span><br><span class="line">		String key,value;</span><br><span class="line">		<span class="keyword">int</span> index;</span><br><span class="line">		<span class="keyword">while</span> (!(input = in.nextLine()).equals(<span class="string">""</span>))&#123;</span><br><span class="line">			index = input.indexOf(<span class="string">' '</span>);</span><br><span class="line">			key = input.substring(<span class="number">0</span>,index);</span><br><span class="line">			value = input.substring(index + <span class="number">1</span>,input.length());</span><br><span class="line">			map.put(value,key);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!(input = in.nextLine()).equals(<span class="string">""</span>))&#123;</span><br><span class="line">			<span class="keyword">if</span>(map.containsKey(input))&#123;</span><br><span class="line">				System.out.println(map.get(input));</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"eh"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>POJ</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Flip Game</title>
    <url>/2019/12/14/Flip-Game/</url>
    <content><![CDATA[<p>来源POJ第1753题Flip Game</p>
<p><strong>Description</strong></p>
<p>Flip game is played on a rectangular 4x4 field with two-sided pieces placed on each of its 16 squares. One side of each piece is white and the other one is black and each piece is lying either it’s black or white side up. <a id="more"></a>Each round you flip 3 to 5 pieces, thus changing the color of their upper side from black to white and vice versa. The pieces to be flipped are chosen every round according to the following rules:</p>
<ol>
<li>Choose any one of the 16 pieces.</li>
<li>Flip the chosen piece and also all adjacent pieces to the left, to the right, to the top, and to the bottom of the chosen piece (if there are any).</li>
</ol>
<p><img src="/2019/12/14/Flip-Game/1753_1.jpg" alt="img">Consider the following position as an example:</p>
<p>bwbw<br>wwww<br>bbwb<br>bwwb<br>Here “b” denotes pieces lying their black side up and “w” denotes pieces lying their white side up. If we choose to flip the 1st piece from the 3rd row (this choice is shown at the picture), then the field will become:</p>
<p>bwbw<br>bwww<br>wwwb<br>wwwb<br>The goal of the game is to flip either all pieces white side up or all pieces black side up. You are to write a program that will search for the minimum number of rounds needed to achieve this goal.</p>
<p><strong>Input</strong></p>
<p>The input consists of 4 lines with 4 characters “w” or “b” each that denote game field position.</p>
<p><strong>Output</strong></p>
<p>Write to the output file a single integer number - the minimum number of rounds needed to achieve the goal of the game from the given position. If the goal is initially achieved, then write 0. If it’s impossible to achieve the goal, then write the word “Impossible” (without quotes).</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bwwb</span></span><br><span class="line"><span class="keyword">bbwb</span></span><br><span class="line"><span class="keyword">bwwb</span></span><br><span class="line"><span class="keyword">bwww</span></span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>递归遍历所有情况，即从当前点出发，翻还是不翻，然后进入下一层递归，直到满足条件为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> [][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> first = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span> ;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(matrix[i][j] != first)</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">		matrix[x][y] = matrix[x][y] ^ <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">			matrix[x - <span class="number">1</span>][y] ^= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(y - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">			matrix[x][y - <span class="number">1</span>] ^= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(x + <span class="number">1</span> &lt; <span class="number">4</span>)</span><br><span class="line">			matrix[x + <span class="number">1</span>][y] ^= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(y + <span class="number">1</span> &lt; <span class="number">4</span>)</span><br><span class="line">			matrix[x][y + <span class="number">1</span>] ^= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> times)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(judge())&#123;</span><br><span class="line">			<span class="keyword">if</span>(ans &gt; times)</span><br><span class="line">			&#123;</span><br><span class="line">				ans = times;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x &gt;= <span class="number">4</span> || y &gt;= <span class="number">4</span>)</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		<span class="keyword">int</span> aX,aY;</span><br><span class="line">		aX = (x + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">		aY = y + (x + <span class="number">1</span>) / <span class="number">4</span>;</span><br><span class="line">		dfs(aX,aY,times);</span><br><span class="line">		change(x, y);</span><br><span class="line">		dfs(aX,aY,times + <span class="number">1</span>);</span><br><span class="line">		change(x, y);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	String temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">4</span>; i ++) &#123;</span><br><span class="line">		temp = in.nextLine();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp.charAt(j) == <span class="string">'b'</span>) &#123;</span><br><span class="line">				matrix[i][j] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//定义黑为1，白为0</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">		dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(ans == Integer.MAX_VALUE)</span><br><span class="line">			System.out.println(<span class="string">"Impossible"</span>);</span><br><span class="line">		<span class="keyword">else</span> System.out.println(ans);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="BFS-位压缩"><a href="#BFS-位压缩" class="headerlink" title="BFS+位压缩"></a>BFS+位压缩</h3><p>来源于<a href="https://blog.csdn.net/hackbuteer1/article/details/7392245" target="_blank" rel="noopener">blog</a></p>
<p>主要思想：</p>
<p>1、如果用一个4*4的数组存储每一种状态，不但存储空间很大，而且在穷举状态时也不方便记录。因为每一颗棋子都只有两种状态，所以可以用二进制0和1表示每一个棋子的状态，则棋盘的状态就可以用一个16位的整数唯一标识。而翻转的操作也可以通过通过位操作来完成。显然当棋盘状态id为0（全白）或65535（全黑）时，游戏结束。</p>
<p>2、对于棋盘的每一个状态，都有十六种操作，首先要判断这十六种操作之后是否有完成的情况，如果没有，则再对这十六种操作的结果分别再进行上述操作，显然这里就要用到队列来存储了。而且在翻转的过程中有可能会回到之前的某种状态，而这种重复的状态是不应该再次入队的，所以维护 Visit[i]数组来判断 id==i 的状态之前是否已经出现过，如果不是才将其入队。如果游戏无法完成，状态必定会形成循环，由于重复状态不会再次入队，所以最后的队列一定会是空队列。</p>
<p>3、由于0^1=1，1^1=0，所以翻转的操作可以通过异或操作来完成，而翻转的位置可以通过移位来确定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> state;</span><br><span class="line">	<span class="keyword">int</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">65536</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> change[<span class="number">16</span>] =   <span class="comment">//16种状态转换，对应4*4的翻子位置</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="number">51200</span>,<span class="number">58368</span>,<span class="number">29184</span>,<span class="number">12544</span>,</span><br><span class="line">     <span class="number">35968</span>,<span class="number">20032</span>,<span class="number">10016</span>,<span class="number">4880</span>,</span><br><span class="line">	 <span class="number">2248</span>,<span class="number">1252</span>,<span class="number">626</span>,<span class="number">305</span>,</span><br><span class="line">	 <span class="number">140</span>,<span class="number">78</span>,<span class="number">39</span>,<span class="number">19</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">memset</span>(visit,<span class="literal">false</span>,<span class="keyword">sizeof</span>(visit));    <span class="comment">//标记每一个状态都未访问过</span></span><br><span class="line">	<span class="built_in">queue</span>&lt;Node&gt;q;</span><br><span class="line">	Node cur,next;</span><br><span class="line">	cur.state = state;</span><br><span class="line">	cur.step = <span class="number">0</span>;</span><br><span class="line">	q.push(cur);</span><br><span class="line">	visit[state] = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		cur = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span>(cur.state == <span class="number">0</span> || cur.state == <span class="number">0xffff</span>)   <span class="comment">//65535</span></span><br><span class="line">			<span class="keyword">return</span> cur.step;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			next.state = cur.state^change[i];</span><br><span class="line">			next.step = cur.step + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(visit[next.state])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(next.state == <span class="number">0</span> || next.state == <span class="number">0xffff</span>)   <span class="comment">//65535</span></span><br><span class="line">				<span class="keyword">return</span> next.step;</span><br><span class="line">			visit[next.state] = <span class="literal">true</span>;</span><br><span class="line">			q.push(next);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,state,ans;</span><br><span class="line">	<span class="keyword">char</span> ch[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,ch[<span class="number">0</span>])!=EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; <span class="number">4</span> ; ++i)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>,ch[i]);</span><br><span class="line">		state = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//初始化棋盘状态</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; <span class="number">4</span> ; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				state &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(ch[i][j] == <span class="string">'b'</span>)</span><br><span class="line">					state += <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//state ^= (1&lt;&lt;((3-i)*4+(3-j)));</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = bfs(state);</span><br><span class="line">		<span class="keyword">if</span>(ans == <span class="number">-1</span>)</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"Impossible"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代码二：DFS+Bit</span></span><br><span class="line"><span class="comment">本题由于要输出每次翻转的棋子，因此不适宜用BFS，应该使用DFS输出完整路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">int</span> chess;        <span class="comment">//棋盘状态</span></span><br><span class="line"> <span class="keyword">int</span> step;</span><br><span class="line"> <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"> <span class="keyword">int</span> ri[<span class="number">16</span>],cj[<span class="number">16</span>];</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">isopen</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(chess == <span class="number">0xFFFF</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span> bit)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     chess=chess^(<span class="number">0x1</span>&lt;&lt;bit);  <span class="comment">//对翻转位取反</span></span><br><span class="line">     <span class="keyword">int</span> row=bit/<span class="number">4</span>;</span><br><span class="line">     <span class="keyword">int</span> col=bit%<span class="number">4</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;<span class="number">4</span>;c++)</span><br><span class="line">         chess=chess^(<span class="number">0x1</span>&lt;&lt;(row*<span class="number">4</span>+c));  <span class="comment">//对全行取反</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;<span class="number">4</span>;r++)</span><br><span class="line">         chess=chess^(<span class="number">0x1</span>&lt;&lt;(r*<span class="number">4</span>+col));  <span class="comment">//对全列取反</span></span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> bit,<span class="keyword">int</span> deep)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(deep==step)</span><br><span class="line">     &#123;</span><br><span class="line">         flag=isopen();</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span>(flag || bit&gt;<span class="number">15</span>)</span><br><span class="line">		 <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">int</span> row=ri[deep]=bit/<span class="number">4</span>;</span><br><span class="line">     <span class="keyword">int</span> col=cj[deep]=bit%<span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">     flip(bit);</span><br><span class="line">     <span class="keyword">if</span>(col&lt;<span class="number">4</span>)</span><br><span class="line">         dfs(bit+<span class="number">1</span>,deep+<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         dfs((bit+<span class="number">4</span>)/<span class="number">4</span>*<span class="number">4</span>,deep+<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">     flip(bit);</span><br><span class="line">     <span class="keyword">if</span>(col&lt;<span class="number">4</span>)</span><br><span class="line">         dfs(bit+<span class="number">1</span>,deep);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         dfs((bit+<span class="number">4</span>)/<span class="number">4</span>*<span class="number">4</span>,deep);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> temp;</span><br><span class="line">     <span class="keyword">int</span> i,j;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">	 &#123;</span><br><span class="line">         <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">             <span class="keyword">if</span>(temp==<span class="string">'-'</span>)</span><br><span class="line">                 chess=chess^(<span class="number">1</span>&lt;&lt;(i*<span class="number">4</span>+j));</span><br><span class="line">         &#125;</span><br><span class="line">	 &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/*DFS*/</span></span><br><span class="line">     <span class="keyword">for</span>(step=<span class="number">0</span>;step&lt;=<span class="number">16</span>;step++)</span><br><span class="line">     &#123;</span><br><span class="line">         dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">if</span>(flag)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,step);</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;step;i++)</span><br><span class="line">		 <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ri[i]+<span class="number">1</span>,cj[i]+<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>POJ</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>I Think I Need a Houseboat</title>
    <url>/2019/12/14/I-Think-I-Need-a-Houseboat/</url>
    <content><![CDATA[<p>来源POJ第1005题</p>
<p><strong>Description</strong></p>
<p>Fred Mapper is considering purchasing some land in Louisiana to build his house on. In the process of investigating the land, he learned that the state of Louisiana is actually shrinking by 50 square miles each year,<a id="more"></a> due to erosion caused by the Mississippi River. Since Fred is hoping to live in this house the rest of his life, he needs to know if his land is going to be lost to erosion.</p>
<p>After doing more research, Fred has learned that the land that is being lost forms a semicircle. This semicircle is part of a circle centered at (0,0), with the line that bisects the circle being the X axis. Locations below the X axis are in the water. The semicircle has an area of 0 at the beginning of year 1. (Semicircle illustrated in the Figure.)</p>
<p><img src="/2019/12/14/I-Think-I-Need-a-Houseboat/semicircle.GIF" alt="img"></p>
<p><strong>Input</strong></p>
<p>The first line of input will be a positive integer indicating how many data sets will be included (N). Each of the next N lines will contain the X and Y Cartesian coordinates of the land Fred is considering. These will be floating point numbers measured in miles. The Y coordinate will be non-negative. (0,0) will not be given.</p>
<p><strong>Output</strong></p>
<p>For each data set, a single line of output should appear. This line should take the form of: “Property N: This property will begin eroding in year Z.” Where N is the data set (counting from 1), and Z is the first year (start from 1) this property will be within the semicircle AT THE END OF YEAR Z. Z must be an integer. After the last data set, this should print out “END OF OUTPUT.”</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1.0</span> <span class="number">1.0</span></span><br><span class="line"><span class="number">25.0</span> <span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Property</span><span class="title"> 1:</span> This <span class="keyword">property</span><span class="title"> </span>will begin eroding <span class="keyword">in</span> year <span class="number">1</span>.</span><br><span class="line"><span class="keyword">Property</span><span class="title"> 2:</span> This <span class="keyword">property</span><span class="title"> </span>will begin eroding <span class="keyword">in</span> year <span class="number">20</span>.</span><br><span class="line">END OF OUTPUT.</span><br></pre></td></tr></table></figure>
<p><strong>Hint</strong></p>
<p>1.No property will appear exactly on the semicircle boundary: it will either be inside or outside.<br>2.This problem will be judged automatically. Your answer must match exactly, including the capitalization, punctuation, and white-space. This includes the periods at the ends of the lines.<br>3.All locations are given in miles.</p>
<hr>
<p>水题一题，求目标点与原点构成的圆的面积与100之比即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	<span class="keyword">int</span> len = in.nextInt();</span><br><span class="line">	<span class="keyword">float</span> years;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len ;i ++)&#123;</span><br><span class="line">		<span class="keyword">float</span> a = in.nextFloat();</span><br><span class="line">		<span class="keyword">float</span> b = in.nextFloat();</span><br><span class="line">		years = (<span class="keyword">float</span>)(Math.PI)*(a*a + b*b)/<span class="number">100</span>;</span><br><span class="line">		System.out.println(<span class="string">"Property "</span> + (i+<span class="number">1</span>) + <span class="string">": This property will begin eroding in year "</span> + (<span class="keyword">int</span>)(years + <span class="number">1</span>) + <span class="string">"."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"END OF OUTPUT."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>POJ</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最小深度</title>
    <url>/2019/12/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p>来自Leetcode第111题二叉树的最小深度</p>
<p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br><a id="more"></a><br><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong></p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>返回它的最小深度  2.</p>
<hr>
<h3 id="翻车现场"><a href="#翻车现场" class="headerlink" title="翻车现场"></a>翻车现场</h3><p>最开始以为是和最大深度那题差不多的，结果忽略了一种情况，即[1,2]这种根结点只有一个叶子结点的情况，这时最小深度应该是2，因为按题目定义根结点不能作为自己的叶结点，以下是初始代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> left_height = minDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right_height = minDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.min(left_height,right_height) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>根据上面的分析，知道要在递归里做判断，判断是否是叶子结点,然后再进行递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> minDepth = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">        minDepth = Math.min(minDepth,minDepth(root.left));</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">        minDepth = Math.min(minDepth,minDepth(root.right));</span><br><span class="line">    <span class="keyword">return</span> minDepth + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BFS迭代"><a href="#BFS迭代" class="headerlink" title="BFS迭代"></a>BFS迭代</h3><p>利用一个队列进行层次遍历，用一个 <code>level</code> 变量保存当前的深度,只要在 <code>for</code> 循环中判断当前是不是叶子节点，如果是的话，返回当前的 level 就可以了。此外要把<code>level</code>初始化改为<code>1</code>，因为如果只有一个根节点，它就是叶子节点，而在代码中，level 是在 <code>for</code>循环以后才<code>++</code>的，如果被提前结束的话，此时应该返回<code>1</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> levelNum = queue.size();  <span class="comment">//当前层元素个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; levelNum ; i++)&#123;</span><br><span class="line">            TreeNode tmp = queue.poll();  <span class="comment">//队列首元素出队</span></span><br><span class="line">            <span class="keyword">if</span>(tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp.left == <span class="keyword">null</span> &amp;&amp; tmp.right == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> level;</span><br><span class="line">                <span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.offer(tmp.left);  <span class="comment">//节点入队尾</span></span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.offer(tmp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        level ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>配置gitalk的坑</title>
    <url>/2019/12/12/%E9%85%8D%E7%BD%AEgitalk%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>今天在把主题从yilia迁移到next的时候，配置gitalk出现了坑，先是gitalk notfound，然后又是说issue过长，把解决办法mark一下。</p>
<p>先是配置gitalk的gitalk.swig<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.css"</span>&gt;</span><br><span class="line">  &lt;script src=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;script src=<span class="string">"https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;div id=<span class="string">"gitalk-container"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  </span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    var gitalk = new Gitalk(&#123;</span></span><br><span class="line"><span class="string">      clientID: '&#123;&#123; theme.gitalk.clientID &#125;&#125;',</span></span><br><span class="line"><span class="string">      clientSecret: '&#123;&#123; theme.gitalk.clientSecret &#125;&#125;',</span></span><br><span class="line"><span class="string">      repo: '&#123;&#123; theme.gitalk.repo &#125;&#125;',</span></span><br><span class="line"><span class="string">      owner: '&#123;&#123; theme.gitalk.owner &#125;&#125;',</span></span><br><span class="line"><span class="string">      admin: ['&#123;&#123; theme.gitalk.admin &#125;&#125;'],</span></span><br><span class="line"><span class="string">      id: md5(window.location.pathname),</span></span><br><span class="line"><span class="string">      distractionFreeMode: '&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;'</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">    gitalk.render('gitalk-container')</span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>在网上找的配置或多或少有问题，折腾之后发现创建issue时会提示名称过长的问题，百度了解决办法是md5加密，但是会与之前创建的issue冲突，折腾了半天才想起来，直接照搬之前yilia里的gitalk即可，发现他的id直接就是md5加密好的，利用md5，不用担心名称过长的问题，并且利用之前的gitalk.swig，可以解决其他的问题，特此mark。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>重排链表</title>
    <url>/2019/12/12/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>来自Leetcode第143题重排链表</p>
<p>给定一个单链表 <em>L</em>：<em>L</em>0→<em>L</em>1→…→<em>L</em>n-1→<em>L</em>n ，<br>将其重新排列后变为： <em>L</em>0→<em>L</em>n→<em>L</em>1→<em>L</em>n-1→<em>L</em>2→<em>L</em>n-2→…</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br><a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">给定链表 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>, 重新排列为 <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3.</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">给定链表 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 重新排列为 <span class="number">1</span>-&gt;<span class="number">5</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3.</span></span><br></pre></td></tr></table></figure>
<h3 id="空间换时间"><a href="#空间换时间" class="headerlink" title="空间换时间"></a>空间换时间</h3><p>创建线性表，依次存储各个链表结点，然后用双指针依次取头尾元素，避免了每次从头遍历.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    List&lt;ListNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//保存结点</span></span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        list.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//头尾指针取元素</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span> , j = list.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        list.get(i).next = list.get(j);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">//偶数结点相遇</span></span><br><span class="line">        <span class="keyword">if</span>(i == j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        list.get(j).next = list.get(i);</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    list.get(i).next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>参考 <a href="https://leetcode.com/problems/reorder-list/discuss/45113/Share-a-consise-recursive-solution-in-C%2B%2B" target="_blank" rel="noopener">这里</a>。</p>
<p>解法一中也说到了，我们的问题就是取尾元素的时候，需要遍历一遍链表。</p>
<p>如果我们的递归函数能够返回当前头元素对应的尾元素，并且将头元素和尾元素之间的链表按要求完成，那就变得简单了。</p>
<p><img src="https://pic.leetcode-cn.com/cc05523815b2eb5baf80741809193cc5b17f29b6a6efe2c235007a036aff5625.jpg" alt="img"></p>
<p>如上图，我们只需要将 <code>head</code> 指向 <code>tail</code>，<code>tail</code> 指向处理完的链表头即可。</p>
<p><img src="https://pic.leetcode-cn.com/0a9173afb9b7f62587f5132689ad5bceb98cd24f8f7a3d5f938ca2886d308892.jpg" alt="img"></p>
<p>然后我们把之前的 <code>tail.next</code> 返回就是外层 <code>head</code> 对应的 <code>tail</code> 了。</p>
<p>递归出口的话，如果只有一个节点，那么我们只需要将 <code>head.next</code> 返回。</p>
<p>递归出口的话，如果只有一个节点，那么我们只需要将 <code>head.next</code> 返回。</p>
<p>如果是两个节点，我们需要将 <code>head.next.next</code> 返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode ahead = head;</span><br><span class="line">    <span class="keyword">while</span> (ahead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        ahead = ahead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    reorderListHelper(head, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reorderListHelper</span><span class="params">(ListNode head, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">        ListNode outTail = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> outTail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">2</span>) &#123;</span><br><span class="line">        ListNode outTail = head.next.next;</span><br><span class="line">        head.next.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> outTail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到对应的尾节点，并且将头结点和尾节点之间的链表通过递归处理</span></span><br><span class="line">    ListNode tail = reorderListHelper(head.next, len - <span class="number">2</span>);</span><br><span class="line">    ListNode subHead = head.next;<span class="comment">//中间链表的头结点</span></span><br><span class="line">    head.next = tail;</span><br><span class="line">    ListNode outTail = tail.next;  <span class="comment">//上一层 head 对应的 tail</span></span><br><span class="line">    tail.next = subHead;</span><br><span class="line">    <span class="keyword">return</span> outTail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>参考 <a href="https://leetcode.com/problems/reorder-list/discuss/44992/Java-solution-with-3-steps" target="_blank" rel="noopener">这里</a>，主要是利用到一头一尾取元素的特性。</p>
<p>主要是三步，举个例子。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="number">6</span></span><br><span class="line">第一步，将链表平均分成两半</span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="number">6</span></span><br><span class="line">    </span><br><span class="line">第二步，将第二个链表逆序</span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">6</span> -&gt; <span class="number">5</span> -&gt; <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">第三步，依次连接两个链表</span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">6</span> -&gt; <span class="number">2</span> -&gt; <span class="number">5</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>第一步找中点的话，可以应用 19 题的方法，快慢指针。快指针一次走两步，慢指针一次走一步，当快指针走到终点的话，慢指针会刚好到中点。如果节点个数是偶数的话，<code>slow</code> 走到的是左端点，利用这一点，我们可以把奇数和偶数的情况合并，不需要分开考虑。</p>
<p>第二步链表逆序的话，在 第 2 题]讨论过了，有迭代和递归的两种方式，迭代的话主要利用两个指针，依次逆转。</p>
<p>第三步的话就很简单了，两个指针分别向后移动就可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快慢指针找中点，链表一分为二</span></span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode newHead = slow.next;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二个链表倒置</span></span><br><span class="line">    newHead = reverseList(newHead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表节点依次连接</span></span><br><span class="line">    <span class="keyword">while</span> (newHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode temp = newHead.next;</span><br><span class="line">        newHead.next = head.next;</span><br><span class="line">        head.next = newHead;</span><br><span class="line">        head = newHead.next;</span><br><span class="line">        newHead = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode tail = head;</span><br><span class="line">    head = head.next;</span><br><span class="line"></span><br><span class="line">    tail.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode temp = head.next;</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail = head;</span><br><span class="line">        head = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>对链表进行插入排序</title>
    <url>/2019/12/12/%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>来自Leetcode第147题对链表进行插入排序</p>
<p>对链表进行插入排序。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt="img"><br>插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。<a id="more"></a><br>每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。</p>
<p><strong>插入排序算法：</strong></p>
<ol>
<li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li>
<li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li>
<li>重复直到所有输入数据插入完为止。</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">4</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">3</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="转换成列表后排序"><a href="#转换成列表后排序" class="headerlink" title="转换成列表后排序"></a>转换成列表后排序</h3><p>最简单思路，转换成数组（列表）后直接sort，最后转回链表即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        list.add(p1.val);</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    p1 = head;</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">        head.val = it.next();</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>先假定一个伪头结点，并把尾结点tail设置为伪头结点，接着依次比较当前结点cur与tai的值，如果tail的值大于等于cur，则说明cur应该插入tail之前，先记录下cur.next，并将tail.next设置为cur.next,从伪头结点开始遍历，直到找到一个结点下一个结点的值大于cur，这样就找到了cur结点的插入位置，修改对应结点的位置即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p1 = <span class="keyword">new</span> ListNode(Integer.MIN_VALUE);  <span class="comment">//傀儡头结点</span></span><br><span class="line">    ListNode pre = p1, tail = p1, cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail.val &lt; cur.val)&#123;</span><br><span class="line">            tail.next = cur;</span><br><span class="line">            tail = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ListNode tmp = cur.next;</span><br><span class="line">            tail.next = tmp;</span><br><span class="line">            <span class="comment">//不加这一句，当前面是已经排好序的1-&gt;2-&gt;3-&gt;4这种情况时，</span></span><br><span class="line">            <span class="comment">//如果要再把5插入里面，会造成后面的while语句一直循环</span></span><br><span class="line">            <span class="comment">//tail.next后面接的就是cur，然后cur.next = pre.next;</span></span><br><span class="line">            <span class="comment">//pre.next = cur;就成环了，因为成环接下来会一直困在主while循环</span></span><br><span class="line">            <span class="comment">//找到适当的插入位置</span></span><br><span class="line">            <span class="keyword">while</span> (pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.val &lt; cur.val)</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            cur.next = pre.next;</span><br><span class="line">            pre.next = cur;</span><br><span class="line">            pre = p1;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>排序</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel表列名称</title>
    <url>/2019/12/12/Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</url>
    <content><![CDATA[<p>来自Leetcode第168题Excel表列名称</p>
<p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p>
<p>例如，</p>
<a id="more"></a>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> -&gt; A</span><br><span class="line"><span class="number">2</span> -&gt; B</span><br><span class="line"><span class="number">3</span> -&gt; C</span><br><span class="line">...</span><br><span class="line"><span class="number">26</span> -&gt; Z</span><br><span class="line"><span class="number">27</span> -&gt; AA</span><br><span class="line"><span class="number">28</span> -&gt; AB </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: 1</span></span><br><span class="line"><span class="section">输出: "A"</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: 28</span></span><br><span class="line"><span class="section">输出: "AB"</span></span><br></pre></td></tr></table></figure>
<h4 id="伪进制转换I"><a href="#伪进制转换I" class="headerlink" title="伪进制转换I"></a>伪进制转换I</h4><p>一开始以为是10进制转26进制的题目，但是提交之后发现不对，因为题目要求是从1-26，而不是从0-25，所以取模后取余的方法不适用，需要修改。</p>
<blockquote>
<p>此题可以近似看成一个求26进制的题，但是值得注意的是对于26的整数倍，如果我们不加以限制的话就会造成A0的情况出现，而题目给出的条件中是不考虑这种情况的。所以我们只需要排除这种情况对于任何26的整数倍，我们就直接先插入‘Z’，同时还要对原数进行减一的操作。因为如果不进行减一的话对于26所对应的就是AZ（其实就是为了将A0映射为Z要对A0整体减一，由于0-1不够，所以要向A借一位，所以最后就得到了Z。所以我们要插入Z之后再对原数减1。）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    StringBuilder string = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        i = n % <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)  <span class="comment">//第26个字母</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = <span class="number">26</span>;</span><br><span class="line">            n -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string.insert(<span class="number">0</span>,(<span class="keyword">char</span>)(<span class="string">'A'</span> + i - <span class="number">1</span>));</span><br><span class="line">        n /= <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="伪进制转换II"><a href="#伪进制转换II" class="headerlink" title="伪进制转换II"></a>伪进制转换II</h4><blockquote>
<p>上一种思路我们看到了为什么对于26的整数倍要进行减一的操作，同时对于1-25而言，我们应该映射到A-Y，但是对于1我们直接加上A的ascii码就会得到B，所以我们也要进行减一的操作，(char)(temp+’A’-1)。对于Z我们需要减一，对于A-Y也需要减一，如果我们可以减这两种减一统一起来事情就变得简单了。所以我们可以考虑在取余之前就整体减一。我们可以证明对于26的N倍（num%26 = N），我们整体减一在取余就会得到(num-1)%26 = N-1余25，所以25直接加上A的ASCII码就得Z，所以对于Z而言是可以提前减一的。对于A-Y而言num%26 = N余t，t属于1到25的范围。这个t减一在加上’A’的ASCII码就对于与A-Y（t+’A’-1），而如果我们提前减一的话这个表达式就变成了(num-1)%26 =N余t-1;最后我们的到的值就不用进行减一操作（t-1+’A’）。所以可以将Z和A-Y的操作统一起来了，提前减一，然后再正常取模即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n--;</span><br><span class="line">            temp = n%<span class="number">26</span>;</span><br><span class="line">            res =(<span class="keyword">char</span>)(temp+<span class="string">'A'</span>) + res;</span><br><span class="line">            n = n/<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>多数元素</title>
    <url>/2019/12/11/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>来源Leetcode第169题多数元素</p>
<p>给定一个大小为 <em>n</em> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。<br><a id="more"></a><br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>利用HashMap存储每个元素的出现次数，最后在对HashMap做一次遍历，找出最大值即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(i))</span><br><span class="line">            map.put(i,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            map.put(i,map.get(i) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Map.Entry&lt;Integer,Integer&gt; major = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">        <span class="keyword">if</span>(major == <span class="keyword">null</span> || entry.getValue() &gt; major.getValue())</span><br><span class="line">            major = entry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> major.getKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>由题目可知，出现次数最多的元素大于n / 2，因而排序后返回中位即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Boyer-Moore-投票算法"><a href="#Boyer-Moore-投票算法" class="headerlink" title="Boyer-Moore 投票算法"></a>Boyer-Moore 投票算法</h4><p>来源<a href="https://leetcode-cn.com/problems/majority-element/solution/qiu-zhong-shu-by-leetcode-2/" target="_blank" rel="noopener">题解</a></p>
<p><strong>想法</strong></p>
<p>如果我们把众数记为 +1+1 ，把其他数记为 -1−1 ，将它们全部加起来，显然和大于 0 ，从结果本身我们可以看出众数比其他数多。</p>
<p><strong>算法</strong></p>
<p>本质上， Boyer-Moore 算法就是找 <code>nums</code> 的一个后缀 suf ，其中 suf[0]就是后缀中的众数。我们维护一个计数器，如果遇到一个我们目前的候选众数，就将计数器加一，否则减一。只要计数器等于 0 ，我们就将 <code>nums</code> 中之前访问的数字全部 <em>忘记</em> ，并把下一个数字当做候选的众数。直观上这个算法不是特别明显为何是对的，我们先看下面这个例子（竖线用来划分每次计数器归零的情况）</p>
<p>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</p>
<p>首先，下标为 0 的 <code>7</code> 被当做众数的第一个候选。在下标为 5 处，计数器会变回0 。所以下标为 6 的 <code>5</code> 是下一个众数的候选者。由于这个例子中 <code>7</code> 是真正的众数，所以通过忽略掉前面的数字，我们忽略掉了同样多数目的众数和非众数。因此， <code>7</code> 仍然是剩下数字中的众数。</p>
<p>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | <strong>5, 5, 5, 5</strong>]</p>
<p>现在，众数是 <code>5</code> （在计数器归零的时候我们把候选从 <code>7</code> 变成了 <code>5</code>）。此时，我们的候选者并不是真正的众数，但是我们在 <em>遗忘</em> 前面的数字的时候，要去掉相同数目的众数和非众数（如果遗忘更多的非众数，会导致计数器变成负数）。</p>
<p>因此，上面的过程说明了我们可以放心地遗忘前面的数字，并继续求解剩下数字中的众数。最后，总有一个后缀满足计数器是大于 0 的，此时这个后缀的众数就是整个数组的众数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Integer ans = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            ans = i;</span><br><span class="line">        count += (i == ans)? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>看到 <a href="https://leetcode.com/problems/majority-element/discuss/51612/C%2B%2B-6-Solutions" target="_blank" rel="noopener">这里</a> 介绍的，就是把数字放眼到二进制的形式，举个例子。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">5 </span><span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> 都写成 <span class="number">2</span> 进制</span><br><span class="line"><span class="symbol">1 </span><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>由于 <code>2</code> 是超过半数的数，它的二进制是 <code>010</code>，所以对于从右边数第一列一定是 <code>0</code> 超过半数，从右边数第二列一定是 <code>1</code> 超过半数，从右边数第三列一定是 <code>0</code> 超过半数。然后每一列超过半数的 <code>0,1,0</code> 用 <code>10</code>进制表示就是 <code>2</code> 。</p>
<p>所以我们只需要统计每一列超过半数的数，<code>0</code> 或者 <code>1</code>，然后这些超过半数的二进制位组成一个数字，就是我们要找的数。</p>
<p>当然，我们可以只统计 <code>1</code> 的个数，让每一位开始默认为 <code>0</code>，如果发现某一列的 <code>1</code> 的个数超过半数，就将当前位改为 <code>1</code>。</p>
<p>具体算法通过按位与和按位或实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> majority = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">//判断每一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, mask = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++, mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> bits = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录当前列 1 的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mask &amp; nums[j]) == mask) &#123;</span><br><span class="line">                bits++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前列 1 的个数是否超过半数</span></span><br><span class="line">        <span class="keyword">if</span> (bits &gt; n / <span class="number">2</span>) &#123;</span><br><span class="line">            majority |= mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>位运算</tag>
        <tag>投票法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法习题</title>
    <url>/2019/12/09/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h4 id="活动教室分配"><a href="#活动教室分配" class="headerlink" title="活动教室分配"></a>活动教室分配</h4><p>T16.1-4 活动教室分配(区间着色问题)</p>
<p>题目：</p>
<p>　　有一组活动，我们需要将它们安排到一些教室，任意活动都可以在任意教室进行。我们希望使用最少的教室完成所有活动。</p>
<p>　　设计一个高效的贪心算法求每个活动应该在哪个教室进行。<a id="more"></a></p>
<p>分析：</p>
<p>　　本题是对书中活动选择问题的一个扩展。在活动选择问题中，我们要求的是一个最大兼容活动集，也就是在所有时间内时间不重叠的最多的活动集合。</p>
<p>　　易知，这样一个活动集，就是一个教室最多能够举办的活动集。所以剩下的活动一定不能和该活动集内的活动在同一个教室举行。我们不断对剩下的活动使用贪心算法，需要多少次贪心能够选取完所有的活动，就最少需要几个教室。</p>
<p>　　我们首先对所有活动按结束时间排序。遍历所有活动，如果下一个活动开始时间比某教室中最后一个活动结束时间晚，则加入该教室。如果不能加入已使用的任何教室，则需要新开一个教室。
　　</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; Acti;<span class="comment">//用起始时间和结束时间的pair表示一个活动。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">party</span><span class="params">(<span class="built_in">vector</span>&lt;Acti&gt;&amp; acti_vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(acti_vec.begin(),acti_vec.end(),[](<span class="keyword">const</span> Acti&amp; a,<span class="keyword">const</span> Acti&amp; b)&#123;<span class="keyword">return</span> a.second &lt; b.second;&#125;);<span class="comment">//按结束时间对所有活动排序。</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Acti&gt;&gt; classroom;<span class="comment">//教室列表。</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Acti&gt; classroom1;</span><br><span class="line">    classroom1.push_back(*acti_vec.begin());<span class="comment">//初始化第一个教室，将结束时间最早的活动放入。</span></span><br><span class="line">    classroom.push_back(classroom1);<span class="comment">//将第一个教室加入教室列表。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;(<span class="keyword">int</span>)acti_vec.size();i++)<span class="comment">//遍历一遍活动列表。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; (<span class="keyword">int</span>)classroom.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(acti_vec[i].first &gt;= (*(classroom[j].end()<span class="number">-1</span>)).second)<span class="comment">//如果该活动的开始时间比某教室目前为止最后一个活动结束结束时间晚，则加入该教室。</span></span><br><span class="line">            &#123;</span><br><span class="line">                classroom[j].push_back(acti_vec[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == (<span class="keyword">int</span>)classroom.size())<span class="comment">//如果无法加入当前任何一个教室，则需要一个新的教室。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;Acti&gt; classroom_temp;</span><br><span class="line">            classroom_temp.push_back(acti_vec[i]);</span><br><span class="line">            classroom.push_back(classroom_temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)classroom.size();i++)<span class="comment">//对每一个教室，按起始时间 结束时间输出每一个活动。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"classroom "</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">":"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; (<span class="keyword">int</span>)classroom[i].size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;classroom[i][j].first&lt;&lt;<span class="string">" "</span>&lt;&lt;classroom[i][j].second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Acti&gt; acti_vec = &#123;</span><br><span class="line">                            &#123;<span class="number">1</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">3</span>,<span class="number">5</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">0</span>,<span class="number">6</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">5</span>,<span class="number">7</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">3</span>,<span class="number">9</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">5</span>,<span class="number">9</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">6</span>,<span class="number">10</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">8</span>,<span class="number">11</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">8</span>,<span class="number">12</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">2</span>,<span class="number">14</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">12</span>,<span class="number">16</span>&#125;</span><br><span class="line">                            &#125;;</span><br><span class="line">    party(acti_vec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="找零问题"><a href="#找零问题" class="headerlink" title="找零问题"></a>找零问题</h4><p>题目：<br>考虑用最少的硬币找n美分零钱的问题。假设每种硬币的面额都是整数。</p>
<p>A.设计贪心算法求解找零问题，假定有25美分、10美分、5美分和1美分4种面额的硬币。证明你的算法能找到最优解。</p>
<p>B.假定硬币的面额是c的幂，即面额c0,c1,…,ck,c和k为整数，c&gt;1,k&gt;=1.证明：贪心算法总能得到最优解。</p>
<p>C.设计一组硬币面额，使得贪心算法不能保证得到最优解。这组硬币面额中应该包含1美分，使得对每个零钱值都存在找零方案。</p>
<p>D.设计一个O(nk)时间的找零算法，适用于任何k种不同面额的硬币，假定问题包含1美分硬币。</p>
<p>分析:</p>
<p>A：</p>
<p>引理1（离散数学其及应用3.1.4）：若n是正整数，则用25美分、10美分、5美分和1美分等尽可能少的硬币找出的n美分零钱中，至多有2个10美分、至多有1个5美分、至多有4个1美分硬币，而不能有2个10美分和1个5美分硬币。用10美分、5美分和1美分硬币找出的零钱不能超过24美分。</p>
<p>证用反证法。证明如果有超过规定数目的各种类型的硬币，就可以用等值的数目更少的硬币来替换。注意，如果有3个10美分硬币，就可以换成1个25美分和1个5美分硬币；如果有2个5美分硬币，就可以换成1个10美分硬币；如果有5个1美分硬币，就可以换成1个5美分硬币；如果有2个10美分和1个5美分硬币，就可以换成1个25美分硬币。由于至多可以有2个10美分、1个5美分和4个1美分硬币，而不能有2个10美分和1个5美分硬币，所以当用尽可能少的硬币找n美分零钱时，24美分就是用10美分、5美分和1美分硬币能找出的最大值。</p>
<p>假设存在正整数n，使得有办法将25美分、10美分、5美分和1美分硬币用少于贪心算法所求出的硬币去找n美分零钱。首先注意，在这种找n美分零钱的最优方式中使用25美分硬币的个数q′，一定等于贪心算法所用25美分硬币的个数。为说明这一点，注意贪心算法使用尽可能多的25美分硬币，所以q′≤q。但是q′也不能小于q。假如q′小于q，需要在这种最优方式中用10美分、5美分和1美分硬币至少找出25美分零钱。而根据引理1，这是不可能的。由于在找零钱的这两种方式中一定有同样多的25美分硬币，所以在这两种方式中10美分、5美分和1美分硬币的总值一定相等，并且这些硬币的总值不超过24美分。10美分硬币的个数一定相等，因为贪心算法使用尽可能多的10美分硬币。而根据引理1，当使用尽可能少的硬币找零钱时，至多使用1个5分硬币和4个1分硬币，所以在找零钱的最优方式中也使用尽可能多的10美分硬币。类似地，5美分硬币的个数相等；最终，1美分的个数相等。</p>
<p>B：</p>
<p>分析——同A题，由于1+c1+c2+c3+…ck-1=ck - 1&lt;ck,故当n大于ck时，可以分解为ck与n-ck的值，其中ck只用一个硬币值为ck的硬币就能得到最少硬币数，而子问题变成n-ck的最少硬币数，依次类推，贪心算法总能得到最好的结果。</p>
<p>C:<br>分析——要分析什么情况下贪心算法无效，如果出现一组硬币25，6，5，1.由于1+5=6，当遇到10元时，按照贪心算法将分解为6+4<em>1，而其实为2</em>5.</p>
<p>D：<br>假设m(n)表示找零n美分需要的最少硬币数，硬币面值为c1,c2, …,ck，并令m[0]=0,则m(n)=1如果n等于某个ci，否则m(n) =min{ m(n-c1)+1, m(n-c2)+1, …, m(n-ck)+1 }</p>
<p>代码如下:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;c,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;s,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = c.size()<span class="number">-1</span>;<span class="comment">//减掉填充符</span></span><br><span class="line">	m[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m[i] = <span class="number">2147483647</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k &amp;&amp; (i&gt;=c[j]);j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(m[i-c[j]]+<span class="number">1</span>&lt; m[i])</span><br><span class="line">			&#123;</span><br><span class="line">				m[i] = m[i-c[j]]+<span class="number">1</span>;</span><br><span class="line">				s[i] = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;c,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;s,<span class="keyword">int</span> n,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = c.size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;number(k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++)</span><br><span class="line">		number[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		number[s[n]] ++;</span><br><span class="line">		n = n - c[s[n]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"needs coins : %d \n"</span>,count);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(number[i] &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"need %d %d cents coin  "</span>,number[i],c[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//const int c1[] = &#123;0,1,5,10,25&#125;;//零钱种类 第一个元素0起填充的作用 方便下标处理</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> c1[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="keyword">sizeof</span>(c1)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">15</span>;<span class="comment">//所需找零钱数</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">		c.push_back(c1[i]);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;m(n+<span class="number">1</span>);<span class="comment">//不同零钱数对应的最小硬币数</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;s(n+<span class="number">1</span>);<span class="comment">//记录所选硬币</span></span><br><span class="line">	change(c,m,s,n);</span><br><span class="line">	print(c,s,n,m[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法导论</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>乘积最大子序列</title>
    <url>/2019/12/07/%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>来源Leetcode第152题乘积最大子序列</p>
<p>给定一个整数数组 <code>nums</code> ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。<br><a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 子数组 [<span class="number">2</span>,<span class="number">3</span>] 有最大乘积 <span class="number">6</span>。</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="同最大连续子序和"><a href="#同最大连续子序和" class="headerlink" title="同最大连续子序和"></a>同最大连续子序和</h4><ul>
<li>遍历数组时计算当前最大值，不断更新</li>
<li>令imax为当前最大值，则当前最大值为 <code>imax = max(imax * nums[i], nums[i])</code></li>
<li>由于存在负数，那么会导致最大的变最小的，最小的变最大的。因此还需要维护当前最小值imin，<code>imin = min(imin * nums[i], nums[i])</code></li>
<li><strong>当负数出现时则imax与imin进行交换再进行下一步计算</strong></li>
<li>时间复杂度：O(n)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE, imax = <span class="number">1</span>, imin = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = imax;</span><br><span class="line">            imax = imin;</span><br><span class="line">            imin = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        imax = Math.max(imax*nums[i], nums[i]);</span><br><span class="line">        imin = Math.min(imin*nums[i], nums[i]);</span><br><span class="line">        max = Math.max(max, imax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转字符串里的单词</title>
    <url>/2019/12/06/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<p>来源Leetcode第151题翻转字符串里的单词</p>
<p>给定一个字符串，逐个翻转字符串中的每个单词。<br><a id="more"></a><br><strong>示例 1：</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: "  hello world!  "</span></span><br><span class="line"><span class="section">输出: "world! hello"</span></span><br><span class="line"><span class="section">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ul>
<hr>
<h4 id="2次遍历"><a href="#2次遍历" class="headerlink" title="2次遍历"></a>2次遍历</h4><p>第一次倒序遍历将单词缓存，接着将单词翻转加入答案字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String ans = <span class="keyword">new</span> String();</span><br><span class="line">    String temp = <span class="keyword">new</span> String();</span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">""</span>) || s.equals(<span class="string">" "</span>))</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span> &amp;&amp; i &gt; <span class="number">1</span>  &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">' '</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp.length() == <span class="number">0</span> ||temp.charAt(<span class="number">0</span>) == <span class="string">' '</span> )</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                ans += reverse(temp);</span><br><span class="line">                ans += <span class="string">' '</span>;</span><br><span class="line">                temp = <span class="keyword">new</span> String();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp += s.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!temp.equals(<span class="string">" "</span>))&#123;</span><br><span class="line">        ans += reverse(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ans.length() &gt; <span class="number">0</span> &amp;&amp; ans.charAt(ans.length() - <span class="number">1</span>) == <span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">return</span> ans.substring(<span class="number">0</span>,ans.length() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] array = s.toCharArray();</span><br><span class="line">    String reverse = <span class="string">""</span>;<span class="comment">//新建空字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        reverse += array[i];</span><br><span class="line">    <span class="keyword">return</span> reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><p>trim()方法：去掉字符串两端的多余空格</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//去掉s的首尾空格 然后将字符串拆分</span></span><br><span class="line">    String[] s1 = s.trim().split(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s1.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">//空格后面的空格会变成空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(!s1[i].equals(<span class="string">""</span>)) ans.append(s1[i] + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去掉最后添加上的空格</span></span><br><span class="line">    ans = <span class="keyword">new</span> StringBuilder(ans.toString().trim());</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == s || s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = c.length;</span><br><span class="line">        <span class="keyword">int</span> i = len - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//去掉末尾的空格</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; c[i] == <span class="string">' '</span>) i--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = i + <span class="number">1</span>;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(i + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right != left) </span><br><span class="line">                <span class="comment">//左不等于右是为了判断没有空格</span></span><br><span class="line">                sb.append(c, left, right - left).append(<span class="string">" "</span>);</span><br><span class="line">                <span class="comment">//加入单词</span></span><br><span class="line">                left = i;</span><br><span class="line">                right = i;</span><br><span class="line">                <span class="comment">//调整指针位置</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left = i;</span><br><span class="line">            <span class="comment">//往前找到不为空格的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != left)</span><br><span class="line">            <span class="keyword">return</span> sb.append(c, left, right - left).toString();</span><br><span class="line">        <span class="keyword">return</span> sb.length() &gt; <span class="number">0</span> ? sb.substring(<span class="number">0</span>, sb.length() - <span class="number">1</span>) : <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和II</title>
    <url>/2019/12/06/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII/</url>
    <content><![CDATA[<p>来源Leetcode第167题两数之和 II - 输入有序数组</p>
<blockquote>
<p>给定一个已按照<strong><em>升序排列\</em></strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p>
<p><strong>说明:</strong><br><a id="more"></a></p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt; 输入: numbers = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">&gt; 输出: [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">&gt; 解释: <span class="number">2</span> 与 <span class="number">7</span> 之和等于目标数 <span class="number">9</span> 。因此 index1 = <span class="number">1</span>, index2 = <span class="number">2</span> 。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> [] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(numbers.length == <span class="number">0</span> || numbers.length == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        sum = numbers[i] + numbers[j];</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">            ans[<span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> [] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(numbers.length == <span class="number">0</span> || numbers.length == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; numbers.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(target - numbers[i]))&#123;</span><br><span class="line">            ans[<span class="number">0</span>] = map.get(target - numbers[i]);</span><br><span class="line">            ans[<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            map.put(numbers[i], i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>固定一个数，用二分查找搜索target-nums[I]，时间复杂度O(nlgn)，不如双指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> [] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(numbers.length == <span class="number">0</span> || numbers.length == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = numbers.length - <span class="number">1</span>,mid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; numbers.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] &gt; target - numbers[i])</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &lt; target - numbers[i])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans[<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">                ans[<span class="number">1</span>] = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>最小栈</title>
    <url>/2019/12/05/%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<p>来源Leetcode第155题最小栈</p>
<blockquote>
<p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li>push(x) — 将元素 x 推入栈中。</li>
<li>pop() — 删除栈顶的元素。<a id="more"></a></li>
<li>top() — 获取栈顶元素。</li>
<li>getMin() — 检索栈中的最小元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">&gt;  M<span class="keyword">in</span>Stack <span class="keyword">min</span>Stack = new M<span class="keyword">in</span>Stack();</span><br><span class="line">&gt;  <span class="keyword">min</span>Stack.push(-<span class="number">2</span>);</span><br><span class="line">&gt;  <span class="keyword">min</span>Stack.push(<span class="number">0</span>);</span><br><span class="line">&gt;  <span class="keyword">min</span>Stack.push(-<span class="number">3</span>);</span><br><span class="line">&gt;  <span class="keyword">min</span>Stack.getM<span class="keyword">in</span>();   --&gt; 返回 -<span class="number">3</span>.</span><br><span class="line">&gt;  <span class="keyword">min</span>Stack.pop();</span><br><span class="line">&gt;  <span class="keyword">min</span>Stack.top();      --&gt; 返回 <span class="number">0</span>.</span><br><span class="line">&gt;  <span class="keyword">min</span>Stack.getM<span class="keyword">in</span>();   --&gt; 返回 -<span class="number">2</span>.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 双栈</span><br><span class="line"></span><br><span class="line">利用两个栈，一个数据栈，一个保存所有最小值栈实现。</span><br><span class="line"></span><br><span class="line">当最小值栈非空时，元素直接入栈，否则需要比较栈顶元素与入栈元素大小，如果小于等于，则入栈</span><br><span class="line"></span><br><span class="line">代码如下：</span><br><span class="line"></span><br><span class="line">​```JAVA</span><br><span class="line">    class MinStack &#123;</span><br><span class="line"></span><br><span class="line">        /** initialize your data structure here. */</span><br><span class="line"></span><br><span class="line">        private Stack&lt;Integer&gt; stack;</span><br><span class="line">        private Stack&lt;Integer&gt; miniStack;</span><br><span class="line"></span><br><span class="line">        public MinStack() &#123;</span><br><span class="line">            stack = new Stack&lt;&gt;();</span><br><span class="line">            miniStack = new Stack&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void push(int x) &#123;</span><br><span class="line">            <span class="attribute">stack.push(x);</span></span><br><span class="line">            if(!miniStack.empty())&#123;</span><br><span class="line">                if(x &lt;= miniStack.peek())&#123;</span><br><span class="line">                    <span class="attribute">miniStack.push(x);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else</span><br><span class="line">                <span class="attribute">miniStack.push(x);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void pop() &#123;</span><br><span class="line">            int pop = stack.pop();</span><br><span class="line"></span><br><span class="line">            if(pop == miniStack.peek())</span><br><span class="line">                <span class="attribute">miniStack.pop();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int top() &#123;</span><br><span class="line">            return stack.peek();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getMin() &#123;</span><br><span class="line">            return miniStack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="单栈"><a href="#单栈" class="headerlink" title="单栈"></a>单栈</h4><p>当有更小的值来的时候，我们只需要把之前的最小值入栈，当前更小的值再入栈即可。当这个最小值要出栈的时候，下一个值便是之前的最小值了。</p>
<p>例如：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">入栈 3 </span><br><span class="line">|<span class="string">   </span>|<span class="string">   min = 3</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">     </span></span><br><span class="line">|<span class="string">_3_</span>|<span class="string">    </span></span><br><span class="line"><span class="string">stack   </span></span><br><span class="line"></span><br><span class="line"><span class="string">入栈 5 </span></span><br><span class="line">|<span class="string">   </span>|<span class="string">   min = 3</span></span><br><span class="line">|<span class="string"> 5 </span>|<span class="string">     </span></span><br><span class="line">|<span class="string">_3_</span>|<span class="string">    </span></span><br><span class="line"><span class="string">stack  </span></span><br><span class="line"></span><br><span class="line"><span class="string">入栈 2 </span></span><br><span class="line">|<span class="string"> 2 </span>|<span class="string">   min = 2?</span></span><br><span class="line">|<span class="string"> 5 </span>|<span class="string">     </span></span><br><span class="line">|<span class="string">_3_</span>|<span class="string">    </span></span><br><span class="line"><span class="string">stack  </span></span><br><span class="line"></span><br><span class="line"><span class="string">入栈 2 ，同时将之前的 min 值 3 入栈，再把 2 入栈，同时更新 min = 2</span></span><br><span class="line">|<span class="string"> 2 </span>|<span class="string">   min = 2</span></span><br><span class="line">|<span class="string"> 3 </span>|<span class="string">  </span></span><br><span class="line">|<span class="string"> 5 </span>|<span class="string">     </span></span><br><span class="line">|<span class="string">_3_</span>|<span class="string">    </span></span><br><span class="line"><span class="string">stack  </span></span><br><span class="line"></span><br><span class="line"><span class="string">入栈 6 </span></span><br><span class="line">|<span class="string"> 6 </span>|<span class="string">  min = 2</span></span><br><span class="line">|<span class="string"> 2 </span>|<span class="string">   </span></span><br><span class="line">|<span class="string"> 3 </span>|<span class="string">  </span></span><br><span class="line">|<span class="string"> 5 </span>|<span class="string">     </span></span><br><span class="line">|<span class="string">_3_</span>|<span class="string">    </span></span><br><span class="line"><span class="string">stack  </span></span><br><span class="line"></span><br><span class="line"><span class="string">出栈 6     </span></span><br><span class="line">|<span class="string"> 2 </span>|<span class="string">   min = 2</span></span><br><span class="line">|<span class="string"> 3 </span>|<span class="string">  </span></span><br><span class="line">|<span class="string"> 5 </span>|<span class="string">     </span></span><br><span class="line">|<span class="string">_3_</span>|<span class="string">    </span></span><br><span class="line"><span class="string">stack  </span></span><br><span class="line"></span><br><span class="line"><span class="string">出栈 2     </span></span><br><span class="line">|<span class="string"> 2 </span>|<span class="string">   min = 2</span></span><br><span class="line">|<span class="string"> 3 </span>|<span class="string">  </span></span><br><span class="line">|<span class="string"> 5 </span>|<span class="string">     </span></span><br><span class="line">|<span class="string">_3_</span>|<span class="string">    </span></span><br><span class="line"><span class="string">stack  </span></span><br><span class="line"></span><br><span class="line"><span class="string">出栈 2     </span></span><br><span class="line">|<span class="string">   </span>|<span class="string">  min = 3   </span></span><br><span class="line">|<span class="string"> 5 </span>|<span class="string">   </span></span><br><span class="line">|<span class="string">_3_</span>|<span class="string">    </span></span><br><span class="line"><span class="string">stack</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前值更小</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt;= min)&#123;   </span><br><span class="line">            <span class="comment">//将之前的最小值保存</span></span><br><span class="line">            stack.push(min);</span><br><span class="line">            <span class="comment">//更新最小值</span></span><br><span class="line">            min=x;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果弹出的值是最小值，那么将下一个元素更新为最小值</span></span><br><span class="line">        <span class="keyword">if</span>(stack.pop() == min) &#123;</span><br><span class="line">            min=stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="差值栈"><a href="#差值栈" class="headerlink" title="差值栈"></a>差值栈</h4><p>用一个 min 变量保存最小值。只不过栈里边我们不去保存原来的值，而是去存储入栈的值和最小值的差值。然后得到之前的最小值的话，我们就可以通过 min 值和栈顶元素得到，举个例子。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">入栈 <span class="number">3</span>，存入 <span class="number">3</span> - <span class="number">3</span> = <span class="number">0</span></span><br><span class="line">|   |   min = <span class="number">3</span></span><br><span class="line">|   |     </span><br><span class="line">|_0_|    </span><br><span class="line">stack   </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">5</span>，存入 <span class="number">5</span> - <span class="number">3</span> = <span class="number">2</span></span><br><span class="line">|   |   min = <span class="number">3</span></span><br><span class="line">| <span class="number">2</span> |     </span><br><span class="line">|_0_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">2</span>，因为出现了更小的数，所以我们会存入一个负数，这里很关键</span><br><span class="line">也就是存入  <span class="number">2</span> - <span class="number">3</span> = <span class="number">-1</span>, 并且更新 min = <span class="number">2</span> </span><br><span class="line">对于之前的 min 值 <span class="number">3</span>, 我们只需要用更新后的 min - 栈顶元素 <span class="number">-1</span> 就可以得到    </span><br><span class="line">| <span class="number">-1</span>|   min = <span class="number">2</span></span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">入栈 <span class="number">6</span>，存入  <span class="number">6</span> - <span class="number">2</span> = <span class="number">4</span></span><br><span class="line">| <span class="number">4</span> |   min = <span class="number">2</span></span><br><span class="line">| <span class="number">-1</span>| </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">出栈，返回的值就是栈顶元素 <span class="number">4</span> 加上 min，就是 <span class="number">6</span></span><br><span class="line">|   |   min = <span class="number">2</span></span><br><span class="line">| <span class="number">-1</span>| </span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack  </span><br><span class="line"></span><br><span class="line">出栈，此时栈顶元素是负数，说明之前对 min 值进行了更新。</span><br><span class="line">入栈元素 - min = 栈顶元素，入栈元素其实就是当前的 min 值 <span class="number">2</span></span><br><span class="line">所以更新前的 min 就等于入栈元素 <span class="number">2</span> - 栈顶元素(<span class="number">-1</span>) = <span class="number">3</span></span><br><span class="line">|   | min = <span class="number">3</span></span><br><span class="line">| <span class="number">5</span> |     </span><br><span class="line">|_3_|    </span><br><span class="line">stack</span><br></pre></td></tr></table></figure>
<p>再理一下上边的思路，我们每次存入的是 <code>原来值 - 当前最小值</code>。</p>
<p>当原来值大于等于当前最小值的时候，我们存入的肯定就是非负数，所以出栈的时候就是 <code>栈中的值 + 当前最小值</code> 。</p>
<p>当原来值小于当前最小值的时候，我们存入的肯定就是负值，此时的值我们不入栈，用 <code>min</code> 保存起来，同时将差值入栈。</p>
<p>当后续如果出栈元素是负数的时候，那么要出栈的元素其实就是 <code>min</code>。此外之前的 <code>min</code> 值，我们可以通过栈顶的值和当前 <code>min</code> 值进行还原，就是用 <code>min</code> 减去栈顶元素即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> min;</span><br><span class="line">	Stack&lt;Long&gt; stack;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">			min = x;</span><br><span class="line">			stack.push(x - min);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			stack.push(x - min);</span><br><span class="line">			<span class="keyword">if</span> (x &lt; min)&#123;</span><br><span class="line">				min = x; <span class="comment">// 更新最小值</span></span><br><span class="line">			&#125;</span><br><span class="line">				</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">long</span> pop = stack.pop();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//弹出的是负值，要更新 min</span></span><br><span class="line">		<span class="keyword">if</span> (pop &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			min = min - pop;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> top = stack.peek();</span><br><span class="line">		<span class="comment">//负数的话，出栈的值保存在 min 中</span></span><br><span class="line">		<span class="keyword">if</span> (top &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">int</span>) (min);</span><br><span class="line">        <span class="comment">//出栈元素加上最小值即可</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">int</span>) (top + min);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">int</span>) min;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>再分享一个有趣的解法，参考 <a href="https://leetcode.com/problems/min-stack/discuss/49217/6ms-Java-Solution-using-Linked-List.-Clean-self-explanatory-and-efficient." target="_blank" rel="noopener">这里</a> 。</p>
<p>回到最初的疑虑，我们要不要用 <code>java</code> 提供的 <code>stack</code> 。如果不用的话，可以怎么做的？</p>
<p>直接用一个链表即可实现栈的基本功能，那么最小值该怎么得到呢？我们可以在 <code>Node</code> 节点中增加一个 <code>min</code> 字段，这样的话每次加入一个节点的时候，我们同时只要确定它的 <code>min</code> 值即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> x, <span class="keyword">int</span> min)&#123;</span><br><span class="line">            <span class="keyword">this</span>.value=x;</span><br><span class="line">            <span class="keyword">this</span>.min=min;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head;</span><br><span class="line">    <span class="comment">//每次加入的节点放到头部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>==head)&#123;</span><br><span class="line">            head = <span class="keyword">new</span> Node(x,x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前值和之前头结点的最小值较小的做为当前的 min</span></span><br><span class="line">            Node n = <span class="keyword">new</span> Node(x, Math.min(x,head.min));</span><br><span class="line">            n.next=head;</span><br><span class="line">            head=n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">            head =head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head.value;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>!=head)</span><br><span class="line">            <span class="keyword">return</span> head.min;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>栈</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的后序遍历</title>
    <url>/2019/12/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>来源Leetcode第145题二叉树的后序遍历</p>
<blockquote>
<p>给定一个二叉树，返回它的 <strong>后序</strong> 遍历。</p>
</blockquote>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归顺序左右根就完事了嗷。<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">        postorderTraversal(root.left);</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)</span><br><span class="line">        postorderTraversal(root.right);</span><br><span class="line">    ans.add(root.val);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BFS-倒序输出-后序？"><a href="#BFS-倒序输出-后序？" class="headerlink" title="BFS+倒序输出 = 后序？"></a>BFS+倒序输出 = 后序？</h4><p>再改前序遍历的代码改的时候发现直接reverse输出左右子树的顺序不对，于是将入栈顺序改了就行了。。。<br>原理就是这样的遍历顺序是根右左，而后序遍历是左右根，因而翻转就是左右根了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">        TreeNode temp = stack.pop();</span><br><span class="line">        ans.add(temp.val);</span><br><span class="line">        <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(temp.left);</span><br><span class="line">        <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(temp.right);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的前序遍历</title>
    <url>/2019/12/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>来自Leetcode第144题二叉树的前序遍历</p>
<blockquote>
<p>给定一个二叉树，返回它的<strong>前序</strong>遍历。</p>
</blockquote>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归很简单，在大二上就已经学过了，按根左右的顺序即可。<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    ans.add(root.val);</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">        preorderTraversal(root.left);</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)</span><br><span class="line">        preorderTraversal(root.right);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>利用栈，首先根结点入栈，当栈非空，栈顶元素出栈，并且其值写入List，如果左右子树都非空，就右子树入栈再左子树出栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">        TreeNode temp = stack.pop();</span><br><span class="line">        ans.add(temp.val);</span><br><span class="line">        <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(temp.right);</span><br><span class="line">        <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(temp.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="莫里斯遍历"><a href="#莫里斯遍历" class="headerlink" title="莫里斯遍历"></a>莫里斯遍历</h4><p>题解里有，好像之前也看到过，摸了咕咕咕</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>验证二叉搜索树</title>
    <url>/2019/12/03/%E9%AA%8C%E8%AF%81%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>来源Leetcode第98题验证二叉搜索树</p>
<blockquote>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。<a id="more"></a></li>
</ul>
</blockquote>
<hr>
<h4 id="错误的思路"><a href="#错误的思路" class="headerlink" title="错误的思路"></a>错误的思路</h4><p>做的时候忘记判断当前结点的左子树数据是否大于上一结点的数据了，最终在第70/75个用例时出错</p>
<p>错误的代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> root.val&lt; root.right.val &amp;&amp; isValidBST(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> root.val &gt; root.left.val &amp;&amp; isValidBST(root.left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root.val &gt; root.left.val &amp;&amp; root.val&lt; root.right.val &amp;&amp; isValidBST(root.left) &amp;&amp; isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>来源<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode/" target="_blank" rel="noopener">题解</a><br>首先将结点的值与上界和下界（如果有）比较。然后，对左子树和右子树递归进行该过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode node, Integer lower, Integer upper)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> val = node.val;</span><br><span class="line">   <span class="keyword">if</span> (lower != <span class="keyword">null</span> &amp;&amp; val &lt;= lower) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (upper != <span class="keyword">null</span> &amp;&amp; val &gt;= upper) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//遍历右子树，当前结点的值放入lower</span></span><br><span class="line">   <span class="keyword">if</span> (! helper(node.right, val, upper)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//遍历左子树，当前结点的值放入upper</span></span><br><span class="line">   <span class="keyword">if</span> (! helper(node.left, lower, val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> helper(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历迭代"><a href="#中序遍历迭代" class="headerlink" title="中序遍历迭代"></a>中序遍历迭代</h4><p>利用中序遍历来判断是否是二叉搜索树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">		<span class="comment">//先将左子树全部入栈</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//弹出最后一个左边结点</span></span><br><span class="line">            p = stack.pop();</span><br><span class="line">			<span class="comment">//如果右子树的值比左子树的值小</span></span><br><span class="line">			<span class="comment">//直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt;= p.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            pre = p;</span><br><span class="line">			<span class="comment">//右子树入栈</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历递归"><a href="#中序遍历递归" class="headerlink" title="中序遍历递归"></a>中序遍历递归</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> last = -Double.MAX_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (isValidBST(root.left)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (last &lt; root.val) &#123;</span><br><span class="line">               last = root.val;</span><br><span class="line">               <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>位1的个数</title>
    <url>/2019/12/03/%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>来源Leetcode第191题位1的个数</p>
<blockquote>
<p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p>
<p>示例 1：</p>
<p>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。<a id="more"></a></p>
</blockquote>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><ul>
<li>1.计算出来的值i的二进制可以按每2个二进制位为一组进行分组，各组的十进制表示的就是该组的汉明重量。</li>
<li>2.计算出来的值i的二进制可以按每4个二进制位为一组进行分组，各组的十进制表示的就是该组的汉明重量。</li>
<li>3.计算出来的值i的二进制可以按每8个二进制位为一组进行分组，各组的十进制表示的就是该组的汉明重量。</li>
<li>4.i * (0x01010101)计算出汉明重量并记录在二进制的高八位，&gt;&gt;24语句则通过右移运算，将汉明重量移到最低八位，最后二进制对应的十进制数就是汉明重量。<br>算法时间复杂度是O（1）的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">i = (i &amp; <span class="number">0x55555555</span>) + ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);  <span class="comment">//相邻位相加</span></span><br><span class="line">i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);  <span class="comment">//相邻为以2为单位相加</span></span><br><span class="line">i = (i &amp; <span class="number">0x0F0F0F0F</span>) + ((i &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F0F0F0F</span>);  <span class="comment">//相邻为以4为单位相加</span></span><br><span class="line">i = (i * (<span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><p>执行32次，每次与1相与，判断结果后累加</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">            bits++;</span><br><span class="line">        &#125;</span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h4><p>来源官方题解</p>
<blockquote>
<p>在二进制表示中，数字 nn 中最低位的 11 总是对应 n - 1n−1 中的 00 。因此，将 nn 和 n - 1n−1 与运算总是能把 nn 中最低位的 11 变成 00 ，并保持其他位不变。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Integet类库"><a href="#Integet类库" class="headerlink" title="Integet类库"></a>Integet类库</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.bitCount(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lowbit公式"><a href="#lowbit公式" class="headerlink" title="lowbit公式"></a>lowbit公式</h4><p>lowbit公式： x &amp; ~x<br>作用是找出数字n中最后一个1出现的位置<br>例如n = 10。用二进制表示就是1010，而它的负数-10用二进制补码表示则为0110，<br>取&amp;后得到的结果为10，这就得到了n最后一个1出现的位置对应的数字。<br>知道lowbit公式后，这个题目就非常简单了。每次通过lowbit公式找到最后一个1对应的数，然后将它减去，直到n为0为止。统计减法操作的次数即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            n -= lowbit(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍</title>
    <url>/2019/12/02/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<p>来源Leetcode第198题打家劫舍</p>
<blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br><a id="more"></a><br>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,1]<br>输出: 4<br>解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p>
</blockquote>
<hr>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>易知，当前房屋的最大收益dp[i] = max(dp[i - 1],dp[i - 2] + nums[i]}<br>即当前房屋的收益要么是上一房屋的累积收益，即当前房间不抢劫，要么是前前房屋的收益加上当前房屋的收益</p>
<p>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= nums.length ; i++)&#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h4><p>来自<a href="https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<p>利用3个变量替代了dp数组，使空间利用率从O(n)降到了O(1)</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prevMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> currMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : num) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = currMax;</span><br><span class="line">        currMax = Math.max(prevMax + x, currMax);</span><br><span class="line">        prevMax = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程的软中断和管道通信</title>
    <url>/2019/12/02/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h3 id="Linux进程管理命令——进程查看"><a href="#Linux进程管理命令——进程查看" class="headerlink" title="Linux进程管理命令——进程查看"></a>Linux进程管理命令——进程查看</h3><ul>
<li>ps命令：报告进程标识、用户、CPU时间消耗及其他属性 <ul>
<li>命令单独使用可以看到前台执行的进程；后台进程可以使用带参 数的ps命令（如ps -ax） <a id="more"></a></li>
<li>提供进程的一次性查看，结果不连续 </li>
<li>结果数据很精确，但数据量庞大</li>
</ul>
</li>
<li>top命令：显示CPU占用率为前几位的进程 <ul>
<li>动态显示，输出结果连续 </li>
<li>消耗较多的系统资源</li>
</ul>
</li>
<li>pstree命令：列出当前的进程，以及它们的树状结构 <ul>
<li>将当前的执行程序以树状结构显示，弥补ps命令的不足</li>
<li>支持指定特定程序(PID)或使用者(USER)作为显示的起始</li>
</ul>
</li>
</ul>
<h3 id="Linux进程管理命令—进程终止"><a href="#Linux进程管理命令—进程终止" class="headerlink" title="Linux进程管理命令—进程终止"></a>Linux进程管理命令—进程终止</h3><ul>
<li>终止一个进程或终止一个正在运行的程序 <ul>
<li>kill命令：根据PID向进程发送信号，缺省操作是停止进程 </li>
<li>如果进程启动了子进程，只终止父进程，子进程运行中将仍 消耗资源成为“僵尸”进程，可用kill -9强制终止退出 </li>
<li>pkill命令：终止同一进程组内的所有进程。允许指定要终止的进程名称，而非PID </li>
<li>Killall命令：与pkill应用方法类似，直接杀死运行中的程 序</li>
<li>数据库服务器的父进程不能用这些命令杀死（容易产生更多 的文件碎片导致数据库崩溃）</li>
</ul>
</li>
</ul>
<h3 id="Linux进程控制函数——进程创建"><a href="#Linux进程控制函数——进程创建" class="headerlink" title="Linux进程控制函数——进程创建"></a>Linux进程控制函数——进程创建</h3><h4 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h4><p>pid=fork();<br>fork系统调用用于创建一个新进程，称为子进程，它与进程（称为系统调用fork的进程）同时运行，此进程称为父进程。创建新的子进程后，两个进程将执行fork（）系统调用之后的下一条指令。子进程使用相同的pc（程序计数器），相同的CPU寄存器，在父进程中使用的相同打开文件。</p>
<div align="center">
<img width="500" src="/2019/12/02/进程的软中断和管道通信/1.jpg">
</div>

<p>它不需要参数并返回一个整数值。下面是fork（）返回的不同值。</p>
<ul>
<li>负值：创建子进程失败。</li>
<li>零：返回到新创建的子进程。</li>
<li>正值：返回父母或来电者。该值包含新创建的子进程的进程ID</li>
</ul>
<p><strong>头文件</strong>:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;/*#包含&lt;unistd.h&gt;*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;/*#包含&lt;sys/types.h&gt;*/</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>函数原型</strong>:<br>pid_t fork( void);<br>（pid_t 是一个宏定义，其实质是int 被定义在#include<sys types.h>中）<br>返回值： 若成功调用一次则返回两个值，子进程返回0，父进程返回子进程ID；否则，出错返回-1</sys></p>
<p><strong>函数说明</strong>：<br>一个现有进程可以调用fork函数创建一个新进程。由fork创建的新进程被称为子进程（child process）。fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值而父进程中返回子进程ID。<br>子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。<br>UNIX将复制父进程的地址空间内容给子进程，因此，子进程有了独立的地址空间。在不同的UNIX (Like)系统下，我们无法确定fork之后是子进程先运行还是父进程先运行，这依赖于系统的实现。所以在移植代码的时候我们不应该对此作出任何的假设。</p>
<p><strong>为什么fork会返回两次？</strong><br>由于在复制时复制了父进程的堆栈段，所以两个进程都停留在fork函数中，等待返回。因此fork函数会返回两次，一次是在父进程中返回，另一次是在子进程中返回，这两次的返回值是不一样的。</p>
<p>fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：<br>(1)在父进程中，fork返回新创建子进程的进程ID；<br>(2)在子进程中，fork返回0；<br>(3)如果出现错误，fork返回一个负值。<br>在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。<br>引用一位网友的话来解释fork函数返回的值为什么在父子进程中不同。“其实就相当于链表，进程形成了链表，父进程的fork函数返回的值指向子进程的进程id, 因为子进程没有子进程，所以其fork函数返回的值为0.<br>调用fork之后，数据、堆、栈有两份，代码仍然为一份但是这个代码段成为两个进程的共享代码段都从fork函数中返回，箭头表示各自的执行处。当父子进程有一个想要修改数据或者堆栈时，两个进程真正分裂。</p>
<h4 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h4><p>函数族exec() ：启动另外的进程取代当前的进程 </p>
<ul>
<li><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <unistd.h></unistd.h></h1></li>
<li>extern char **environ;</li>
<li>int execl(const char *path, const char *arg, …); </li>
<li>int execlp(const char *file, const char *arg, …); </li>
<li>int execle(const char *path, const char *arg, const char *envp[]); </li>
<li>int execv(const char *path, const char *argv[]); </li>
<li>int execve(const char *path, const char *argv[], const char *envp[]; </li>
<li>int execvp(const char *file, const char *argv[]);</li>
</ul>
<p>其中只有execve是真正意义上的系统调用，其它都是在此基础上经过包装的库函数。</p>
<p><strong>exec族函数的作用</strong></p>
<p>exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。这里的可执行文件既可以是二进制文件，也可以是任何Linux下可执行的脚本文件。<br>与一般情况不同，exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样，颇有些神似”三十六计”中的”金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回一个-1，从原程序的调用点接着往下执行。<br>现在我们应该明白了，Linux下是如何执行新程序的，每当有进程认为自己不能为系统和用户做出任何贡献了，他就可以发挥最后一点余热，调用任何一个exec，让自己以新的面貌重生；或者，更普遍的情况是，如果一个进程想执行另一个程序，它就可以fork出一个新进程，然后调用任何一个exec，这样看起来就好像通过执行应用程序而产生了一个新进程一样。<br>事实上第二种情况被应用得如此普遍，以至于Linux专门为其作了优化，我们已经知道，fork会将调用进程的所有内容原封不动的拷贝到新产生的子进程中去，这些拷贝的动作很消耗时间，而如果fork完之后我们马上就调用exec，这些辛辛苦苦拷贝来的东西又会被立刻抹掉，这看起来非常不划算，于是人们设计了一种”写时拷贝（copy-on-write）”技术，使得fork结束后并不立刻复制父进程的内容，而是到了真正实用的时候才复制，这样如果下一条语句是exec，它就不会白白作无用功了，也就提高了效率。<br>对于新程序的命令行参数和环境表有长度大小的限制，对于linux来讲这个限制是4096个字节。执行了exec函数的进程不改变以下进程特征：</p>
<ul>
<li>1.进程ID和父进程ID</li>
<li>2.实际用户ID和实际组ID</li>
<li>3.进程组ID和附加组ID</li>
<li>4.控制终端 </li>
<li>5.会话ID</li>
<li>6.时钟预留着时间</li>
<li>7.当前工作目录和根目录</li>
<li>8.文件创建屏蔽字和文件锁</li>
<li>9.信号屏蔽字和未处理信号集</li>
<li>10.资源限制</li>
</ul>
<p><strong>返回值</strong><br>如果执行成功则函数不会返回，执行失败则直接返回-1，失败原因存于errno 中。</p>
<p><strong>注意</strong><br>大家在平时的编程中，如果用到了exec函数族，一定记得要加错误判断语句。因为与其他系统调用比起来，exec很容易受伤，被执行文件的位置，权限等很多因素都能导致该调用的失败。最常见的错误是：</p>
<ul>
<li>1.找不到文件或路径，此时errno被设置为ENOENT；</li>
<li>2.数组argv和envp忘记用NULL结束，此时errno被设置为EFAULT；</li>
<li>3.没有对要执行文件的运行权限，此时errno被设置为EACCES。</li>
<li>l表示以参数列表的形式调用</li>
<li>v表示以参数数组的方式调用</li>
<li>e表示可传递环境变量</li>
<li>p表示PATH中搜索执行的文件，如果给出的不是绝对路径就会去PATH搜索相应名字的文件，如PATH没有设置， 则会默认在/bin,/usr/bin下搜索。</li>
<li>另：调用时参数必须以NULL结束。原进程打开的文件描述符是不会在exec中关闭的，除非用fcntl设置它们的“执行时关闭标志（close on exec）”而原进程打开的目录流都将在新进程中关闭。</li>
</ul>
<h4 id="Linux进程属性操作"><a href="#Linux进程属性操作" class="headerlink" title="Linux进程属性操作"></a>Linux进程属性操作</h4><ul>
<li>设置进程属性 <ul>
<li>nice()：改变进程执行的优先级 </li>
<li>setpgid()：将指定进程的组进程设为指定的组识别码 </li>
<li>setpgrp()：将目前进程的组进程识别码设为目前进程的进程 识别码，等价于setpgid(0,0) </li>
<li>setpriority()：设置进程、进程组和用户的执行优先权 </li>
</ul>
</li>
<li>获取进程属性 <ul>
<li>getpid()：获取目前进程的进程标识 </li>
<li>getpgid()：获得参数pid指定进程所属的组识别码 </li>
<li>getpgrp()：获得目前进程所属的组识别号，等价于 </li>
<li>getpgid(0) </li>
<li>getpriotity()：获得进程、进程组和用户的执行优先权</li>
</ul>
</li>
</ul>
<h4 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h4><ul>
<li>正常退出：在main()函数中执行return、调用exit()函数 或_exit()函数 </li>
<li>异常退出：调用abort()函数、进程收到信号而终止 </li>
<li>区别 <ul>
<li>exit是一个函数，有参数，把控制权交给系统 </li>
<li>return是函数执行完后的返回，将控制权交给调用函数 </li>
<li>exit是正常终止进程，abort是异常终止 </li>
<li>exit中参数为0代表进程正常终止，为其他值表示程序执行过程 中有错误发生 </li>
<li>exit()在头文件stdlib.h中声明，先执行清除操作，再将控制权 返回给内核 </li>
<li>_exit()在头文件unistd.h中声明，执行后立即返回给内核</li>
</ul>
</li>
</ul>
<h4 id="等待进程终止"><a href="#等待进程终止" class="headerlink" title="等待进程终止"></a>等待进程终止</h4><p>wait();    waitpid();</p>
<ul>
<li>① wait() 语法格式： pid=wait(stat_addr);<br> wait()函数使父进程暂停执行，直到它的一个子进程结束为止，该函数 的返回值是终止运行的子进程的PID。参数status所指向的变量存放子 进程的退出码，即从子进程的main函数返回的值或子进程中exit()函数 的参数。如果status不是一个空指针，状态信息将被写入它指向的变量。</li>
<li><p>② waitpid() 语法格式：waitpid(pid_t pid,int * status,int options)<br> 用来等待子进程的结束，但它用于等待某个特定进程结束。<br> 参数pid指明要等待的子进程的PID，参数status的含义与wait()函数中的 status相同。</p>
<p> 如果在调用 waitpid()时子进程已经结束,则 waitpid()会立即返回子进程结束状态值。 子进程的结束状态值会由参数 status 返回,而子进程的进程识别码也会一起返回。如果不在意结束状态值,则参数 status 可以设成 NULL。参数 pid 为欲等待的子进程识别码.<br> 其他数值意义如下:</p>
<ul>
<li>pid&lt;-1 等待进程组识别码为 pid 绝对值的任何子进程。</li>
<li>pid=-1 等待任何子进程,相当于 wait()。</li>
<li>pid=0 等待进程组识别码与目前进程相同的任何子进程。</li>
<li>pid&gt;0 等待任何子进程识别码为 pid 的子进程。</li>
<li><p>参数options提供了一些额外的选项来控制waitpid，参数 option 可以为 0 或可以用”|”运算符把它们连接起来使用，比如：<code>ret=waitpid(-1,NULL,WNOHANG | WUNTRACED);</code><br>WNOHANG 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若结束，则返回该子进程的ID。<br>WUNTRACED 若子进程进入暂停状态，则马上返回，但子进程的结束状态不予以理会。WIFSTOPPED(status)宏确定返回值是否对应与一个暂停子进程。</p>
<p>子进程的结束状态返回后存于 status,底下有几个宏可判别结束情况:<br>WIFEXITED(status)如果若为正常结束子进程返回的状态，则为真；对于这种情况可执行WEXITSTATUS(status)，取子进程传给exit或_eixt的低8位。<br>WEXITSTATUS(status)取得子进程 exit()返回的结束代码,一般会先用 WIFEXITED 来判断是否正常结束才能使用此宏。<br>WIFSIGNALED(status)若为异常结束子进程返回的状态，则为真；对于这种情况可执行WTERMSIG(status)，取使子进程结束的信号编号。<br>WTERMSIG(status) 取得子进程因信号而中止的信号代码,一般会先用 WIFSIGNALED 来判断后才使用此宏。<br>WIFSTOPPED(status) 若为当前暂停子进程返回的状态，则为真；对于这种情况可执行WSTOPSIG(status)，取使子进程暂停的信号编号。<br>WSTOPSIG(status) 取得引发子进程暂停的信号代码,一般会先用 WIFSTOPPED 来判断后才使用此宏。<br>如果执行成功则返回子进程识别码(PID) ,如果有错误发生则返回<br>返回值-1。失败原因存于 errno 中。</p>
</li>
</ul>
</li>
</ul>
<h3 id="进程的软中断通信"><a href="#进程的软中断通信" class="headerlink" title="进程的软中断通信"></a>进程的软中断通信</h3><h4 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h4><p><strong>表头文件</strong>#include<signal.h></signal.h></p>
<p><strong>功能</strong>：设置某一信号的对应动作</p>
<p><strong>函数原型</strong>：void (*signal(int signum,void(* handler)(int)))(int);<br>或者：typedef void (*sig_t)( int );<br>sig_t signal(int signum,sig_t handler);</p>
<p><strong>参数说明</strong>：<br>第一个参数signum指明了所要处理的信号类型，它可以取除了SIGKILL和SIGSTOP外的任何一种信号。<br>第二个参数handler描述了与信号关联的动作，它可以取以下三种值：</p>
<ul>
<li>（1）一个无返回值的函数地址<br> 此函数必须在signal()被调用前申明，handler中为这个函数的名字。当接收到一个类型为signum的信号时，就执行handler 所指定的函数。这个函数应有如下形式的定义：<br> void func(int sig);</li>
<li>（2）SIG_IGN<br> 这个符号表示忽略该信号，执行了相应的signal()调用后，进程会忽略类型为sig的信号。</li>
<li>（3）SIG_DFL<br> 这个符号表示恢复系统对信号的默认处理。</li>
</ul>
<p><strong>函数说明</strong>：<br>signal()会依参数signum 指定的信号编号来设置该信号的处理函数。当指定的信号到达时就会跳转到参数handler指定的函数执行。当一个信号的信号处理函数执行时，如果进程又接收到了该信号，该信号会自动被储存而不会中断信号处理函数的执行，直到信号处理函数执行完毕再重新调用相应的处理函数。但是如果在信号处理函数执行时进程收到了其它类型的信号，该函数的执行就会被中断。</p>
<p><strong>返回值</strong>：返回先前的信号处理函数指针，如果有错误则返回SIG_ERR(-1)。</p>
<p>下面的情况可以产生Signal：</p>
<ul>
<li>按下CTRL+C产生SIGINT</li>
<li>硬件中断，如除0，非法内存访问（SIGSEV）等等</li>
<li>Kill函数可以对进程发送Signal</li>
<li>Kill命令。实际上是对Kill函数的一个包装</li>
<li>软件中断。如当Alarm Clock超时（SIGURG），当Reader中止之后又向管道写数据（SIGPIPE），等等</li>
</ul>
<p>Signals:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Signal</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SIGABRT</td>
<td style="text-align:center">由调用abort函数产生，进程非正常退出 </td>
</tr>
<tr>
<td style="text-align:center">SIGALRM</td>
<td style="text-align:center">用alarm函数设置的timer超时或setitimer函数设置的interval timer超时 </td>
</tr>
<tr>
<td style="text-align:center">SIGBUS</td>
<td style="text-align:center">某种特定的硬件异常，通常由内存访问引起</td>
</tr>
<tr>
<td style="text-align:center">SIGCANCEL</td>
<td style="text-align:center">由Solaris Thread Library内部使用，通常不会使用</td>
</tr>
<tr>
<td style="text-align:center">SIGCHLD</td>
<td style="text-align:center">进程Terminate或Stop的时候，SIGCHLD会发送给它的父进程。缺省情况下该Signal会被忽略</td>
</tr>
<tr>
<td style="text-align:center">SIGCONT</td>
<td style="text-align:center">当被stop的进程恢复运行的时候，自动发送</td>
</tr>
<tr>
<td style="text-align:center">SIGEMT</td>
<td style="text-align:center">和实现相关的硬件异常</td>
</tr>
<tr>
<td style="text-align:center">SIGFPE</td>
<td style="text-align:center">数学相关的异常，如被0除，浮点溢出，等等</td>
</tr>
<tr>
<td style="text-align:center">SIGFREEZE</td>
<td style="text-align:center">Solaris专用，Hiberate或者Suspended时候发送</td>
</tr>
<tr>
<td style="text-align:center">SIGHUP</td>
<td style="text-align:center">发送给具有Terminal的Controlling Process，当terminal被disconnect时候发送</td>
</tr>
<tr>
<td style="text-align:center">SIGILL</td>
<td style="text-align:center">非法指令异常</td>
</tr>
<tr>
<td style="text-align:center">SIGINFO</td>
<td style="text-align:center">BSD signal。由Status Key产生，通常是CTRL+T。发送给所有Foreground Group的进程</td>
</tr>
<tr>
<td style="text-align:center">SIGINT</td>
<td style="text-align:center">由Interrupt Key产生，通常是CTRL+C或者DELETE。发送给所有ForeGround Group的进程</td>
</tr>
<tr>
<td style="text-align:center">SIGIO</td>
<td style="text-align:center">异步IO事件</td>
</tr>
<tr>
<td style="text-align:center">SIGIOT</td>
<td style="text-align:center">实现相关的硬件异常，一般对应SIGABRT</td>
</tr>
<tr>
<td style="text-align:center">SIGKILL</td>
<td style="text-align:center">无法处理和忽略。中止某个进程</td>
</tr>
<tr>
<td style="text-align:center">SIGLWP</td>
<td style="text-align:center">由Solaris Thread Libray内部使用</td>
</tr>
<tr>
<td style="text-align:center">SIGPIPE</td>
<td style="text-align:center">在reader中止之后写Pipe的时候发送</td>
</tr>
<tr>
<td style="text-align:center">SIGPOLL</td>
<td style="text-align:center">当某个事件发送给Pollable Device的时候发送</td>
</tr>
<tr>
<td style="text-align:center">SIGPROF</td>
<td style="text-align:center">Setitimer指定的Profiling Interval Timer所产生</td>
</tr>
<tr>
<td style="text-align:center">SIGPWR</td>
<td style="text-align:center">和系统相关。和UPS相关。</td>
</tr>
<tr>
<td style="text-align:center">SIGQUIT</td>
<td style="text-align:center">输入Quit Key的时候（CTRL+\）发送给所有Foreground Group的进程</td>
</tr>
<tr>
<td style="text-align:center">SIGSEGV</td>
<td style="text-align:center">非法内存访问</td>
</tr>
<tr>
<td style="text-align:center">SIGSTKFLT</td>
<td style="text-align:center">Linux专用，数学协处理器的栈异常</td>
</tr>
<tr>
<td style="text-align:center">SIGSTOP</td>
<td style="text-align:center">中止进程。无法处理和忽略。</td>
</tr>
<tr>
<td style="text-align:center">SIGSYS</td>
<td style="text-align:center">非法系统调用</td>
</tr>
<tr>
<td style="text-align:center">SIGTERM</td>
<td style="text-align:center">请求中止进程，kill命令缺省发送</td>
</tr>
<tr>
<td style="text-align:center">SIGTHAW</td>
<td style="text-align:center">Solaris专用，从Suspend恢复时候发送</td>
</tr>
<tr>
<td style="text-align:center">SIGTRAP</td>
<td style="text-align:center">实现相关的硬件异常。一般是调试异常</td>
</tr>
<tr>
<td style="text-align:center">SIGTSTP</td>
<td style="text-align:center">Suspend Key，一般是Ctrl+Z。发送给所有Foreground Group的进程</td>
</tr>
<tr>
<td style="text-align:center">SIGTTIN</td>
<td style="text-align:center">当Background Group的进程尝试读取Terminal的时候发送</td>
</tr>
<tr>
<td style="text-align:center">SIGTTOU</td>
<td style="text-align:center">当Background Group的进程尝试写Terminal的时候发送</td>
</tr>
<tr>
<td style="text-align:center">SIGURG</td>
<td style="text-align:center">当out-of-band data接收的时候可能发送</td>
</tr>
<tr>
<td style="text-align:center">SIGUSR1</td>
<td style="text-align:center">用户自定义signal 1</td>
</tr>
<tr>
<td style="text-align:center">SIGUSR2</td>
<td style="text-align:center">用户自定义signal 2</td>
</tr>
<tr>
<td style="text-align:center">SIGVTALRM</td>
<td style="text-align:center">setitimer函数设置的Virtual Interval Timer超时的时候</td>
</tr>
<tr>
<td style="text-align:center">SIGWAITING</td>
<td style="text-align:center">Solaris Thread Library内部实现专用</td>
</tr>
<tr>
<td style="text-align:center">SIGWINCH</td>
<td style="text-align:center">当Terminal的窗口大小改变的时候，发送给Foreground Group的所有进程</td>
</tr>
<tr>
<td style="text-align:center">SIGXCPU</td>
<td style="text-align:center">当CPU时间限制超时的时候</td>
</tr>
<tr>
<td style="text-align:center">SIGXFSZ</td>
<td style="text-align:center">进程超过文件大小限制</td>
</tr>
<tr>
<td style="text-align:center">SIGXRES</td>
<td style="text-align:center">Solaris专用，进程超过资源限制的时候发送</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意</strong></p>
<ul>
<li>不要使用低级的或者STDIO.H的IO函数</li>
<li>不要使用对操作</li>
<li>不要进行系统调用</li>
<li>不是浮点信号的时候不要用longjmp</li>
<li>signal函数是由ISO C定义的。因为ISO C不涉及多进程，进程组以及终端I/O等，所以他对信号的定义非常含糊，以至于对UNIX系统而言几乎毫无用处。</li>
<li>备注：因为signal的语义与现实有关，所以最好使用sigaction函数替代本函数</li>
</ul>
<p>当某个信号出现时，系统有三种处理方式： </p>
<ul>
<li>忽略信号：大多数信号使用，但SIGKIL和SIGSTOP不能被忽略 </li>
<li>捕捉信号：通知内核在某种信号发生时，调用一个用户函数 </li>
<li>执行系统默认动作：异常终止(abort)、退出(exit)、忽略(ignore)、停 止(stop)或继续(continue)</li>
</ul>
<p><strong>功能 </strong></p>
<ul>
<li>发送信号：发送进程把信号送到指定进程信号域的某一位上，如目标进程正在一个可被中断的优先级上睡眠，核心便将其唤醒 </li>
<li>预置对信号的处理方式：进程处于核心态时，即使受到软中断也不予理睬；只有当它返回到用户态后，才处理软中断信号 </li>
<li>收受信号的进程按事先规定完成对相应事件的处理</li>
</ul>
<h3 id="进程的软中断通信——函数的使用"><a href="#进程的软中断通信——函数的使用" class="headerlink" title="进程的软中断通信——函数的使用"></a>进程的软中断通信——函数的使用</h3><ul>
<li><p>向一个进程或一组进程发送一个信号：int kill(pid, sig)<br> pid&gt;0时，核心将信号发送给进程pid<br> pid&lt;0时，核心将信号发送给与发送进程同组的所有进程<br> pid=-1时，核心将信号发送给所有用户标识符真正等于发送进程的有 效用户标识号的进程</p>
</li>
<li><p>预置信号接收后的处理方式：signal(sig, function)<br> function=1时，屏蔽该类信号<br> function=0时，收到sig信号后终止自己<br> function为非0、非1类整数时，执行用户设置的软中断处理程序</p>
</li>
</ul>
<h3 id="Linux进程间通信—管道和有名管道"><a href="#Linux进程间通信—管道和有名管道" class="headerlink" title="Linux进程间通信—管道和有名管道"></a>Linux进程间通信—管道和有名管道</h3><ul>
<li>管道用于具有亲缘关系进程间的通信<ul>
<li>管道是半双工的，数据只能单向流动（双方通信需建立两个管道）</li>
<li>管道只能用于父子进程或兄弟进程之间</li>
<li>管道对于管道两端的进程而言就是一个文件，并单独构成一种文件 系统，存在于内存中</li>
<li>写管道的内容添加在管道缓冲区的末尾，读管道则从缓冲区头部读 出</li>
</ul>
</li>
<li>有名管道在普通管道具备功能基础上，通过给管道命名的 方法变成管道文件，允许无亲缘关系进程间通过访问管道 文件进行通信</li>
</ul>
<h4 id="无名管道的使用"><a href="#无名管道的使用" class="headerlink" title="无名管道的使用"></a>无名管道的使用</h4><ul>
<li>int pipefd[2]; int pipe(pipefd); /*创建无名管道*/<br> pipefd[0]只能用于读;  pipe[1]只能用于写</li>
</ul>
<p>pipe函数定义中的fd参数是一个大小为2的一个数组类型的指针。该函数成功时返回0，并将一对打开的文件描述符值填入fd参数指向的数组。失败时返回 -1并设置errno。</p>
<p>通过pipe函数创建的这两个文件描述符 fd[0] 和 fd[1] 分别构成管道的两端，往 fd[1] 写入的数据可以从 fd[0] 读出。并且 fd[1] 一端只能进行写操作，fd[0] 一端只能进行读操作，不能反过来使用。要实现双向数据传输，可以使用两个管道。</p>
<p>默认情况下，这一对文件描述符都是阻塞的。此时，如果我们用read系统调用来读取一个空的管道，则read将被阻塞，知道管道内有数据可读；如果我们用write系统调用往一个满的管道中写数据，则write也将被阻塞，直到管道有足够的空闲空间可用(read读取数据后管道中将清除读走的数据)。当然，用户可自行将 fd[0] 和 fd[1] 设置为非阻塞的。</p>
<p>如果管道的写端文件描述符 fd[1] 的引用计数减少至0，即没有任何进程需要往管道中写入数据，则对该管道的读端文件描述符 fd[0] 的read操作将返回0(管道内不存在数据的情况)，即读到了文件结束标记(EOF，End Of File)；反之，如果管道的读端文件描述符 fd[0] 的引用计数减少至0，即没有任何进程需要从管道读取数据，则针对该管道的写端文件描述符 fd[1] 的write操作将失败，并引发SIGPIPE信号(往读端被关闭的管道或socket连接中写数据)。</p>
<p>管道内部传输的数据是字节流，这和TCP字节流的概念相同。但它们又存在细微的差别。应用层程序能往一个TCP连接中写入多少字节的数据，取决于对方接受窗口的大小和本端的拥塞窗口的大小。而管道的话本身拥有一个容量限制，它规定如果管道的写端应用程序不将管道中数据读走的话，该管道最多还能被写入多少字节的数据。管道容量的大小默认是65536字节。我们也可以使用fcntl函数来修改管道容量。</p>
<div align="center">
<img width="500" src="/2019/12/02/进程的软中断和管道通信/2.jpg">
</div>

<ol>
<li><p>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。</p>
</li>
<li><p>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</p>
</li>
<li><p>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</p>
</li>
</ol>
<ul>
<li>将数据写入管道：write() <ul>
<li>函数原型:<code>int write(int handle, void *buf, int nbyte)</code></li>
<li>管道长度受到限制，管道满时写入操作将被阻塞，直到管道中的 数据被读取 </li>
<li>fcntl()可将管道设置为非阻塞模式</li>
</ul>
</li>
<li>从管道读取数据：read() <ul>
<li>函数原型:<code>ssize_t read   (int fd, void *buf, size_t count);</code></li>
<li>返回值：成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0。</li>
<li>参数：参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移。注意这个读写位置和使用C标准I/O库时的读写位置有可能不同，这个读写位置是记在内核中的，而使用C标准I/O库时的读写位置是用户空间I/O缓冲区中的位置。比如用fgetc读一个字节，fgetc有可能从内核中预读1024个字节到I/O缓冲区中，再返回第一个字节，这时该文件在内核中记录的读写位置是1024，而在FILE结构体中记录的读写位置是1。注意返回值类型是ssize_t，表示有符号的size_t，这样既可以返回正的字节数、0（表示到达文件末尾）也可以返回负值-1（表示出错）。<br>read函数返回时，返回值说明了buf中前多少个字节是刚读上来的。有些情况下，实际读到的字节数（返回值）会小于请求读的字节数count，例如：读常规文件时，在读到count个字节之前已到达文件末尾。例如，距文件末尾还有30个字节而请求读100个字节，则read返回30，下次read将返回0。</li>
<li>当数据被读取后，数据将自动被管道清除 </li>
<li>不能由一个进程向多个进程同时传递同一个数据 </li>
<li>fcntl()可将管道读模式设置为非阻塞模式 </li>
</ul>
</li>
<li>关闭管道：close()<ul>
<li>函数原型:<code>int close(int fd);</code></li>
<li>返回值：成功返回0，出错返回-1并设置errno</li>
<li>参数fd是要关闭的文件描述符。需要说明的是，当一个进程终止时，内核对该进程所有尚未关闭的文件描述符调用close关闭，所以即使用户程序不调用close，在终止时内核也会自动关闭它打开的所有文件。但是对于一个长年累月运行的程序（比如网络服务器），打开的文件描述符一定要记得关闭，否则随着打开的文件越来越多，会占用大量文件描述符和系统资源。</li>
<li>关闭读端口时，在管道上进行写操作的进程将收到SIGPIPE信号 </li>
<li>关闭写端口时，进行读操作的read()函数将返回0</li>
</ul>
</li>
</ul>
<h4 id="管道通信的使用—命名管道的创建与读写"><a href="#管道通信的使用—命名管道的创建与读写" class="headerlink" title="管道通信的使用—命名管道的创建与读写"></a>管道通信的使用—命名管道的创建与读写</h4><ul>
<li><p>创建命名管道： </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">int mknod(const char *path, mode_t mod, dev_t dev)； </span><br><span class="line">int mkfifo(const char *path, mode_t mode)；</span><br></pre></td></tr></table></figure>
</li>
<li><p>命名管道必须先调用open()将其打开 </p>
<ul>
<li>同时用读写方式(O_RDWR)打开时，一定不会导致阻塞 </li>
<li>以只读方式(O_RDONLY)打开时，调用open()函数的进程将会被 阻塞直到有写方打开管道 </li>
<li>以写方式(O_WRONLY)打开时，阻塞直到有读方打开管道</li>
</ul>
</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>实现进程简单控制和利用管道通信</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  //exex、fork头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;  //signal头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  //wait头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;  //wait头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  //exit头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; //mutex头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pipefd[<span class="number">2</span>];   <span class="comment">/*创建无名管道,pipefd[0]只能用于读;  pipe[1]只能用于写*/</span></span><br><span class="line"><span class="keyword">int</span> child_1, child_2;  <span class="comment">//用于存储创建的子进程pid</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;  <span class="comment">//进程互斥锁，避免抢占打印输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill_child1</span><span class="params">()</span> </span>&#123; <span class="comment">//父进程杀死子进程1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Child process 1 is killed by parent!\n"</span>);</span><br><span class="line">	close(pipefd[<span class="number">1</span>]);  <span class="comment">//关闭管道写端</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">//子进程1退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill_child2</span><span class="params">()</span> </span>&#123; <span class="comment">//父进程杀死子进程2</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Child process 2 is killed by parent!\n"</span>);</span><br><span class="line">	close(pipefd[<span class="number">0</span>]);  <span class="comment">//关闭管道读端</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">//子进程2退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill_childprocess</span><span class="params">()</span> </span>&#123;  <span class="comment">//父进程捕捉到中断信号，用系统调用Kill()向两个子进 程发出信号</span></span><br><span class="line">	<span class="keyword">if</span> (kill(child_1, SIGUSR1) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Kill child1 process error!\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (kill(child_2, SIGUSR1) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Kill child2 process error!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> rtn; </span><br><span class="line">	pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>); <span class="comment">//初始化mutex</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建管道 </span></span><br><span class="line">	<span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Create a nameless pipe error!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建第一个子进程</span></span><br><span class="line">	<span class="keyword">switch</span> (child_1 = fork())</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> - <span class="number">1</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Create child process failed!\n"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		close(pipefd[<span class="number">0</span>]);  <span class="comment">//子进程1关闭读端</span></span><br><span class="line">		signal(SIGINT, SIG_IGN);  <span class="comment">//SIGINT:由Interrupt Key产生，通常是CTRL+C或者DELETE。</span></span><br><span class="line">													 <span class="comment">//发送给所有ForeGround Group的进程</span></span><br><span class="line">		signal(SIGUSR1, kill_child1);   <span class="comment">// 设置进程处理信号</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">//死循环里每秒通过管道发送信号给子进程2</span></span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">			write(pipefd[<span class="number">1</span>], (<span class="keyword">void</span>*)&amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">			pthread_mutex_lock(&amp;mutex);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"I have send you %d times!\n"</span>, i);</span><br><span class="line">			pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建第二个子进程</span></span><br><span class="line">	<span class="keyword">switch</span> (child_2 = fork())</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Create child process failed!\n"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		close(pipefd[<span class="number">1</span>]);  <span class="comment">//子进程关闭写端</span></span><br><span class="line">		signal(SIGINT, SIG_IGN);  <span class="comment">//SIGINT:由Interrupt Key产生，通常是CTRL+C或者DELETE。</span></span><br><span class="line">											 <span class="comment">//发送给所有ForeGround Group的进程</span></span><br><span class="line">		signal(SIGUSR1, kill_child2);   <span class="comment">// 设置进程处理信号</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">//死循环里每秒通过管道发送信号给子进程2</span></span><br><span class="line">			read(pipefd[<span class="number">0</span>], (<span class="keyword">void</span>*)&amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">			pthread_mutex_lock(&amp;mutex);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"I have received your message %d times!\n"</span>, i);</span><br><span class="line">			pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	signal(SIGINT,kill_childprocess);  <span class="comment">//当捕捉到中断信号后</span></span><br><span class="line">	<span class="comment">//父进程用系统调用Kill()向两个子进 程发出信号</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//等到两个子进程结束</span></span><br><span class="line">	waitpid(child_1, &amp;rtn, <span class="number">0</span>);</span><br><span class="line">	waitpid(child_2, &amp;rtn, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭管道</span></span><br><span class="line">	close(pipefd[<span class="number">0</span>]);</span><br><span class="line">	close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Parent Process is killed!\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划习题</title>
    <url>/2019/12/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="矩阵链乘法"><a href="#矩阵链乘法" class="headerlink" title="矩阵链乘法"></a>矩阵链乘法</h2><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p>本节给出了一个关于矩阵链相乘问题的动态规划算法。给定一个n个矩阵<a1,a2,……,an>的矩阵链，要计算它们的乘积A1*A2*A3……An。矩阵乘法满足结合律，所以通过加括号，一个矩阵链的乘法可以按照不同的顺序进行。例如，4个矩阵的矩阵链，共有5种加括号的方式：<a id="more"></a></a1,a2,……,an></p>
<div align="center">
<img width="200" src="/2019/12/02/动态规划习题/矩阵乘法0.png">
</div>

<p>加括号的方式对矩阵链乘法的时间代价产生巨大的影响。我们先来分析两个矩阵相乘的时间代价。下面的代码给出了两个矩阵相乘的标准算法。</p>
<div align="center">
<img width="300" src="/2019/12/02/动态规划习题/矩阵乘法1.png">
</div>

<p>两个矩阵A和B只有相容，即A的列数等于B的行数时，才能相乘。如果A是 p×q 矩阵，B是 q×r 矩阵，那么乘积C是 p×r 矩阵。分析上面的代码，矩阵乘法的时间代价主要由最内层循环的标量乘法的次数决定，一共需要做 pqr 次标量乘法。</p>
<p>现在考虑计算矩阵链乘法的时间代价。以3个矩阵为例， 它们的维数分别为10×100、100×5和5×50，有以下两种加括号的方式：</p>
<ul>
<li>按((A1·A2)·A3)的顺序计算<br> 先(A1·A2)计算，需要做10×100×5 = 5000次标量乘法，得到的结果矩阵的维度为10×5；再与A3相乘，需要做10×5×50 = 2500次标量乘法。总共需要做5000+2500 = 7500次标量乘法。</li>
<li>按(A1·(A2·A3))的顺序计算<br> 先计算(A2·A3)，需要做100×5×50 = 25000次标量乘法，得到的结果矩阵的维度为100×50;A1再与(A2·A3的结果相乘，需要做10×100×50 = 50000次标量乘法。总共需要做25000+50000 = 75000次标量乘法。</li>
</ul>
<p>可以看到，第(2)种计算顺序的时间代价是第(1)种顺序的10倍。</p>
<p><strong>矩阵链乘法问题</strong>:给定一个n个矩阵的矩阵链，矩阵Ai的维度为 (1 ≤ i ≤ n)，求一个最优的加括号方案，使得计算矩阵A1*A2*A3……An乘积所需要的标量乘法次数最少。<br>矩阵A1的维度为p0*p1，A2的维度为p1*p2，… …。以此类推，矩阵An的维度为pn-1*pn。矩阵的维度可以构成一个n+1元的数组{p0,p1……,pn}。以这个数组作为算法输入。<br>令P(n)表示n个矩阵的矩阵链的所有加括号的方案的数量。当n =1时，由于只有一个矩阵，所以P(1) = 1。当n ≥ 2时，可以先将矩阵链划分为两个子链<a1,……ak>和<ak+1……an>，其中k = 1,2,…, n-1，对两个子链加括号又是规模更小的子问题，因此矩阵链乘法问题满足最优子结构。由此，我们可以得到</ak+1……an></a1,……ak></p>
<div align="center">
<img width="300" src="/2019/12/02/动态规划习题/矩阵乘法2.png">
</div>

<p>易知道,P(n) = O(2^n)。显然，遍历所有加括号的方案，并不是一个明智的选择，这样的算法至少有一个指数增长的时间复杂度。现在我们用动态规划方法来求解这个问题。</p>
<p>用m[i, j]表示计算矩阵链<a1,a2,……,an>所需标量乘法次数的最小值。如果i = j，矩阵链中只有一个矩阵，显然m[i, j] = 0。对于i &lt; j 的情况，上文提到，可以先将矩阵链划分为两个子链<ai,ai+1,……,ak>和<ak+1,ak+2,……,aj>。左子链的乘积是一个矩阵，右子链的乘积是一个矩阵。假设两个子链的最优解已知，它们分别为m[i, k]和m[k+1, j ]，并且可以知道两个子链的结果相乘需要次pi-1·pk·pj 标量乘法。于是，可以得到m[i,j] = m[i,k] + m[k + 1,j] + pi-1·pk·pj。<br>矩阵链的划分点k可以取值i, i+1,…, j-1，我们需要检查k的所有可能的取值情况，并从中找到最优解。于是有</ak+1,ak+2,……,aj></ai,ai+1,……,ak></a1,a2,……,an></p>
<div align="center">
<img width="400" src="/2019/12/02/动态规划习题/矩阵乘法3.png">
</div>

<p>我们已经确立了问题的最优子结构，现在要合理安排子问题的求解顺序。子问题的规模是用相应的子链中矩阵的个数来度量的。我们要计算m[i, j]，只依赖于更短的子链的求解结果。因此，我们可以按照长度递增的顺序求解矩阵链乘法问题。另外，还需要在求解过程中记录下每个子问题的最优解的分割点位置k。以下是代码。</p>
<div align="center">
<img width="500" src="/2019/12/02/动态规划习题/矩阵乘法4.png">
</div>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>T15.2-1 对矩阵链<5,10,3,12,5,50,6>，求矩阵链最有括号化方案</5,10,3,12,5,50,6></p>
<!--more-->
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> String [] A = &#123;<span class="string">"A0"</span>,<span class="string">"A1"</span>,<span class="string">"A2"</span>,<span class="string">"A3"</span>,<span class="string">"A4"</span>,<span class="string">"A5"</span>,<span class="string">"A6"</span>&#125;;<span class="comment">//六个矩阵A1～A6 但是伪码是从下标1开始计算，因此在首位填充0</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> [] p = &#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">50</span>,<span class="number">6</span>&#125;;  <span class="comment">//矩阵维数为p[i-1]*p[i]</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>[][] matrix_chain_order(<span class="keyword">int</span> [] p,<span class="keyword">int</span> [][] matrix,<span class="keyword">int</span> [][] brakcet,<span class="keyword">int</span> n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			matrix[i][i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n- len + <span class="number">1</span>;i++)&#123;</span><br><span class="line">				<span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">				matrix[i][j] = Integer.MAX_VALUE; <span class="comment">//设置为无穷大</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j - <span class="number">1</span>; k++)&#123;</span><br><span class="line">					<span class="keyword">int</span> mulTimes = matrix[i][k] + matrix[k + <span class="number">1</span>][j] + p[i - <span class="number">1</span>]*p[k]*p[j];</span><br><span class="line">					<span class="keyword">if</span>(mulTimes &lt; matrix[i][j])&#123;</span><br><span class="line">						matrix[i][j] = mulTimes;</span><br><span class="line">						brakcet[i][j] = k;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n;j++)</span><br><span class="line">				System.out.print(matrix[i][j] + <span class="string">" "</span>);</span><br><span class="line">			System.out.println(<span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;= n;j++)</span><br><span class="line">				System.out.print(brakcet[i][j] + <span class="string">" "</span>);</span><br><span class="line">			System.out.println(<span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> brakcet;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_optimal_parens</span><span class="params">(<span class="keyword">int</span> [][] brakcet,<span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(i == j)</span><br><span class="line">			System.out.print(A[i]);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.print(<span class="string">"("</span>);</span><br><span class="line">			print_optimal_parens(brakcet,i,brakcet[i][j]);</span><br><span class="line">			print_optimal_parens(brakcet,brakcet[i][j] + <span class="number">1</span>,j);</span><br><span class="line">			System.out.print(<span class="string">")"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> [][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>][<span class="number">7</span>];</span><br><span class="line">		<span class="keyword">int</span> [][] brakcet = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>][<span class="number">7</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">6</span> ; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;= <span class="number">6</span> ;j++)</span><br><span class="line">				matrix[i][j] = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">		brakcet = matrix_chain_order(p,matrix,brakcet,<span class="number">6</span>);</span><br><span class="line">		print_optimal_parens(brakcet,<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：</p>
<blockquote>
<p>0 150 330 405 1655 2010<br>2147483647 0 360 330 2430 1950<br>2147483647 2147483647 0 180 930 1770<br>2147483647 2147483647 2147483647 0 3000 1860<br>2147483647 2147483647 2147483647 2147483647 0 1500<br>2147483647 2147483647 2147483647 2147483647 2147483647 0 </p>
<p>0 1 2 2 4 2<br>0 0 2 2 2 2<br>0 0 0 3 4 4<br>0 0 0 0 4 4<br>0 0 0 0 0 5<br>0 0 0 0 0 0  </p>
<p>((A1A2)((A3A4)(A5A6)))</p>
</blockquote>
<h2 id="最优二叉搜索树"><a href="#最优二叉搜索树" class="headerlink" title="最优二叉搜索树"></a>最优二叉搜索树</h2><h3 id="笔记-1"><a href="#笔记-1" class="headerlink" title="笔记"></a>笔记</h3><p>二叉搜索树满足如下性质：假设x xx是二叉搜索树中的一个结点。如果l ll是x xx的左子树的一个结点，那么l.key≤x.key l.key ≤ x.keyl.key≤x.key。如果r rr是x xx的右子树的一个结点，那么r.key≥x.key r.key ≥ x.keyr.key≥x.key。<br>也就是说，二叉搜索树中的任意一个结点，它的左子树中的所有结点都不大于它，它的右子树中的所有结点都不小于它。下图给出了一个二叉搜索树的例子。</p>
<div align="center">
<img width="200" src="/2019/12/02/动态规划习题/二叉搜索树0.png">
</div>

<p><strong>最优二叉搜索树</strong>(Optimal Binary Search Tree)问题描述如下。给定一个n nn个不同关键字的已排序的序列K[1..n]=<k1,k2,…,kn>（因此k1<k2<…<kn），我们希望用这些关键字构造一个二叉搜索树。对每个关键字ki,都有一个概率pi表示其搜索概率。搜索过程中有可能遇到不在k[1..n]中的元素，因此我们还有n+1个元素的“伪关键字”序列d[0..n]=<d0,d1,d2,…,dn> ，表示搜索过程中可能遇到的所有不在K[1..n] K[1..n]K[1..n]中的元素。d0表示所有小于k1的元素；dn 表示所有大于kn 的元素；对i=1,2,…,n−1 i = 1, 2, …, n-1，di表示所有在ki到ki+1之间的元素。对每个伪关键字di，也有一个概率qi 表示对应的搜索概率。在二叉搜索树中，伪关键字di 必然出现在叶结点上，关键字ki 必然出现在非叶结点上。每次搜索要么成功（找到某个关键字ki），要么失败（找到某个伪关键字di）。关键字和伪关键字的概率满足：</k2<…<kn），我们希望用这些关键字构造一个二叉搜索树。对每个关键字ki,都有一个概率pi表示其搜索概率。搜索过程中有可能遇到不在k[1..n]中的元素，因此我们还有n+1个元素的“伪关键字”序列d[0..n]=<d0,d1,d2,…,dn></k1,k2,…,kn></p>
<div align="center">
<img width="150" src="/2019/12/02/动态规划习题/二叉搜索树1.png">
</div>

<p>假定一次搜索的代价等于访问的结点数，也就是此次搜索找到的结点在二叉搜索树中的深度再加1 11。给定一棵二叉搜索树T TT，我们可以确定进行一次搜索的期望代价。</p>
<div align="center">
<img width="350" src="/2019/12/02/动态规划习题/二叉搜索树2.png">
</div>

<p>其中depthT表示一个结点在二叉搜索树T中的深度。</p>
<p>对于一组给定的关键字和伪关键字，以及它们对应的概率，我们希望构造一棵期望搜索代价最小的二叉搜索树，这称之为最优二叉搜索树。现在我们用动态规划方法来求解最优二叉搜索树问题。</p>
<p>首先我们描述最优二叉搜索树问题的最优子结构：假设由关键字子序列K[i..j]=<ki,…,kj> 和伪关键字子序列D[i−1..j]=<di−1,…,dj> 构成的一棵最优二叉搜索树以kr(i≤r≤j)为根结点。那么它的左子树由子序列K[i..r−1]和D[i−1..r−1]构成，这颗左子树显然也是一棵最优二叉搜索树。同样，它的右子树由子序列K[r+1..j]和D[r..j]构成，这颗右子树显然也是一棵最优二叉搜索树。<br>这里有一个值得注意的细节—空子树。如果包含子序列K[i..j]的最优二叉搜索树以ki为根结点。根据最优子结构性质，它的左子树包含子序列K[i..i−1]，这个子序列不包含任何关键字。但请注意，左子树仍然包含一个伪关键字di−1。同理，如果选择kj为根结点，那么右子树也不包含任何关键字，而只包含一个伪关键字dj。<br>用e[i,j] 表示包含关键字子序列K[i..j]=<ki,…,kj> 的最优二叉搜索树的期望搜索代价。我们最终希望计算出e[1,n]。<br>对于j=i−1的情况，由于子树只包含伪关键字di−1 ，所以期望搜索代价为e[i,i−1]=qi−1。<br>当j≥i时，我们要遍历以ki,ki+1,…,kj作为根结点的情况，然后从中选择期望搜索代价最小的情况作为子问题的最优解。假设选择kr(i≤r≤j)作为根结点，那么子序列K[i..r−1]构成的最优二叉搜索树作为左子树，左子树的期望搜索代价为e[i,r−1]；子序列K[r+1..j]构成的最优二叉搜索树作为右子树，右子树的期望搜索代价为e[r+1,j]。<br>当一棵子树链接到一个根结点上时，子树中所有结点的深度都增加了1 ，那么这棵子树的期望搜索代价的增加值为它的所有结点的概率之和。对于一棵包含子序列K[i..j]的子树，所有结点的概率之和为</ki,…,kj></di−1,…,dj></ki,…,kj></p>
<div align="center">
<img width="200" src="/2019/12/02/动态规划习题/二叉搜索树3.png">
</div>
接上文，若kr(i≤r≤j)作为包含关键字子序列K[i..j]的最优二叉搜索树的根结点，可以得到如下公式
e[i,j]=pr+(e[i,r−1]+w[i,r−1])+(e[r+1,j]+w[r+1,j]) 
由于w[i,j]=w[i,r−1]+pr+w[r+1,j]，所以上式可重写为
e[i,j]=e[i,r−1]+e[r+1,j]+w[i,j]
我们要遍历以ki,ki+1,…,kj作为根结点的情况，并选择期望搜索代价最小的情况作为子问题的最优解。于是我们可以得到下面的递归式。
<div align="center">
<img width="350" src="/2019/12/02/动态规划习题/二叉搜索树4.png">
</div>

<p>e[i,j]给出了最优二叉搜索树子问题的期望搜索代价。我们还需要记录最优二叉搜索树子问题的根结点，用root[i,j]来记录。<br>根据上文给出的递归式，我们可以采用自下而上的动态规划方法来求解最优二叉搜索树问题。下面给出了伪代码。</p>
<div align="center">
<img width="500" src="/2019/12/02/动态规划习题/二叉搜索树5.png">
</div>

<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>T15.5-2:若7 77个关键字的概率如下所示，求其最优二叉搜索树的结构和代价。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">i</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">pi</td>
<td style="text-align:center"></td>
<td style="text-align:center">0.04</td>
<td style="text-align:center">0.06</td>
<td style="text-align:center">0.08</td>
<td style="text-align:center">0.02</td>
<td style="text-align:center">0.10</td>
<td style="text-align:center">0.12</td>
<td style="text-align:center">0.14 </td>
</tr>
<tr>
<td style="text-align:center">qi</td>
<td style="text-align:center">0.06</td>
<td style="text-align:center">0.06</td>
<td style="text-align:center">0.06</td>
<td style="text-align:center">0.06</td>
<td style="text-align:center">0.05</td>
<td style="text-align:center">0.05</td>
<td style="text-align:center">0.05</td>
<td style="text-align:center">0.05 </td>
</tr>
</tbody>
</table>
</div>
<p>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">optimal_bst</span><span class="params">(<span class="keyword">double</span> [] p,<span class="keyword">double</span> [] q,<span class="keyword">double</span> [][] e,<span class="keyword">double</span> [][] w, <span class="keyword">int</span> [][] root)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = p.length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			e[i][i-<span class="number">1</span>] = q[i-<span class="number">1</span>];</span><br><span class="line">			w[i][i-<span class="number">1</span>] = q[i-<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=n;l++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">1</span>;start&lt;=n-l+<span class="number">1</span>;start++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> end = start + l -<span class="number">1</span>;</span><br><span class="line">				w[start][end] = w[start][end-<span class="number">1</span>] + p[end] + q[end];</span><br><span class="line">				e[start][end] = <span class="number">1000</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> r = start;r&lt;=end;r++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">double</span> t = e[start][r-<span class="number">1</span>] + e[r+<span class="number">1</span>][end]  + w[start][end];</span><br><span class="line">					<span class="keyword">if</span>(t&lt;e[start][end])</span><br><span class="line">					&#123;</span><br><span class="line">						e[start][end] = t;</span><br><span class="line">						root[start][end] = r;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> [][] root,<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(p == -<span class="number">1</span>)</span><br><span class="line">			System.out.println(<span class="string">"k"</span> + root[a][b] + <span class="string">"为根"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> r = root[a][b];</span><br><span class="line">		<span class="comment">//左子树</span></span><br><span class="line">		<span class="keyword">if</span>(r == a)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">"d"</span> + (a - <span class="number">1</span>) + <span class="string">"是k"</span> + a + <span class="string">"d的左孩子"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">"k"</span> + root[a][r-<span class="number">1</span>] + <span class="string">"是k"</span> + r +<span class="string">"的左孩子"</span>);</span><br><span class="line">			print(root,a,r-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//右子树</span></span><br><span class="line">		<span class="keyword">if</span>(r == b)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">"d"</span> + b + <span class="string">"是k"</span> + b + <span class="string">"的右孩子"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">"k"</span> + root[r+<span class="number">1</span>][b] + <span class="string">"是k"</span> + r + <span class="string">"的右孩子"</span>);</span><br><span class="line">			print(root,r+<span class="number">1</span>,b,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> [] p1 = &#123;<span class="number">0</span>,<span class="number">0.04</span>,<span class="number">0.06</span>,<span class="number">0.08</span>,<span class="number">0.02</span>,<span class="number">0.10</span>,<span class="number">0.12</span>,<span class="number">0.14</span>&#125;;</span><br><span class="line">		<span class="keyword">double</span> [] q1 = &#123;<span class="number">0.06</span>,<span class="number">0.06</span>,<span class="number">0.06</span>,<span class="number">0.06</span>,<span class="number">0.05</span>,<span class="number">0.05</span>,<span class="number">0.05</span>,<span class="number">0.05</span>&#125;;</span><br><span class="line">		<span class="keyword">double</span> [] p = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">8</span>];</span><br><span class="line">		<span class="keyword">double</span> [] q = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">8</span>];</span><br><span class="line">		System.arraycopy(p1,<span class="number">0</span>,p,<span class="number">0</span>,<span class="number">8</span>);</span><br><span class="line">		System.arraycopy(q1,<span class="number">0</span>,q,<span class="number">0</span>,<span class="number">8</span>);</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">double</span> [][] e = <span class="keyword">new</span> <span class="keyword">double</span>[n+<span class="number">2</span>][n+<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">int</span> [][] root = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">		<span class="keyword">double</span> [][] w = <span class="keyword">new</span> <span class="keyword">double</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">		optimal_bst(p,q,e,w,root);</span><br><span class="line">		print(root,<span class="number">1</span>,n,-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：</p>
<blockquote>
<p>k5为根<br>k2是k5的左孩子<br>k1是k2的左孩子<br>d0是k1d的左孩子<br>d1是k1的右孩子<br>k3是k2的右孩子<br>d2是k3d的左孩子<br>k4是k3的右孩子<br>d3是k4d的左孩子<br>d4是k4的右孩子<br>k7是k5的右孩子<br>k6是k7的左孩子<br>d5是k6d的左孩子<br>d6是k6的右孩子<br>d7是k7的右孩子</p>
</blockquote>
<p>最优二叉搜索树如下所示。期望搜索代价为3.12。</p>
<div align="center">
<img width="400" src="/2019/12/02/动态规划习题/二叉搜索树6.png">
</div>

<div align="center">
<img width="500" src="/2019/12/02/动态规划习题/二叉搜索树7.png">
</div>

<div align="center">
<img width="500" src="/2019/12/02/动态规划习题/二叉搜索树8.png">
</div>

<div align="center">
<img width="500" src="/2019/12/02/动态规划习题/二叉搜索树9.png">
</div>

<p>图片及部分内容来自<a href="https://blog.csdn.net/yangtzhou" target="_blank" rel="noopener">yangtzhou</a>。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法导论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU缓存机制</title>
    <url>/2019/12/01/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>来自Leetcode第146题LRU缓存机制</p>
<blockquote>
<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<a id="more"></a><br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>
<p>示例:</p>
<p>LRUCache cache = new LRUCache( 2 /<em> 缓存容量 </em>/ );</p>
<p>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // 返回  1<br>cache.put(3, 3);    // 该操作会使得密钥 2 作废<br>cache.get(2);       // 返回 -1 (未找到)<br>cache.put(4, 4);    // 该操作会使得密钥 1 作废<br>cache.get(1);       // 返回 -1 (未找到)<br>cache.get(3);       // 返回  3<br>cache.get(4);       // 返回  4</p>
</blockquote>
<hr>
<h3 id="硬件实现的4路组相联-LRU算法"><a href="#硬件实现的4路组相联-LRU算法" class="headerlink" title="硬件实现的4路组相联 + LRU算法"></a>硬件实现的4路组相联 + LRU算法</h3><p>参考组原实验mooc</p>
<p>输入输出引脚图：</p>
<div align="center">
<img width="800" src="/2019/12/01/LRU缓存机制/3.jpg">
</div>

<p>8个cache槽分2组4路：</p>
<div align="center">
<img width="800" src="/2019/12/01/LRU缓存机制/1.jpg">
</div>

<p>替换算法LRU：</p>
<div align="center">
<img width="800" src="/2019/12/01/LRU缓存机制/2.jpg">
</div>

<p>测试图：</p>
<div align="center">
<img width="800" src="/2019/12/01/LRU缓存机制/4.jpg">
</div>

<h3 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h3><h4 id="哈希链表实现"><a href="#哈希链表实现" class="headerlink" title="哈希链表实现"></a>哈希链表实现</h4><p>来源<a href="https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/" target="_blank" rel="noopener">题解</a></p>
<p>LRU 算法实际上是让你设计数据结构：首先要接收一个 capacity 参数作为缓存的最大容量，然后实现两个 API，一个是 put(key, val) 方法存入键值对，另一个是 get(key) 方法获取 key 对应的 val，如果 key 不存在则返回 -1。</p>
<p>注意哦，get 和 put 方法必须都是 O(1)O(1) 的时间复杂度，我们举个具体例子来看看 LRU 算法怎么工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 缓存容量为 2 */</span></span><br><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 你可以把 cache 理解成一个队列</span></span><br><span class="line"><span class="comment">// 假设左边是队头，右边是队尾</span></span><br><span class="line"><span class="comment">// 最近使用的排在队头，久未使用的排在队尾</span></span><br><span class="line"><span class="comment">// 圆括号表示键值对 (key, val)</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// cache = [(1, 1)]</span></span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// cache = [(2, 2), (1, 1)]</span></span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回 1</span></span><br><span class="line"><span class="comment">// cache = [(1, 1), (2, 2)]</span></span><br><span class="line"><span class="comment">// 解释：因为最近访问了键 1，所以提前至队头</span></span><br><span class="line"><span class="comment">// 返回键 1 对应的值 1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// cache = [(3, 3), (1, 1)]</span></span><br><span class="line"><span class="comment">// 解释：缓存容量已满，需要删除内容空出位置</span></span><br><span class="line"><span class="comment">// 优先删除久未使用的数据，也就是队尾的数据</span></span><br><span class="line"><span class="comment">// 然后把新的数据插入队头</span></span><br><span class="line">cache.get(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line"><span class="comment">// cache = [(3, 3), (1, 1)]</span></span><br><span class="line"><span class="comment">// 解释：cache 中不存在键为 2 的数据</span></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">4</span>);    </span><br><span class="line"><span class="comment">// cache = [(1, 4), (3, 3)]</span></span><br><span class="line"><span class="comment">// 解释：键 1 已存在，把原始值 1 覆盖为 4</span></span><br><span class="line"><span class="comment">// 不要忘了也要将键值对提前到队头</span></span><br></pre></td></tr></table></figure>
<p>从流程里可以看到，不需要设计计数器来实现对每次未命中的cache槽做计数+1，淘汰时将数值最大的淘汰。<br>在put时将元素放到了队头，每次get都会将元素提前，我们要做的就是把队尾元素替换掉。</p>
<p>LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：</p>
<div align="center">
<img width="300" src="/2019/12/01/LRU缓存机制/5.jpg">
</div>

<p>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key,val;</span><br><span class="line">    <span class="keyword">public</span> Node next,prior;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head,tail ; <span class="comment">//头尾结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">//链表元素数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);  <span class="comment">//头尾虚结点</span></span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prior = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再头部添加结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        x.next = head.next;</span><br><span class="line">        x.prior = head;</span><br><span class="line">        head.next.prior = x;</span><br><span class="line">        head.next = x;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除链表中的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        x.prior.next = x.next;</span><br><span class="line">        x.next.prior = x.prior;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表中最后一个节点，并返回该节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前链表没有结点</span></span><br><span class="line">        <span class="keyword">if</span>(tail.prior == head)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node last = tail.prior;</span><br><span class="line">        remove(last);</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  HashMap&lt;Integer ,Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> DoubleList cache; <span class="comment">//双向链表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val = map.get(key).val;</span><br><span class="line">        <span class="comment">//利用put方法把数据提前</span></span><br><span class="line">        put(key,val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先把新节点 x 做出来</span></span><br><span class="line">        Node x = <span class="keyword">new</span> Node(key, val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 删除旧的节点，新的插到头部</span></span><br><span class="line">            cache.remove(map.get(key));</span><br><span class="line">            cache.addFirst(x);</span><br><span class="line">            <span class="comment">// 更新 map 中对应的数据</span></span><br><span class="line">            map.put(key, x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (capacity == cache.getSize()) &#123;</span><br><span class="line">                <span class="comment">// 删除链表最后一个数据</span></span><br><span class="line">                Node last = cache.removeLast();</span><br><span class="line">                map.remove(last.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 直接添加到头部</span></span><br><span class="line">            cache.addFirst(x);</span><br><span class="line">            map.put(key, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="有序字典"><a href="#有序字典" class="headerlink" title="有序字典"></a>有序字典</h4><p>来源<a href="https://leetcode-cn.com/problems/lru-cache/solution/lru-huan-cun-ji-zhi-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<p>利用了LinkedHashMap这样一种数据结构<br>在构造器里第三个参数accessOrder,设置为false表示不是访问顺序而是插入顺序存储的，这也是默认值，表示LinkedHashMap中存储的顺序是按照调用put方法插入的顺序进行排序的;true则是按照<strong>访问顺序</strong>，访问过后的元素会到链表的末尾。</p>
<p>0.75F表示负载因子<br>HashMap有一个初始容量大小，默认是16<br>static final int DEAFULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16<br>为了减少冲突概率，当HashMap的数组长度达到一个临界值就会触发扩容，把所有元素rehash再放回容器中，这是一个非常耗时的操作。<br>而这个临界值由负载因子和当前的容量大小来决定：<br>DEFAULT_INITIAL_CAPACITY<em>DEFAULT_LOAD_FACTOR<br>即默认情况下数组长度是16</em>0.75=12时，触发扩容操作。<br>所以使用hash容器时尽量预估自己的数据量来设置初始值。<br>在理想情况下，使用随机哈希吗，节点出现的频率在hash桶中遵循泊松分布，同时给出了桶中元素的个数和概率的对照表。<br>从上表可以看出当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为负载因子，每个碰撞位置的链表长度超过8个是几乎不可能的。<br>hash容器指定初始容量尽量为2的幂次方。<br>HashMap负载因子为0.75是空间和时间成本的一种折中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRUCache 对象会以如下语句构造和调用:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数据结构设计</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>设计</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>加油站</title>
    <url>/2019/11/30/%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
    <content><![CDATA[<p>来源Leetcode第134题加油站</p>
<blockquote>
<p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。<br>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。<br>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。<a id="more"></a></p>
<p>说明: </p>
<ul>
<li>如果题目有解，该答案即为唯一答案。</li>
<li>输入数组均为非空数组，且长度相同。</li>
<li>输入数组中的元素均为非负数。<br>示例 1:</li>
</ul>
<p>输入:<br>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]</p>
<p>输出: 3</p>
<p>解释:<br>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油<br>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油<br>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油<br>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油<br>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油<br>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>因此，3 可为起始索引。</p>
</blockquote>
<hr>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>这题其实和之前的53题<a href="https://yorxika.github.io/2019/11/05/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/">最大子序和是一样的</a></p>
<p>先考虑每个站点能剩多少油 那么就是 get[i] - cost[i]，因而能不能环形一圈就是判断所有的剩余的油加起来的值是否大于0<br>接下来找从哪出发能环绕一圈。如果当前结点的耗油量为负，或者总的耗油量为负，那么就考虑下一个位置作为起点。因为从题目我们可以知道如果题目有解，该答案即为唯一答案，因而如果在总剩余油量≥0的情况下，唯一解的每一步剩余油量都是≥0的，如果是等于0的话，就不会是唯一解了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">//位置</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rest = <span class="number">0</span>; <span class="comment">//剩余油量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; gas.length; i++)&#123;</span><br><span class="line">        rest += gas[i] - cost[i];</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sum += gas[i] - cost[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum = gas[i] - cost[i];</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rest&gt;= <span class="number">0</span>? pos : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双重循环"><a href="#双重循环" class="headerlink" title="双重循环"></a>双重循环</h4><p>最简单的无非就是求差后，对每一个元素从该位置开始进行遍历，当剩余油量小于0时continue，直到找到所求.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">//位置</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> [] rest  = <span class="keyword">new</span> <span class="keyword">int</span>[gas.length]; <span class="comment">//剩余油量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; gas.length; i++)&#123;</span><br><span class="line">        rest[i] += gas[i] - cost[i];</span><br><span class="line">        sum += rest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; gas.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rest[i] &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i ; j &lt; i + gas.length; j++)&#123;</span><br><span class="line">            sum += rest[j % gas.length];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>克隆图</title>
    <url>/2019/11/30/%E5%85%8B%E9%9A%86%E5%9B%BE/</url>
    <content><![CDATA[<p>来源Leetcode第133题克隆图</p>
<blockquote>
<p>给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值 val（Int） 和其邻居的列表（list[Node]）。<br><a id="more"></a></p>
<h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3></blockquote>
<p>class Node {<br>    public int val;<br>    public List<node> neighbors;</node></p>
<pre><code>public Node() {}

public Node(int _val,List&lt;Node&gt; _neighbors) {
    val = _val;
    neighbors = _neighbors;
}
</code></pre><p>};</p>
<h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>这题的本质就是对图的遍历，在遍历时怎么把图的邻居添加进去。</p>
<p>首先对图进行一个 BFS，把所有节点 new 出来，不处理 neighbors，并且把所有的节点存到 map 中。<br>然后再对图做一个 BFS，因为此时所有的节点已经创建了，只需要更新所有节点的 neighbors。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//队列用来判断是否遍历完所有结点</span></span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//map key值为原结点，val值为克隆结点</span></span><br><span class="line">    Node new_node = <span class="keyword">new</span> Node(node.val, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">    queue.offer(node);</span><br><span class="line">    <span class="comment">//头结点入队</span></span><br><span class="line">    map.put(node, new_node);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (Node n : cur.neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(n)) &#123;</span><br><span class="line">                <span class="comment">//不包含的结点加入到map里</span></span><br><span class="line">                queue.offer(n);</span><br><span class="line">                <span class="comment">//同把该结点入队</span></span><br><span class="line">                Node tmp = <span class="keyword">new</span> Node(n.val, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">                map.put(n, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(cur).neighbors.add(map.get(n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>同样利用一个map来存储原结点和克隆结点，接着对第一个结点进行深度优先搜索，出口为当所有结点都在map时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    HashMap&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;Node,Node&gt;();</span><br><span class="line">    node = dfs(node,map);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">dfs</span><span class="params">(Node node,HashMap&lt;Node,Node&gt; map)</span></span>&#123;</span><br><span class="line">   <span class="comment">//当所有结点都在map里时退出递归</span></span><br><span class="line">    Node aNode = <span class="keyword">new</span> Node(node.val,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    map.put(node,aNode);</span><br><span class="line">    <span class="keyword">for</span>(Node neighbours : node.neighbors)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(neighbours))</span><br><span class="line">            <span class="comment">//如果没有包含此结点，从此结点一直往下遍历</span></span><br><span class="line">            neighbours = dfs(neighbours,map);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果包含了此结点，返回其克隆结点</span></span><br><span class="line">            neighbours = map.get(neighbours);</span><br><span class="line">        aNode.neighbors.add(neighbours);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> aNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>图</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>排序链表</title>
    <url>/2019/11/30/%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>来自Leetcode第148题排序链表</p>
<blockquote>
<p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<p>示例 1:</p>
<p>输入: 4-&gt;2-&gt;1-&gt;3<br>输出: 1-&gt;2-&gt;3-&gt;4 <a id="more"></a></p>
</blockquote>
<hr>
<h4 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h4><p>将所有结点放入一个Hashset里，最后依次取出最小值，倒数第二个用例时超时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    Set&lt;ListNode&gt; list = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        list.add(p1);</span><br><span class="line">        <span class="comment">//System.out.print(p1);</span></span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//Iterator&lt;Map.Entry&lt;ListNode,Integer&gt;&gt;  it = list.entrySet().iterator();</span></span><br><span class="line">    <span class="keyword">while</span> (!list.isEmpty())&#123;</span><br><span class="line">        Iterator&lt;ListNode&gt;  it = list.iterator();</span><br><span class="line">        ListNode p2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> val = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            ListNode temp = it.next();</span><br><span class="line">            <span class="keyword">if</span>(temp.val &lt; val)&#123;</span><br><span class="line">                p2 = temp;</span><br><span class="line">                val = temp.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            newHead.val = p2.val;</span><br><span class="line">            k++;</span><br><span class="line">            p1 = newHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p1.next = p2;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        list.remove(p2);</span><br><span class="line">    &#125;</span><br><span class="line">    p1.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归归并排序"><a href="#递归归并排序" class="headerlink" title="递归归并排序"></a>递归归并排序</h4><p>来自<a href="https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/" target="_blank" rel="noopener">题解</a></p>
<blockquote>
<p>通过递归实现链表归并排序，有以下两个环节：</p>
<ul>
<li>分割 cut 环节： 找到当前链表中点，并从中点将链表断开（以便在下次递归 cut 时，链表片段拥有正确边界）；<ul>
<li>我们使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。<ul>
<li>找到中点 slow 后，执行 slow.next = None 将链表切断。</li>
<li>递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 tmp(因为链表是从 slow 切断的)。</li>
</ul>
</li>
<li>cut 递归终止条件： 当head.next == None时，说明只有一个节点了，直接返回此节点。</li>
</ul>
</li>
<li>合并 merge 环节： 将两个排序链表合并，转化为一个排序链表。<ul>
<li>双指针法合并，建立辅助ListNode h 作为头部。</li>
<li>设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。</li>
<li>返回辅助ListNode h 作为头部的下个节点 h.next。</li>
<li>时间复杂度 O(l + r)，l, r 分别代表两个链表长度。</li>
</ul>
</li>
<li>当题目输入的 head == None 时，直接返回None。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode fast = head.next,slow = head;</span><br><span class="line">    <span class="comment">//声明两个快慢指针</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode tmp = slow.next;</span><br><span class="line">    <span class="comment">//此时temp是中点后一个结点</span></span><br><span class="line">    <span class="comment">//若是偶数结点，tmp在中点偏右</span></span><br><span class="line">    <span class="comment">//奇数结点，tmp在中点后一个</span></span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//切割链表</span></span><br><span class="line">    ListNode left = sortList(head);</span><br><span class="line">    ListNode right = sortList(tmp);</span><br><span class="line">    <span class="comment">//递归分割左右链表</span></span><br><span class="line">    ListNode h = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//头结点作为合并链表的开始</span></span><br><span class="line">    ListNode res = h;</span><br><span class="line">    <span class="keyword">while</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//合并过程</span></span><br><span class="line">        <span class="keyword">if</span>(left.val &lt; right.val)&#123;</span><br><span class="line">            h.next = left;</span><br><span class="line">            left = left.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            h.next = right;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h.next;</span><br><span class="line">    &#125;</span><br><span class="line">    h.next = left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链表转为数组排序后在转回链表"><a href="#链表转为数组排序后在转回链表" class="headerlink" title="链表转为数组排序后在转回链表"></a>链表转为数组排序后在转回链表</h4><p>来自评论区，首先将链表转为数组，对数组做排序后在放回链表里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        list.add(p1.val);</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    p1 = head;</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">        head.val = it.next();</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
        <tag>归并</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀表达式求值</title>
    <url>/2019/11/29/%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<p>来源Leetcode第150题逆波兰表达式求值</p>
<blockquote>
<p>根据逆波兰表示法，求表达式的值。</p>
<p>有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br><a id="more"></a><br>说明：</p>
<p>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。<br>示例 1：</p>
<p>输入: [“2”, “1”, “+”, “3”, “<em>“]<br>输出: 9<br>解释: ((2 + 1) </em> 3) = 9</p>
</blockquote>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>老题目了，操作数压栈，运算符2个操作数出栈，运算后在压栈.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">"+"</span>)) &#123;</span><br><span class="line">            stack.push(stack.pop() + stack.pop());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">            stack.push(-stack.pop() + stack.pop());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">            stack.push(stack.pop() * stack.pop());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = stack.pop();</span><br><span class="line">            stack.push(stack.pop() / num1);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(Integer.parseInt(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>第十行</title>
    <url>/2019/11/28/%E7%AC%AC%E5%8D%81%E8%A1%8C/</url>
    <content><![CDATA[<p>来源Leetcode第195题第10行</p>
<blockquote>
<p>给定一个文本文件 file.txt，请只打印这个文件中的第十行。<a id="more"></a></p>
</blockquote>
<h3 id="三种解法"><a href="#三种解法" class="headerlink" title="三种解法"></a>三种解法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tail -n +10 file.txt | head -n 1</span><br><span class="line">sed -n <span class="string">'10p'</span> file.txt</span><br><span class="line">awk <span class="string">'NR==10 &#123;print $0&#125;'</span> file.txt</span><br></pre></td></tr></table></figure>
<h4 id="tail命令和head命令"><a href="#tail命令和head命令" class="headerlink" title="tail命令和head命令"></a>tail命令和head命令</h4><p>tail命令显示最后一组文件行。默认情况下，它显示文件的最后10行，但是也是使用命令行参数更改数字，使用tail —h查看命令行参数，截图如下：</p>
<div align="center">
<img width="600" src="https://img-blog.csdn.net/20161123103714273?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
</div>

<p>如果K前有+，则表示显示除开头K行外所有行</p>
<p>head命令显示开头的一组文件行。默认情况下，它显示文件的前10行。通过head —h命令查看参数截图：</p>
<div align="center">
<img width="600" src="https://img-blog.csdn.net/20161123103740312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
</div>

<h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p><strong>说明</strong>：<br>1.从文件中读取数据，StreamEDitor流（行）编辑器，逐行处理文本；<br>Sed 是一个脚本型的编译器，是非交互式的编辑器<br>2.模式空间（将一行数据加载到内存，进行处理），默认不编辑源文件，仅对模式空间中的数据处理，将处理的数据输出到屏幕</p>
<p>用法：<br>&nbsp;&nbsp;&nbsp;&nbsp;一般用法：<br>&nbsp;&nbsp;&nbsp;&nbsp;sed [-neri] ‘指令’ file…<br>&nbsp;&nbsp;&nbsp;&nbsp;sed -f scriptsfile file…<br>选项：<br>&nbsp;&nbsp;&nbsp;&nbsp;-n 安静模式，只有经过Sed处理的行才显示出来，其他不显示<br>&nbsp;&nbsp;&nbsp;&nbsp;-e 表示直接在命令行模式上进行Sed操作（默认选项）;<br>&nbsp;&nbsp;&nbsp;&nbsp;   进行多项编辑，即对输入行应用多条sed命令时使用<br>&nbsp;&nbsp;&nbsp;&nbsp;-f 将Sed的操作写在一个文件里，用的时候“-f filename”就可以按照内容进行Sed操作<br>&nbsp;&nbsp;&nbsp;&nbsp;-r 使Sed支持扩展正则表达式(预设支持基础正则表达式)<br>&nbsp;&nbsp;&nbsp;&nbsp;-i 直接修改读取的文件内容，而不是输出到终端<br>&nbsp;&nbsp;&nbsp;&nbsp;sed 编辑指令的格式如下 :<br>              [address1[,address2]]function[argument]<br>&nbsp;&nbsp;&nbsp;&nbsp;==addres (指定需要操作的行)==<br>&nbsp;&nbsp;&nbsp;&nbsp;1. n1,n2    例：1,100 表示1至100行<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n1行开始，n2行结束<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理n1行开始到n2行结束的数据<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$符号表示文件最后一行<br>&nbsp;&nbsp;&nbsp;&nbsp;2. /RegExp/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配正则表达式<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理正则表达式匹配的行的数据<br>&nbsp;&nbsp;&nbsp;&nbsp;3. /pattern1/,/pattern2/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pattern1匹配到为行开始<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pattern2匹配到为行结束<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理pattern1,到pattern2之间所有行数据<br>&nbsp;&nbsp;&nbsp;&nbsp;4. n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定第n行的<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理指定第n行的数据<br>&nbsp;&nbsp;&nbsp;&nbsp;5. n1,+n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n1 为行开始<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+n 开始行向后n行<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理行开始到向后n行的数据<br>&nbsp;&nbsp;&nbsp;&nbsp;==function(可对数据处理的动作(sed内定函数))==<br>&nbsp;&nbsp;&nbsp;&nbsp;d 删除符合条件的行<br>&nbsp;&nbsp;&nbsp;&nbsp;D 删除模板块的第一行<br>&nbsp;&nbsp;&nbsp;&nbsp;h 拷贝模板块的内容到内存中的缓冲区<br>&nbsp;&nbsp;&nbsp;&nbsp;H 追加模板块的内容到内存中的缓冲区<br>&nbsp;&nbsp;&nbsp;&nbsp;g 获得内存缓冲区的内容，并替代当前模板块中的文本<br>&nbsp;&nbsp;&nbsp;&nbsp;G 获得内存缓冲区的内容，并追加到当前模板块文本的后面<br>&nbsp;&nbsp;&nbsp;&nbsp;p 显示符合条件的行<br>&nbsp;&nbsp;&nbsp;&nbsp;P (大写) 打印模板块的第一行<br>&nbsp;&nbsp;&nbsp;&nbsp;q 退出Sed<br>&nbsp;&nbsp;&nbsp;&nbsp;l 列表不能打印字符的清单<br>&nbsp;&nbsp;&nbsp;&nbsp;n 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。<br>&nbsp;&nbsp;&nbsp;&nbsp;N 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码<br>&nbsp;&nbsp;&nbsp;&nbsp;a \”string” 在指定的行后面追加新行，内容为”string”<br>&nbsp;&nbsp;&nbsp;&nbsp;i \”string” 在指定的行前面插入新行，内容为”string”<br>&nbsp;&nbsp;&nbsp;&nbsp;c \”string” 将处理的数据行,取代内容为”string”<br>&nbsp;&nbsp;&nbsp;&nbsp;r file 将指定文件的内容天骄到符合条件的行后<br>&nbsp;&nbsp;&nbsp;&nbsp;w file 将指定范围内的内容另存至指定的文件中<br>&nbsp;&nbsp;&nbsp;&nbsp;W file （大写）写并追加模板块的第一行到file末尾。<br>&nbsp;&nbsp;&nbsp;&nbsp;s/pattern/string/修饰符 查找并替换，默认只替换每行第一次被模式匹配到的字符串<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修饰符：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g 表示行内全面替换。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p 表示打印行。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w 表示把行写入一个文件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x 表示互换模板块中的文本和缓冲区中的文本。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y 表示把一个字符翻译为另外的字符（但是不用于正则表达式）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\1 子串匹配标记<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp; 已匹配字符串标记<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i 忽略大小写<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特别说明: s///,s###,s@@@都可以，当所使用的分割符号与内容中显示<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;的相同时，需使用转义字符转义 ,\1,\2：成组匹配，\1表示匹配第一<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;个‘(’，\2表示匹配第二个‘(’<br>&nbsp;&nbsp;&nbsp;&nbsp;b lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾<br>&nbsp;&nbsp;&nbsp;&nbsp;t label if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾<br>&nbsp;&nbsp;&nbsp;&nbsp;T label 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾<br>&nbsp;&nbsp;&nbsp;&nbsp;! 表示后面的命令对所有没有被选定的行发生作用。<br>&nbsp;&nbsp;&nbsp;&nbsp;= 打印当前行号码。<br>&nbsp;&nbsp;&nbsp;&nbsp;# 把注释扩展到下一个换行符以前</p>
<h4 id="awk操作"><a href="#awk操作" class="headerlink" title="awk操作"></a>awk操作</h4><p>awk [-F|-f] ‘BEGIN{}{command1; command2} END{}’ file<br>[-F|-f]   大参数，-F指定分隔符，-f调用脚本<br>‘  ‘          引用代码块<br>//           匹配代码块，可以是字符串或正则表达式<br>{}           命令代码块，包含一条或多条命令<br>；          多条命令使用分号分隔</p>
<hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F : <span class="string">'&#123;print $1&#125;'</span> passwd  <span class="comment">###指定分隔符为： ，输出第一列</span></span><br><span class="line">awk -F : <span class="string">'BEGIN&#123;print '</span>hello<span class="string">'&#125;&#123;print $2&#125;'</span> passwd   <span class="comment">###指定分隔符为：，在输出前加上hello，输出第二列【hello在第一行】</span></span><br><span class="line">awk -F : <span class="string">'BEGIN&#123;n=1&#125;&#123;print $2,n&#125;'</span> passwd   <span class="comment">###指定分隔符为：，在输出的第二列每一行后面都输出n的值1</span></span><br><span class="line">awk -F : <span class="string">'BEGIN&#123;n=1&#125;&#123;print $2,n++&#125;'</span> passwd   <span class="comment">###n的值每一行会加1</span></span><br><span class="line">awk -F : <span class="string">'BEGIN&#123;n=1&#125;&#123;print n++，$1&#125;'</span> passwd   <span class="comment">###相当于序号</span></span><br><span class="line">awk -F : <span class="string">'BEGIN&#123;n=1&#125;&#123;print n++,$1&#125;END&#123;print "over"&#125;'</span> passwd <span class="comment">###指定分隔符为：，在第一列每一行开头加上n的值，n每行+1，在最后一行输出over</span></span><br><span class="line">awk -F : <span class="string">'BEGIN&#123;n=1&#125;&#123;print n++,$1&#125;END&#123;print NR&#125;'</span> passwd  <span class="comment">###指定分隔符为：，在第一列每一行开头加上n的值，n每行+1，最后一行输出有多少行</span></span><br><span class="line">awk -F : <span class="string">'BEGIN&#123;n=1&#125;&#123;print n++,$1&#125;END&#123;print NF&#125;'</span> passwd  <span class="comment">###指定分隔符为：，在第一列每一行开头加上n的值，n每行+1，最后一行输出有多少列</span></span><br><span class="line">awk <span class="string">'/bash/&#123;print&#125;'</span> passwd  <span class="comment">###输出包含bash的内容</span></span><br><span class="line">awk -F : <span class="string">'/bash/&#123;print $1&#125;'</span> passwd  <span class="comment">###输出包含bash的第一列</span></span><br><span class="line">awk -F : <span class="string">'NR==3&#123;print $1&#125;'</span> passwd <span class="comment">###输出第三行第一列</span></span><br><span class="line">awk -F : <span class="string">'NR&gt;=4&amp;&amp;NR&lt;=6&#123;print&#125;'</span> passwd <span class="comment">###输出4-6行</span></span><br><span class="line">awk -F : <span class="string">'NR==4||NR==6&#123;PRINT&#125;'</span> passwd  <span class="comment">###输出第四行和第六行</span></span><br><span class="line">awk <span class="string">'BEGIN&#123;a=34;print a+12&#125;'</span>   <span class="comment">###得到a的值46</span></span><br><span class="line">awk <span class="string">'/^[^a-d]/&#123;print&#125;'</span> passwd  <span class="comment">###输出除了以a-d开头的</span></span><br><span class="line">awk <span class="string">'/^r|bash$/&#123;print&#125;'</span> passwd  <span class="comment">###输出以r开头，或许以bash结尾的</span></span><br><span class="line">awk <span class="string">'/^r/&amp;&amp;/bash$/&#123;print&#125;'</span> passwd  <span class="comment">###并且</span></span><br><span class="line">awk -F : <span class="string">'$6~/bin$/&#123;print&#125;'</span> passwd <span class="comment">###以：为分隔符，输出第六列以bin结尾的</span></span><br><span class="line">awk -F : <span class="string">'$6!~/\&lt;bin$/&#123;print&#125;'</span> passwd  <span class="comment">###输出第六列不是以bin结尾且bin前面没有内容的【非贪婪模式】</span></span><br><span class="line">awk -F : <span class="string">'BEGIN=&#123;N=0&#125;$6!~/^\/home/&amp;&amp;$7~/bash$/&#123;print $1;N++&#125;END&#123;print N&#125;'</span> /etc/passwd <span class="comment">###并统计个数</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>杨辉三角II</title>
    <url>/2019/11/28/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/</url>
    <content><![CDATA[<p>来源Leetcode第119题杨辉三角II</p>
<blockquote>
<p>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。<br>示例:</p>
<p>输入: 3<br>输出: [1,3,3,1]<br>进阶：</p>
<p>你可以优化你的算法到 O(k) 空间复杂度吗？<a id="more"></a></p>
</blockquote>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>思路同上一题杨辉三角，按序求出第0行到第N行，返回第N行即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rowIndex;i++)&#123;</span><br><span class="line">        List&lt;Integer&gt; subList=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">2</span>) &#123;<span class="comment">//前两行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                subList.add(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(subList);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            subList.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">                Integer twoSum=list.get(i-<span class="number">1</span>).get(j-<span class="number">1</span>)+list.get(i-<span class="number">1</span>).get(j);</span><br><span class="line">                subList.add(twoSum);</span><br><span class="line">            &#125;</span><br><span class="line">            subList.add(<span class="number">1</span>);</span><br><span class="line">            list.add(subList);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> list.get(rowIndex - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h4><p>只用当前行，从当前行构造出下一行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">    List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    cur.add(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = cur.get(j);</span><br><span class="line">            cur.set(j, pre + cur.get(j));</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h4><p>杨辉三角第n行第k列的值为：<br>C(n,k) =n!/(k!(n−k)!)=(n∗(n−1)∗(n−2)∗…(n−k+1))/k!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> n = rowIndex;</span><br><span class="line">    <span class="keyword">long</span> pre = <span class="number">1</span>;</span><br><span class="line">    ans.add(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; k &lt;= (n + <span class="number">1</span>) /<span class="number">2</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">long</span> cur = pre * (n - k + <span class="number">1</span>) / k;</span><br><span class="line">        ans.add((<span class="keyword">int</span>) cur);</span><br><span class="line">        pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;k &lt;=n; k++)&#123;</span><br><span class="line">        ans.add(ans.get(n - k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h4><p>评论区看到的2333</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">pre33</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Integer[][] list = <span class="keyword">new</span> Integer[][]&#123;</span><br><span class="line">        &#123;<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">7</span>,<span class="number">21</span>,<span class="number">35</span>,<span class="number">35</span>,<span class="number">21</span>,<span class="number">7</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">28</span>,<span class="number">56</span>,<span class="number">70</span>,<span class="number">56</span>,<span class="number">28</span>,<span class="number">8</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">36</span>,<span class="number">84</span>,<span class="number">126</span>,<span class="number">126</span>,<span class="number">84</span>,<span class="number">36</span>,<span class="number">9</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">45</span>,<span class="number">120</span>,<span class="number">210</span>,<span class="number">252</span>,<span class="number">210</span>,<span class="number">120</span>,<span class="number">45</span>,<span class="number">10</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">11</span>,<span class="number">55</span>,<span class="number">165</span>,<span class="number">330</span>,<span class="number">462</span>,<span class="number">462</span>,<span class="number">330</span>,<span class="number">165</span>,<span class="number">55</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">12</span>,<span class="number">66</span>,<span class="number">220</span>,<span class="number">495</span>,<span class="number">792</span>,<span class="number">924</span>,<span class="number">792</span>,<span class="number">495</span>,<span class="number">220</span>,<span class="number">66</span>,<span class="number">12</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">13</span>,<span class="number">78</span>,<span class="number">286</span>,<span class="number">715</span>,<span class="number">1287</span>,<span class="number">1716</span>,<span class="number">1716</span>,<span class="number">1287</span>,<span class="number">715</span>,<span class="number">286</span>,<span class="number">78</span>,<span class="number">13</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">14</span>,<span class="number">91</span>,<span class="number">364</span>,<span class="number">1001</span>,<span class="number">2002</span>,<span class="number">3003</span>,<span class="number">3432</span>,<span class="number">3003</span>,<span class="number">2002</span>,<span class="number">1001</span>,<span class="number">364</span>,<span class="number">91</span>,<span class="number">14</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">15</span>,<span class="number">105</span>,<span class="number">455</span>,<span class="number">1365</span>,<span class="number">3003</span>,<span class="number">5005</span>,<span class="number">6435</span>,<span class="number">6435</span>,<span class="number">5005</span>,<span class="number">3003</span>,<span class="number">1365</span>,<span class="number">455</span>,<span class="number">105</span>,<span class="number">15</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">16</span>,<span class="number">120</span>,<span class="number">560</span>,<span class="number">1820</span>,<span class="number">4368</span>,<span class="number">8008</span>,<span class="number">11440</span>,<span class="number">12870</span>,<span class="number">11440</span>,<span class="number">8008</span>,<span class="number">4368</span>,<span class="number">1820</span>,<span class="number">560</span>,<span class="number">120</span>,<span class="number">16</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">17</span>,<span class="number">136</span>,<span class="number">680</span>,<span class="number">2380</span>,<span class="number">6188</span>,<span class="number">12376</span>,<span class="number">19448</span>,<span class="number">24310</span>,<span class="number">24310</span>,<span class="number">19448</span>,<span class="number">12376</span>,<span class="number">6188</span>,<span class="number">2380</span>,<span class="number">680</span>,<span class="number">136</span>,<span class="number">17</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">18</span>,<span class="number">153</span>,<span class="number">816</span>,<span class="number">3060</span>,<span class="number">8568</span>,<span class="number">18564</span>,<span class="number">31824</span>,<span class="number">43758</span>,<span class="number">48620</span>,<span class="number">43758</span>,<span class="number">31824</span>,<span class="number">18564</span>,<span class="number">8568</span>,<span class="number">3060</span>,<span class="number">816</span>,<span class="number">153</span>,<span class="number">18</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">19</span>,<span class="number">171</span>,<span class="number">969</span>,<span class="number">3876</span>,<span class="number">11628</span>,<span class="number">27132</span>,<span class="number">50388</span>,<span class="number">75582</span>,<span class="number">92378</span>,<span class="number">92378</span>,<span class="number">75582</span>,<span class="number">50388</span>,<span class="number">27132</span>,<span class="number">11628</span>,<span class="number">3876</span>,<span class="number">969</span>,<span class="number">171</span>,<span class="number">19</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">20</span>,<span class="number">190</span>,<span class="number">1140</span>,<span class="number">4845</span>,<span class="number">15504</span>,<span class="number">38760</span>,<span class="number">77520</span>,<span class="number">125970</span>,<span class="number">167960</span>,<span class="number">184756</span>,<span class="number">167960</span>,<span class="number">125970</span>,<span class="number">77520</span>,<span class="number">38760</span>,<span class="number">15504</span>,<span class="number">4845</span>,<span class="number">1140</span>,<span class="number">190</span>,<span class="number">20</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">21</span>,<span class="number">210</span>,<span class="number">1330</span>,<span class="number">5985</span>,<span class="number">20349</span>,<span class="number">54264</span>,<span class="number">116280</span>,<span class="number">203490</span>,<span class="number">293930</span>,<span class="number">352716</span>,<span class="number">352716</span>,<span class="number">293930</span>,<span class="number">203490</span>,<span class="number">116280</span>,<span class="number">54264</span>,<span class="number">20349</span>,<span class="number">5985</span>,<span class="number">1330</span>,<span class="number">210</span>,<span class="number">21</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">22</span>,<span class="number">231</span>,<span class="number">1540</span>,<span class="number">7315</span>,<span class="number">26334</span>,<span class="number">74613</span>,<span class="number">170544</span>,<span class="number">319770</span>,<span class="number">497420</span>,<span class="number">646646</span>,<span class="number">705432</span>,<span class="number">646646</span>,<span class="number">497420</span>,<span class="number">319770</span>,<span class="number">170544</span>,<span class="number">74613</span>,<span class="number">26334</span>,<span class="number">7315</span>,<span class="number">1540</span>,<span class="number">231</span>,<span class="number">22</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">253</span>,<span class="number">1771</span>,<span class="number">8855</span>,<span class="number">33649</span>,<span class="number">100947</span>,<span class="number">245157</span>,<span class="number">490314</span>,<span class="number">817190</span>,<span class="number">1144066</span>,<span class="number">1352078</span>,<span class="number">1352078</span>,<span class="number">1144066</span>,<span class="number">817190</span>,<span class="number">490314</span>,<span class="number">245157</span>,<span class="number">100947</span>,<span class="number">33649</span>,<span class="number">8855</span>,<span class="number">1771</span>,<span class="number">253</span>,<span class="number">23</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">24</span>,<span class="number">276</span>,<span class="number">2024</span>,<span class="number">10626</span>,<span class="number">42504</span>,<span class="number">134596</span>,<span class="number">346104</span>,<span class="number">735471</span>,<span class="number">1307504</span>,<span class="number">1961256</span>,<span class="number">2496144</span>,<span class="number">2704156</span>,<span class="number">2496144</span>,<span class="number">1961256</span>,<span class="number">1307504</span>,<span class="number">735471</span>,<span class="number">346104</span>,<span class="number">134596</span>,<span class="number">42504</span>,<span class="number">10626</span>,<span class="number">2024</span>,<span class="number">276</span>,<span class="number">24</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">25</span>,<span class="number">300</span>,<span class="number">2300</span>,<span class="number">12650</span>,<span class="number">53130</span>,<span class="number">177100</span>,<span class="number">480700</span>,<span class="number">1081575</span>,<span class="number">2042975</span>,<span class="number">3268760</span>,<span class="number">4457400</span>,<span class="number">5200300</span>,<span class="number">5200300</span>,<span class="number">4457400</span>,<span class="number">3268760</span>,<span class="number">2042975</span>,<span class="number">1081575</span>,<span class="number">480700</span>,<span class="number">177100</span>,<span class="number">53130</span>,<span class="number">12650</span>,<span class="number">2300</span>,<span class="number">300</span>,<span class="number">25</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">26</span>,<span class="number">325</span>,<span class="number">2600</span>,<span class="number">14950</span>,<span class="number">65780</span>,<span class="number">230230</span>,<span class="number">657800</span>,<span class="number">1562275</span>,<span class="number">3124550</span>,<span class="number">5311735</span>,<span class="number">7726160</span>,<span class="number">9657700</span>,<span class="number">10400600</span>,<span class="number">9657700</span>,<span class="number">7726160</span>,<span class="number">5311735</span>,<span class="number">3124550</span>,<span class="number">1562275</span>,<span class="number">657800</span>,<span class="number">230230</span>,<span class="number">65780</span>,<span class="number">14950</span>,<span class="number">2600</span>,<span class="number">325</span>,<span class="number">26</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">27</span>,<span class="number">351</span>,<span class="number">2925</span>,<span class="number">17550</span>,<span class="number">80730</span>,<span class="number">296010</span>,<span class="number">888030</span>,<span class="number">2220075</span>,<span class="number">4686825</span>,<span class="number">8436285</span>,<span class="number">13037895</span>,<span class="number">17383860</span>,<span class="number">20058300</span>,<span class="number">20058300</span>,<span class="number">17383860</span>,<span class="number">13037895</span>,<span class="number">8436285</span>,<span class="number">4686825</span>,<span class="number">2220075</span>,<span class="number">888030</span>,<span class="number">296010</span>,<span class="number">80730</span>,<span class="number">17550</span>,<span class="number">2925</span>,<span class="number">351</span>,<span class="number">27</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">28</span>,<span class="number">378</span>,<span class="number">3276</span>,<span class="number">20475</span>,<span class="number">98280</span>,<span class="number">376740</span>,<span class="number">1184040</span>,<span class="number">3108105</span>,<span class="number">6906900</span>,<span class="number">13123110</span>,<span class="number">21474180</span>,<span class="number">30421755</span>,<span class="number">37442160</span>,<span class="number">40116600</span>,<span class="number">37442160</span>,<span class="number">30421755</span>,<span class="number">21474180</span>,<span class="number">13123110</span>,<span class="number">6906900</span>,<span class="number">3108105</span>,<span class="number">1184040</span>,<span class="number">376740</span>,<span class="number">98280</span>,<span class="number">20475</span>,<span class="number">3276</span>,<span class="number">378</span>,<span class="number">28</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">29</span>,<span class="number">406</span>,<span class="number">3654</span>,<span class="number">23751</span>,<span class="number">118755</span>,<span class="number">475020</span>,<span class="number">1560780</span>,<span class="number">4292145</span>,<span class="number">10015005</span>,<span class="number">20030010</span>,<span class="number">34597290</span>,<span class="number">51895935</span>,<span class="number">67863915</span>,<span class="number">77558760</span>,<span class="number">77558760</span>,<span class="number">67863915</span>,<span class="number">51895935</span>,<span class="number">34597290</span>,<span class="number">20030010</span>,<span class="number">10015005</span>,<span class="number">4292145</span>,<span class="number">1560780</span>,<span class="number">475020</span>,<span class="number">118755</span>,<span class="number">23751</span>,<span class="number">3654</span>,<span class="number">406</span>,<span class="number">29</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">30</span>,<span class="number">435</span>,<span class="number">4060</span>,<span class="number">27405</span>,<span class="number">142506</span>,<span class="number">593775</span>,<span class="number">2035800</span>,<span class="number">5852925</span>,<span class="number">14307150</span>,<span class="number">30045015</span>,<span class="number">54627300</span>,<span class="number">86493225</span>,<span class="number">119759850</span>,<span class="number">145422675</span>,<span class="number">155117520</span>,<span class="number">145422675</span>,<span class="number">119759850</span>,<span class="number">86493225</span>,<span class="number">54627300</span>,<span class="number">30045015</span>,<span class="number">14307150</span>,<span class="number">5852925</span>,<span class="number">2035800</span>,<span class="number">593775</span>,<span class="number">142506</span>,<span class="number">27405</span>,<span class="number">4060</span>,<span class="number">435</span>,<span class="number">30</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">31</span>,<span class="number">465</span>,<span class="number">4495</span>,<span class="number">31465</span>,<span class="number">169911</span>,<span class="number">736281</span>,<span class="number">2629575</span>,<span class="number">7888725</span>,<span class="number">20160075</span>,<span class="number">44352165</span>,<span class="number">84672315</span>,<span class="number">141120525</span>,<span class="number">206253075</span>,<span class="number">265182525</span>,<span class="number">300540195</span>,<span class="number">300540195</span>,<span class="number">265182525</span>,<span class="number">206253075</span>,<span class="number">141120525</span>,<span class="number">84672315</span>,<span class="number">44352165</span>,<span class="number">20160075</span>,<span class="number">7888725</span>,<span class="number">2629575</span>,<span class="number">736281</span>,<span class="number">169911</span>,<span class="number">31465</span>,<span class="number">4495</span>,<span class="number">465</span>,<span class="number">31</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">32</span>,<span class="number">496</span>,<span class="number">4960</span>,<span class="number">35960</span>,<span class="number">201376</span>,<span class="number">906192</span>,<span class="number">3365856</span>,<span class="number">10518300</span>,<span class="number">28048800</span>,<span class="number">64512240</span>,<span class="number">129024480</span>,<span class="number">225792840</span>,<span class="number">347373600</span>,<span class="number">471435600</span>,<span class="number">565722720</span>,<span class="number">601080390</span>,<span class="number">565722720</span>,<span class="number">471435600</span>,<span class="number">347373600</span>,<span class="number">225792840</span>,<span class="number">129024480</span>,<span class="number">64512240</span>,<span class="number">28048800</span>,<span class="number">10518300</span>,<span class="number">3365856</span>,<span class="number">906192</span>,<span class="number">201376</span>,<span class="number">35960</span>,<span class="number">4960</span>,<span class="number">496</span>,<span class="number">32</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">33</span>,<span class="number">528</span>,<span class="number">5456</span>,<span class="number">40920</span>,<span class="number">237336</span>,<span class="number">1107568</span>,<span class="number">4272048</span>,<span class="number">13884156</span>,<span class="number">38567100</span>,<span class="number">92561040</span>,<span class="number">193536720</span>,<span class="number">354817320</span>,<span class="number">573166440</span>,<span class="number">818809200</span>,<span class="number">1037158320</span>,<span class="number">1166803110</span>,<span class="number">1166803110</span>,<span class="number">1037158320</span>,<span class="number">818809200</span>,<span class="number">573166440</span>,<span class="number">354817320</span>,<span class="number">193536720</span>,<span class="number">92561040</span>,<span class="number">38567100</span>,<span class="number">13884156</span>,<span class="number">4272048</span>,<span class="number">1107568</span>,<span class="number">237336</span>,<span class="number">40920</span>,<span class="number">5456</span>,<span class="number">528</span>,<span class="number">33</span>,<span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(pre33.list[rowIndex]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>SOCKET编程</title>
    <url>/2019/11/28/SOCKET%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="Socket套接字介绍"><a href="#Socket套接字介绍" class="headerlink" title="Socket套接字介绍"></a>Socket套接字介绍</h3><p>网络应用程序是由通信进程对组成，每对互相通信的应用程序进程互相发送报文，他们之间的通信必须通过下面的网络来进行。为了将应用程序和底层的网络通信协议屏蔽开来，采用套接字（Socket）这样一个抽象概念来作为应用程序和底层网络之间的应用程序编程接口（API）。<a id="more"></a><br>因为网络应用程序是进程之间的通信，为了唯一的标识通信对等方的通信进程，套接字必须包含2种信息：(1) 通信对等方的网络地址。(2) 通信对等方的进程号，通常叫端口号。<br>就像Unix操作系统下有一套实现TCP/IP网络通信协议的开发接口：BSD Sockets一样，在Windows操作系统下，也提供了一套网络通信协议的开发接口，称为Windows Sockets或简称Winsock。<br>Winsock 是通过动态链接库的方式提供给软件开发者，而且从Windows 95以后已经被集成到了Windows操作系统中。<br>Winsock主要经历了2个版本：Winsock 1.1和Winsock 2.0。Winsock 2.0是Winsock 1.1的扩展，它向下完全兼容。<br>Winsock同时包括了16位和32位的编程接口，16位的Windows Socket 2应用程序使用的动态链接库是WINSOCK.DLL，而32位的Windows Socket应用程序使用WSOCK32.DLL（Winsock 1.1版）和WS2_32.DLL（Winsock 2.0版）。另外，使用Winsock API时要包含头文件winsock.h（Winsock 1.1版）或winsock2.h（Winsock 2.0版）。</p>
<h3 id="Socket套接字编程原理"><a href="#Socket套接字编程原理" class="headerlink" title="Socket套接字编程原理"></a>Socket套接字编程原理</h3><h4 id="Socket的2种类型"><a href="#Socket的2种类型" class="headerlink" title="Socket的2种类型"></a>Socket的2种类型</h4><p>Socket是一个抽象概念，代表了通信双方的端点（Endpoint），通信双方通过Socket发送或接收数据。<br>在Winsock里，用数据类型SOCKET作为Windows Sockets对象的句柄，就好像一个窗口的句柄HWND、一个打开的文件的文件指针一样。下面我们会看到，在Winsock API的许多函数里，都会用到SOCKET类型的参数。<br>Socket有2种类型：</p>
<ul>
<li>流类型（Stream Sockets）。<br>流式套接字提供了一种可靠的、面向连接的数据传输方法，使用传输控制协议TCP。</li>
<li>数据报类型（Datagram Sockets）。<br>数据报套接字提供了一种不可靠的、非连接的数据包传输方式，使用用户数据报协议UDP。</li>
</ul>
<h4 id="Socket-I-O的2种模式"><a href="#Socket-I-O的2种模式" class="headerlink" title="Socket I/O的2种模式"></a>Socket I/O的2种模式</h4><p>一个SOCKET句柄可以看成代表了一个I/O设备。在Windows Sockets里，有2种I/O模式：</p>
<ul>
<li>阻塞式I/O（blocking I/O）<br>在阻塞方式下，收发数据的函数在调用后一直要到传送完毕或者出错才能完成，在阻塞期间，除了等待网络操作的完成不能进行任何操作。阻塞式I/O是一个Winsock API函数的缺省行为。</li>
<li>非阻塞式I/O（non-blocking I/O）<br>对于非阻塞方式，Winsock API函数被调用后立即返回；当网络操作完成后，由Winsock给应用程序发送消息（Socket Notifications）通知操作完成，这时应用程序可以根据发送的消息中的参数对消息做出响应。Winsock提供了2种异步接受数据的方法：一种方法是使用BSD类型的函数select（），另外一种方法是使用Winsock提供的专用函数WSAAsyncSelect（）。</li>
</ul>
<h4 id="使用数据报套接字"><a href="#使用数据报套接字" class="headerlink" title="使用数据报套接字"></a>使用数据报套接字</h4><p>首先，客户机和服务器都要创建一个数据报套接字。接着，服务器调用bind（）函数给套接字分配一个公认的端口。一旦服务器将公认的端口分配给了套接字，客户机和服务器都能使用sendto（）和revfron（）来传递数据报。通信完毕调用closesocket（）来关闭套接字。流程如图2.1所示：</p>
<div align="center">
<img width="600" src="/2019/11/28/SOCKET编程/1.jpg">
</div>

<h4 id="使用流式套接字"><a href="#使用流式套接字" class="headerlink" title="使用流式套接字"></a>使用流式套接字</h4><p>由于流式套接字使用的是基于连接的协议，所以你必须首先建立连接，而后才能从数据流中读出数据，而不是从一个数据报或一个记录中读出数据，其流程如图2.2所示。</p>
<div align="center">
<img width="600" src="/2019/11/28/SOCKET编程/2.jpg">
</div>

<h3 id="套接字部分库函数列表"><a href="#套接字部分库函数列表" class="headerlink" title="套接字部分库函数列表"></a>套接字部分库函数列表</h3><h4 id="WSAStartup（）"><a href="#WSAStartup（）" class="headerlink" title="WSAStartup（）"></a>WSAStartup（）</h4><p><strong>函数原型</strong><br>int WSAStartup (WORD wVersionRequested,  LPWSADATA  lpWSAData  );</p>
<p><strong>参数</strong><br>wVersionRequested<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 表示欲使用的Windows Sockets API版本；这是个WORD类型的整数，高字节定义的是次版本号，低字节定义的是主版本号。<br>lpWSAData<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 指向WSAData资料的指针。WSAData是结构数据类型，描述了关于Windows Sockecs底层实现的相关信息。<br>&nbsp;&nbsp;&nbsp;&nbsp;<br><strong>返回值</strong><br>函数执行成功返回0，失败则返回如下错误代码：<br>&nbsp;&nbsp;&nbsp;&nbsp;WSASYSNOTREADY：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 底层网络子系统没有准备好。<br>&nbsp;&nbsp;&nbsp;&nbsp;WSAVERNOTSUPPORTED：Winsock版本信息号不支持。WSAEINPROGRESS：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 阻塞式Winsock1.1存在于进程中。<br>&nbsp;&nbsp;&nbsp;&nbsp;WSAEPROCLIM：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 已经达到Winsock使用量的上限。<br>&nbsp;&nbsp;&nbsp;&nbsp;WSAEFAULT：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lpWSAData不是一个有效的指针。<br>&nbsp;&nbsp;&nbsp;&nbsp;<br><strong>函数功能</strong><br>这个函数是应用程序应该第一个调用的Winsock API函数，以完成一系列初始化的工作。</p>
<p><strong>相关数据结构</strong><br>WSADATA的定义如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;typedef struct WSAData {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WORD&nbsp;&nbsp;&nbsp;&nbsp;wVersion;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WORD &nbsp;&nbsp;&nbsp;&nbsp;wHighVersion;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;szDescription[WSADESCRIPTION_LEN+1];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char &nbsp;&nbsp;&nbsp;&nbsp;szSystemStatus[WSASYS_STATUS_LEN+1];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iMaxSockets;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iMaxUdpDg;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char FAR <em> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lpVendorInfo;<br>} WSADATA, FAR </em> LPWSADATA;<br>其中，各结构成员的含义为:<br>wVersion<br>&nbsp;&nbsp;&nbsp;&nbsp;应用程序应该使用的Winsock版本号。<br>wHighVersion<br>&nbsp;&nbsp;&nbsp;&nbsp;DLL所支持的最高版本号。通常应该等于wVersion。<br>szDescription<br>&nbsp;&nbsp;&nbsp;&nbsp;以0结尾的ASCII字符串，关于Winsock底层实现的描述信息。<br>szSystemStatus<br>&nbsp;&nbsp;&nbsp;&nbsp;以0结尾的ASCII字符串，关于Winsock底层状态或者配置信息。<br>iMaxSockets<br>&nbsp;&nbsp;&nbsp;&nbsp;一个进程最多可使用的套接字数，仅用于Winsock1.1，Winsock 2.0应该忽略该成员。<br>iMaxUdpDg<br>&nbsp;&nbsp;&nbsp;&nbsp;最大的UDP报文大小，仅用于Winsock1.1，Winsock 2.0应该忽略该成员。对于Winsock 2.0，应该使用getsockopt函数取得SO_MAX_MSG_SIZE。<br>lpVendorInfo<br>&nbsp;&nbsp;&nbsp;&nbsp;Winsock开发厂商信息，仅用于Winsock1.1，Winsock 2.0应该忽略该成员。对于Winsock 2.0，应该使用getsockopt函数取得PVD_CONFIG。</p>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock.h&gt;</span></span></span><br><span class="line"><span class="comment">//对于Winsock 2, include &lt;winsock2.h&gt;</span></span><br><span class="line"></span><br><span class="line">WSADATA  wsaData;</span><br><span class="line"><span class="keyword">int</span> nRc = WSAStartup(<span class="number">0x0101</span>, &amp; wsaData);		</span><br><span class="line"><span class="keyword">if</span>(nRc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//Winsock初始化错误</span></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(wsaData.wVersion != <span class="number">0x0101</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//版本支持不够</span></span><br><span class="line"><span class="comment">//报告错误给用户，清除Winsock，返回</span></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WSACleanup();</span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="socket（）"><a href="#socket（）" class="headerlink" title="socket（）"></a>socket（）</h4><p><strong>函数原型</strong><br>SOCKET socket(int af, int type,    int protocol);</p>
<p><strong>参数</strong><br>af<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 指定地址族（address family），一般填AF_INET（使用Internet地址）。<br>type<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 指定SOCKET的类型：SOCK_STREAM（流类型），SOCK_DGRAM（数据报类型）。<br>protocol<br>&nbsp;&nbsp;&nbsp;&nbsp;[in]    指定af参数指定的地址族所使用的具体一个协议。建议设为0，那么它就会根据地址格式和SOCKET类型，自动为你选择一个合适的协议。另外2个常用的值为：IPPROTO_UDP和IPPROTO_TCP。<br><strong>返回值</strong><br>函数执行成功返回一个新的SOCKET，失败则返回INVALID_SOCKET。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>所有的通信在建立之前都要创建一个SOCKET。</p>
<p>示例代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="comment">//创建数据报socket</span></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SCOKET udpSock = socket(AF_INET, </span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<span class="comment">//创建流socket</span></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SCOKET tcpSock = socket(AF_INET, </span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SOCK_STREAM, IPPROTO_TCP);</span><br></pre></td></tr></table></figure></p>
<h4 id="bind（）"><a href="#bind（）" class="headerlink" title="bind（）"></a>bind（）</h4><p><strong>函数原型</strong><br>int bind(SOCKET s, const struct sockaddr FAR* name, int namelen);</p>
<p><strong>参数</strong><br>s<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 一个需要绑定的SOCKET，例如用socket函数创建的SOCKET。<br>name<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 指向描述通信对象地址信息的结构体sockaddr的指针。在该结构体中可以指定地址族（一般为 AF_INET）、主机的地址和端口。通常把主机地址指定为INADDR_ANY（一个主机可能有多个网卡）。<br>namelen<br>&nbsp;&nbsp;&nbsp;&nbsp;[in]    name指针指向的结构体的长度。<br><strong>返回值</strong><br>函数执行成功返回0，失败则返回SOCKET_ERROR。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>成功地创建了一个SOCKET后，用bind函数将SOCKET和主机地址绑定。</p>
<p><strong>相关数据结构</strong><br>struct sockaddr {<br>&nbsp;&nbsp;&nbsp;&nbsp;u_short         sa_family;<br>&nbsp;&nbsp;&nbsp;&nbsp;char         sa_data[14];<br>};<br>sa_family<br>地址族，比如AF_INET，2个字节大小。<br>sa_data<br>用来存放地址和端口，14个字节大小。<br>sockaddr结构是一个通用的结构（因为Winsock支持的协议族不只是TCP/IP）。对TCP/IP协议，用如下结构来定义地址和端口。<br>struct sockaddr_in {<br>&nbsp;&nbsp;&nbsp;&nbsp;short             sin_family;<br>&nbsp;&nbsp;&nbsp;&nbsp;u_short            sin_port;<br>&nbsp;&nbsp;&nbsp;&nbsp;struct  in_addr    sin_addr;<br>&nbsp;&nbsp;&nbsp;&nbsp;char             sin_zero[8];<br>};<br>sin_family<br>&nbsp;&nbsp;&nbsp;&nbsp;地址族，设为AF_INET。<br>sin_port<br>&nbsp;&nbsp;&nbsp;&nbsp;端口号。如果端口号为0，Winsock会自动为应用程序分配一个值在1024-5000间的一个端口号，所以客户端一般把sin_port设为0。<br>sin_addr<br>&nbsp;&nbsp;&nbsp;&nbsp;为in_addr结构类型，用来指定IP地址。通常把主机地址指定为INADDR_ANY（一个主机可能有多个网卡）。结构in_addr下面介绍。<br>sin_zero<br>&nbsp;&nbsp;&nbsp;&nbsp;8字节的数组，值全为0。这个8个字节用来填充结构sockaddr_in，使其大小等于结构sockaddr（16字节）。<br>结构in_addr用来指定IP地址，其定义为：<br>struct in_addr {<br>&nbsp;union {<br>&nbsp;&nbsp;&nbsp;&nbsp;struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;<br>&nbsp;&nbsp;&nbsp;&nbsp;struct { u_short s_w1,s_w2; } S_un_w;<br>&nbsp;&nbsp;&nbsp;&nbsp; u_long S_addr;<br>&nbsp;} S_un;<br>};<br>对于IP地址10.14.25.90，sockaddr_in结构中的sin_addr可以这样赋值：<br>sin_addr. S_un .S_un_b. s_b1 = 10;<br>sin_addr. S_un .S_un_b. s_b2 = 14;<br>sin_addr. S_un .S_un_b. s_b3 = 25;<br>sin_addr. S_un .S_un_b. s_b4 = 90;<br>或者<br>sin_addr. S_un . S_un_w. s_w1 = (14&lt;&lt;8)|10;<br>sin_addr. S_un . S_un_w. s_w2 = (90&lt;&lt;8)|25;<br>或者<br>sin_addr. S_un . S_addr = (90&lt;&lt;24)|(25&lt;&lt;16)|(14&lt;&lt;8)|10;<br>或者<br>sin_addr. S_un . S_addr = inet_addr(“10.14.25.90”);<br>这里的inet_addr函数可以将字符串形式的IP地址转换为unsigned long形式的值。</p>
<p>示例代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SOCKET sServSock;</span><br><span class="line">sockaddr_in addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建socket</span></span><br><span class="line">sServSock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line"><span class="comment">//htons和htonl函数把主机字节顺序转换为网络字节顺序，分别用于//短整型和长整型数据</span></span><br><span class="line">addr.sin_port = htons(<span class="number">5050</span>);	</span><br><span class="line">addr.sin_addr.S_un.S_addr = htonl(INADDR_ANY); </span><br><span class="line"></span><br><span class="line"><span class="comment">// LPSOCKADDR类型转换是必须的</span></span><br><span class="line"><span class="keyword">int</span> nRc = bind(sServSock, (LPSOCKADDR)&amp;addr, <span class="keyword">sizeof</span>(addr) );</span><br></pre></td></tr></table></figure></p>
<h4 id="listen（）"><a href="#listen（）" class="headerlink" title="listen（）"></a>listen（）</h4><p><strong>函数原型</strong><br>int listen (SOCKET s,  int backlog);</p>
<p><strong>参数</strong><br>s<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 一个已经绑定但未连接的SOCKET。<br>backlog<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 等待连接的队列的长度，可取SOMAXCONN。如果某个客户程序要求连接的时候，服务器已经与其他客户程序连接，则后来的连接请求会放在等待队列中，等待服务器空闲时再与之连接。当等待队列达到最大长度（backlog指定的值）时，再来的连接请求都将被拒绝。<br><strong>返回值</strong><br>函数执行成功返回0，失败则返回SOCKET_ERROR。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>对于服务器的程序，当申请到SOCKET,并将通信对象指定为INADDR_ANY之后，就应该等待一个客户机的程序来要求连接，listen函数就是把一个SOCKET设置为这个状态。</p>
<h4 id="accept（）"><a href="#accept（）" class="headerlink" title="accept（）"></a>accept（）</h4><p><strong>函数原型</strong><br>SOCKET accept (SOCKET s, struct sockaddr FAR* addr,<br>int FAR* addrlen );</p>
<p><strong>参数</strong><br>s<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 一个已经处于listen状态的SOCKET。<br>addr<br>&nbsp;&nbsp;&nbsp;&nbsp;[out] 指向sockaddr结构体的指针，里面包含了客户端的地址和端口。<br>addrlen<br>&nbsp;&nbsp;&nbsp;&nbsp;[out] int型指针，指向的内容为addr指针指向的结构体的长度。<br><strong>返回值</strong><br>如果函数执行成功，会建立并返回一个新的SOCKET来与对方通信，新建的SOCKET与原来的SOCKET（函数的第一个参数s）有相同的特性，包括端口号。原来的SOCKET继续等待其他的连接请求。而新生成的SOCKET才是与客户端通信的实际SOCKET。所以一般将参数中的SOCKET称作“监听”SOCKET，它只负责接受连接，不负责通话；而对于函数返回的SOCKET，把它称作“会话”SOCKET，它负责与客户端通话。<br>如果失败则返回INVALID_SOCKET。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>accept函数从等待连接的队列中取第一个连接请求，并且创建一个新的SOCKET来负责与客户端会话。</p>
<p>示例代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SOCKET sServSock;	<span class="comment">//服务器监听socket</span></span><br><span class="line">sockaddr_in addr;</span><br><span class="line"><span class="keyword">int</span> nSockErr;</span><br><span class="line"><span class="keyword">int</span> nNumConns = <span class="number">0</span>;	<span class="comment">//当前请求连接数</span></span><br><span class="line">SOCKET sConns[<span class="number">5</span>];	<span class="comment">//会话SOCKET数组</span></span><br><span class="line">sockaddr ConnAddrs[<span class="number">5</span>];<span class="comment">//请求连接的客户端地址</span></span><br><span class="line"><span class="keyword">int</span> nAddrLen;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务器监听socket</span></span><br><span class="line">sServSock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">5050</span>);</span><br><span class="line">addr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( bind(sServSock,(LPSOCKADDR)&amp;addr,<span class="keyword">sizeof</span>(addr)) == </span><br><span class="line">			SOCKET_ERROR )</span><br><span class="line">&#123;</span><br><span class="line">nSockErr = WSAGetLastError();</span><br><span class="line"><span class="comment">//绑定出错处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//监听客户端请求连接</span></span><br><span class="line"><span class="keyword">if</span>( listen(sServSock, <span class="number">2</span>)  ==  SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">nSockErr = WSAGetLastError();</span><br><span class="line"><span class="comment">//出错处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( nNumConns &lt; <span class="number">5</span>)&#123;</span><br><span class="line"><span class="comment">//每当收到客户端连接请求，创建新的会话SOCKET，保存在/	//sConns数组中</span></span><br><span class="line"><span class="comment">//客户端地址保存在ConnAddrs数组中</span></span><br><span class="line">sConns[nNumConns] = accept(sServSock, </span><br><span class="line">ConnAddrs[nNumConns], &amp;nAddrLen);</span><br><span class="line"><span class="keyword">if</span>(sConns[nNumConns] == INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line">	nSockErr = WSAGetLastError();</span><br><span class="line">	<span class="comment">//创建会话SOCKET出错处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//创建会话SOCKET成功，启动新的线程与客户端会话</span></span><br><span class="line">	StartNewHandlerThread(sConns[nNumConns]);</span><br><span class="line">	<span class="comment">//当前请求连接数+1</span></span><br><span class="line">	nNumConns ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="connect（）"><a href="#connect（）" class="headerlink" title="connect（）"></a>connect（）</h4><p><strong>函数原型</strong><br>int connect (SOCKET s, const struct sockaddr FAR* name,<br> int  namelen );</p>
<p><strong>参数</strong><br>s<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 一个未连接SOCKET，一般是由socket函数建立的。<br>name<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 同bind函数。<br>namelen<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 同bind函数。<br><strong>返回值</strong><br>函数执行成功返回0，失败则返回SOCKET_ERROR。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>向对方主动提出连接请求。</p>
<h4 id="send（）"><a href="#send（）" class="headerlink" title="send（）"></a>send（）</h4><p><strong>函数原型</strong><br>int send (SOCKET s, char <em> buf, int len ,int flags);<br>【参数】<br>s<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 一个已经连接的SOCKET。<br>buf<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 指向要传输的数据的缓冲区的指针。<br>len<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] buf的长度。<br>flags<br>&nbsp;&nbsp;&nbsp;&nbsp;[in]指定函数调用的方式。一般取0。<br><strong>返回值</strong><br>函数执行成功返回发送的字节数（可能小于len），失败则返回SOCKET_ERROR。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><em>*函数功能</em></em><br>通过已经连接的SOCKET发送数据。</p>
<h4 id="recv（）"><a href="#recv（）" class="headerlink" title="recv（）"></a>recv（）</h4><p><strong>函数原型</strong><br>int recv (SOCKET s, char * buf, int len ,int flags);</p>
<p><strong>参数</strong><br>s<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 一个已经连接的SOCKET。<br>buf<br>&nbsp;&nbsp;&nbsp;&nbsp;[out] 指向接收数据的缓冲区的指针。<br>len<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] buf的长度。<br>flags<br>&nbsp;&nbsp;&nbsp;&nbsp;[in]指定函数调用的方式。一般取0。<br><strong>返回值</strong><br>函数执行成功返回接收到数据的字节数。如果失败则返回SOCKET_ERROR。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>通过已经连接的SOCKET接收数据。当读到的数据字节少于规定接受的数目（len）时，就把数据全部接收，并返回实际接收到的字节数；当读到的数据多于规定的值时，在流方式下剩余的数据由下个recv读出，在数据报方式下多余的数据被丢弃。</p>
<h4 id="sendto（）"><a href="#sendto（）" class="headerlink" title="sendto（）"></a>sendto（）</h4><p><strong>函数原型</strong><br>int sendto (SOCKET s, char * buf, int len ,int flags,<br>struct sockaddr_in * to, int tolen);</p>
<p><strong>参数</strong><br>s<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 一个SOCKET(可能已连接)。<br>buf<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 指向要传输的数据的缓冲区的指针。<br>len<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] buf的长度。<br>flags<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 指定函数调用的方式。一般取0。<br>to<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 指向目标地址结构体的指针。<br>tolen<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 目标地址结构体的长度。<br><strong>返回值</strong><br>函数执行成功返回发送的字节数（可能小于len），失败则返回SOCKET_ERROR。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>该函数一般用于通过无连接的SOCKET发送数据报文，报文的接受者由to参数指定。</p>
<h4 id="recvfrom（）"><a href="#recvfrom（）" class="headerlink" title="recvfrom（）"></a>recvfrom（）</h4><p><strong>函数原型</strong><br>int recvfrom (SOCKET s, char * buf, int len ,int flags,<br>struct sockaddr_in * from, int * fromlen);<br><strong>参数</strong><br>s<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 一个已经绑定的SOCKET。<br>buf<br>&nbsp;&nbsp;&nbsp;&nbsp;[out] 指向接收数据的缓冲区的指针。<br>len<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] buf的长度。<br>flags<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 指定函数调用的方式。一般取0。<br>from<br>&nbsp;&nbsp;&nbsp;&nbsp;[out] 指向源地址结构体的指针。<br>fromlen<br>&nbsp;&nbsp;&nbsp;&nbsp;[in/out] 源地址结构体的长度。<br><strong>返回值</strong><br>函数执行成功返回发送的字节数（可能小于len），失败则返回SOCKET_ERROR。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>该函数一般用于通过无连接的SOCKET接收数据报文，报文的发送者由from参数指定。</p>
<h4 id="closesocket（）"><a href="#closesocket（）" class="headerlink" title="closesocket（）"></a>closesocket（）</h4><p><strong>函数原型</strong><br>int closesocket (SOCKET s,);</p>
<p><strong>参数</strong><br>s<br>&nbsp;&nbsp;&nbsp;&nbsp;[in] 要关闭的SOCKET。<br><strong>返回值</strong><br>函数执行成功返回0，失败则返回SOCKET_ERROR。这时可以调用WSAGetLastError函数取得具体的错误代码。<br><strong>函数功能</strong><br>关闭指定的SOCKET。</p>
<h3 id="Windows-Socket-2的扩展特性"><a href="#Windows-Socket-2的扩展特性" class="headerlink" title="Windows Socket 2的扩展特性"></a>Windows Socket 2的扩展特性</h3><h4 id="Winsock-2-0简介"><a href="#Winsock-2-0简介" class="headerlink" title="Winsock 2.0简介"></a>Winsock 2.0简介</h4><p>Winsock 1.1原先设计的时候把API限定在TCP/IP的范畴里，它不象Berkerly模型那样支持多种协议。而Winsock 2.0正规化了一些其它的协议（如ATM、IPX/SPX和DECNet协议）的API。<br>Winsock 2.0之所以能支持多种协议，是因为Winsock 2.0在Windows Sockets DLL和底层协议栈之间定义了一个SPI（Service Provider Interface）接口，这样，通过一个Windows Sockets DLL可以同时访问底层不同厂商的协议栈。<br>Winsock 2.0不仅允许多种协议栈的并存，而且从理论上讲，它还允许创造一个与网络协议无关的应用程序。Winsock 2.0可以基于服务的需要透明地选择协议，应用程序可以适用于不同的网络名和网络地址。<br>Winsock 2.0还扩展了它的API函数集，当然Winsock 2.0是向下兼容的，可以把Winsock 1.1的代码原封不动地用在Winsock 2.0中。</p>
<h4 id="Winsock-2-0新特性"><a href="#Winsock-2-0新特性" class="headerlink" title="Winsock 2.0新特性"></a>Winsock 2.0新特性</h4><p>下面列出了一些Winsock 2.0的重要新特性：</p>
<ul>
<li>多重协议支持：SPI接口使得新的协议可以被支持。</li>
<li>传输协议独立：根据服务提供不同的协议。</li>
<li>多重命名空间：根据需要的服务和解析的主机名选择协议。</li>
<li>分散和聚集：  从多个缓冲区接受和发送数据。</li>
<li>重叠I/O和事件对象：增强吞吐量。</li>
<li>服务质量（Qos）：协商和跟踪网络带宽。</li>
<li>条件接受：可以选择性地决定是否接受连接。</li>
<li>Socket共享：多个进程可以共享一个SOKCKET句柄。</li>
</ul>
<h4 id="Winsock-2-0新增函数"><a href="#Winsock-2-0新增函数" class="headerlink" title="Winsock 2.0新增函数"></a>Winsock 2.0新增函数</h4><p>下面列出了一些Winsock 2.0的重要新增函数：</p>
<ul>
<li>WSAAccept（）：accept（）函数的扩展版本，支持条件接受和套接字分组。</li>
<li>WASCloseEvent（）：释放一个时间对象。</li>
<li>WSAConnect（）：connect（）函数的扩展版本，支持连接数据交换和Qos规范。</li>
<li>WSACreatEvent（）：创建一个事件对象。</li>
<li>WSADuplicateSocket（）：为一个共享套接字创建一个新的套接字。</li>
<li>WSAEnumNetworkEvents（）：检查是否有网络事件发生。</li>
<li>WSAEnumProtocols（）：得到每个可用的协议的信息。</li>
<li>WSAEventSelect（）：把一个网络事件和一个事件对象连接。</li>
<li>WSAGetOverlappedResu（）：得到重叠操作的完成状态。</li>
<li>WSAHtonl（）：htonl（）函数的扩展版本。</li>
<li>WSAHtons（）：htons（）函数的扩展版本。</li>
<li>WSAIoctl（）：ioctlsocket（）函数允许重叠操作的扩展版本。</li>
<li>WSANtohl（）：ntohl（）函数的扩展版本。</li>
<li>WSANtohs（）：ntohs（）函数的扩展版本。</li>
<li>WSARecv（）：recv（）的扩展版本，支持分散/聚集/重叠I/O。</li>
<li>WSARecvDisconnect（）：终止套接字的接受操作。</li>
<li>WSARecvFrom（）：recvfrom（）的扩展版本，支持分散/聚集/重叠I/O。</li>
<li>WSAResetEvent（）：重新初始化事件对象。</li>
<li>WSASend（）：send（）的扩展版本，支持分散/聚集/重叠I/O。</li>
<li>WSARecvDisconnect（）：终止套接字的接受操作。</li>
<li>WSASendDisconnect（）：终止套接字的发送操作。</li>
<li>WSASendTo（）：sendto（）的扩展版本，支持分散/聚集/重叠I/O。</li>
<li>WSASetEvent（）：设置事件对象。</li>
<li>WSASocket（）：socket（）函数的扩展版本。它以一个PROTOCOL_INFO结构作为输入参数，并且允许创建重叠套接字，还允许创建套接字组。</li>
<li>WSAWaitForMultipleEvents（）：阻塞多个事件对象。<br>关于这些函数的具体细节，请查阅MSDN。 </li>
</ul>
<h3 id="基于SOCKET实现的小型web服务器"><a href="#基于SOCKET实现的小型web服务器" class="headerlink" title="基于SOCKET实现的小型web服务器"></a>基于SOCKET实现的小型web服务器</h3><p>项目划分为启动，配置，服务器收发3个模块。</p>
<h4 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h4><p>start部分用于启动服务器，并在启动后可关闭服务器。</p>
<p>start.cpp代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"server.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭服务器线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closeServer</span><span class="params">(Server *server)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"If you want to close server, please input exit"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> Exit;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; Exit;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Exit == <span class="string">"exit"</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//到这里意味着要关闭服务器</span></span><br><span class="line">	(*server).~Server();</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Server server;</span><br><span class="line">	<span class="keyword">if</span> (server.WinsockStartup() == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (server.ServerStartup() == <span class="number">-1</span> ) <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">	<span class="keyword">if</span> (server.ListenStartup() == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">	<span class="function">thread <span class="title">closeThread</span><span class="params">(closeServer, &amp;server)</span></span>;</span><br><span class="line">	closeThread.detach();</span><br><span class="line">	<span class="keyword">if</span> (server.ServerWork() == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="服务器收发"><a href="#服务器收发" class="headerlink" title="服务器收发"></a>服务器收发</h4><p>server部分实现了服务器绑定IP端口,监听并接收HTTP请求，并建立连接，传送文件的功能。</p>
<p>server.h代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	SOCKET ServerSocket;  <span class="comment">//服务器socket</span></span><br><span class="line">	sockaddr_in ServerAddr;		<span class="comment">//服务器端IP地址</span></span><br><span class="line">	<span class="keyword">char</span>* RecvBuf;  <span class="comment">//接受缓冲区</span></span><br><span class="line">	<span class="keyword">char</span>* SendBuf;  <span class="comment">//发送缓冲区</span></span><br><span class="line">	<span class="keyword">int</span> SocketNums;<span class="comment">//socket总数</span></span><br><span class="line"></span><br><span class="line">	fd_set rfds;				<span class="comment">//用于检查socket是否有数据到来的的文件描述符</span></span><br><span class="line">	fd_set wfds;				<span class="comment">//用于检查socket是否可以发送的文件描述符</span></span><br><span class="line"></span><br><span class="line">	mutex lockRecBuf;  <span class="comment">//写接收缓冲区信号灯</span></span><br><span class="line">	mutex lockRecBuf2;  <span class="comment">//读接收缓冲区信号灯</span></span><br><span class="line">	mutex sendHeader;  <span class="comment">//发送报文头部信号灯</span></span><br><span class="line">	mutex sendMessage;  <span class="comment">//发送报文主体信号灯</span></span><br><span class="line">	mutex ClosedList;  <span class="comment">//失效队列信号灯</span></span><br><span class="line">	mutex ClosedList2;  <span class="comment">//失效队列信号灯</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span>&lt;SOCKET&gt;* threadsessions; <span class="comment">//线程队列</span></span><br><span class="line">	<span class="built_in">list</span>&lt;SOCKET&gt;* SocketList;  <span class="comment">//当前的会话socket队列</span></span><br><span class="line">	<span class="built_in">list</span>&lt;SOCKET&gt;* ClosedSocketList;	 <span class="comment">//所有已失效的会话socket队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	Server(<span class="keyword">void</span>);</span><br><span class="line">	<span class="keyword">virtual</span> ~Server(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">closeServer</span><span class="params">()</span></span>; <span class="comment">//关闭服务器</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RecvMessage</span><span class="params">(SOCKET socket)</span></span>;  <span class="comment">//从SOCKET接受消息</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(SOCKET socket, <span class="built_in">string</span> msg)</span></span>;  <span class="comment">//向SOCKET发送消息</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">endWith</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fullStr, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; endStr)</span></span>; <span class="comment">//判断是否以特定格式结尾</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">WinsockStartup</span><span class="params">()</span></span>;  <span class="comment">//初始化Winsock</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ServerStartup</span><span class="params">()</span></span>;  <span class="comment">//初始化Server，包括创建SOCKET，绑定到IP和PORT</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ListenStartup</span><span class="params">()</span></span>;  <span class="comment">//开始监听客户端请求</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ServerWork</span><span class="params">()</span></span>;	  <span class="comment">//收客户机请求 连接并生成会话socket</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddSocket</span><span class="params">(SOCKET socket)</span></span>;  <span class="comment">//将新的会话SOCKET加入队列</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddClosedSocket</span><span class="params">(SOCKET socket)</span></span>; <span class="comment">//将失效的会话SOCKET加入失效队列</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RemoveClosedSocket</span><span class="params">(SOCKET socket)</span></span>;  <span class="comment">//将失效的SOCKET从会话SOCKET队列删除</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RemoveClosedSocket</span><span class="params">()</span></span>;  <span class="comment">//将所有失效的SOCKET从会话SOCKET队列删除</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>server.cpp代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;streambuf&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"server.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"Ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">Server::Server(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;RecvBuf = <span class="keyword">new</span> <span class="keyword">char</span>[Config::BufferLength]; <span class="comment">//初始化接受缓冲区</span></span><br><span class="line">	<span class="built_in">memset</span>(<span class="keyword">this</span>-&gt;RecvBuf, <span class="string">'\0'</span>, Config::BufferLength); <span class="comment">// 并设置为0</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;SendBuf = <span class="keyword">new</span> <span class="keyword">char</span>[Config::BufferLength]; <span class="comment">//初始化发送缓冲区</span></span><br><span class="line">	<span class="built_in">memset</span>(<span class="keyword">this</span>-&gt;SendBuf, <span class="string">'\0'</span>, Config::BufferLength); <span class="comment">// 并设置为0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>-&gt;SocketList = <span class="keyword">new</span> <span class="built_in">list</span>&lt;SOCKET&gt;();  <span class="comment">//初始化有关List和Map</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;ClosedSocketList = <span class="keyword">new</span> <span class="built_in">list</span>&lt;SOCKET&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Server::~Server(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;RecvBuf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//释放接收缓冲区</span></span><br><span class="line">		<span class="built_in">free</span>(<span class="keyword">this</span>-&gt;RecvBuf);</span><br><span class="line">		<span class="keyword">this</span>-&gt;RecvBuf = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"RecvBuf has been free!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;SendBuf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//释放接收缓冲区</span></span><br><span class="line">		<span class="built_in">free</span>(<span class="keyword">this</span>-&gt;SendBuf);</span><br><span class="line">		<span class="keyword">this</span>-&gt;SendBuf = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"SendBuf has been free!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭服务器端socket</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ServerSocket != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		closesocket(<span class="keyword">this</span>-&gt;ServerSocket);</span><br><span class="line">		<span class="keyword">this</span>-&gt;ServerSocket = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"ServerSocket has been closed!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭所有会话socket并释放会话队列</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;SocketList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">list</span>&lt;SOCKET&gt;::iterator it = <span class="keyword">this</span>-&gt;SocketList-&gt;begin(); it != <span class="keyword">this</span>-&gt;SocketList-&gt;end(); it++)</span><br><span class="line">			closesocket(*it); <span class="comment">//关闭会话</span></span><br><span class="line">		<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;SocketList;  <span class="comment">//释放队列</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;SocketList = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"SocketList has been deleted!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放失效会话队列</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ClosedSocketList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">list</span>&lt;SOCKET&gt;::iterator it = <span class="keyword">this</span>-&gt;ClosedSocketList-&gt;begin(); it != <span class="keyword">this</span>-&gt;ClosedSocketList-&gt;end(); it++)</span><br><span class="line">			closesocket(*it);</span><br><span class="line">		<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;ClosedSocketList;</span><br><span class="line">		<span class="keyword">this</span>-&gt;ClosedSocketList = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"ClosedSocketList has been deleted!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	WSACleanup(); <span class="comment">//清理winsock 运行环境</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否以某一特定后缀名结尾</span></span><br><span class="line"><span class="keyword">bool</span> Server::endWith(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fullStr, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; endStr) &#123;</span><br><span class="line">	<span class="keyword">if</span> (endStr.size() &gt; fullStr.size())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> indexFull = fullStr.size() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> indexEnd = endStr.size() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (indexEnd &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (fullStr[indexFull] != endStr[indexEnd])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		indexFull--;</span><br><span class="line">		indexEnd--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化Winsock</span></span><br><span class="line"><span class="keyword">int</span> Server::WinsockStartup() &#123;</span><br><span class="line"></span><br><span class="line">	WSADATA wsaData;<span class="comment">//用于返回Winsock的环境信息   </span></span><br><span class="line">	<span class="keyword">int</span> nRc = WSAStartup(<span class="number">0x0202</span>, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nRc) &#123;</span><br><span class="line">		<span class="comment">//Winsock初始化失败</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"WSAstartup error!\n"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断返回的Winsock版本号</span></span><br><span class="line">	<span class="keyword">if</span> (wsaData.wVersion != <span class="number">0x0202</span>) &#123; <span class="comment">//如果版本不对</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Server's winsock version error!"</span>;</span><br><span class="line">		WSACleanup();  <span class="comment">//清除Winsock</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Server's winsock startup success!\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化Server</span></span><br><span class="line"><span class="keyword">int</span> Server::ServerStartup() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input the ServerAddr: "</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; Config::ServerAddr;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\rPlease input the ServerPort: "</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; Config::ServerPort;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Server mainpath is:"</span> &lt;&lt;Config::mainPath &lt;&lt; <span class="string">" now"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Do you want to change it: y/n "</span>;</span><br><span class="line">	<span class="keyword">char</span> changePath;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; changePath;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (changePath == <span class="string">'Y'</span> || changePath == <span class="string">'y'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input the new server mainpath:"</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; Config::mainPath;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建 TCP socket</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;ServerSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ServerSocket == INVALID_SOCKET) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Server create socket error!!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		WSACleanup();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Server TCP socket create OK!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Bind socket to Server's IP and port 5050</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;ServerAddr.sin_family = AF_INET;</span><br><span class="line">	<span class="keyword">this</span>-&gt;ServerAddr.sin_port = htons(Config::ServerPort);</span><br><span class="line">	<span class="keyword">this</span>-&gt;ServerAddr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);</span><br><span class="line">	<span class="keyword">int</span> nRC = bind(<span class="keyword">this</span>-&gt;ServerSocket, (LPSOCKADDR) &amp; (<span class="keyword">this</span>-&gt;ServerAddr), <span class="keyword">sizeof</span>(<span class="keyword">this</span>-&gt;ServerAddr));</span><br><span class="line">	<span class="keyword">if</span> (nRC == SOCKET_ERROR) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Server socket bind error!\n"</span>;</span><br><span class="line">		closesocket(<span class="keyword">this</span>-&gt;ServerSocket);</span><br><span class="line">		WSACleanup();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Server socket bind ok!\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///关闭服务器线程</span></span><br><span class="line"><span class="keyword">int</span> Server::closeServer() &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"If you want to close server, please input exit"</span> &lt;&lt;<span class="built_in">endl</span> ;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> Exit;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; Exit;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Exit == <span class="string">"exit"</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//到这里意味着要关闭服务器</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;~Server();</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始监听过程，等待客户的连接</span></span><br><span class="line"><span class="keyword">int</span> Server::ListenStartup() &#123;</span><br><span class="line">	<span class="keyword">int</span> nRC = listen(<span class="keyword">this</span>-&gt;ServerSocket, Config::MaxConnetion);</span><br><span class="line">	<span class="keyword">if</span> (nRC == SOCKET_ERROR) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Server socket listen error!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		closesocket(<span class="keyword">this</span>-&gt;ServerSocket);</span><br><span class="line">		WSACleanup();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Server socket listen ok!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将新的会话socket加入队列</span></span><br><span class="line"><span class="keyword">void</span> Server::AddSocket(SOCKET socket) &#123;</span><br><span class="line">	<span class="keyword">if</span> (socket != INVALID_SOCKET) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;SocketList-&gt;insert(<span class="keyword">this</span>-&gt;SocketList-&gt;end(), socket);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将失效的会话socket加入失效队列</span></span><br><span class="line"><span class="keyword">void</span> Server::AddClosedSocket(SOCKET socket) &#123;</span><br><span class="line">	<span class="keyword">if</span> (socket != INVALID_SOCKET) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;ClosedSocketList-&gt;insert(<span class="keyword">this</span>-&gt;ClosedSocketList-&gt;end(), socket);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将失效的socket从会话socket队列删除</span></span><br><span class="line"><span class="keyword">void</span> Server::RemoveClosedSocket(SOCKET socket) &#123;</span><br><span class="line">	<span class="keyword">if</span> (socket != INVALID_SOCKET) &#123;</span><br><span class="line">		<span class="built_in">list</span>&lt;SOCKET&gt;::iterator it = find(<span class="keyword">this</span>-&gt;SocketList-&gt;begin(), <span class="keyword">this</span>-&gt;SocketList-&gt;end(), socket);</span><br><span class="line">		<span class="keyword">if</span> (it != <span class="keyword">this</span>-&gt;SocketList-&gt;end()) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;SocketList-&gt;erase(it);</span><br><span class="line">			<span class="comment">//closesocket(*it);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有失效的socket从会话socket队列删除</span></span><br><span class="line"><span class="keyword">void</span> Server::RemoveClosedSocket() &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">list</span>&lt;SOCKET&gt;::iterator it = <span class="keyword">this</span>-&gt;ClosedSocketList-&gt;begin(); it != <span class="keyword">this</span>-&gt;ClosedSocketList-&gt;end(); it++) &#123;</span><br><span class="line">		<span class="comment">/*if ((*it) != INVALID_SOCKET) &#123;</span></span><br><span class="line"><span class="comment">			if (it != this-&gt;SocketList-&gt;end())</span></span><br><span class="line"><span class="comment">				this-&gt;SocketList-&gt;erase(it);</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;RemoveClosedSocket(*it);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向socket发送消息</span></span><br><span class="line"><span class="keyword">void</span> Server::SendMessage(SOCKET socket, <span class="built_in">string</span> msg) &#123;</span><br><span class="line">	<span class="keyword">int</span> rtn = send(socket, msg.c_str(), msg.length(), <span class="number">0</span>);</span><br><span class="line">	unique_lock&lt;mutex&gt;closedList(<span class="keyword">this</span>-&gt;ClosedList2, defer_lock);</span><br><span class="line">	<span class="keyword">if</span> (rtn == SOCKET_ERROR) &#123;					<span class="comment">//发送数据错误</span></span><br><span class="line">		closedList.lock();</span><br><span class="line">		<span class="keyword">this</span>-&gt;AddClosedSocket(socket);</span><br><span class="line">		closedList.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从socket接受消息</span></span><br><span class="line"><span class="keyword">void</span> Server::RecvMessage(SOCKET socket) &#123;</span><br><span class="line"></span><br><span class="line">	unique_lock&lt;mutex&gt;writeRecBuf(<span class="keyword">this</span>-&gt;lockRecBuf, defer_lock);  <span class="comment">//接收资源写信号灯</span></span><br><span class="line">	unique_lock&lt;mutex&gt;readRecBuf(<span class="keyword">this</span>-&gt;lockRecBuf2, defer_lock);  <span class="comment">//接收资源读信号灯</span></span><br><span class="line">	unique_lock&lt;mutex&gt;sendHeader(<span class="keyword">this</span>-&gt;sendHeader, defer_lock);  <span class="comment">//发送报文头部信号灯</span></span><br><span class="line">	unique_lock&lt;mutex&gt;sendMessage(<span class="keyword">this</span>-&gt;sendMessage, defer_lock);  <span class="comment">//发送报文主体信号灯</span></span><br><span class="line">	unique_lock&lt;mutex&gt;closedList(<span class="keyword">this</span>-&gt;ClosedList, defer_lock);  <span class="comment">//发送报文主体信号灯</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//writeRecBuf.lock();   //写RecBuf时需要上锁</span></span><br><span class="line">	<span class="keyword">char</span>* RecvBufn = <span class="keyword">new</span> <span class="keyword">char</span>[Config::BufferLength];</span><br><span class="line">	<span class="built_in">memset</span>(RecvBufn, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(RecvBufn)); <span class="comment">//缓存清零</span></span><br><span class="line">	<span class="keyword">int</span> receivedBytes = recv(socket, RecvBufn, Config::BufferLength, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//writeRecBuf.unlock();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果会话SOCKET有数据到来，则接受客户的数据</span></span><br><span class="line">	<span class="keyword">if</span> (receivedBytes == SOCKET_ERROR) &#123;    <span class="comment">//接受数据错误</span></span><br><span class="line">		<span class="comment">/*receivedBytes = WSAGetLastError();</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; "Thread falied!" &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">		return;*/</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; "ReceiveBytes == -1,Receive Error!" &lt;&lt; endl;</span></span><br><span class="line">		closedList.lock();</span><br><span class="line">		<span class="keyword">this</span>-&gt;AddClosedSocket(socket);</span><br><span class="line">		closedList.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (receivedBytes == <span class="number">0</span>) &#123; <span class="comment">//对方断开连接</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; "ReceiveBytes ==0,Server disconnected!" &lt;&lt; std::endl;</span></span><br><span class="line">		closedList.lock();</span><br><span class="line">		<span class="keyword">this</span>-&gt;AddClosedSocket(socket);</span><br><span class="line">		closedList.unlock();</span><br><span class="line">		<span class="comment">//return;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; "\r\n" &lt;&lt; RecvBuf;</span></span><br><span class="line">		<span class="comment">//找到报文头部</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> fullPath;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> respondHttpHeader, clientHttpHeader;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> statusCode, firstHeader, typeStr, lengthStr;</span><br><span class="line">		<span class="built_in">std</span>::<span class="function">regex <span class="title">regRequest</span><span class="params">(<span class="string">R"(([A-Z]+) (.*?) HTTP/\d\.\d)"</span>)</span></span>;</span><br><span class="line">		<span class="built_in">std</span>::smatch matchRst;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> strRecv, strSend;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> method;</span><br><span class="line">	    <span class="built_in">std</span>:<span class="built_in">string</span> url;</span><br><span class="line"></span><br><span class="line">		respondHttpHeader = <span class="string">""</span>;</span><br><span class="line">		statusCode = Config::Ok;</span><br><span class="line">		firstHeader = <span class="string">"HTTP/1.1 200 OK\r\n"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//找到HTTP报文头部</span></span><br><span class="line">		<span class="comment">//readRecBuf.lock();  //读RecBuf时需要上锁</span></span><br><span class="line">		strRecv.assign(RecvBufn);</span><br><span class="line">		<span class="keyword">size_t</span> headerEnd = strRecv.find(<span class="string">"\r\n\r\n"</span>);</span><br><span class="line">		clientHttpHeader = strRecv.substr(<span class="number">0</span>, headerEnd);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//正则表达式提取关键字method(GET,POST),url</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">std</span>::regex_search(clientHttpHeader, matchRst, regRequest)) &#123;</span><br><span class="line">			method = matchRst[<span class="number">1</span>].str();</span><br><span class="line">			url = matchRst[<span class="number">2</span>].str();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; url.size(); i++) &#123;</span><br><span class="line">			<span class="comment">//替换成windows路径</span></span><br><span class="line">			<span class="keyword">if</span> (url[i] == <span class="string">'/'</span>)</span><br><span class="line">				url[i] = <span class="string">'\\'</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fullPath = Config::mainPath + url; <span class="comment">//完整路径</span></span><br><span class="line">		<span class="comment">//writeRecBuf.unlock();</span></span><br><span class="line">		<span class="comment">//readRecBuf.unlock();</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Client http header:\r\n"</span> &lt;&lt; clientHttpHeader.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"\r\nmethod:"</span> &lt;&lt; method.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"url:"</span> &lt;&lt; url.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//sendHeader.lock();  //发送报文头部信号灯</span></span><br><span class="line"></span><br><span class="line">		DWORD ftyp;</span><br><span class="line">		ftyp = GetFileAttributesA(fullPath.c_str());</span><br><span class="line">		<span class="keyword">if</span> ((ftyp &amp; FILE_ATTRIBUTE_DIRECTORY) &amp;&amp; (!INVALID_FILE_ATTRIBUTES)) &#123;</span><br><span class="line">			<span class="comment">//如果是一个目录，打开该目录下的索引index.html</span></span><br><span class="line">			fullPath = fullPath + <span class="string">"\\index.html"</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		FILE* infile = fopen(fullPath.c_str(), <span class="string">"rb"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!infile) &#123;</span><br><span class="line">			<span class="comment">//文件不存在</span></span><br><span class="line">			<span class="comment">//<span class="doctag">TODO:</span>发送自定义404页面</span></span><br><span class="line">			infile = fopen((Config::mainPath + <span class="string">"\\404.html"</span>).c_str(), <span class="string">"rb"</span>);</span><br><span class="line">			statusCode = Config::Error;</span><br><span class="line">			firstHeader = <span class="string">"HTTP/1.1 404 Not Found\r\n"</span>;</span><br><span class="line">			typeStr = <span class="string">"Content-Type: text/html\r\n"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".html"</span>) || endWith(url, <span class="string">"htm"</span>))</span><br><span class="line">			typeStr = <span class="string">"Content-Type: text/html\r\n"</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".txt"</span>))</span><br><span class="line">			typeStr = <span class="string">"Content-Type: text /plain\r\n"</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".jpg"</span>))</span><br><span class="line">			typeStr = <span class="string">"Content-Type: image/jpeg\r\n"</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".jpeg"</span>) || endWith(url, <span class="string">".png"</span>))</span><br><span class="line">			typeStr = <span class="string">"Content-Type: image/"</span> + (url.substr(url.rfind(<span class="string">'.'</span>) + <span class="number">1</span>)) + <span class="string">"\r\n"</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".ico"</span>))</span><br><span class="line">			typeStr = <span class="string">"Content-Type: image/x-icon\r\n"</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".css"</span>))</span><br><span class="line">			typeStr = <span class="string">"Content-Type: text/css\r\n"</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".gif"</span>))</span><br><span class="line">			typeStr = <span class="string">"Content-Type: image/gif\r\n"</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".png"</span>))</span><br><span class="line">			typeStr = <span class="string">"Content-Type: image/png\r\n"</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".js"</span>))</span><br><span class="line">			typeStr = <span class="string">"Content-Type: application/javascript\r\n"</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (endWith(url, <span class="string">".eot"</span>))</span><br><span class="line">			typeStr = <span class="string">"Content-Type: application/vnd.ms-fontobject\r\n"</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(endWith(url,<span class="string">".mp3"</span>))</span><br><span class="line">			typeStr = <span class="string">"Content-Type: audio/mpeg\r\n"</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (infile != <span class="literal">NULL</span>)  <span class="comment">//文件存在，但是不支持解析</span></span><br><span class="line">				fclose(infile);</span><br><span class="line">			<span class="comment">//<span class="doctag">TODO:</span>发送自定义501页面</span></span><br><span class="line">			infile = fopen((Config::mainPath + <span class="string">"\\501.html"</span>).c_str(), <span class="string">"rb"</span>);</span><br><span class="line">			statusCode = Config::Error;</span><br><span class="line">			firstHeader = <span class="string">"HTTP/1.1 501 Not Implemented\r\n"</span>;</span><br><span class="line">			typeStr = <span class="string">"Content-Type: text/html\r\n"</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取文件大小</span></span><br><span class="line">		fseek(infile, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">		fseek(infile, <span class="number">0</span>, SEEK_END);</span><br><span class="line">		<span class="keyword">int</span> fileLength = ftell(infile);</span><br><span class="line">		<span class="comment">//文件指针归位</span></span><br><span class="line">		fseek(infile, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">		respondHttpHeader = firstHeader + typeStr + <span class="string">"Content-Length: "</span> + <span class="built_in">std</span>::to_string(fileLength) + <span class="string">"\r\n"</span> + <span class="string">"Server: CServer_HTTP1.1\r\n"</span> + <span class="string">"Connection: close\r\n"</span> + <span class="string">"\r\n"</span>;</span><br><span class="line">		<span class="comment">//发送报文头部</span></span><br><span class="line">	   <span class="comment">//send(socket, respondHttpHeader.c_str, respondHttpHeader.length(), 0);</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;SendMessage(socket, respondHttpHeader);</span><br><span class="line">		<span class="comment">//sendHeader.unlock();</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"respond http header:"</span> &lt;&lt; respondHttpHeader.c_str();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//发送请求的文件</span></span><br><span class="line">		<span class="comment">//sendMessage.lock();</span></span><br><span class="line">		<span class="keyword">int</span> bufReadNum;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="comment">//缓存清零</span></span><br><span class="line">			<span class="built_in">memset</span>(RecvBufn, <span class="number">0</span>, <span class="keyword">sizeof</span>(RecvBufn));</span><br><span class="line">			bufReadNum = fread(RecvBufn, <span class="number">1</span>, Config::BufferLength, infile);</span><br><span class="line">			<span class="keyword">if</span> (SOCKET_ERROR == (send(socket, RecvBufn, bufReadNum, <span class="number">0</span>)))</span><br><span class="line">			&#123;<span class="comment">//发送失败</span></span><br><span class="line">				<span class="comment">//rtn = SOCKET_ERROR;							</span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"File: "</span> &lt;&lt; url &lt;&lt; <span class="string">" transfer error!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (feof(infile))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		fclose(infile);</span><br><span class="line">		<span class="comment">//memset(RecvBufn, '\0', Config::BufferLength);//清除接受缓冲区</span></span><br><span class="line">		<span class="comment">//sendMessage.unlock();</span></span><br><span class="line">		<span class="keyword">if</span> (RecvBufn != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">delete</span>(RecvBufn);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"File: "</span> &lt;&lt; fullPath &lt;&lt; <span class="string">" transfer successful!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//writeRecBuf.unlock();</span></span><br><span class="line">	<span class="comment">//closesocket(socket);</span></span><br><span class="line">	<span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">100</span>));</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受客户端发来的请求连接并生成会话socket</span></span><br><span class="line"><span class="keyword">int</span> Server::ServerWork() &#123;</span><br><span class="line"></span><br><span class="line">	u_long blockMode = Config::uNonBlock;</span><br><span class="line">	<span class="keyword">int</span> rtn;</span><br><span class="line">	<span class="comment">//nThread.MemberProc = &amp;Server::RecvMessage;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//将ServerSocket设为非阻塞模式以监听客户连接请求</span></span><br><span class="line">	<span class="keyword">if</span> ((rtn = ioctlsocket(<span class="keyword">this</span>-&gt;ServerSocket, FIONBIO, &amp;blockMode) == SOCKET_ERROR)) &#123; <span class="comment">//FIONBIO：允许或禁止套接口s的非阻塞模式。</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Set Server unblockMode error!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//等到客户端的连接请求</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//设置socket集</span></span><br><span class="line">		<span class="comment">//FD_ZERO(fd_set *fdset);将指定的文件描述符集清空，在对文件描述符集合进行设置前，必须对其进行初始化，</span></span><br><span class="line">		<span class="comment">//如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的。</span></span><br><span class="line">		FD_ZERO(&amp;<span class="keyword">this</span>-&gt;rfds);  </span><br><span class="line">		FD_ZERO(&amp;<span class="keyword">this</span>-&gt;wfds);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//FD_SET(fd_set *fdset);用于在文件描述符集合中增加一个新的文件描述符。</span></span><br><span class="line">		<span class="comment">//把serverSocket加入到rfds，等待用户连接请求</span></span><br><span class="line">		FD_SET(<span class="keyword">this</span>-&gt;ServerSocket, &amp;<span class="keyword">this</span>-&gt;rfds);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//把当前的会话socket加入到rfds,等待用户数据的到来;加到wfds，等待socket可发送数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">list</span>&lt;SOCKET&gt;::iterator it = <span class="keyword">this</span>-&gt;SocketList-&gt;begin(); it != <span class="keyword">this</span>-&gt;SocketList-&gt;end(); it++) &#123;</span><br><span class="line">			FD_SET(*it, &amp;rfds);</span><br><span class="line">			FD_SET(*it, &amp;wfds);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//等待用户连接请求或用户数据到来或会话socke可发送数据</span></span><br><span class="line">		<span class="comment">//返回有可读或可写的socket的总数</span></span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">this</span>-&gt;SocketNums = select(<span class="number">0</span>, &amp;<span class="keyword">this</span>-&gt;rfds, &amp;<span class="keyword">this</span>-&gt;wfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) == SOCKET_ERROR)</span><br><span class="line">		&#123; </span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Select socket nums error!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//此时有客户端请求到来</span></span><br><span class="line">		sockaddr_in ClientAddr;  <span class="comment">//客户端IP地址</span></span><br><span class="line">		<span class="keyword">int</span> AddrLen = <span class="keyword">sizeof</span>(ClientAddr);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//检查srvSocket是否收到用户连接请求</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;SocketNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (FD_ISSET(<span class="keyword">this</span>-&gt;ServerSocket, &amp;rfds)) &#123;  <span class="comment">//检查有socket就绪</span></span><br><span class="line">				<span class="keyword">this</span>-&gt;SocketNums--;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//产生会话socket</span></span><br><span class="line">				SOCKET sockket = accept(<span class="keyword">this</span>-&gt;ServerSocket, (LPSOCKADDR) &amp; (ClientAddr), &amp;AddrLen);</span><br><span class="line">				<span class="keyword">if</span> (sockket == INVALID_SOCKET) &#123;</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">"Server accept error!\n"</span>;</span><br><span class="line">					<span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">					<span class="comment">/*closesocket(this-&gt;ServerSocket);</span></span><br><span class="line"><span class="comment">					WSACleanup();</span></span><br><span class="line"><span class="comment">					return -1;*/</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//将socket设为非阻塞模式以监听客户连接请求</span></span><br><span class="line">				<span class="keyword">if</span> (ioctlsocket(sockket, FIONBIO, &amp;blockMode) == SOCKET_ERROR) &#123;</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">"Set accept socket unbolockmode error!\n"</span>;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//将产生的会话SOCKET保存在SocketList中</span></span><br><span class="line">				getpeername(sockket, (struct sockaddr*) &amp; ClientAddr, &amp;AddrLen);</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"Receive Ip:"</span> &lt;&lt; inet_ntoa(ClientAddr.sin_addr) &lt;&lt; <span class="string">" from Port:"</span> &lt;&lt; ntohs(ClientAddr.sin_port) &lt;&lt; <span class="string">" request"</span>;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">""</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">this</span>-&gt;AddSocket(sockket);</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"Server accept success!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//接收用户请求</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;SocketNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//遍历socket队列，检查是否有数据到来</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">list</span>&lt;SOCKET&gt;::iterator it = <span class="keyword">this</span>-&gt;SocketList-&gt;begin(); it != <span class="keyword">this</span>-&gt;SocketList-&gt;end(); it++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (*it != INVALID_SOCKET) &#123;</span><br><span class="line">					<span class="comment">//FD_ISSET(int fd,fd_set *fdset);用于测试指定的文件描述符是否在该集合中。</span></span><br><span class="line">					<span class="keyword">if</span> (FD_ISSET(*it, &amp;rfds)) &#123;  <span class="comment">//某会话socket有数据到来</span></span><br><span class="line">						SOCKADDR_IN RequestSocket;</span><br><span class="line">						<span class="keyword">int</span> socketAddrLen = <span class="keyword">sizeof</span>(RequestSocket);</span><br><span class="line">						getpeername(*it, (struct sockaddr*) &amp; RequestSocket, &amp;socketAddrLen);</span><br><span class="line">						<span class="comment">/*cout &lt;&lt; "Receive Ip:" &lt;&lt; inet_ntoa(RequestSocket.sin_addr) &lt;&lt; " from Port:" &lt;&lt; ntohs(RequestSocket.sin_port) &lt;&lt; " request";</span></span><br><span class="line"><span class="comment">						cout &lt;&lt; "" &lt;&lt; endl;*/</span></span><br><span class="line">						<span class="function">thread <span class="title">talkThread</span><span class="params">(&amp;Server::RecvMessage, <span class="built_in">std</span>::ref(*<span class="keyword">this</span>), *it)</span></span>;  <span class="comment">//开启一个新的线程来处理这一个客户的请求</span></span><br><span class="line">						talkThread.detach();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//从socketList里删掉已经关闭的socket</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;RemoveClosedSocket();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>config 配置了一些常用变量</p>
<p>config.h代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> ServerPort;  <span class="comment">//服务器端口号</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> ClientPort;   <span class="comment">//客户端端口</span></span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">string</span> ServerAddr;   <span class="comment">//服务器IP地址</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MaxConnetion;  <span class="comment">//最大连接数</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BufferLength;   <span class="comment">//缓冲区大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">string</span> mainPath; <span class="comment">//虚拟主路径</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> Ok;  <span class="comment">//客户端请求成功</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> Error;   <span class="comment">//客户端语法错误，服务端尚未实现</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> NotFound;   <span class="comment">//文件不存在</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> HttpVersion;   <span class="comment">//HTTP版本</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> u_long uNonBlock;  <span class="comment">//SOCKET阻塞模式</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Config();</span><br><span class="line">	~Config();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>config.cpp代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Config::Config()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Config::~Config()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> Config::ServerPort = <span class="number">5050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Config::ClientPort = <span class="number">8080</span>;</span><br><span class="line"><span class="built_in">string</span> Config::ServerAddr = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Config::MaxConnetion = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Config::BufferLength = <span class="number">65535</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Config::Ok= <span class="string">"200 OK"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Config::Error = <span class="string">"501 Not Implemented"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Config::NotFound = <span class="string">"404 Not Found"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Config::HttpVersion = <span class="string">"HTTP/1.1 "</span>;</span><br><span class="line"><span class="keyword">const</span> u_long Config::uNonBlock = <span class="number">1</span>;	  <span class="comment">//SOCKET为非阻塞模式	</span></span><br><span class="line"><span class="built_in">string</span> Config::mainPath = <span class="string">"D:\\html\\"</span>;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>只出现一次的数字II</title>
    <url>/2019/11/27/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97II/</url>
    <content><![CDATA[<p>来源Leetcode第137题只出现一次的数字II</p>
<blockquote>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？<br><a id="more"></a><br>示例 1:</p>
<p>输入: [2,2,3,2]<br>输出: 3</p>
</blockquote>
<hr>
<h4 id="排序后遍历"><a href="#排序后遍历" class="headerlink" title="排序后遍历"></a>排序后遍历</h4><p>思路同136题，排序后遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> len = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length ;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[i + <span class="number">1</span>] &amp;&amp; nums[i + <span class="number">1</span>] == nums[i + <span class="number">2</span>]) &#123;</span><br><span class="line">            i += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] != nums[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>来源<a href="https://leetcode-cn.com/problems/single-number-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--31/" target="_blank" rel="noopener">题解</a></p>
<p><strong>将问题一般化</strong></p>
<p>给一个数组，每个元素都出现 k ( k &gt; 1) 次，除了一个数字只出现 p 次(p &gt;= 1, p % k !=0)，找到出现 p 次的那个数。<br>考虑其中的一个 bit<br>为了计数 k 次，我们必须要 m 个比特，其中 2^m &gt;=k，也就是 m &gt;= log2k。<br>假设我们 m 个比特依次是 x_mx_{m-1}…x_2x_1x 。<br>开始全部初始化为 0。00…00。<br>然后扫描所有数字的当前 bit 位，用 i 表示当前的 bit。</p>
<p>假如例子是 1 2 6 1 1 2 2 3 3 3, 3 个 1, 3 个 2, 3 个 3,1 个 6<br>1 0 0 1<br>2 0 1 0<br>6 1 1 0<br>1 0 0 1<br>1 0 0 1<br>2 0 1 0<br>2 0 1 0<br>3 0 1 1<br>3 0 1 1<br>3 0 1 1<br>初始 状态 00…00。<br>第一次遇到 1 , m 个比特依次是 00…01。<br>第二次遇到 1 , m 个比特依次是 00…10。<br>第三次遇到 1 , m 个比特依次是 00…11。<br>第四次遇到 1 , m 个比特依次是 00..100。</p>
<p>x1 的变化规律就是遇到 1 变成 1 ，再遇到 1 变回 0。遇到 0 的话就不变。<br>所以 x1 = x1 ^ i，可以用异或来求出 x1 。<br>那么 x2…xm 怎么办呢？<br>x2 的话，当遇到 1 的时候，如果之前 x1 是 0，x2 就不变。如果之前 x1 是 1，对应于上边的第二次遇到 1 和第四次遇到 1。 x2 从 0 变成 1 和 从 1 变成 0。<br>所以 x2 的变化规律就是遇到 1 同时 x1 是 1 就变成 1，再遇到 1 同时 x1 是 1 就变回 0。遇到 0 的话就不变。和 x1 的变化规律很像，所以同样可以使用异或。<br>x2 = x2 ^ (i &amp; x1)，多判断了 x1 是不是 1。<br>x3，x4 … xm 就是同理了，xm = xm ^ (xm-1 &amp; … &amp; x1 &amp; i) 。<br>再说直接点，上边其实就是模拟了每次加 1 的时候，各个比特位的变化。所以高位 xm 只有当低位全部为 1 的时候才会得到进位 1 。</p>
<p>00 -&gt; 01 -&gt; 10 -&gt; 11 -&gt; 00</p>
<p>上边有个问题，假设我们的 k = 3，那么我们应该在 10 之后就变成 00，而不是到 11。<br>所以我们需要一个 mask ，当没有到达 k 的时候和 mask进行与操作是它本身，当到达 k 的时候和 mask 相与就回到 00…000。<br>根据上边的要求构造 mask，假设 k 写成二进制以后是 km…k2k1。<br>mask = ~(y1 &amp; y2 &amp; … &amp; ym),<br>如果kj = 1，那么yj = xj<br>如果 kj = 0，yj = ~xj 。</p>
<p>举两个例子。</p>
<p>k = 3: 写成二进制，k1 = 1, k2 = 1, mask = ~(x1 &amp; x2);</p>
<p>k = 5: 写成二进制，k1 = 1, k2 = 0, k3 = 1, mask = ~(x1 &amp; ~x2 &amp; x3);</p>
<p>很容易想明白，当 x1x2…xm 达到 k1k2…km 的时候因为我们要把 x1x2…xm 归零。我们只需要用 0 和每一位进行与操作就回到了 0。<br>所以我们只需要把等于 0 的比特位取反，然后再和其他所有位相与就得到 1 ，然后再取反就是 0 了。<br>如果 x1x2…xm 没有达到 k1k2…km ，那么求出来的结果一定是 1，这样和原来的 bit 位进行与操作的话就保持了原来的数。<br>总之，最后我们的代码就是下边的框架。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">    xm ^= (xm-<span class="number">1</span> &amp; ... &amp; x1 &amp; i);</span><br><span class="line">    xm-<span class="number">1</span> ^= (xm-<span class="number">2</span> &amp; ... &amp; x1 &amp; i);</span><br><span class="line">    .....</span><br><span class="line">    x1 ^= i;</span><br><span class="line">    </span><br><span class="line">    mask = ~(y1 &amp; y2 &amp; ... &amp; ym) where yj = xj <span class="keyword">if</span> kj = <span class="number">1</span>, and yj = ~xj <span class="keyword">if</span> kj = <span class="number">0</span> (j = <span class="number">1</span> to m).</span><br><span class="line"></span><br><span class="line">    xm &amp;= mask;</span><br><span class="line">    ......</span><br><span class="line">    x1 &amp;= mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>考虑全部 bit</strong></p>
<p>假如例子是 1 2 6 1 1 2 2 3 3 3, 3 个 1, 3 个 2, 3 个 3,1 个 6<br>1 0 0 1<br>2 0 1 0<br>6 1 1 0<br>1 0 0 1<br>1 0 0 1<br>2 0 1 0<br>2 0 1 0<br>3 0 1 1<br>3 0 1 1<br>3 0 1 1<br>之前是完成了一个 bit 位，也就是每一列的操作。因为我们给的数是 int 类型，所以有 32 位。所以我们需要对每一位都进行计数。有了上边的分析，我们不需要再向解法三那样依次考虑每一位，我们可以同时对 32 位进行计数。<br>对于 k 等于 3 ，也就是这道题。我们可以用两个 int，x1 和 x2。x1 表示对于 32 位每一位计数的低位，x2 表示对于 32 位每一位计数的高位。通过之前的公式，我们利用位操作就可以同时完成计数了。</p>
<p><strong>返回什么</strong><br>最后一个问题，我们需要返回什么？<br>因为所有的数字都出现了 k 次，只有一个数字出现了 p 次。<br>因为 xm…x2x1 组合起来就是对于每一列 1 的计数。<br>如果 p = 1，那么如果出现一次的数字的某一位是 1 ，一定会使得 x1 ，也就是计数的最低位置的对应位为 1，所以我们把 x1 返回即可。对于上边的例子，就是 110 ，所以返回 6。<br>如果 p = 2，二进制就是 10，那么如果出现 2次的数字的某一位是 1 ，一定会使得 x2 的对应位变为 1，所以我们把 x2 返回即可。<br>如果 p = 3，二进制就是 11，那么如果出现 3次的数字的某一位是 1 ，一定会使得 x1 和x2的对应位都变为1，所以我们把 x1 或者 x2 返回即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = <span class="number">0</span>, x2 = <span class="number">0</span>, mask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">        x2 ^= x1 &amp; i;</span><br><span class="line">        x1 ^= i;</span><br><span class="line">        mask = ~(x1 &amp; x2);</span><br><span class="line">        x2 &amp;= mask;</span><br><span class="line">        x1 &amp;= mask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三进制运算"><a href="#三进制运算" class="headerlink" title="三进制运算"></a>三进制运算</h4><p>摸了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            ones = (ones ^ A[i]) &amp; ~twos;</span><br><span class="line">            twos = (twos ^ A[i]) &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表II</title>
    <url>/2019/11/26/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/</url>
    <content><![CDATA[<p>来自Leetcode第142题环形链表II</p>
<blockquote>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>说明：不允许修改给定的链表。<br>示例 1：<br><a id="more"></a><br>输入：head = [3,2,0,-4], pos = 1<br>输出：tail connects to node index 1<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
</blockquote>
<hr>
<h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>思路同141环形链表，用一个set来判断，如果有重复的，直接返回该元素即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Set&lt;ListNode&gt; map = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.contains(head))</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            map.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>这题有个坑，和上一题不一样。<br>上一题条件宽松，在环里相遇即可，并且对初始步数无要求。<br>我在复用上一题代码时，因为初始步数的不一致，导致了最终在死循环里出不来。代码块里注释部分就是导致死循环的地方，尽管两个都能判断相遇成环，但是相遇点不一样，就为后来的找环入口算法带来了障碍。<br>或者注释部分用最开始的双指针代替也可。</p>
<p>数学解释：</p>
<blockquote>
<p>从 head 到入口点的距离设为 x，入口点到相遇点的距离设为 y，环的的长度设为 n。<br>假设 slow 指针走过的距离为 t，那么 fast 指针走过的一定是 slow 指针的 2 倍，也就是 2t。<br>slow 指针从 head 出发走了 x 的距离到达入口点，然后可能走了 k1 圈，然后再次回到入口点，再走了 y 的距离到达相遇点和 fast 指针相遇。<br>t = x + k1 <em> n + y<br>fast 指针同理，fast 指针从 head 出发走了 x 的距离到达入口点，然后可能走了 k2 圈，然后再次回到入口点，再走了 y 的距离到达相遇点和 slow 指针相遇。<br>2t = x + k2 </em> n + y<br>上边两个等式做一个差，可以得到<br>t = (k2 - k1) <em> n<br>设 k = k2 - k1 ，那么 t = k </em> n。<br>把 t = k <em> n 代入到第一个式子 t = x + k1 </em> n + y 中。<br>k <em> n = x + k1 </em> n + y<br>移项，x = (k - k1) <em> n - y<br>取出一个 n 和 y 结合，x = (k - k1 - 1) </em> n + (n - y)<br>左边的含义就是从 head 到达入口点。<br>右边的含义， n - y 就是从相遇点到入口点的距离，(k - k1 - 1) * n 就是转 (k - k1 - 1) 圈。<br>左边右边的含义结合起来就是，从相遇点走到入口点，然后转 (k - k1 - 1) 圈后再次回到入口点的这段时间，刚好就等于从 head 走向入口点的时间。<br>所以代码的话，我们只需要 meet 指针从相遇点出发的同时，让 head 指针也出发， head 指针和 meet 指针相遇的位置就是入口点了。</p>
</blockquote>
<p>通过上面的数学解释，在回顾最开始的代码，就知道了原因所在。最开始就异步，两个指针的步数不一致，也就破坏了后续的推导证明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*ListNode slow = head;</span></span><br><span class="line"><span class="comment">    ListNode fast = head.next;</span></span><br><span class="line"><span class="comment">    while (slow != fast) &#123;</span></span><br><span class="line"><span class="comment">        if (fast == null || fast.next == null) &#123;</span></span><br><span class="line"><span class="comment">            return null;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        slow = slow.next;</span></span><br><span class="line"><span class="comment">        fast = fast.next.next;</span></span><br><span class="line"><span class="comment">        if(fast == slow)</span></span><br><span class="line"><span class="comment">            break;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    ListNode fast = head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这时候已经相遇</span></span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表</title>
    <url>/2019/11/26/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>来自Leetcode第141题环形链表</p>
<blockquote>
<p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。<br><a id="more"></a><br>示例 1：</p>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
</blockquote>
<hr>
<h4 id="丑陋的双指针"><a href="#丑陋的双指针" class="headerlink" title="丑陋的双指针"></a>丑陋的双指针</h4><p>用一个快指针，一个慢指针，快指针每次比慢指针多走1步，这样，如果有环的话两者迟早相遇。<br>但是写的时候循环条件选择不当，导致出现了3次空指针异常，最终加了几个if判断才过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    ListNode p1 = head,p2 = head;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="keyword">null</span> || p2.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        p2 = p2.next.next;</span><br><span class="line">        <span class="keyword">if</span> (p2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1.val == p2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>通过向哈希表里添加结点，每次询问是否包含此节点来判断是否成环.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Set&lt;ListNode&gt; map = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(head !=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.contains(head))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            map.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>来自<a href="https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2019/11/26/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>来源Leetcode第一题两数之和</p>
<blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br><a id="more"></a><br>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
</blockquote>
<hr>
<h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>暴力解法来自于2个半月之前，两轮循环遍历数组，找到目标元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>* res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numsSize; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums [j] == target) &#123;</span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">                res[<span class="number">1</span>] = j;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>来自于<a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/" target="_blank" rel="noopener">题解</a></p>
<p>建立哈希表存放元素值以及位置值，每次查找target - nums[i]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(complement))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(complement),i&#125;;</span><br><span class="line">        map.put(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="POJ上的两数之和"><a href="#POJ上的两数之和" class="headerlink" title="POJ上的两数之和"></a>POJ上的两数之和</h4><p>来自POJ2366题，提交WA，问题未知。</p>
<p>问题代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    	<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    	<span class="keyword">int</span> len1 = in.nextInt();</span><br><span class="line">    	<span class="keyword">int</span> [] A = <span class="keyword">new</span> <span class="keyword">int</span>[len1];</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">    		A[i] = in.nextInt();  <span class="comment">//数组A升序</span></span><br><span class="line">    	<span class="keyword">int</span> len2 = in.nextInt();</span><br><span class="line">    	<span class="keyword">int</span> [] B = <span class="keyword">new</span> <span class="keyword">int</span>[len2];</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len2;i++)</span><br><span class="line">    		B[i] = in.nextInt();  <span class="comment">//数组B降序</span></span><br><span class="line">		<span class="keyword">int</span> temp;</span><br><span class="line">		Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 + len2 ; i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> complement;</span><br><span class="line">			<span class="keyword">if</span>(i &gt;= len1)&#123;</span><br><span class="line">				temp = B[i - len1];</span><br><span class="line">				complement = <span class="number">10000</span> - temp;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				temp = A[i];</span><br><span class="line">				complement = <span class="number">10000</span> - A[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(map.containsKey(complement))&#123;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			map.put(temp,i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">			System.out.println(<span class="string">"YES"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			System.out.println(<span class="string">"NO"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>买股票的最佳时机II</title>
    <url>/2019/11/25/%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/</url>
    <content><![CDATA[<p>来源Leetcode第122题买股票的最佳时机II</p>
<blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br><a id="more"></a><br>示例 1:</p>
<p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>       随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
</blockquote>
<hr>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>同<a href="https://yorxika.github.io/2019/11/18/%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/">买股票的最佳时机III</a>，采用状态机模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h4><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<blockquote>
<p>在这种情况下，我们可以简单地继续在斜坡上爬升并持续增加从连续交易中获得的利润，而不是在谷之后寻找每个峰值。最后，我们将有效地使用峰值和谷值，但我们不需要跟踪峰值和谷值对应的成本以及最大利润，但我们可以直接继续增加加数组的连续数字之间的差值，如果第二个数字大于第一个数字，我们获得的总和将是最大利润。</p>
</blockquote>
<p>即遍历整个股票交易日价格列表 price，策略是所有上涨交易日都买卖（赚到所有利润），所有下降交易日都不买卖（永不亏钱）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>])</span><br><span class="line">            maxprofit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的深度</title>
    <url>/2019/11/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p>来自Leetcode第104题二叉树的深度</p>
<blockquote>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
</blockquote>
<h4 id="递归I"><a href="#递归I" class="headerlink" title="递归I"></a>递归I</h4><a id="more"></a>
<p>如果根结点不为空，递归遍历左右子树，并且深度+1，最后返回最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    backOrder(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        depth++;</span><br><span class="line">        max = Math.max(max, depth);</span><br><span class="line">        backOrder(root.left);</span><br><span class="line">        backOrder(root.right);</span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归II"><a href="#递归II" class="headerlink" title="递归II"></a>递归II</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="built_in">int</span> max<span class="constructor">Depth(TreeNode <span class="params">root</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (root<span class="operator"> == </span>null) &#123;</span><br><span class="line">     return <span class="number">0</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="built_in">int</span> left_height = max<span class="constructor">Depth(<span class="params">root</span>.<span class="params">left</span>)</span>;</span><br><span class="line">     <span class="built_in">int</span> right_height = max<span class="constructor">Depth(<span class="params">root</span>.<span class="params">right</span>)</span>;</span><br><span class="line">     return java.lang.<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(left_height, right_height) + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>来自<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode/" target="_blank" rel="noopener">题解</a>的评论区</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(TreeNode node,<span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">            <span class="keyword">this</span>.height = height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        Stack&lt;Pair&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.add(<span class="keyword">new</span> Pair(root,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            Pair pair = stack.pop();</span><br><span class="line">            TreeNode pop = pair.node;</span><br><span class="line">            depth = depth&gt;pair.height?depth:pair.height;</span><br><span class="line">            <span class="keyword">if</span>(pop.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.add(<span class="keyword">new</span> Pair(pop.right,pair.height+<span class="number">1</span>)); <span class="comment">//right先一步进入栈中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pop.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.add(<span class="keyword">new</span> Pair(pop.left,pair.height+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的层次遍历II</title>
    <url>/2019/11/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86II/</url>
    <content><![CDATA[<p>来自Leetcode第107题二叉树的层次遍历II</p>
<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<h4 id="Collections-reverse"><a href="#Collections-reverse" class="headerlink" title="Collections.reverse()"></a>Collections.reverse()<a id="more"></a></h4><p>最简单的是按照上一次的写法，加上Collections.reverse()即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">                  List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">          <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">          Queue&lt;TreeNode&gt; tree = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">          tree.add(root);</span><br><span class="line">          <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> ( !tree.isEmpty() ) &#123;</span><br><span class="line">              ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">              <span class="keyword">int</span> level_length = tree.size();</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level_length; ++i) &#123;</span><br><span class="line">                  TreeNode p1 = tree.remove();</span><br><span class="line">                  ans.get(level).add(p1.val);</span><br><span class="line">                  <span class="keyword">if</span> (p1.left != <span class="keyword">null</span>) tree.add(p1.left);</span><br><span class="line">                  <span class="keyword">if</span> (p1.right != <span class="keyword">null</span>) tree.add(p1.right);</span><br><span class="line">              &#125;</span><br><span class="line">              level++;</span><br><span class="line">          &#125;</span><br><span class="line">          Collections.reverse(ans);</span><br><span class="line">          <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>来自<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--23/" target="_blank" rel="noopener">题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    DFS(root, <span class="number">0</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode root, <span class="keyword">int</span> level, List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前层数还没有元素，先 new 一个空的列表</span></span><br><span class="line">    <span class="keyword">if</span> (ans.size() &lt;= level) &#123;</span><br><span class="line">        ans.add(<span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前值加入</span></span><br><span class="line">    ans.get(ans.size() - <span class="number">1</span> - level).add(root.val);</span><br><span class="line"></span><br><span class="line">    DFS(root.left, level + <span class="number">1</span>, ans);</span><br><span class="line">    DFS(root.right, level + <span class="number">1</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p>这个写法和102题没啥区别，就是把结点插在了头部，但是为啥用LinkedList的addfirst不行？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> levelNum = queue.size(); <span class="comment">// 当前层元素的个数</span></span><br><span class="line">        List&lt;Integer&gt; subList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelNum; i++) &#123;</span><br><span class="line">            TreeNode curNode = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (curNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                subList.add(curNode.val);</span><br><span class="line">                queue.offer(curNode.left);</span><br><span class="line">                queue.offer(curNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (subList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="number">0</span>, subList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的层次遍历</title>
    <url>/2019/11/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>来源Leetcode第102题二叉树的层次遍历</p>
<blockquote>
<p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>
</blockquote>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>习惯用栈写，出错了，遍历给出的顺序错了，应该改成队列的。<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; tree = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    tree.add(root);</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( !tree.isEmpty() ) &#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">int</span> level_length = tree.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level_length; ++i) &#123;</span><br><span class="line">            TreeNode p1 = tree.remove();</span><br><span class="line">            ans.get(level).add(p1.val);</span><br><span class="line">            <span class="keyword">if</span> (p1.left != <span class="keyword">null</span>) tree.add(p1.left);</span><br><span class="line">            <span class="keyword">if</span> (p1.right != <span class="keyword">null</span>) tree.add(p1.right);</span><br><span class="line">        &#125;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>摸了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    levelHelper(res, root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelHelper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, TreeNode root, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (height &gt;= res.size()) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    res.get(height).add(root.val);</span><br><span class="line">    levelHelper(res, root.left, height+<span class="number">1</span>);</span><br><span class="line">    levelHelper(res, root.right, height+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>对称二叉树</title>
    <url>/2019/11/24/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>来自Leetcode第101题对称二叉树</p>
<blockquote>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
</blockquote>
<hr>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isMirror(root, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (t1.val == t2.val)</span><br><span class="line">            &amp;&amp; isMirror(t1.right, t2.left)</span><br><span class="line">            &amp;&amp; isMirror(t1.left, t2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>来源<a href="https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<p>除了递归的方法外，我们也可以利用队列进行迭代。队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像。最初，队列中包含的是 root 以及 root。该算法的工作原理类似于 BFS，但存在一些关键差异。每次提取两个结点并比较它们的值。然后，将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p>
<p>业转载请联系作者获得授权，非商业转载请注明出处。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        TreeNode t1 = q.poll();</span><br><span class="line">        TreeNode t2 = q.poll();</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1.val != t2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        q.add(t1.left);</span><br><span class="line">        q.add(t2.right);</span><br><span class="line">        q.add(t1.right);</span><br><span class="line">        q.add(t2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>按自己思路写了一个，用栈的结构，效率低了好多。。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    stack.push(root);  <span class="comment">//根结点两次入栈，方便后续比较</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode t1 = stack.pop();  <span class="comment">//出栈</span></span><br><span class="line">        TreeNode t2 = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1.val != t2.val) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        stack.push(t1.left);  <span class="comment">//入栈</span></span><br><span class="line">        stack.push(t2.right);</span><br><span class="line">        stack.push(t1.right);</span><br><span class="line">        stack.push(t2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>复原IP地址</title>
    <url>/2019/11/23/%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<p>来自Leetcode第93题复原IP地址</p>
<blockquote>
<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>示例:</p>
<p>输入: “25525511135”<br>输出: [“255.255.11.135”, “255.255.111.35”]<a id="more"></a></p>
</blockquote>
<hr>
<h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>4层循环遍历解决所有情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    StringBuilder ip = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">1</span> ; a &lt; <span class="number">4</span> ; ++ a)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">1</span> ; b &lt; <span class="number">4</span> ; ++ b)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span> ; c &lt; <span class="number">4</span> ; ++ c)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span> ; d &lt; <span class="number">4</span> ; ++ d)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a + b + c + d == s.length() )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> n1 = Integer.parseInt(s.substring(<span class="number">0</span>, a));</span><br><span class="line">                        <span class="keyword">int</span> n2 = Integer.parseInt(s.substring(a, a+b));</span><br><span class="line">                        <span class="keyword">int</span> n3 = Integer.parseInt(s.substring(a+b, a+b+c));</span><br><span class="line">                        <span class="keyword">int</span> n4 = Integer.parseInt(s.substring(a+b+c));</span><br><span class="line">                        <span class="keyword">if</span>(n1 &lt;= <span class="number">255</span> &amp;&amp; n2 &lt;= <span class="number">255</span> &amp;&amp; n3 &lt;= <span class="number">255</span> &amp;&amp; n4 &lt;= <span class="number">255</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            ip.append(n1).append(<span class="string">'.'</span>).append(n2)</span><br><span class="line">                                    .append(<span class="string">'.'</span>).append(n3).append(<span class="string">'.'</span>).append(n4);</span><br><span class="line">                            <span class="keyword">if</span>(ip.length() == s.length() + <span class="number">3</span>) ret.add(ip.toString());</span><br><span class="line">                            ip.delete(<span class="number">0</span>, ip.length());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>来自<a href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/fu-yuan-ipdi-zhi-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<ul>
<li>遍历三个有效位置curr_pos 以放置点。<ul>
<li>检查从上一个点到现在点中间的部分是否有效 :</li>
<li>是 :<ul>
<li>放置该点。</li>
<li>检查全部 3个点是否放好:<ul>
<li>是 :<ul>
<li>将结果添加到输出列表中。</li>
</ul>
</li>
<li>否 :<ul>
<li>继续放下一个点 backtrack(curr_pos, dots - 1)。</li>
</ul>
</li>
</ul>
</li>
<li>回溯，移除最后一个点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"> String s;</span><br><span class="line"> LinkedList&lt;String&gt; segments = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"> ArrayList&lt;String&gt; output = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(String segment)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if the current segment is valid :</span></span><br><span class="line"><span class="comment">   1. less or equal to 255      </span></span><br><span class="line"><span class="comment">   2. the first character could be '0' </span></span><br><span class="line"><span class="comment">   only if the segment is equal to '0'</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">int</span> m = segment.length();</span><br><span class="line">   <span class="keyword">if</span> (m &gt; <span class="number">3</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">return</span> (segment.charAt(<span class="number">0</span>) != <span class="string">'0'</span>) ? (Integer.valueOf(segment) &lt;= <span class="number">255</span>) : (m == <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update_output</span><span class="params">(<span class="keyword">int</span> curr_pos)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   Append the current list of segments </span></span><br><span class="line"><span class="comment">   to the list of solutions</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   String segment = s.substring(curr_pos + <span class="number">1</span>, n);</span><br><span class="line">   <span class="keyword">if</span> (valid(segment)) &#123;</span><br><span class="line">     segments.add(segment);</span><br><span class="line">     output.add(String.join(<span class="string">"."</span>, segments));</span><br><span class="line">     segments.removeLast();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> prev_pos, <span class="keyword">int</span> dots)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   prev_pos : the position of the previously placed dot</span></span><br><span class="line"><span class="comment">   dots : number of dots to place</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="comment">// The current dot curr_pos could be placed </span></span><br><span class="line">   <span class="comment">// in a range from prev_pos + 1 to prev_pos + 4.</span></span><br><span class="line">   <span class="comment">// The dot couldn't be placed </span></span><br><span class="line">   <span class="comment">// after the last character in the string.</span></span><br><span class="line">   <span class="keyword">int</span> max_pos = Math.min(n - <span class="number">1</span>, prev_pos + <span class="number">4</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> curr_pos = prev_pos + <span class="number">1</span>; curr_pos &lt; max_pos; curr_pos++) &#123;</span><br><span class="line">     String segment = s.substring(prev_pos + <span class="number">1</span>, curr_pos + <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">if</span> (valid(segment)) &#123;</span><br><span class="line">       segments.add(segment);  <span class="comment">// place dot</span></span><br><span class="line">       <span class="keyword">if</span> (dots - <span class="number">1</span> == <span class="number">0</span>)      <span class="comment">// if all 3 dots are placed</span></span><br><span class="line">         update_output(curr_pos);  <span class="comment">// add the solution to output</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">         backtrack(curr_pos, dots - <span class="number">1</span>);  <span class="comment">// continue to place dots</span></span><br><span class="line">       segments.removeLast();  <span class="comment">// remove the last placed dot </span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="摸"><a href="#摸" class="headerlink" title="摸"></a>摸</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">public List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">    List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    int n = s.<span class="built_in">length</span>();</span><br><span class="line">    backtrack(<span class="number">0</span>, <span class="string">""</span>, <span class="number">4</span>, s, res, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void backtrack(int <span class="built_in">i</span>, String tmp, int flag, String s, List&lt;String&gt; res, int n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">i</span> == n &amp;&amp; flag == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(tmp.substring(<span class="number">0</span>, tmp.<span class="built_in">length</span>() - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="built_in">i</span>; <span class="built_in">j</span> &lt; <span class="built_in">i</span> + <span class="number">3</span>; <span class="built_in">j</span>++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">j</span> &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">i</span> == <span class="built_in">j</span> &amp;&amp; s.charAt(<span class="built_in">j</span>) == <span class="string">'0'</span>) &#123;</span><br><span class="line">                backtrack(<span class="built_in">j</span> + <span class="number">1</span>, tmp + s.charAt(<span class="built_in">j</span>) + <span class="string">"."</span>, flag - <span class="number">1</span>, s, res, n);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Integer.parseInt(s.substring(<span class="built_in">i</span>, <span class="built_in">j</span> + <span class="number">1</span>)) &lt;= <span class="number">255</span>)</span><br><span class="line">                backtrack(<span class="built_in">j</span> + <span class="number">1</span>, tmp + s.substring(<span class="built_in">i</span>, <span class="built_in">j</span> + <span class="number">1</span>) + <span class="string">"."</span>, flag - <span class="number">1</span>, s, res, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表II</title>
    <url>/2019/11/22/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/</url>
    <content><![CDATA[<p>来源Leetcode第92题反转链表II</p>
<blockquote>
<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL <a id="more"></a></p>
</blockquote>
<hr>
<h4 id="憨批写法"><a href="#憨批写法" class="headerlink" title="憨批写法"></a>憨批写法</h4><p>写的时候没考虑到一些特殊条件，用了太多的if了判断特殊情况，但是用时0ms，击败了100% hhh</p>
<p>思路就是找到要交换的部分，然后切开，交换那部分链表，在重新连接即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || m ==<span class="number">1</span> &amp;&amp; n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//找到前一个结点</span></span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p2 = p1.next;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        <span class="comment">//找到末尾结点</span></span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newHead,newCur;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">1</span>)</span><br><span class="line">        newHead = head;</span><br><span class="line">    <span class="keyword">else</span> newHead = p1.next;</span><br><span class="line">    newCur = p2;</span><br><span class="line">    p2 = p2.next;</span><br><span class="line">    newCur.next = <span class="keyword">null</span>;</span><br><span class="line">    newCur = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(m != <span class="number">1</span>)</span><br><span class="line">    p1.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(newHead != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode temp = newHead.next;</span><br><span class="line">        newHead.next = newCur;</span><br><span class="line">        newCur = newHead;</span><br><span class="line">        newHead = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">1</span>)</span><br><span class="line">        p1 = newCur;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p1.next = newCur;</span><br><span class="line">    <span class="keyword">while</span>(newCur.next != <span class="keyword">null</span>)</span><br><span class="line">        newCur = newCur.next;</span><br><span class="line">    newCur.next = p2;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="简洁"><a href="#简洁" class="headerlink" title="简洁"></a>简洁</h4><p>在<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/zhao-dao-mhao-jie-dian-de-qian-yi-ge-jie-dian-zai-/" target="_blank" rel="noopener">题解</a>里找到了一个写的相对比较简洁的代码，思路大概是差不多的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode tail = head;  <span class="comment">// tail 记录首个需要翻转的节点</span></span><br><span class="line">        ListNode pre = head;   <span class="comment">// pre 记录首个需要翻转的节点的前一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; ++i) <span class="comment">// 用 pre 记录翻转序列的前一个节点, tail 记录翻转序列的头一个节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre = tail;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n -= m; <span class="comment">// 新的 n 记录需要翻转的次数</span></span><br><span class="line">        ListNode sub_head = tail;  <span class="comment">// 记录需翻转的字串的头节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n-- != <span class="number">0</span>)&#123; <span class="comment">// 翻转子串</span></span><br><span class="line">            ListNode h = tail.next;</span><br><span class="line">            tail.next = h.next;</span><br><span class="line">            h.next = sub_head;</span><br><span class="line">            sub_head = h;</span><br><span class="line">            <span class="keyword">if</span>(m != <span class="number">1</span>) <span class="comment">// 若不是从第一个节点就开始翻转,则进行子串头节点的拼接操作</span></span><br><span class="line">                pre.next = sub_head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m != <span class="number">1</span>) <span class="comment">// 若不是从首节点开始翻转,直接返回原头结点</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">return</span> sub_head; <span class="comment">// 否则表示从首节点开始翻转,返回新的头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2019/11/22/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>来源Leetcode第206题反转链表</p>
<blockquote>
<p>反转一个单链表。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<a id="more"></a><br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
</blockquote>
<hr>
<h4 id="初次提交"><a href="#初次提交" class="headerlink" title="初次提交"></a>初次提交</h4><p>一开始做的时候直接想着把链表形成一个闭环，然后通过这个闭环从最后一个结点逐一找到前一个结点，提交后用时击败了5.75%的用户，在二重循环里浪费了太多的时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    ListNode p2;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    p1.next = head;</span><br><span class="line">    ListNode newHead = p1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len; i ++)&#123;</span><br><span class="line">        p2 = p1;</span><br><span class="line">        <span class="keyword">for</span>(;p2.next != p1;p2 = p2.next);</span><br><span class="line">        p2.next = head;</span><br><span class="line">        p1.next = p2;</span><br><span class="line">        <span class="keyword">if</span>(p2.next.next == p2)&#123;</span><br><span class="line">            p2.next.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode p1 = <span class="keyword">null</span>;</span><br><span class="line">    ListNode P2 = head;</span><br><span class="line">    <span class="keyword">while</span> (P2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode nextTemp = P2.next;</span><br><span class="line">        P2.next = p1;</span><br><span class="line">        p1 = P2;</span><br><span class="line">        P2 = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>来源<a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<p>假设链表是[1, 2, 3, 4, 5]从最底层最后一个reverseList(5)来看</p>
<ul>
<li>返回了5这个节点</li>
<li>reverseList(4)中</li>
<li>p为5</li>
<li>head.next.next = head 相当于 5 -&gt; 4</li>
<li>现在节点情况为 4 -&gt; 5 -&gt; 4</li>
<li>head.next = null,切断4 -&gt; 5 这一条，现在只有 5 -&gt; 4</li>
<li>返回（return）p为5，5 -&gt; 4</li>
<li>返回上一层reverseList(3)</li>
<li>处理完后返回的是4 -&gt; 3</li>
<li>依次向上</li>
</ul>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">public ListNode reverseList(ListNode<span class="built_in"> head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">(head</span> == null ||<span class="built_in"> head</span>.<span class="keyword">next</span> == null) <span class="keyword">return</span><span class="built_in"> head</span>;</span><br><span class="line">    ListNode p = reverseList<span class="built_in">(head</span>.<span class="keyword">next</span>);</span><br><span class="line">   <span class="built_in"> head</span>.<span class="keyword">next</span>.<span class="keyword">next</span> =<span class="built_in"> head</span>;</span><br><span class="line">   <span class="built_in"> head</span>.<span class="keyword">next</span> = null;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>格雷编码</title>
    <url>/2019/11/22/%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>来源Leetcode第89题格雷编码</p>
<blockquote>
<p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p>
<p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。<a id="more"></a></p>
</blockquote>
<hr>
<h4 id="套公式"><a href="#套公式" class="headerlink" title="套公式"></a>套公式</h4><p>其实看题目描述会吐槽这是什么玩意，但是格雷码是数电里出现过的。<br>数电第一章1.4.2节格雷码公式：<br>设二进制数B = Bn-1 Bn-2 …… B1 B0<br>则其格雷码 G = Gn-1 Gn-2 …… G1 G0<br>且 Gn-1 = Bn-1<br>   Gi = Bi+1 ^ Bi<br>即最高位保留，其它位是当前位和它的高一位进行异或操作。<br>而在这题中，题目是输入 n 代表n位二进制位，输出其编码系统。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>&lt;&lt;n; ++i)</span><br><span class="line">        ret.add(i ^ i&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>解码方法</title>
    <url>/2019/11/21/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>来源Leetcode第91题解码方法</p>
<blockquote>
<p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>给定一个只包含数字的非空字符串，请计算解码方法的总数。<a id="more"></a></p>
<p>示例 1:</p>
<p>输入: “12”<br>输出: 2<br>解释: 它可以解码为 “AB”（1 2）或者 “L”（12）。</p>
</blockquote>
<hr>
<h4 id="自顶向下动态规划"><a href="#自顶向下动态规划" class="headerlink" title="自顶向下动态规划"></a>自顶向下动态规划</h4><p>一开始从前往后推的动态规划写错了，在处理当前位为“0”时没处理好，现在想想，如果当前位为“0”，那么dp[i] = dp[i - 2] 即可。<br>利用动态规划,dp[i]表示当前位置至往前的字符串共有多少种表示方式。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">    dp[len] = <span class="number">1</span> ; <span class="comment">//</span></span><br><span class="line">    <span class="comment">//如果最后一个数字不等于0，就初始化为1</span></span><br><span class="line">    <span class="keyword">if</span>(s.charAt(len - <span class="number">1</span>) != <span class="string">'0'</span>)</span><br><span class="line">        dp[len - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span> ; i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">'0'</span> )</span><br><span class="line">            <span class="comment">//当前数字为0，构成不了任何字母，跳过</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> ans1 = dp[i + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//保存后一串字符串的解码个数</span></span><br><span class="line">        <span class="keyword">int</span> ans2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ten = (s.charAt(i) - <span class="string">'0'</span>) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> one = s.charAt(i + <span class="number">1</span>) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(ten + one &lt;= <span class="number">26</span>)</span><br><span class="line">            ans2 = dp[i + <span class="number">2</span>];</span><br><span class="line">        dp[i] = ans1 + ans2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="自底向上动态规划"><a href="#自底向上动态规划" class="headerlink" title="自底向上动态规划"></a>自底向上动态规划</h4><p>这题的测试用例什么奇葩，给我整了那么多的边界条件，我人都傻了。<br>101 输出2<br>100 输出0<br>00 输出0<br>这题就是在疯狂测试边界条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)&#123;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((s.charAt(i - <span class="number">1</span>) == <span class="string">'2'</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">'1'</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">                    dp[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i] = dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == <span class="string">'0'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans1 = dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> ans2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ten = (s.charAt(i - <span class="number">1</span>) - <span class="string">'0'</span>) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> one = s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>( ten &gt; <span class="number">0</span> &amp;&amp; ten + one &lt;= <span class="number">26</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">                ans2 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> ans2 = dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = ans1 + ans2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划优化"><a href="#动态规划优化" class="headerlink" title="动态规划优化"></a>动态规划优化</h4><p>来源<a href="https://leetcode-cn.com/problems/decode-ways/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-2-3/" target="_blank" rel="noopener">题解</a></p>
<p>只需要 2 空间个就够了，更新的时候，指针移动一下即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> (s.charAt(len - <span class="number">1</span>) != <span class="string">'0'</span>) &#123;</span><br><span class="line">        cur = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">'0'</span>) &#123;</span><br><span class="line">            end = cur;<span class="comment">//end 前移</span></span><br><span class="line">            cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans1 = cur;</span><br><span class="line">        <span class="keyword">int</span> ans2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ten = (s.charAt(i) - <span class="string">'0'</span>) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> one = s.charAt(i + <span class="number">1</span>) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (ten + one &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">            ans2 = end;</span><br><span class="line">        &#125;</span><br><span class="line">        end = cur; <span class="comment">//end 前移</span></span><br><span class="line">        cur = ans1 + ans2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>子集</title>
    <url>/2019/11/21/%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<p>来源Leetcode第78题子集</p>
<blockquote>
<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。<br>示例:</p>
<p>输入: nums = [1,2,3]<br>输出:<a id="more"></a><br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p>
</blockquote>
<hr>
<h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>同第77题组合，修改第77题的代码，从1 组合到n即可。<br>注意要加上空集。</p>
<p>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">( <span class="keyword">int</span> first,ArrayList&lt;Integer&gt; curr,<span class="keyword">int</span> k,<span class="keyword">int</span> []nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.size() == k)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = first;i &lt;= nums.length - k + curr.size() + <span class="number">1</span> ; ++i) &#123;</span><br><span class="line">        curr.add(nums[i - <span class="number">1</span>]);</span><br><span class="line">        backtrack(i + <span class="number">1</span>, curr,k,nums);</span><br><span class="line">        curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> k,<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    backtrack(<span class="number">1</span>,<span class="keyword">new</span> ArrayList&lt;Integer&gt;(),k,nums);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</span><br><span class="line">        combine(i + <span class="number">1</span>,nums);</span><br><span class="line">    &#125;</span><br><span class="line">    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>思路来自<a href="https://leetcode-cn.com/problems/subsets/solution/hui-su-die-dai-wei-yan-ma-qing-xi-si-lu-zhu-xing-f/" target="_blank" rel="noopener">题解</a></p>
<p>对于[1,2,3][1,2,3]，可用三位二进制表示是否选择对应下标的数组元素。则有8种组合方式。</p>
<ul>
<li>初始化数组长度nn，最终结果的长度res_len=1&lt;&lt;n，此处位运算表示的是2^n。</li>
<li>对于每种结果，对于i在遍历区间[0,res_len)中:<ul>
<li>初始化中间结果cur=[]</li>
<li>从数组第一位到最后一位进行遍历，对于j在遍历区间[0,n)中：<ul>
<li>若满足条件i&gt;&gt;j&amp;1，表示第j位是否为1，若满足，则将该位元素加入中间结果cur中</li>
</ul>
</li>
<li>将cur加入res</li>
</ul>
</li>
<li>返回res</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span> &lt;&lt; len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((i &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                cur.add(nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>验证回文串</title>
    <url>/2019/11/21/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<p>来自Leetcode第125题验证回文串</p>
<blockquote>
<p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>说明：本题中，我们将空字符串定义为有效的回文串。<br><a id="more"></a><br>示例 1:</p>
<p>输入: “A man, a plan, a canal: Panama”<br>输出: true</p>
</blockquote>
<h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>头尾两个指针，遇到空格直接跳过，遇到大写字母转为小写字母比对即可。</p>
<p>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] cs = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="string">'0'</span> &lt;= cs[i] &amp;&amp; cs[i] &lt;= <span class="string">'9'</span>) || (<span class="string">'a'</span> &lt;= cs[i] &amp;&amp; cs[i] &lt;= <span class="string">'z'</span>)) &#123;</span><br><span class="line">            cs[cnt++] = cs[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= cs[i] &amp;&amp; cs[i] &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">            cs[cnt++] = (<span class="keyword">char</span>) (cs[i] - <span class="string">'A'</span> + <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt--;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; cnt) <span class="keyword">if</span> (cs[j++] != cs[cnt--]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
        <tag>回文</tag>
      </tags>
  </entry>
  <entry>
    <title>只出现一次的数字</title>
    <url>/2019/11/21/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>来源Leetcode第136题只出现一次的数字</p>
<blockquote>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？<br><a id="more"></a><br>示例 1:</p>
<p>输入: [2,2,1]<br>输出: 1</p>
</blockquote>
<hr>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>最开始是想用哈希表来做的，但是还是有点不熟，就用了一个链表，然而在查找结点，删除结点上花费了太多的时间复杂度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lenth = nums.length;</span><br><span class="line">    List&lt;Integer&gt; flag = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenth ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            flag.add(nums[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(flag.contains(nums[i]))&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = flag.indexOf(nums[i]);</span><br><span class="line">            flag.remove(pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            flag.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>利用快速排序，在一次遍历找到落单的元素，然而还是很慢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == nums.length - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[i + <span class="number">1</span>])</span><br><span class="line">            i +=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] != nums[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>来源<a href="https://leetcode-cn.com/problems/single-number/solution/xue-suan-fa-jie-guo-xiang-dui-yu-guo-cheng-bu-na-y/" target="_blank" rel="noopener">题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer i : nums) &#123;</span><br><span class="line">        Integer count = map.get(i);</span><br><span class="line">        count = count == <span class="keyword">null</span> ? <span class="number">1</span> : ++count;</span><br><span class="line">        map.put(i, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : map.keySet()) &#123;</span><br><span class="line">        Integer count = map.get(i);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// can't find it.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h4><p>在电路和汇编里见到过的，利用异或求单一的一个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (nums.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            ans = ans ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>哈希</tag>
        <tag>数学</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>十字路口信号灯</title>
    <url>/2019/11/20/%E5%8D%81%E5%AD%97%E8%B7%AF%E5%8F%A3%E4%BF%A1%E5%8F%B7%E7%81%AF/</url>
    <content><![CDATA[<p>有两条道路双向两个车道，即每条路每个方向只有一个车道，两条道路十字交叉。假设车辆只能向前直行，而不允许转弯和后退。如果有4辆车几乎同时到达这个十字路口，如图（a）所示；相互交叉地停下来，如图（b），此时4辆车都将不能继续向前，这是一个典型的死锁问题。从操作系统原理的资源分配观点，如果4辆车都想驶过十字路口，那么对资源的要求如下：<a id="more"></a></p>
<ul>
<li>向北行驶的车1需要象限a和b；</li>
<li>向西行驶的车2需要象限b和c；</li>
<li>向南行驶的车3需要象限c和d；</li>
<li>向东行驶的车4需要象限d和a。</li>
</ul>
<p><img src="https://img-blog.csdn.net/20161030120134081" alt></p>
<h4 id="双向同行"><a href="#双向同行" class="headerlink" title="双向同行"></a>双向同行</h4><p>上课的时候写的，允许同时双向通行，三向通行的先摸了</p>
<p>代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"pthreadVC2.lib"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	操作系统十字路口信号灯作业：</span></span><br><span class="line"><span class="comment">	目前仅支持南北方向或者东西方向同时通行</span></span><br><span class="line"><span class="comment">	采用3个信号灯判断，其中1个信号灯用于为东西方向或者南北方向的车辆抢占路口</span></span><br><span class="line"><span class="comment">	剩下2个信号灯表示某个方向有车辆到来</span></span><br><span class="line"><span class="comment">	利用随机数来模拟不同时刻从不同方向到达路口的车辆</span></span><br><span class="line"><span class="comment">	例：当东方向有车辆到来，此车辆是第一个到达路口的，占据了路口，每当东西方向有车辆过来就允许通行</span></span><br><span class="line"><span class="comment">	直到东西方向没有车辆到来，才允许南北方向的车辆通行</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	输入：为产生车辆的总数，设置最大值为65535</span></span><br><span class="line"><span class="comment">	输出：产生的随机车辆通过路口的情况</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//5个互斥信号灯</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex_road; <span class="comment">//道路信号灯</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex_we;  <span class="comment">//西到东方向信号灯</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex_ns; <span class="comment">//南北方向信号灯</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//进程数组，用于保存所有车辆进程</span></span><br><span class="line"><span class="keyword">pthread_t</span> car[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//车辆数计数</span></span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化南北方向和东西方向到达路口的车辆数</span></span><br><span class="line"><span class="keyword">int</span> numOfWE = <span class="number">0</span>, numOfNS = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前各个方向上的车辆ID</span></span><br><span class="line"><span class="comment">/*int current_north;</span></span><br><span class="line"><span class="comment">int current_south;</span></span><br><span class="line"><span class="comment">int current_east;</span></span><br><span class="line"><span class="comment">int current_west;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//车辆队列，用于描述从各个方向到达的车辆</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">pthread_t</span> thread[MAX];</span><br><span class="line">	<span class="keyword">int</span> num[MAX];  <span class="comment">//车辆序号</span></span><br><span class="line">	<span class="keyword">int</span> front; <span class="comment">//头指针</span></span><br><span class="line">	<span class="keyword">int</span> rear; <span class="comment">//尾指针</span></span><br><span class="line">	<span class="keyword">int</span> count; <span class="comment">//队列里的车辆数</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">queue</span>() &#123;</span><br><span class="line">		front = rear = count = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//车辆入队</span></span><br><span class="line">		count++;</span><br><span class="line">		rear = (rear + <span class="number">1</span>) % MAX;</span><br><span class="line">		num[rear] = n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;<span class="comment">//车辆出队</span></span><br><span class="line">		count--;</span><br><span class="line">		front = (front + <span class="number">1</span>) % MAX;</span><br><span class="line">		<span class="keyword">return</span> num[front];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4个方向的车辆队列</span></span><br><span class="line"><span class="built_in">queue</span> car_south;</span><br><span class="line"><span class="built_in">queue</span> car_east;</span><br><span class="line"><span class="built_in">queue</span> car_north;</span><br><span class="line"><span class="built_in">queue</span> car_west;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">car_from_west</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> current_west;</span><br><span class="line">	<span class="keyword">time_t</span> start, end;  <span class="comment">//计时变量</span></span><br><span class="line">	<span class="keyword">double</span> lastTimes;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (car_west.count &gt; <span class="number">0</span>)</span><br><span class="line">		 current_west = car_west.pop();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"第 %d  辆车从西方向到达路口\n"</span>, current_west);</span><br><span class="line"></span><br><span class="line">	start = clock();  <span class="comment">//开始计时</span></span><br><span class="line"></span><br><span class="line">	Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;mutex_we);</span><br><span class="line">	numOfWE++;</span><br><span class="line">	<span class="keyword">if</span>(numOfWE == <span class="number">1</span>)  <span class="comment">//东西方向到达路口的第一辆车先抢占道路</span></span><br><span class="line">		pthread_mutex_lock(&amp;mutex_road);</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex_we);</span><br><span class="line"></span><br><span class="line">	end = clock();</span><br><span class="line">	lastTimes = (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"第 %d  辆车从西方向到达路口等待了 %lfs 并从东方向离开路口\n"</span>, current_west,lastTimes);</span><br><span class="line">	pthread_mutex_lock(&amp;mutex_we);</span><br><span class="line">	numOfWE--;</span><br><span class="line">	<span class="keyword">if</span>(numOfWE == <span class="number">0</span>) <span class="comment">//如果东西方向上没有车了，解锁信号灯</span></span><br><span class="line">		pthread_mutex_unlock(&amp;mutex_road);</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex_we);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">car_from_east</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> current_east;</span><br><span class="line">	<span class="keyword">time_t</span> start, end;  <span class="comment">//计时变量</span></span><br><span class="line">	<span class="keyword">double</span> lastTimes;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (car_east.count &gt; <span class="number">0</span>)</span><br><span class="line">		current_east = car_east.pop();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"第 %d  辆车从东方向到达路口\n"</span>, current_east);</span><br><span class="line"></span><br><span class="line">	start = clock();  <span class="comment">//开始计时</span></span><br><span class="line"></span><br><span class="line">	Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;mutex_we);</span><br><span class="line">	numOfWE++;</span><br><span class="line">	<span class="keyword">if</span> (numOfWE == <span class="number">1</span>)  <span class="comment">//东西方向到达路口的第一辆车先抢占道路</span></span><br><span class="line">		pthread_mutex_lock(&amp;mutex_road);</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex_we);</span><br><span class="line"></span><br><span class="line">	end = clock();</span><br><span class="line">	lastTimes = (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"第 %d  辆车从东方向到达路口等待了 %lfs 并从西方向离开路口\n"</span>, current_east, lastTimes);</span><br><span class="line">	pthread_mutex_lock(&amp;mutex_we);</span><br><span class="line">	numOfWE--;</span><br><span class="line">	<span class="keyword">if</span> (numOfWE == <span class="number">0</span>) <span class="comment">//如果东西方向上没有车了，解锁信号灯</span></span><br><span class="line">		pthread_mutex_unlock(&amp;mutex_road);</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex_we);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">car_from_south</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> current_south;</span><br><span class="line">	<span class="keyword">time_t</span> start, end;  <span class="comment">//计时变量</span></span><br><span class="line">	<span class="keyword">double</span> lastTimes;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (car_south.count &gt; <span class="number">0</span>)</span><br><span class="line">		current_south = car_south.pop();</span><br><span class="line"></span><br><span class="line">	start = clock();  <span class="comment">//开始计时</span></span><br><span class="line"></span><br><span class="line">	Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"第 %d  辆车从南方向到达路口\n"</span>, current_south);</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;mutex_ns);</span><br><span class="line">	numOfNS++;</span><br><span class="line">	<span class="keyword">if</span> (numOfNS == <span class="number">1</span>)  <span class="comment">//南北方向到达路口的第一辆车先抢占道路</span></span><br><span class="line">		pthread_mutex_lock(&amp;mutex_road);</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex_ns);</span><br><span class="line"></span><br><span class="line">	end = clock();</span><br><span class="line">	lastTimes = (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"第 %d  辆车从南方向到达路口等待了 %lfs 并从北方向离开路口\n"</span>, current_south,lastTimes);</span><br><span class="line">	pthread_mutex_lock(&amp;mutex_ns);</span><br><span class="line">	numOfNS--;</span><br><span class="line">	<span class="keyword">if</span> (numOfNS == <span class="number">0</span>) <span class="comment">//如果南北方向上没有车了，解锁信号灯</span></span><br><span class="line">		pthread_mutex_unlock(&amp;mutex_road);</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex_ns);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">car_from_north</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> current_north;</span><br><span class="line">	<span class="keyword">time_t</span> start, end;  <span class="comment">//计时变量</span></span><br><span class="line">	<span class="keyword">double</span> lastTimes;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(car_north.count &gt; <span class="number">0</span>)</span><br><span class="line">		current_north = car_north.pop();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"第 %d  辆车从北方向到达路口\n"</span>, current_north);</span><br><span class="line"></span><br><span class="line">	start = clock();  <span class="comment">//开始计时</span></span><br><span class="line"></span><br><span class="line">	Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;mutex_ns);</span><br><span class="line">	numOfNS++;</span><br><span class="line">	<span class="keyword">if</span> (numOfNS == <span class="number">1</span>)  <span class="comment">//南北方向到达路口的第一辆车先抢占道路</span></span><br><span class="line">		pthread_mutex_lock(&amp;mutex_road);</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex_ns);</span><br><span class="line"></span><br><span class="line">	end = clock();</span><br><span class="line">	lastTimes = (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"第 %d  辆车从北方向到达路口等待了 %lfs 并从南方向离开路口\n"</span>, current_north,lastTimes);</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;mutex_ns);</span><br><span class="line">	numOfNS--;</span><br><span class="line">	<span class="keyword">if</span> (numOfNS == <span class="number">0</span>) <span class="comment">//如果南北方向上没有车了，解锁信号灯</span></span><br><span class="line">		pthread_mutex_unlock(&amp;mutex_road);</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex_ns);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化信号灯</span></span><br><span class="line">	pthread_mutex_init(&amp;mutex_road,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_mutex_init(&amp;mutex_we, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_mutex_init(&amp;mutex_ns, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*printf("\n以n表示从北方向到达路口的车辆，s表示南方，w表示西方，e表示东方");*/</span></span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入到达路口的车辆总数："</span>);</span><br><span class="line">	scanf_s(<span class="string">"%d"</span>, &amp;len);</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"开始产生随机车辆队列\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"--------------------------------------------------\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> Car = <span class="number">0</span>;  <span class="comment">//随机数用于标记产生的车辆是从哪个方向到达路口</span></span><br><span class="line">	<span class="comment">//创建线程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		Car = rand() % <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">switch</span> (Car)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: &#123;  <span class="comment">//0表示从西方向到达路口</span></span><br><span class="line">			car_west.push(i + <span class="number">1</span>);</span><br><span class="line">			car[size++] = car_west.thread[car_west.front];</span><br><span class="line">			pthread_create(&amp;car_west.thread[car_west.front],<span class="literal">NULL</span>, car_from_west, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: &#123;  <span class="comment">//1表示从东方向到达路口</span></span><br><span class="line">			car_east.push(i + <span class="number">1</span>);</span><br><span class="line">			car[size++] = car_east.thread[car_east.front];</span><br><span class="line">			pthread_create(&amp;car_east.thread[car_east.rear],<span class="literal">NULL</span>, car_from_east, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: &#123;  <span class="comment">//2表示从南方向到达路口</span></span><br><span class="line">			car_south.push(i + <span class="number">1</span>);</span><br><span class="line">			car[size++] = car_south.thread[car_south.rear];</span><br><span class="line">			pthread_create(&amp;car_south.thread[car_south.rear],<span class="literal">NULL</span>, car_from_south, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>: &#123;  <span class="comment">//3表示从北方向到达路口</span></span><br><span class="line">			car_north.push(i + <span class="number">1</span>);</span><br><span class="line">			car[size++] = car_north.thread[car_north.rear];</span><br><span class="line">			pthread_create(&amp;car_north.thread[car_north.rear],<span class="literal">NULL</span>, car_from_north, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//加入进程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		pthread_join(car[i], <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>颜色分类</title>
    <url>/2019/11/19/%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>来源Leetcode第75题颜色分类</p>
<blockquote>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>注意:<br>不能使用代码库中的排序函数来解决这道题。<br><a id="more"></a><br>示例:</p>
<p>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]</p>
</blockquote>
<hr>
<h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><p>直接调用库函数<code>Arrays.sort(nums);</code>就完事了</p>
<h4 id="2次遍历"><a href="#2次遍历" class="headerlink" title="2次遍历"></a>2次遍历</h4><p>一次遍历先统计3个球的总数，二次遍历重写数组</p>
<p>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> nums0 = <span class="number">0</span>,nums1 = <span class="number">0</span>,nums2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)</span><br><span class="line">            nums0++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)</span><br><span class="line">            nums1++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">2</span>)</span><br><span class="line">            nums2++;</span><br><span class="line">    &#125;</span><br><span class="line">    nums1 += nums0;</span><br><span class="line">    nums2 += nums1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; nums0)</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; nums1)</span><br><span class="line">            nums[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums[i] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。<br>沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。</p>
<ul>
<li>初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx &lt; p0] = 0.</li>
<li>初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx &gt; p2] = 2.</li>
<li>初始化当前考虑的元素序号 ：curr = 0.</li>
<li>While curr &lt;= p2 :<ul>
<li>若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。</li>
<li>若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。</li>
<li>若 nums[curr] = 1 ：将指针curr右移。</li>
</ul>
</li>
</ul>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">int</span> p0 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//0的边界指针</span></span><br><span class="line">      <span class="keyword">int</span> p2 = nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//2的边界指针</span></span><br><span class="line">      <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//当前数组指针</span></span><br><span class="line">      <span class="keyword">while</span>(cur &lt;= p2)&#123;</span><br><span class="line"><span class="comment">//3种交换情况</span></span><br><span class="line">          <span class="keyword">if</span>(nums[cur] == <span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">int</span> tmp = nums[p0];</span><br><span class="line">              nums[p0++] = nums[cur];</span><br><span class="line">              nums[cur++] = tmp;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[cur] == <span class="number">2</span>)&#123;</span><br><span class="line">              <span class="keyword">int</span> tmp = nums[p2];</span><br><span class="line">              nums[p2--] = nums[cur];</span><br><span class="line">              nums[cur] = tmp;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              cur++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>排序</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索二维矩阵</title>
    <url>/2019/11/19/%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>来源Leetcode第74题搜索二维矩阵</p>
<blockquote>
<p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ul>
<li>每行中的整数从左到右按升序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。<a id="more"></a><br>示例 1:</li>
</ul>
<p>输入:<br>matrix = [<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>target = 3<br>输出: true</p>
</blockquote>
<hr>
<h4 id="二分查找1"><a href="#二分查找1" class="headerlink" title="二分查找1"></a>二分查找1</h4><p>标准的二分查找模板，做这题时先想着确定所在行，最后在确定所在列。<br>提交的时候遇到了坑，对特殊情况的考虑不周全。</p>
<p>AC的代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>] == <span class="keyword">null</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> midRow ;</span><br><span class="line">    <span class="keyword">int</span> leftRow = <span class="number">0</span>, rightRow = row - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (leftRow &lt;= rightRow)&#123;</span><br><span class="line">        <span class="comment">//确定行号</span></span><br><span class="line">        midRow = (leftRow + rightRow) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix[midRow][<span class="number">0</span>] &lt;= target &amp;&amp; matrix[midRow][col - <span class="number">1</span>] &gt;= target)&#123;</span><br><span class="line">            <span class="keyword">int</span> midCol = <span class="number">0</span>;</span><br><span class="line">            leftRow = <span class="number">0</span>;</span><br><span class="line">            rightRow = col - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (leftRow &lt;= rightRow)&#123;</span><br><span class="line">                midCol = (leftRow + rightRow) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(matrix[midRow][midCol] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(matrix[midRow][midCol] &lt; target)&#123;</span><br><span class="line">                    leftRow = midCol + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    rightRow = midCol - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(matrix[midRow][col - <span class="number">1</span>] &lt; target)&#123;</span><br><span class="line">            leftRow = midRow + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[midRow][<span class="number">0</span>] &gt; target)&#123;</span><br><span class="line">            rightRow = midRow - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="压缩成为一维数组"><a href="#压缩成为一维数组" class="headerlink" title="压缩成为一维数组"></a>压缩成为一维数组</h4><p>来源<a href="https://leetcode-cn.com/problems/search-a-2d-matrix/solution/sou-suo-er-wei-ju-zhen-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<p>输入的 m x n 矩阵可以视为长度为 m x n的有序数组。<br>则row = idx // n ， col = idx % n。</p>
<p>算法：</p>
<ul>
<li>初始化左右序号，left = 0 和 right = m x n - 1。</li>
<li>While left &lt; right :<ul>
<li>选取虚数组最中间的序号作为中间序号: pivot_idx = (left + right) / 2。<ul>
<li>该序号对应于原矩阵中的 row = pivot_idx // n行 col = pivot_idx % n 列, 由此可以拿到中间元素pivot_element。该元素将虚数组分为两部分。</li>
<li>比较 pivot_element 与 target 以确定在哪一部分进行进一步查找。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 二分查找</span></span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> pivotIdx, pivotElement;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    pivotIdx = (left + right) / <span class="number">2</span>;</span><br><span class="line">    pivotElement = matrix[pivotIdx / n][pivotIdx % n];</span><br><span class="line">    <span class="keyword">if</span> (target == pivotElement) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (target &lt; pivotElement) right = pivotIdx - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> left = pivotIdx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="筛选法"><a href="#筛选法" class="headerlink" title="筛选法"></a>筛选法</h4><p>来源<a href="https://leetcode-cn.com/problems/search-a-2d-matrix/solution/java-shai-xuan-by-longchenghuang/" target="_blank" rel="noopener">题解</a></p>
<p>从右上角开始比对，如果大于target，就可以往左前进一列，如果小于target，就往下走一行。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从右上角开始，比较target与右上角的数据的大小，如果大于target，就可以往左进一行，如果小于target，就可以往下走一行</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;m &amp;&amp; j&gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &gt; target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>买股票的最佳时机III</title>
    <url>/2019/11/18/%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/</url>
    <content><![CDATA[<p>来源Leetcode第123题买股票的最佳时机III</p>
<blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<a id="more"></a></p>
<p>示例 1:</p>
<p>输入: [3,3,5,0,0,3,1,4]<br>输出: 6<br>解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p>
</blockquote>
<h4 id="状态机模板"><a href="#状态机模板" class="headerlink" title="状态机模板"></a>状态机模板</h4><p>解法来自<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/" target="_blank" rel="noopener">题解</a></p>
<p>采用一个3维数组dp[n][k][2]来标记股票的交易情况。<br>比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。<br>我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。</p>
<p>基础框架:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base case：</span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">0</span>] = dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">//因为 i 是从 <span class="number">0</span> 开始的，所以 i = <span class="number">-1</span> 意味着还没有开始，这时候的利润当然是 <span class="number">0</span> 。</span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">1</span>] = dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line">还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。</span><br><span class="line"></span><br><span class="line">状态转移方程：</span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">//解释：今天我没有持有股票，有两种可能：</span><br><span class="line">要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；</span><br><span class="line">要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">//解释：今天我持有着股票，有两种可能：</span><br><span class="line">要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；</span><br><span class="line">要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。</span><br></pre></td></tr></table></figure></p>
<p>那么构建的代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.length == <span class="number">0</span> || prices.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max_k = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][max_k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i  == <span class="number">0</span>) &#123; <span class="comment">/*处理 base case */</span></span><br><span class="line">                dp[i][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[i][k][<span class="number">1</span>] = - prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][k][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">0</span>], dp[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][k][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][k][<span class="number">1</span>], dp[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 穷举了 n × max_k × 2 个状态，正确。</span></span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][max_k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="状态机精简"><a href="#状态机精简" class="headerlink" title="状态机精简"></a>状态机精简</h4><p>用s0代表初始状态，初始时钱是 0。dp_i_1_1代表第一次买入后当前的钱，dp_i_1_0代表第一次卖出后当前的前，dp_i_2_1代表第二次买入后当前的钱，dp_i_2_0代表第二次卖出后当前的钱。</p>
<p>然后我们只需要更新每天的这四个状态即可。</p>
<p>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.length == <span class="number">0</span> || prices.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//进行初始化，第一天 dp_i_1_1 将股票买入，其他状态全部初始化为最小值</span></span><br><span class="line">    <span class="keyword">int</span> dp_i_1_1 = -prices[<span class="number">0</span>],dp_i_1_0 = Integer.MIN_VALUE,dp_i_2_1 = Integer.MIN_VALUE,dp_i_2_0 = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;++i) &#123;</span><br><span class="line">        dp_i_1_1 = Math.max(dp_i_1_1, -prices[i]); <span class="comment">//买入价格更低的股</span></span><br><span class="line">        dp_i_1_0 = Math.max(dp_i_1_0, dp_i_1_1+prices[i]); <span class="comment">//卖出当前股，或者不操作</span></span><br><span class="line">        dp_i_2_1 = Math.max(dp_i_2_1, dp_i_1_0-prices[i]); <span class="comment">//第二次买入，或者不操作</span></span><br><span class="line">        dp_i_2_0 = Math.max(dp_i_2_0, dp_i_2_1+prices[i]); <span class="comment">//第二次卖出，或者不操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(<span class="number">0</span>,dp_i_2_0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
        <tag>有限状态机</tag>
      </tags>
  </entry>
  <entry>
    <title>三角形最小路径和</title>
    <url>/2019/11/18/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<p>来源Leetcode第120题三角形最小路径和</p>
<blockquote>
<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：<br><a id="more"></a><br>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p>
</blockquote>
<hr>
<h4 id="自顶向下的动态规划"><a href="#自顶向下的动态规划" class="headerlink" title="自顶向下的动态规划"></a>自顶向下的动态规划</h4><p>首先先确定倒数第二层的最短路径，在依次往上推。<br>缺点就是用时有点长，用时13ms，击败了6.51%的用户</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(triangle.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minStep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = triangle.size() - <span class="number">2</span> ; i&gt;=<span class="number">0</span> ; i --)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; triangle.get(i).size(); j++) &#123;</span><br><span class="line">            minStep = Math.min(triangle.get(i + <span class="number">1</span>).get(j),triangle.get(i + <span class="number">1</span>).get(j + <span class="number">1</span>)) + triangle.get(i).get(j);</span><br><span class="line">            triangle.get(i).set(j,minStep);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="O-n-时间复杂度"><a href="#O-n-时间复杂度" class="headerlink" title="O(n)时间复杂度"></a>O(n)时间复杂度</h4><p>思路和上一个是一样的，但是就是因为开拓了O(n)的数组，可以大大缩短访问时间，减少了List的get访问次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = triangle.size();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) dp[i] = triangle.get(row - <span class="number">1</span>).get(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">            dp[j] = Math.min(dp[j], dp[j + <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>买卖股票的最佳时机</title>
    <url>/2019/11/18/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<p>来源Leetcode第121题买卖股票的最佳时机</p>
<blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。<br><a id="more"></a><br>示例 1:</p>
<p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p>
</blockquote>
<hr>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>和之前做的最长连续子序和一样，首先先将价格转化为对比前一天的利润，即 dp[i] = dp[i] - dp[i-1]，接着就转化为求连续最长子序和这个问题了。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.length == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> []dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; prices.length; i++)</span><br><span class="line">        dp[i] = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> thisSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">        thisSum += dp[i];</span><br><span class="line">        <span class="keyword">if</span>(thisSum &lt; <span class="number">0</span>)</span><br><span class="line">            thisSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(thisSum &gt; maxSum)</span><br><span class="line">            maxSum = thisSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h4><p>来自<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<p>对比我自己写的，我想复杂了。<br>求最大利润的话，只用求最大价格与最小价格之间的差即可，那么可以通过一次遍历求出数组里的最大利润。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; minprice)</span><br><span class="line">            minprice = prices[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit)</span><br><span class="line">            maxprofit = prices[i] - minprice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵置零</title>
    <url>/2019/11/18/%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/</url>
    <content><![CDATA[<p>来自Leetcode第73题矩阵置零</p>
<blockquote>
<p>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p>
</blockquote>
<h4 id="统计行列"><a href="#统计行列" class="headerlink" title="统计行列"></a>统计行列</h4><p>最开始是遍历写的，就不放上来了，统计需要置零的行与列，最后再统一置零<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> R = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> C = matrix[<span class="number">0</span>].length;</span><br><span class="line">    List&lt;Integer&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; cols = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记要设为零的行和列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                rows.add(i);</span><br><span class="line">                cols.add(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次遍历数组，并使用行和列集更新元素。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rows.contains(i) || cols.contains(j)) &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="0-1-空间复杂度"><a href="#0-1-空间复杂度" class="headerlink" title="0(1)空间复杂度"></a>0(1)空间复杂度</h4><p>来源<a href="https://leetcode-cn.com/problems/set-matrix-zeroes/solution/ju-zhen-zhi-ling-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<p>算法:</p>
<ul>
<li>遍历整个矩阵，如果 cell[i][j] == 0 就将第 i 行和第 j 列的第一个元素标记。</li>
<li>第一行和第一列的标记是相同的，都是 cell[0][0]，所以需要一个额外的变量告知第一列是否被标记，同时用 cell[0][0] 继续表示第一行的标记。</li>
<li>然后，从第二行第二列的元素开始遍历，如果第 r 行或者第 c 列被标记了，那么就将 cell[r][c] 设为 0。这里第一行和第一列的作用就相当于方法一中的 row_set 和 column_set 。 </li>
<li>然后我们检查是否 cell[0][0] == 0 ，如果是则赋值第一行的元素为零。</li>
<li>然后检查第一列是否被标记，如果是则赋值第一列的元素为零。</li>
</ul>
<h4 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h4><p>来源<a href="https://leetcode-cn.com/problems/set-matrix-zeroes/solution/javaji-bai-100ti-jie-by-chiyuxing-2/" target="_blank" rel="noopener">题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前一行为0标志</span></span><br><span class="line">    <span class="keyword">boolean</span> isLastRowZero = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i ++) &#123;</span><br><span class="line">        <span class="comment">// 当前行为0标志</span></span><br><span class="line">        <span class="keyword">boolean</span> isCurrRowZero = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                isCurrRowZero = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 纵向上一个值不是零，说明纵向第一次出现零，需要把纵向前面的值都置为零</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; matrix[i - <span class="number">1</span>][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k ++) &#123;</span><br><span class="line">                        matrix[k][j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 纵向上一个值如果为零，则把纵向的零延伸到此行</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; matrix[i - <span class="number">1</span>][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果上一行为零标志为真,则上一行这个位置置为零（纵向为零的判断在上面处理过，所以到这里才可以设置为0）</span></span><br><span class="line">            <span class="keyword">if</span> (isLastRowZero) &#123;</span><br><span class="line">                matrix[i - <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isLastRowZero = isCurrRowZero;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理最后一行为零的情况</span></span><br><span class="line">    <span class="keyword">if</span> (isLastRowZero) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].length; i ++) &#123;</span><br><span class="line">            matrix[matrix.length - <span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>爬楼梯</title>
    <url>/2019/11/16/%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<p>来源Leetcode第70题爬楼梯</p>
<blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。<a id="more"></a><br>示例 2：</p>
<p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
</blockquote>
<hr>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>标准的动态规划题，转移方程为dp[i] = dp[i - 1] + dp[i - 2];</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span> ; i &lt;= n ; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="题解里的花活"><a href="#题解里的花活" class="headerlink" title="题解里的花活"></a>题解里的花活</h4><p>在官方<a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode/" target="_blank" rel="noopener">题解</a>里还提到了斐波那契数、用矩阵求斐波那契数、斐波那契数公式，这些都在509题 斐波那契数里整了，就先略过了。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>不同路径II</title>
    <url>/2019/11/16/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</url>
    <content><![CDATA[<p>来源Leetcode第63题不同路径II</p>
<blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<a id="more"></a><br>网格中的障碍物和空位置分别用 1 和 0 来表示。<br>示例 1:</p>
<p>输入:<br>[<br>  [0,0,0],<br> [0,1,0],<br> [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li>
</ol>
</blockquote>
<hr>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>同62题一样，都是套的动态规划模板，当有障碍时dp直接设置为0就行</p>
<p>代码在前面两个for循环里可以优化，当flag == 1时，就可以直接break了，后续可以直接为0</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[obstacleGrid.length][obstacleGrid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; obstacleGrid.length ; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] != <span class="number">1</span> &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; obstacleGrid[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i] != <span class="number">1</span> &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span> &amp;&amp; flag == <span class="number">0</span>)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; obstacleGrid.length;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; obstacleGrid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j] != <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[obstacleGrid.length][obstacleGrid[<span class="number">0</span>].length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>不同路径</title>
    <url>/2019/11/15/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>来源Leetcode第62题不同路径</p>
<blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？<br><a id="more"></a><br>示例 1:</p>
<p>输入: m = 3, n = 2<br>输出: 3<br>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下</li>
<li>向右 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向右</li>
</ol>
</blockquote>
<hr>
<h4 id="二维动态规划"><a href="#二维动态规划" class="headerlink" title="二维动态规划"></a>二维动态规划</h4><p>同第64题，用dp[i][j]表示到第(i,j)位置时有多少种走法<br>则 dp[i][j] = dp[i - 1][j] + dp[i][j - 1];<br>同时初始化第一行和第一列的的值均为1即可。</p>
<p>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i ++ )</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m ; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; n ; j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="一维动态规划"><a href="#一维动态规划" class="headerlink" title="一维动态规划"></a>一维动态规划</h4><p>同64题，将列数设置为dp的数组长度，从行开始遍历，则当前位置的步数等于左边的步数 + 上一行同一列位置的步数 即为 dp[j] += dp[j-1] ;</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[j] += dp[j-<span class="number">1</span>] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h4><p>假设：向右走是1，向下走是2<br>可行的方案就变成了：112 121 211<br>到这里是不是就有点儿眼熟了？这不就是一串数字的排列组合问题吗！<br>m是多少，就有m-1个数字1；n是多少，就有n-1个数字2<br>所以，我们就用这样的方式，把一个虚假的路径问题转化成了一串只有1和2的数字排列组合问题</p>
<p>即最终解可表示为C(m + n - 2, m - 1)</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = n + m - <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">int</span> k = m - <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        res = res * (N - k + i) / i;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最小路径和</title>
    <url>/2019/11/15/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<p>来源Leetcode第64题最小路径和</p>
<blockquote>
<p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>示例:<br><a id="more"></a><br>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p>
</blockquote>
<hr>
<h4 id="二维动态规划"><a href="#二维动态规划" class="headerlink" title="二维动态规划"></a>二维动态规划</h4><p>采用一个二维数组dp[][]来标记到右下角时的最小路径。<br>则dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + arr[i][j],意为到第(i,j)个格子的最短路径等于从上方或者左边的格子的最短路径 加上 到当前格子所需的路径<br>这样的话只需对dp[][]做初始化即可。<br>最开始dp[0][0] = arr[0][0],作为左上角格子走的步数，接下来初始化第一行，第一行等于从左边走的路径加上arr[0][i],即 dp[0][i] = dp[0][i - 1] + grid[0][i]<br>同理初始化第一列为 dp[i][0] = dp[i-1][0] + grid[i][0];</p>
<p>这样的话写出的代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = grid.length;</span><br><span class="line">    <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(row == <span class="number">0</span> || col == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; row;i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; col ; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j&lt; col ; j++)</span><br><span class="line">            dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]) + grid[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="一维动态规划"><a href="#一维动态规划" class="headerlink" title="一维动态规划"></a>一维动态规划</h4><p>来源<a href="https://leetcode-cn.com/problems/minimum-path-sum/solution/zui-xiao-lu-jing-he-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<p>在上个解法中，我们可以用一个一维数组来代替二维数组，dp数组的大小和行大小相同。这是因为对于某个固定状态，只需要<strong>考虑下方和右侧</strong>的节点。首先初始化 dp数组最后一个元素是右下角的元素值，然后我们向左移更新每个 dp(j) 为：<br>dp[j] - min(dp[j],dp[j+1]) + arr[i][j]<br>我们对于每一行都重复这个过程，然后向上一行移动，计算完成后 dp(0) 就是最后的结果。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid[<span class="number">0</span>].length];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = grid.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = grid[<span class="number">0</span>].length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == grid.length - <span class="number">1</span> &amp;&amp; j != grid[<span class="number">0</span>].length - <span class="number">1</span>)</span><br><span class="line">   <span class="comment">//在最后一行的其他列，来自右边的路径</span></span><br><span class="line">                dp[j] = grid[i][j] +  dp[j + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">   <span class="comment">//上移到上一行</span></span><br><span class="line">                dp[j] = grid[i][j] + dp[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j != grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">   <span class="comment">//左移</span></span><br><span class="line">                dp[j] = grid[i][j] + Math.min(dp[j], dp[j + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[j] = grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="不用任何额外存储空间的动态规划"><a href="#不用任何额外存储空间的动态规划" class="headerlink" title="不用任何额外存储空间的动态规划"></a>不用任何额外存储空间的动态规划</h4><p>同二维一致，不过是在原数组上存储，grid[i][j] = grid[i][j] + mid(grid[i-1][j],grid[i][j-1])</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = grid.length;</span><br><span class="line">    <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; row ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; col ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>)</span><br><span class="line">                grid[i][j] = grid[i][j] + grid[i][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>)</span><br><span class="line">                grid[i][j] = grid[i][j] + grid[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j != <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>)</span><br><span class="line">                grid[i][j] = grid[i][j] + Math.min(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列</title>
    <url>/2019/11/14/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>来源Leetcode第509题斐波那契数列</p>
<blockquote>
<p>斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>给定 N，计算 F(N)。<br><a id="more"></a><br>示例 1：</p>
<p>输入：2<br>输出：1</p>
<h2 id="解释：F-2-F-1-F-0-1-0-1"><a href="#解释：F-2-F-1-F-0-1-0-1" class="headerlink" title="解释：F(2) = F(1) + F(0) = 1 + 0 = 1."></a>解释：F(2) = F(1) + F(0) = 1 + 0 = 1.</h2></blockquote>
<h4 id="递归公式"><a href="#递归公式" class="headerlink" title="递归公式"></a>递归公式</h4><p>就按公式来呗，用长度为3的数组保存</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] FIB = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(N-- &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        FIB[<span class="number">1</span>] = FIB[<span class="number">0</span>] + FIB[<span class="number">1</span>];</span><br><span class="line">        FIB[<span class="number">0</span>] = FIB[<span class="number">1</span>] - FIB[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> FIB[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h4><p>提前存好结果，查表输出结果</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] FIB = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">144</span>,<span class="number">233</span>,<span class="number">377</span>,<span class="number">610</span>,<span class="number">987</span>,<span class="number">1597</span>,<span class="number">2584</span>,<span class="number">4181</span>,<span class="number">6765</span>,<span class="number">10946</span>,<span class="number">17711</span>,<span class="number">28657</span>,<span class="number">46368</span>,<span class="number">75025</span>,<span class="number">121393</span>,<span class="number">196418</span>,<span class="number">317811</span>,<span class="number">514229</span>,<span class="number">832040</span>,<span class="number">1346269</span>,<span class="number">2178309</span>,<span class="number">3524578</span>,<span class="number">5702887</span>,<span class="number">9227465</span>,<span class="number">14930352</span>,<span class="number">24157817</span>,<span class="number">39088169</span>,<span class="number">63245986</span>,<span class="number">102334155</span>,<span class="number">165580141</span>,<span class="number">267914296</span>,<span class="number">433494437</span>,<span class="number">701408733</span>,<span class="number">1134903170</span>,<span class="number">1836311903</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> FIB[N-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h4><p>来源于上学期做的一个电路小实验</p>
<p>斐波那契(Fibonacci)数列中每项数值都是其两个直接前项的和，其生成规则如下公式1所示：</p>
<div align="center">
<img width="600" src="https://pic.leetcode-cn.com/29ce09975fddbb57caa6c3b2f238dd7b2da45ba976aa748b7c9e82c770716ee1-2.jpg">
</div>

<p>1.求Fibonacci数的矩阵算法<br>  首先，对于数列的初始条件对应公式2的矩阵运算：<br>   <div align="center">
<img width="600" src="https://pic.leetcode-cn.com/32e6f5abec0d264956f93cb345a9d1ff516a851039b19fd5cc464c3d0f53e523-3.jpg">
</div></p>
<p>   更一般化地，有公式3：<br> <div align="center">
<img width="600" src="https://pic.leetcode-cn.com/4d62f2d3b268eb9a3a8906c6d2b5473bc7e176ead6fbac2089c98313149a6394-4.jpg">
</div><br>   所以，根据递推关系可以得到公式4：<br>  <div align="center">
<img width="600" src="https://pic.leetcode-cn.com/ee83089756860a33fe029da4d147a92e3ff9b9f7643d73e254c35df4fd3a8e57-5.jpg">
</div><br> <div align="center">
<img width="600" src="https://pic.leetcode-cn.com/bf0e8c007d27ee7b7247bd1601b296d3f656ac9a9fdef01e24f9aaef1861b4ab-7.jpg">
</div></p>
<p>2.算法描述</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Fibonacci()&#123;</span><br><span class="line"><span class="keyword">For</span> (<span class="attribute">i</span>=5 downto 0)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="attribute">Start</span>==0) then </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span> (n[i]==1) then <span class="attribute">Start</span>=1; </span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">Else</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span> (n[i]==1) </span><br><span class="line">then <span class="attribute">X</span>=X2•A; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> <span class="attribute">X</span>=X2; &#125;</span><br><span class="line">&#125;</span><br><span class="line">return(X);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] X = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span>[][] A = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    String bin_n = Integer.toBinaryString(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bin_n.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(start == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bin_n.charAt(i) == <span class="string">'1'</span>)</span><br><span class="line">                start = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(bin_n.charAt(i) == <span class="string">'1'</span>) &#123;</span><br><span class="line">                X = multiplyPower(X, <span class="number">2</span>);</span><br><span class="line">                X = multiply(X,A);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                X = multiplyPower(X, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> X[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵快速幂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] multiply(<span class="keyword">int</span> [][]a,<span class="keyword">int</span>[][]b)&#123;</span><br><span class="line">        <span class="keyword">int</span>[][]arr=<span class="keyword">new</span> <span class="keyword">int</span>[a.length][b[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;a[<span class="number">0</span>].length;k++)&#123;</span><br><span class="line">                    arr[i][j]+=a[i][k]*b[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] multiplyPower(<span class="keyword">int</span>[][]a,<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] res=<span class="keyword">new</span> <span class="keyword">int</span>[a.length][a[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;res[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j)</span><br><span class="line">                    res[i][j]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">                res=multiply(res,a);</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            a=multiply(a,a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>组合</title>
    <url>/2019/11/13/%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p>来源Leetcode第77题组合</p>
<blockquote>
<p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>示例:</p>
<p>输入: n = 4, k = 2<br>输出:<a id="more"></a><br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p>
</blockquote>
<hr>
<h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>首先遍历从 first 到 n 的所有整数，将整数 i 添加到现有组合 curr 中，然后继续回溯向组合中添加更多整数，当组合完成，添加到输出中，并移去 i ，实现回溯。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> totals;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; output = <span class="keyword">new</span> LinkedList();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">( <span class="keyword">int</span> first,LinkedList&lt;Integer&gt; curr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.size() == totals)</span><br><span class="line">        output.add(<span class="keyword">new</span> LinkedList(curr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = first;i &lt; n + <span class="number">1</span> ; ++i) &#123;</span><br><span class="line">        curr.add(i);</span><br><span class="line">        backtrack(i + <span class="number">1</span>, curr);</span><br><span class="line">        curr.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    totals = k;</span><br><span class="line">    backtrack(<span class="number">1</span>,<span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><p>优化for循环，没必要遍历到 n ，而是遍历到 n - k + output.size + 1,k - temp.size ( ) 代表我们还需要的数字个数。因为我们最后取到了 n，所以还要加 1。</p>
<p>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> totals;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">( <span class="keyword">int</span> first,ArrayList&lt;Integer&gt; curr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.size() == totals)&#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = first;i &lt;= n - totals + curr.size() + <span class="number">1</span> ; ++i) &#123;</span><br><span class="line">        curr.add(i);</span><br><span class="line">        backtrack(i + <span class="number">1</span>, curr);</span><br><span class="line">        curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    totals = k;</span><br><span class="line">    backtrack(<span class="number">1</span>,<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>来源于<a href="https://leetcode-cn.com/problems/combinations/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-1-9/" target="_blank" rel="noopener">题解</a></p>
<p>完全按照解回溯的思想改成迭代。我们思考一下，回溯其实有三个过程。</p>
<ul>
<li>for 循环结束，也就是 i == n + 1，然后回到上一层的 for 循环</li>
<li>temp.size() == k，也就是所需要的数字够了，然后把它加入到结果中。</li>
<li>每个 for 循环里边，进入递归，添加下一个数字</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        temp.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        temp.set(i, temp.get(i)+ <span class="number">1</span>); <span class="comment">//当前数字加 1</span></span><br><span class="line">        <span class="comment">//当前数字大于 n，对应回溯法的 i == n + 1，然后回到上一层</span></span><br><span class="line">        <span class="keyword">if</span> (temp.get(i) &gt; n) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        <span class="comment">// 当前数字个数够了</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == k - <span class="number">1</span>) &#123; </span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        <span class="comment">//进入更新下一个数字</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">//把下一个数字置为上一个数字，类似于回溯法中的 start</span></span><br><span class="line">            temp.set(i, temp.get(i-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代II"><a href="#迭代II" class="headerlink" title="迭代II"></a>迭代II</h4><p>来源于<a href="https://leetcode-cn.com/problems/combinations/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-1-9/" target="_blank" rel="noopener">题解</a></p>
<p>找 k 个数，我们可以先找出 1 个的所有结果，然后在 1 个的所有结果再添加 1 个数，变成 2 个，然后依次迭代，直到有 k 个数。</p>
<div align="center">
<img width="700" src="https://pic.leetcode-cn.com/363a6d288eecc5a6a3d78f78a0895aacc3e3f5388b20256e914ddeaf0d58c3ca-image.png">
</div>

<p>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || k == <span class="number">0</span> || k &gt; n) <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="comment">//个数为 1 的所有可能</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span> - k; i++) res.add(Arrays.asList(i));</span><br><span class="line">    <span class="comment">//第一层循环，从 2 到 k</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; tmp = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">//第二层循环，遍历之前所有的结果</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : res) &#123;</span><br><span class="line">            <span class="comment">//第三次循环，对每个结果进行扩展</span></span><br><span class="line">            <span class="comment">//从最后一个元素加 1 开始，然后不是到 n ，而是和解法一的优化一样</span></span><br><span class="line">            <span class="comment">//(k - (i - 1） 代表当前已经有的个数，最后再加 1 是因为取了 n</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = list.get(list.size() - <span class="number">1</span>) + <span class="number">1</span>; m &lt;= n - (k - (i - <span class="number">1</span>)) + <span class="number">1</span>; m++) &#123;</span><br><span class="line">                List&lt;Integer&gt; newList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(list);</span><br><span class="line">                newList.add(m);</span><br><span class="line">                tmp.add(newList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="组合公式"><a href="#组合公式" class="headerlink" title="组合公式"></a>组合公式</h4><p>C ( n, k ) = C ( n - 1, k - 1) + C ( n - 1, k )<br>从 n 个数字选 k 个，我们把所有结果分为两种，包含第 n 个数和不包含第 n 个数。这样的话，就可以把问题转换成：</p>
<ul>
<li>从 n - 1 里边选 k - 1 个，然后每个结果加上 n</li>
<li>从 n - 1 个里边直接选 k 个。</li>
</ul>
<p>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == n || k == <span class="number">0</span>) &#123;</span><br><span class="line">        List&lt;Integer&gt; row = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            row.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(row));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n - 1 里边选 k - 1 个</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = combine(n - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//每个结果加上 n</span></span><br><span class="line">    result.forEach(e -&gt; e.add(n));</span><br><span class="line">    <span class="comment">//把 n - 1 个选 k 个的结果也加入</span></span><br><span class="line">    result.addAll(combine(n - <span class="number">1</span>, k));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>插入区间</title>
    <url>/2019/11/12/%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<p>来源Leetcode第57题插入区间</p>
<blockquote>
<p>给出一个无重叠的 ，按照区间起始端点排序的区间列表。</p>
<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。<br><a id="more"></a><br>示例 1:</p>
<p>输入: intervals = [[1,3],[6,9]], newInterval = [2,5]<br>输出: [[1,5],[6,9]]</p>
</blockquote>
<hr>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>同合并区间，就是要注意当intervals为空时，可以直接返回newInterval</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span> []&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans.add(newInterval);</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> [][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length + <span class="number">1</span>][<span class="number">2</span>] ;</span><br><span class="line">    System.arraycopy(intervals,<span class="number">0</span>,matrix,<span class="number">0</span>,intervals.length);</span><br><span class="line">    matrix[intervals.length] = newInterval;</span><br><span class="line">    <span class="comment">//根据二维数组第一个数字大小按每一行整体排序</span></span><br><span class="line">    Arrays.sort(matrix, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] ints, <span class="keyword">int</span>[] t1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ints[<span class="number">0</span>] - t1[<span class="number">0</span>] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; matrix.length)&#123;</span><br><span class="line">        <span class="keyword">int</span> left = matrix[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = matrix[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//合并区间，判断right 是否比下一个区间的左值大</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; matrix.length  &amp;&amp; right&gt;= matrix[i][<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="comment">//重新对right赋值</span></span><br><span class="line">            right = Math.max(right,matrix[i][<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;left,right&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入后合并"><a href="#插入后合并" class="headerlink" title="插入后合并"></a>插入后合并</h4><p>注意到初始数组是<strong>无重叠的 ，按照区间起始端点排序的</strong>，因而可以先找到要插入的地方，然后前后合并即可。<br>具体思路见注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先通过二分查找找到要插入的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">midSearch</span><span class="params">(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = intervals.length;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (start&lt;end)&#123;</span><br><span class="line">            mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(intervals[mid][<span class="number">0</span>]&lt;newInterval[<span class="number">0</span>])</span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//计数，计算合并多少了个区间</span></span><br><span class="line">        <span class="keyword">int</span>[] buffer = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        buffer[<span class="number">0</span>] = newInterval[<span class="number">0</span>];</span><br><span class="line">        buffer[<span class="number">1</span>] = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> place = midSearch(intervals,newInterval);<span class="comment">//找到插入位置</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">//向后合并</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(temp = place;temp&lt;intervals.length;temp++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(buffer[<span class="number">1</span>]&lt;intervals[temp][<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这时候temp如果不和place相等，说明插入的区间的右值比后续若干区间的左值都大</span></span><br><span class="line">        <span class="comment">//这时候要更新新的区间右值</span></span><br><span class="line">        <span class="keyword">if</span>(temp!=place)&#123;</span><br><span class="line">            buffer[<span class="number">1</span>] = Math.max(intervals[temp-<span class="number">1</span>][<span class="number">1</span>],buffer[<span class="number">1</span>]);</span><br><span class="line">            count += temp - place;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向前合并</span></span><br><span class="line">        <span class="keyword">if</span> (place!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//如果插入点前一位置的右值比插入区间的左值大</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[place-<span class="number">1</span>][<span class="number">1</span>]&gt;=buffer[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">//那么更新合并区间的左值和右值</span></span><br><span class="line">                buffer[<span class="number">0</span>] = intervals[place-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                buffer[<span class="number">1</span>] = Math.max(intervals[place-<span class="number">1</span>][<span class="number">1</span>],buffer[<span class="number">1</span>]);</span><br><span class="line">                <span class="comment">//同时插入点倒退，合并数+1；</span></span><br><span class="line">                place--;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//储存结果</span></span><br><span class="line">        <span class="keyword">int</span> target;</span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length - count + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(target = <span class="number">0</span>;target&lt;place;target++)&#123;</span><br><span class="line">            result[target][<span class="number">0</span>] = intervals[target][<span class="number">0</span>];</span><br><span class="line">            result[target][<span class="number">1</span>] = intervals[target][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        result[target][<span class="number">0</span>] = buffer[<span class="number">0</span>];</span><br><span class="line">        result[target][<span class="number">1</span>] = buffer[<span class="number">1</span>];</span><br><span class="line">        target++;</span><br><span class="line">        <span class="keyword">for</span>(;temp&lt;intervals.length;temp++,target++)&#123;</span><br><span class="line">            result[target][<span class="number">0</span>] = intervals[temp][<span class="number">0</span>];</span><br><span class="line">            result[target][<span class="number">1</span>] = intervals[temp][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常规思考"><a href="#常规思考" class="headerlink" title="常规思考"></a>常规思考</h4><p>来自<a href="https://leetcode-cn.com/problems/insert-interval/solution/chang-gui-si-kao-by-powcai/" target="_blank" rel="noopener">题解</a></p>
<blockquote>
<p>先考虑三种极端情况：</p>
<ul>
<li>intervals为空</li>
<li>newInterval[1] &lt; intervals[0][0],直接插入第一个位置</li>
<li>newInterval[0] &gt; intervals[-1][1],直接插入最后一个位置</li>
</ul>
<p>下面就要考虑重叠情况了</p>
<p>我们目标就是找到和newInterval相关那几个区间.</p>
<p>首先,左边,当newInterval[0] &gt; intervals[i][1]说明没有和该区间没有重叠部分,继续遍历下一个区间,比如intervals = [[1,3],[6,9]], newInterval = [2,5]</p>
<p>然后,再看右边,这里有个情况,就是 当intervals[i][0] &gt; newInterval[1]说明newInterval没有和任何区间重合,比如intervals = [[1,3],[6,9]], newInterval = [4,5],直接插入即可.</p>
<p>接下来我们要找右边重合区域,当while i &lt; n and newInterval[1] &gt;= intervals[i][0]说明有重叠部分,记录左边最大值!</p>
<p>最后把数组拼接一下即可!</p>
</blockquote>
<p>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">       List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; intervals.length &amp;&amp; newInterval[<span class="number">0</span>] &gt; intervals[i][<span class="number">1</span>]) &#123;</span><br><span class="line">            res.add(intervals[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newInterval[<span class="number">0</span>], newInterval[<span class="number">1</span>]&#125;;</span><br><span class="line">		<span class="comment">//合并右边</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; intervals.length &amp;&amp; newInterval[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">            tmp[<span class="number">0</span>] = Math.min(tmp[<span class="number">0</span>], intervals[i][<span class="number">0</span>]);</span><br><span class="line">            tmp[<span class="number">1</span>] = Math.max(tmp[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(tmp);</span><br><span class="line">		<span class="comment">//添加剩余部分</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; intervals.length) &#123;</span><br><span class="line">            res.add(intervals[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>排序</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>螺旋矩阵II</title>
    <url>/2019/11/12/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/</url>
    <content><![CDATA[<p>来源Leetcode第59题螺旋矩阵II</p>
<blockquote>
<p>给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
<p>示例:<br><a id="more"></a><br>输入: 3<br>输出:<br>[<br> [ 1, 2, 3 ],<br> [ 8, 9, 4 ],<br> [ 7, 6, 5 ]<br>]</p>
</blockquote>
<hr>
<h4 id="层填充"><a href="#层填充" class="headerlink" title="层填充"></a>层填充</h4><p>思路和54题是一样的</p>
<p>对于每层，我们从左上方开始以顺时针的顺序填充所有元素，假设当前层左上角坐标是 (r1, c1)，右下角坐标是 (r2, c2)。</p>
<p>首先，遍历上方的所有元素 (r1, c)，按照 c = c1,…,c2 的顺序。然后遍历右侧的所有元素 (r, c2)，按照r = r1+1,…,r2 的顺序。如果这一层有四条边（也就是 r1 &lt; r2 并且 c1 &lt; c2 ），我们以下图所示的方式遍历下方的元素和左侧的元素。</p>
<div align="center">
<img width="700" src="https://pic.leetcode-cn.com/21f4b738d3a221048ab021a8c663083b51c76a2d922c91019d6b5f514881688b-54_spiralmatrix.png">
</div>

<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> [][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> r1 = <span class="number">0</span>, r2 = matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c1 = <span class="number">0</span>, c2 = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = c1; c &lt;= c2; c++) &#123;</span><br><span class="line">            matrix[r1][c] = count;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = r1 + <span class="number">1</span>; r &lt;= r2; r++) &#123;</span><br><span class="line">            matrix[r][c2] = count;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r1 &lt; r2 &amp;&amp; c1 &lt; c2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = c2 - <span class="number">1</span>; c &gt; c1; c--) &#123;</span><br><span class="line">                matrix[r2][c] = count;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = r2; r &gt; r1; r--) &#123;</span><br><span class="line">                matrix[r][c1] = count;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r1++;</span><br><span class="line">        r2--;</span><br><span class="line">        c1++;</span><br><span class="line">        c2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><blockquote>
<p>绘制螺旋轨迹路径，我们发现当路径超出界限或者进入之前访问过的单元格时，会顺时针旋转方向。<br>假设数组有 R 行 C 列，seen[r][c] 表示第 r 行第 c 列的单元格之前已经被访问过了。当前所在位置为 (r, c)，前进方向是 di。我们希望访问所有 R x C 个单元格。<br>当我们遍历整个矩阵，下一步候选移动位置是 (cr, cc)。如果这个候选位置在矩阵范围内并且没有被访问过，那么它将会变成下一步移动的位置；否则，我们将前进方向顺时针旋转之后再计算下一步的移动位置。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> [][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4次转向的方向</span></span><br><span class="line">    <span class="keyword">int</span> [] dir_i = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> [] dir_j = &#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//定义行数和列数</span></span><br><span class="line">    <span class="keyword">int</span> row = n;</span><br><span class="line">    <span class="keyword">int</span> cols = n;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">// 方向索引</span></span><br><span class="line">    <span class="keyword">int</span> pos_i = <span class="number">0</span>, pos_j = -<span class="number">1</span> ; <span class="comment">//位置索引</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; n * n + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//获得当前遍历行或列的长度</span></span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span> || index == <span class="number">2</span>)</span><br><span class="line">            len = cols;</span><br><span class="line">        <span class="keyword">else</span> len = row;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            <span class="comment">//遍历行or列</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算当前位置</span></span><br><span class="line">            pos_i = pos_i + dir_i[index];</span><br><span class="line">            pos_j = pos_j + dir_j[index];</span><br><span class="line">            matrix[pos_i][pos_j] = count;</span><br><span class="line">            count ++ ;</span><br><span class="line">            <span class="keyword">if</span>(count == n * n + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> matrix;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span> || index == <span class="number">2</span>)</span><br><span class="line">            <span class="comment">//更新边界值</span></span><br><span class="line">            row--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span> || index == <span class="number">3</span>)</span><br><span class="line">            cols--;</span><br><span class="line"></span><br><span class="line">        index = (index + <span class="number">1</span>) % <span class="number">4</span>; <span class="comment">// 换向</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>合并区间</title>
    <url>/2019/11/11/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<p>来自Leetcode第56题合并区间</p>
<blockquote>
<p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p>示例 1:</p>
<p>输入: [[1,3],[2,6],[8,10],[15,18]]<br>输出: [[1,6],[8,10],[15,18]]<br>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<a id="more"></a></p>
</blockquote>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>思路很简单，就是先将数组按照左边有序的顺序排列，一开始我自己还写了一个排序算法，运行时间大大增加，傻了，放着现成的不用</p>
<p><a href="https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode/" target="_blank" rel="noopener">题解</a>里采用了lamda表达式的方法，而且list和数组的转换很赞</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span> []&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    <span class="comment">//Arrays.sort(intervals,(a,b) -&gt; a[0] - b[0]);</span></span><br><span class="line">    <span class="comment">// 根据二维数组第一个数字大小按每一行整体排序</span></span><br><span class="line">    Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] ints, <span class="keyword">int</span>[] t1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ints[<span class="number">0</span>] - t1[<span class="number">0</span>] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; intervals.length)&#123;</span><br><span class="line">        <span class="keyword">int</span> left = intervals[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//合并区间，判断right 是否比下一个区间的左值大</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.length  &amp;&amp; right&gt;= intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="comment">//重新对right赋值</span></span><br><span class="line">            right = Math.max(right,intervals[i][<span class="number">1</span>]);</span><br><span class="line">i++；</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;left,right&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自己的原代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span> []&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    sort(intervals);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; intervals.length)&#123;</span><br><span class="line">        <span class="keyword">int</span> left = intervals[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//合并区间，判断right 是否比下一个区间的左值大</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; intervals.length  &amp;&amp; right&gt;= intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="comment">//重新对right赋值</span></span><br><span class="line">            right = Math.max(right,intervals[i][<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;left,right&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span> <span class="params">(<span class="keyword">int</span> [][] intervals)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = intervals.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; len ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt; intervals[j][<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp1 = intervals[i][<span class="number">0</span>];</span><br><span class="line">                intervals[i][<span class="number">0</span>] = intervals[j][<span class="number">0</span>];</span><br><span class="line">                intervals[j][<span class="number">0</span>] = temp1;</span><br><span class="line">                <span class="keyword">int</span> temp2 = intervals[i][<span class="number">1</span>];</span><br><span class="line">                intervals[i][<span class="number">1</span>] = intervals[j][<span class="number">1</span>];</span><br><span class="line">                intervals[j][<span class="number">1</span>] = temp2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="执行时间1ms"><a href="#执行时间1ms" class="headerlink" title="执行时间1ms"></a>执行时间1ms</h4><p>在看用时分布时，看了一下用时为1ms的代码，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计数用来表示合并了多少个区间</span></span><br><span class="line">        <span class="keyword">int</span> mergeCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;intervals.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&gt;=intervals[j][<span class="number">0</span>] &amp;&amp; intervals[i][<span class="number">0</span>]&lt;=intervals[j][<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">//开始合并区间的讨论</span></span><br><span class="line">                    <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&gt;intervals[j][<span class="number">1</span>])&#123;</span><br><span class="line">                        <span class="comment">//(i,0) &lt; (j,0) &lt; (j,1) &lt; (i,1)</span></span><br><span class="line">                        intervals[j][<span class="number">1</span>] = intervals[i][<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;intervals[j][<span class="number">0</span>])&#123;</span><br><span class="line">                        <span class="comment">//(i,0) &lt; (i,1) &lt; (j,0) &lt; (j,1)</span></span><br><span class="line">                        intervals[j][<span class="number">0</span>] = intervals[i][<span class="number">0</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    intervals[i] = <span class="keyword">null</span>;</span><br><span class="line">                    mergeCount++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length-mergeCount][];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;j&lt;intervals.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[j] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                result[i++] =intervals[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>排序</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索旋转排序数组II</title>
    <url>/2019/11/11/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/</url>
    <content><![CDATA[<p>来源Leetcode第81题搜索旋转排序数组II</p>
<blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p>
<p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p>
<p>示例 1:<a id="more"></a></p>
<p>输入: nums = [2,5,6,0,0,1,2], target = 0<br>输出: true</p>
</blockquote>
<h4 id="不正经解法"><a href="#不正经解法" class="headerlink" title="不正经解法"></a>不正经解法</h4><p>在做题的时候想到是不是可以用库函数来解决，想到String类里有方法indexOf(char)，但是在提交时失败了，因为所要查找的target可能是2位数及其以上，于是改用contains.(Integer.toString(target)) ,在倒数第二个测试用例时出错了。<br>经过排查发现，target是4764，而在nums里有-4764，转化为String之后调用contains自然而然的就会返回true了。<br>还是不死心，在Array类的方法里看到有Arrays.binarySearch这个函数，最终成功解决了，但是提交时用时才打败了23.52%的用户，按理而言时间复杂度不应该这么高才对。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="keyword">return</span> Arrays.binarySearch(nums,target) &gt; -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>与33题不同的是，这题允许数据重复，因而当有重复数字，会存在A[mid] = A[end]的情况。此时右半序列A[mid-1 : end]可能是sorted，也可能并没有sorted，所以当A[mid] = A[end] != target时，无法排除一半的序列，而只能排除掉A[end]，搜寻A[start : end-1]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length,left = <span class="number">0</span>,right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right])&#123;</span><br><span class="line">            <span class="comment">//此时是在发生了旋转的区域</span></span><br><span class="line">            <span class="comment">//如果中间的数小于最右边的数，则右半段是有序的，</span></span><br><span class="line">            <span class="comment">//如果中间数大于最右边数，则左半段是有序的，</span></span><br><span class="line">            <span class="comment">//我们只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，</span></span><br><span class="line">            <span class="comment">//这样就可以确定保留哪半边了，</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> right-- ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照题解的，稍微的改了一下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length,left = <span class="number">0</span>,right = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right])&#123;</span><br><span class="line">            <span class="comment">//此时是在发生了旋转的区域</span></span><br><span class="line">            <span class="comment">//如果中间的数小于最右边的数，则右半段是有序的，</span></span><br><span class="line">            <span class="comment">//如果中间数大于最右边数，则左半段是有序的，</span></span><br><span class="line">            <span class="comment">//我们只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，</span></span><br><span class="line">            <span class="comment">//这样就可以确定保留哪半边了，</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> right-- ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left] == target;</span><br><span class="line">    <span class="comment">//夹逼以后，还要判断一下，是不是 target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃游戏II</title>
    <url>/2019/11/10/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/</url>
    <content><![CDATA[<p>来源Leetcode第45题跳跃游戏II</p>
<blockquote>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。<a id="more"></a><br>示例:</p>
<p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p>
</blockquote>
<h4 id="自底向上的贪心"><a href="#自底向上的贪心" class="headerlink" title="自底向上的贪心"></a>自底向上的贪心</h4><p>思路同<strong>跳跃游戏</strong>一题里一样，先用一个变量maxLength记录能到达的最远位置，再用变量end记录能到达的最远位置边界，steps记录步数。<br>则每当到达边界end的时候，将end更新为新的maxLength，并且steps++。<br>因为在一次遍历i 到 end 的时候，我们总能找到到达新的最远距离的方法。</p>
<p>提交的时候遇到坑了，在for循环里，i 是应该要小于 nums.length - 1的，少了末尾。因为在最开始第0个位置的时候，step已经加1了。如果是最后一步刚好到达末尾，steps并不用加1。如果是i &lt; nums.length ，i到最后时进入if语句，steps会 + 1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        maxLength = Math.max(maxLength, i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(i == end)&#123;</span><br><span class="line">            end = maxLength;</span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自顶向下的贪心"><a href="#自顶向下的贪心" class="headerlink" title="自顶向下的贪心"></a>自顶向下的贪心</h4><p>来自<a href="https://leetcode-cn.com/problems/jump-game-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-10/" target="_blank" rel="noopener">题解</a></p>
<p>我们知道最终要到达最后一个位置，然后我们找前一个位置，遍历数组，找到能到达它的位置，离它最远的就是要找的位置。然后继续找上上个位置，最后到了第 0 个位置就结束了。</p>
<p>至于离它最远的位置，其实我们从左到右遍历数组，第一个满足的位置就是我们要找的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> position = nums.length - <span class="number">1</span>; <span class="comment">//要找的位置</span></span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (position != <span class="number">0</span>) &#123; <span class="comment">//是否到了第 0 个位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; position; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= position - i) &#123;</span><br><span class="line">                position = i; <span class="comment">//更新要找的位置</span></span><br><span class="line">                steps++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃游戏</title>
    <url>/2019/11/10/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>来源Leetcode第55题跳跃游戏</p>
<blockquote>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。<br>示例 1:<a id="more"></a></p>
<p>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p>
</blockquote>
<h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>来自<a href="https://leetcode-cn.com/problems/jump-game/solution/tiao-yue-you-xi-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<p>模拟从第一个位置跳到最后位置的所有方案。从第一个位置开始，模拟所有可以跳到的位置，然后从当前位置重复上述操作，当没有办法继续跳的时候，就回溯。<br>缺点是会超时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJumpFromPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> furthestJump = Math.min(position + nums[position], nums.length - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//列举所有可能的跳法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nextPosition = furthestJump; nextPosition &gt; position; nextPosition--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canJumpFromPosition(nextPosition, nums)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canJumpFromPosition(<span class="number">0</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自顶向下的动态规划"><a href="#自顶向下的动态规划" class="headerlink" title="自顶向下的动态规划"></a>自顶向下的动态规划</h4><p>来自<a href="https://leetcode-cn.com/problems/jump-game/solution/tiao-yue-you-xi-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<p>定义：能到达最后一个位置的坐标为好坐标，反之为坏坐标。<br>自顶向下的动态规划可以理解成回溯法的一种优化。我们发现当一个坐标已经被确定为好 / 坏之后，结果就不会改变了，这意味着我们可以记录这个结果，每次不用重新计算。</p>
<p>因此，对于数组中的每个位置，我们记录当前坐标是好 / 坏，记录在数组 memo 中，定义元素取值为 GOOD ，BAD，UNKNOWN。这种方法被称为记忆化。</p>
<p>步骤：</p>
<ul>
<li>初始化 memo 的所有元素为 UNKNOWN，除了最后一个显然是 GOOD （自己一定可以跳到自己）</li>
<li>优化递归算法，每步回溯前先检查这个位置是否计算过（当前值为：GOOD / BAD）<ul>
<li>如果已知直接返回结果 True / False</li>
<li>否则按照之前的回溯步骤计算</li>
</ul>
</li>
<li>计算完毕后，将结果存入memo表中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> [] memo; <span class="comment">// 用0，1，-1三态来定义未知，好与坏</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span> position , <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">     <span class="comment">//如果当前位置并非位置，返回状态是否是好位置</span></span><br><span class="line">     <span class="keyword">if</span> (memo[position] != <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> memo[position] == <span class="number">1</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> furthestJump = Math.min(position + nums[position],nums.length - <span class="number">1</span>);</span><br><span class="line">     <span class="comment">//如果能到最后位置，则为好位置</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> nextPosition = position + <span class="number">1</span> ; nextPosition &lt;= furthestJump ; nextPosition++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(canJump(nextPosition,nums))&#123;</span><br><span class="line">             memo[position] = <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//否则记为坏位置</span></span><br><span class="line">     memo[position] = -<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     memo = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">     memo[nums.length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> canJump(<span class="number">0</span> , nums);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="自底向上的动态规划"><a href="#自底向上的动态规划" class="headerlink" title="自底向上的动态规划"></a>自底向上的动态规划</h4><p>来自<a href="https://leetcode-cn.com/problems/jump-game/solution/tiao-yue-you-xi-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<p>自底向上和自顶向下动态规划的区别就是消除了回溯，在实际使用中，自底向下的方法有更好的时间效率因为我们不再需要栈空间，可以节省很多缓存开销。更重要的事，这可以让之后更有优化的空间。回溯通常是通过反转动态规划的步骤来实现的。</p>
<p>这是由于我们每次只会向右跳动，意味着如果我们从右边开始动态规划，每次查询右边节点的信息，都是已经计算过了的，不再需要额外的递归开销，因为我们每次在 memo 表中都可以找到结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Index &#123;</span><br><span class="line">    GOOD, BAD, UNKNOWN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Index[] memo = <span class="keyword">new</span> Index[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; memo.length; i++) &#123;</span><br><span class="line">            memo[i] = Index.UNKNOWN;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[memo.length - <span class="number">1</span>] = Index.GOOD;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> furthestJump = Math.min(i + nums[i], nums.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= furthestJump; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (memo[j] == Index.GOOD) &#123;</span><br><span class="line">                    memo[i] = Index.GOOD;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[<span class="number">0</span>] == Index.GOOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自顶向下的贪心"><a href="#自顶向下的贪心" class="headerlink" title="自顶向下的贪心"></a>自顶向下的贪心</h4><p>当我们把代码改成自底向上的模式，我们会有一个重要的发现，从某个位置出发，我们只需要找到第一个标记为 GOOD 的坐标（由跳出循环的条件可得），也就是说找到最左边的那个坐标。如果我们用一个单独的变量来记录最左边的 GOOD 位置，我们就可以避免搜索整个数组，进而可以省略整个 memo 数组。</p>
<p>从右向左迭代，对于每个节点我们检查是否存在一步跳跃可以到达 GOOD 的位置（currPosition + nums[currPosition] &gt;= leftmostGoodIndex）。如果可以到达，当前位置也标记为 GOOD ，同时，这个位置将成为新的最左边的 GOOD 位置，一直重复到数组的开头，如果第一个坐标标记为 GOOD 意味着可以从第一个位置跳到最后的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastPos = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + nums[i] &gt;= lastPos) &#123;</span><br><span class="line">            lastPos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastPos == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自底向上的贪心"><a href="#自底向上的贪心" class="headerlink" title="自底向上的贪心"></a>自底向上的贪心</h4><p>从第0个位置出发，如果当前位置可跳跃距离为n，意味着接下来n个位置都可以作为跳跃点。<br>接下来对这n个格子都跳一次，更新能到达的最远距离，如果能到最后位置，则返回true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; maxLength) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        maxLength = Math.max(maxLength,i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(maxLength &gt;= nums.length - <span class="number">1</span>)</span><br><span class="line">            <span class="comment">//如果最远可到达的位置大于数组长度，则可到达</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>贪心</tag>
        <tag>回溯</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>螺旋矩阵</title>
    <url>/2019/11/09/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>来源Leetcode第54题螺旋矩阵</p>
<blockquote>
<p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>
<p>示例 1:</p>
<p>输入:<a id="more"></a><br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br>输出: [1,2,3,6,9,8,7,4,5]</p>
</blockquote>
<h4 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h4><p>从最外层向内部逐层遍历打印矩阵。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">int</span> xLength = matrix.length; <span class="comment">//定义x方向长度 即行数</span></span><br><span class="line">    <span class="keyword">int</span> yLength = matrix[<span class="number">0</span>].length; <span class="comment">//定义y方向长度 即列数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>; <span class="comment">// 初始化层数</span></span><br><span class="line">    <span class="keyword">int</span> TotalLevel = (Math.min(xLength,yLength) + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//初始化遍历总的层数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (level &lt; TotalLevel)&#123;</span><br><span class="line">        <span class="comment">//对应着最上层向右的第一次遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = level;j &lt; yLength - level;j++)&#123;</span><br><span class="line">            ans.add(matrix[level][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对应着第二次遍历从右上往右下</span></span><br><span class="line">        <span class="comment">//这时候的起点注意行数 + 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = level + <span class="number">1</span> ; j &lt; xLength - level ; j++)</span><br><span class="line">            ans.add(matrix[j][yLength - <span class="number">1</span> - level]);</span><br><span class="line">        <span class="comment">//右下往左下如果这一层只有1行，那么第一个循环已经将该行打印了</span></span><br><span class="line">        <span class="comment">// 这里就不需要打印了，即 xLength - 1 - level != level</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = yLength - level - <span class="number">2</span>; j &gt;= level &amp;&amp; xLength - <span class="number">1</span> - level != level;j--)</span><br><span class="line">            ans.add(matrix[xLength - level - <span class="number">1</span>][j]);</span><br><span class="line">        <span class="comment">//从左下往左上,如果这一层只有1列，那么第2个循环已经将该列打印了，</span></span><br><span class="line">        <span class="comment">// 这里不需要打印，即yLength - 1 - level != level</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = xLength - level - <span class="number">2</span> ; j &gt;= level + <span class="number">1</span> &amp;&amp; yLength - <span class="number">1</span> - level != level ;j--)</span><br><span class="line">            ans.add(matrix[j][level]);</span><br><span class="line">        level ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><p>来源<a href="https://leetcode-cn.com/problems/spiral-matrix/solution/luo-xuan-ju-zhen-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<blockquote>
<p>绘制螺旋轨迹路径，我们发现当路径超出界限或者进入之前访问过的单元格时，会顺时针旋转方向。<br>假设数组有 R 行 C 列，seen[r][c] 表示第 r 行第 c 列的单元格之前已经被访问过了。当前所在位置为 (r, c)，前进方向是 di。我们希望访问所有 R x C 个单元格。<br>当我们遍历整个矩阵，下一步候选移动位置是 (cr, cc)。如果这个候选位置在矩阵范围内并且没有被访问过，那么它将会变成下一步移动的位置；否则，我们将前进方向顺时针旋转之后再计算下一步的移动位置。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">      List ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">      <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">      <span class="keyword">int</span> R = matrix.length, C = matrix[<span class="number">0</span>].length;</span><br><span class="line">      <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[R][C];</span><br><span class="line"><span class="comment">//定义了4个方向数组，分别对应y+1 x+1 x-1 y-1</span></span><br><span class="line">      <span class="keyword">int</span>[] dr = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">      <span class="keyword">int</span>[] dc = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">      <span class="keyword">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>, di = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R * C; i++) &#123;</span><br><span class="line">          ans.add(matrix[r][c]);</span><br><span class="line">          seen[r][c] = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">int</span> cr = r + dr[di];</span><br><span class="line">          <span class="keyword">int</span> cc = c + dc[di];</span><br><span class="line">          <span class="keyword">if</span> (<span class="number">0</span> &lt;= cr &amp;&amp; cr &lt; R &amp;&amp; <span class="number">0</span> &lt;= cc &amp;&amp; cc &lt; C &amp;&amp; !seen[cr][cc])&#123;</span><br><span class="line">              r = cr;</span><br><span class="line">              c = cc;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//越界之后换向</span></span><br><span class="line">              di = (di + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">              r += dr[di];</span><br><span class="line">              c += dc[di];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="优化模拟"><a href="#优化模拟" class="headerlink" title="优化模拟"></a>优化模拟</h5><p>对题解的代码做了一定的优化，减少了空间使用度<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="comment">//4次转向的方向</span></span><br><span class="line">    <span class="keyword">int</span> [] dir_i = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> [] dir_j = &#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//定义行数和列数</span></span><br><span class="line">    <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">// 方向索引</span></span><br><span class="line">    <span class="keyword">int</span> countsAll = row * cols;</span><br><span class="line">    <span class="keyword">int</span> pos_i = <span class="number">0</span>, pos_j = -<span class="number">1</span> ; <span class="comment">//位置索引</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; countsAll)&#123;</span><br><span class="line">        <span class="comment">//获得当前遍历行或列的长度</span></span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span> || index == <span class="number">2</span>)</span><br><span class="line">            len = cols;</span><br><span class="line">        <span class="keyword">else</span> len = row;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            <span class="comment">//遍历行or列</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算当前位置</span></span><br><span class="line">            pos_i = pos_i + dir_i[index];</span><br><span class="line">            pos_j = pos_j + dir_j[index];</span><br><span class="line">            ans.add(matrix[pos_i][pos_j]);</span><br><span class="line">            count ++ ;</span><br><span class="line">            <span class="keyword">if</span>(count == countsAll)</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span> || index == <span class="number">2</span>)</span><br><span class="line">        <span class="comment">//更新边界值</span></span><br><span class="line">            row--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span> || index == <span class="number">3</span>)</span><br><span class="line">            cols--;</span><br><span class="line"></span><br><span class="line">        index = (index + <span class="number">1</span>) % <span class="number">4</span>; <span class="comment">// 换向</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="层遍历"><a href="#层遍历" class="headerlink" title="层遍历"></a>层遍历</h4><p>对于每层，我们从左上方开始以顺时针的顺序遍历所有元素，假设当前层左上角坐标是 (r1, c1)，右下角坐标是 (r2, c2)。</p>
<p>首先，遍历上方的所有元素 (r1, c)，按照 c = c1,…,c2 的顺序。然后遍历右侧的所有元素 (r, c2)，按照r = r1+1,…,r2 的顺序。如果这一层有四条边（也就是 r1 &lt; r2 并且 c1 &lt; c2 ），我们以下图所示的方式遍历下方的元素和左侧的元素。</p>
<div align="center">
<img width="700" src="https://pic.leetcode-cn.com/21f4b738d3a221048ab021a8c663083b51c76a2d922c91019d6b5f514881688b-54_spiralmatrix.png">
</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List &lt; Integer &gt; spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    List ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">int</span> r1 = <span class="number">0</span>, r2 = matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c1 = <span class="number">0</span>, c2 = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = c1; c &lt;= c2; c++) ans.add(matrix[r1][c]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = r1 + <span class="number">1</span>; r &lt;= r2; r++) ans.add(matrix[r][c2]);</span><br><span class="line">        <span class="keyword">if</span> (r1 &lt; r2 &amp;&amp; c1 &lt; c2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = c2 - <span class="number">1</span>; c &gt; c1; c--) ans.add(matrix[r2][c]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = r2; r &gt; r1; r--) ans.add(matrix[r][c1]);</span><br><span class="line">        &#125;</span><br><span class="line">        r1++;</span><br><span class="line">        r2--;</span><br><span class="line">        c1++;</span><br><span class="line">        c2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数学</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转链表</title>
    <url>/2019/11/09/%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>来源Leetcode第61题旋转链表</p>
<blockquote>
<p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。<br>示例 1:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>解释:<br>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL <a id="more"></a></p>
</blockquote>
<h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>不管移动多少步，如果先将链表连接成环，那么最后移动的步数就是 k%n 了，其中n是总的节点数。<br>这样的话新的头结点是在第n - k % n 个结点，而新的尾结点自然是在n - k % n - 1 个结点了，最后只需要将尾结点的next修改为null即可。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     ListNode next;</span><br><span class="line"></span><br><span class="line">     ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">         val = x;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">         <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">         ListNode preHead = head;</span><br><span class="line">         ListNode newTail = head;</span><br><span class="line"><span class="comment">//计算链表长度</span></span><br><span class="line">         <span class="keyword">while</span> (preHead.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">             n++;</span><br><span class="line">             preHead = preHead.next;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">//将链表闭合成环</span></span><br><span class="line">         preHead.next = head;</span><br><span class="line"><span class="comment">//找到新的尾结点</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k % n - <span class="number">1</span>; i++)</span><br><span class="line">             newTail = newTail.next;</span><br><span class="line"><span class="comment">//新的头结点就是新的尾结点的next</span></span><br><span class="line">         ListNode newHead = head;</span><br><span class="line">         newHead = newTail.next;</span><br><span class="line"><span class="comment">//修改新的尾结点的next</span></span><br><span class="line">         newTail.next = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">return</span> newHead;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>单词搜索</title>
    <url>/2019/11/08/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>来源Leetcode第79题单词搜索</p>
<blockquote>
<p>给定一个二维网格和一个单词,找出该单词是否存在于网格中。<br>单词必须按照字母顺序,通过相邻的单元格内的字母构成,其中”相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。<br>示例<br>board =<br>[<br>[“A”‘,”B’,”c’,”E]<a id="more"></a><br>[“s’,”F’,”c’,”S”]<br>[“A’,”D’,”E’,”E’]<br>]</p>
<p>给定word=” ABCCED”,返回true<br>给定word=”sEE”,返回true<br>给定word=”ABCB”,返回fa1se</p>
</blockquote>
<h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>来自<a href="https://leetcode-cn.com/problems/word-search/solution/zai-er-wei-ping-mian-shang-shi-yong-hui-su-fa-pyth/" target="_blank" rel="noopener">题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] marked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//        x-1,y</span></span><br><span class="line">    <span class="comment">// x,y-1  x,y    x,y+1</span></span><br><span class="line">    <span class="comment">//        x+1,y</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 盘面上有多少行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">// 盘面上有多少列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> String word;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[][] board;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        m = board.length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = board[<span class="number">0</span>].length;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">this</span>.word = word;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> board[i][j] == word.charAt(start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == word.charAt(start)) &#123;</span><br><span class="line">            marked[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> newX = i + direction[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> newY = j + direction[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (inArea(newX, newY) &amp;&amp; !marked[newX][newY]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(newX, newY, start + <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            marked[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列II</title>
    <url>/2019/11/08/%E5%85%A8%E6%8E%92%E5%88%97II/</url>
    <content><![CDATA[<p>来源Leetcode第47题全排列II</p>
<blockquote>
<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p>示例:</p>
<p>输入: [1,1,2]<a id="more"></a><br>输出:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]</p>
</blockquote>
<h4 id="错误的回溯"><a href="#错误的回溯" class="headerlink" title="错误的回溯"></a>错误的回溯</h4><p>这题最开始做的时候是11天前，估计是对应着<strong>全排列</strong>那道题吧，按着那道题的代码改了，有重复的输出正确，没重复的反而输出错误了，emm磨蹭了很久，今天也没找到问题所在，摸了。</p>
<p>错误的代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] used;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    nextPer(nums,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextPer</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="comment">//当start==arr.length-1时，说明子序列的长度为1，就不用再往下分子序列了</span></span><br><span class="line">    <span class="keyword">if</span>(start==arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">        List&lt;Integer&gt; temp_ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length ; i++)&#123;</span><br><span class="line">            temp_ans.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(temp_ans);</span></span><br><span class="line">        ans.add(temp_ans);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!used[i]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; arr[i] == arr[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//start代表的是每一个子序列的第一个位置，我们每一层递归的任务都只有一个：</span></span><br><span class="line">            <span class="comment">//枚举该层子序列第一个位置可以取的值</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[start];</span><br><span class="line">            arr[start] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//该层递归的子序列第一个位置已经确定了，所以又可以往下再分</span></span><br><span class="line">            nextPer(arr, start + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把第该层子序列第一个位置的值换成另外一个值，所以要交换回来</span></span><br><span class="line">            temp = arr[start];</span><br><span class="line">            arr[start] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line"></span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="回溯-剪枝"><a href="#回溯-剪枝" class="headerlink" title="回溯 + 剪枝"></a>回溯 + 剪枝</h4><p>来源<a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/" target="_blank" rel="noopener">题解</a></p>
<blockquote>
<p>我们归纳出“剪枝”要满足的条件:</p>
<ul>
<li>1、在“同一层”,它不是“从左向右数”的第1个分支(标在下图①处);</li>
<li>2、当前已经选出的数与“同一层”前一个分支已经选出的数相等(标在下图②处);</li>
<li>3、“同一层”前一个分支已经选出的数在“当前分支”还未被使用(标在下图③处)</li>
</ul>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] used;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findPermuteUnique</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> depth, Stack&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                <span class="comment">// 修改 2：因为排序以后重复的数一定不会出现在开始，故 i &gt; 0</span></span><br><span class="line">                <span class="comment">// 和之前的数相等，并且之前的数还未使用过，只有出现这种情况，才会出现相同分支</span></span><br><span class="line">                <span class="comment">// 这种情况跳过即可</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                stack.add(nums[i]);</span><br><span class="line">                findPermuteUnique(nums, depth + <span class="number">1</span>, stack);</span><br><span class="line">                stack.pop();</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        findPermuteUnique(nums, <span class="number">0</span>, <span class="keyword">new</span> Stack&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>第K个排列</title>
    <url>/2019/11/08/%E7%AC%ACK%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>来源Leetcode第60题第K个排列</p>
<blockquote>
<p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，<br>给定 n 和 k，返回第 k 个排列。<br><a id="more"></a><br>说明：</p>
<p>给定 n 的范围是 [1, 9]。<br>给定 k 的范围是[1,  n!]。<br>示例 1:</p>
<p>输入: n = 3, k = 3<br>输出: “213”</p>
</blockquote>
<h4 id="TLE代码"><a href="#TLE代码" class="headerlink" title="TLE代码"></a>TLE代码</h4><p>按照之前全排列的代码，改了一下，但是由于生成的列表是无序的，因而我采取了将其排序的操作，但是这样的最后导致了超时。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextPer</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="comment">//当start==arr.length-1时，说明子序列的长度为1，就不用再往下分子序列了</span></span><br><span class="line">    <span class="keyword">if</span>(start==arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">        List&lt;Integer&gt; temp_ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length ; i++)&#123;</span><br><span class="line">            temp_ans.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(temp_ans);</span></span><br><span class="line">        ans.add(temp_ans);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="comment">//start代表的是每一个子序列的第一个位置，我们每一层递归的任务都只有一个：</span></span><br><span class="line">        <span class="comment">//枚举该层子序列第一个位置可以取的值</span></span><br><span class="line">        <span class="keyword">int</span> temp=arr[start];</span><br><span class="line">        arr[start]=arr[i];</span><br><span class="line">        arr[i]=temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//该层递归的子序列第一个位置已经确定了，所以又可以往下再分</span></span><br><span class="line">        nextPer(arr,start+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把第该层子序列第一个位置的值换成另外一个值，所以要交换回来</span></span><br><span class="line">        temp=arr[start];</span><br><span class="line">        arr[start]=arr[i];</span><br><span class="line">        arr[i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ans.size() ; i ++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i  + <span class="number">1</span>; j &lt; ans.size() ; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; ans.get(j).size(); k ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans.get(i).get(k) &lt; ans.get(j).get(k))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ans.get(i).get(k) &gt; ans.get(j).get(k))&#123;</span><br><span class="line">                    <span class="comment">//System.out.println(k + " " + ans.get(i).get(k) + " " + ans.get(j).get(k));</span></span><br><span class="line">                    List&lt;Integer&gt; temp = ans.get(i);</span><br><span class="line">                    ans.set(i,ans.get(j));</span><br><span class="line">                    ans.set(j,temp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)</span><br><span class="line">        nums[i - <span class="number">1</span>] = i;</span><br><span class="line">    nextPer(nums,<span class="number">0</span>);</span><br><span class="line">    sort(ans);</span><br><span class="line">    String result = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )&#123;</span><br><span class="line">        result += ans.get(k - <span class="number">1</span>).get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println(result);</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h4><p>思路来源<a href="https://leetcode-cn.com/problems/permutation-sequence/solution/zhe-ti-ru-guo-di-gui-jiu-zuo-fu-za-liao-qi-shi-shi/" target="_blank" rel="noopener">题解</a></p>
<blockquote>
<p>假设n=5,k=35,<br>n为5的全排列就是首位为1-5的如下排列的所有<br>1_,,,2,,,3,,,4,,,5,,,每个各有24个排列，组成12345的全排列<br>由于k=35&lt;48,也就是说第35个肯定在首位为2的全排列里边,所以第一个取2。<br>接下来就是考虑剩下1345这四个数的全排列里边取第k=35-24=11个，<br>1,,3,,4,,5,,每个各有6个排列，组成1345的全排列，<br>由于k=11&lt;12,也就是说第11个肯定在首位为3的全排列里边，所以第二个数取3<br>接下来就是考虑剩下145这三个数的全排列里边取第k=11-6=5个，<br>1,4,5,_每个各有2个排列，组成145的全排列<br>由于k=5&lt;6,也就是说第5个肯定在首位为5的全排列里边，所以第三个数取5<br>接下来就是考虑剩下14这两个数的排列里边取第k=5-4=1个<br>1_4_每个各有1个排列，组成14的排列，<br>由于k=1,所以第四个数取1<br>最后加上剩下的最后一个4，结果就是23514<br>结束。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StringBuilder nums = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> factor[] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>,<span class="number">720</span>,<span class="number">5040</span>,<span class="number">40320</span>,<span class="number">362880</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">            nums.append(i);</span><br><span class="line">        String answer = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> interval,loop_times = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; loop_times;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            --n;</span><br><span class="line">            interval = (k - <span class="number">1</span>) / factor[n];</span><br><span class="line">            answer += nums.charAt(interval);</span><br><span class="line">            nums = nums.deleteCharAt(interval);</span><br><span class="line">            k = k - interval * factor[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="回溯-剪枝"><a href="#回溯-剪枝" class="headerlink" title="回溯 + 剪枝"></a>回溯 + 剪枝</h4><p>来自<a href="https://leetcode-cn.com/problems/permutation-sequence/solution/hui-su-jian-zhi-python-dai-ma-java-dai-ma-by-liwei/" target="_blank" rel="noopener">题解</a></p>
<p>大致思路其实是同上者</p>
<blockquote>
<ul>
<li>我们知道所求排列一定在叶子结点处得到。事实上，进入每一个分支的时候，我们都可以通过递归的层数，直接计算这一分支可以得到的叶子结点的个数。</li>
</ul>
<p>这是因为：进入一个分支的时候，我们可以根据已经选定的数的个数，进而确定还未选定的数的个数，然后计算阶乘，就知道这一个分支的叶子结点有多少个。</p>
<ul>
<li><p>2、如果 k 大于这一个分支将要产生的叶子结点数，直接跳过这个分支，即“剪枝”即可。</p>
</li>
<li><p>这是因为：即使你回溯去做，要设置状态，回溯回来的时候状态还要重置，但其实跳过的这个分支的叶子结点具体是啥我们并不关心。</p>
</li>
<li><p>3、如果 k 小于等于这一个分支将要产生的叶子结点数，那说明所求的全排列一定在这一个分支将要产生的叶子结点里，需要递归求解。</p>
</li>
<li><p>4、计算阶乘的时候，你可以使用循环计算，特别注意：0!=1，它表示了没有数可选的时候，即表示到达叶子结点了，排列数只剩下 1 个。</p>
</li>
<li><p>又因为题目中说“给定 nn 的范围是 [1,9]”，故可以实现把从 0 到 9 的阶乘计算好，放在一个数组里，可以根据索引直接获得阶乘值，见文后“代码 2”。</p>
</li>
</ul>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] = i + <span class="number">1</span>;</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] factorial = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>, <span class="number">40320</span>, <span class="number">362880</span>&#125;;</span><br><span class="line">        List&lt;String&gt; pre = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, used, n, k, <span class="number">0</span>, pre, factorial);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> depth, List&lt;String&gt; pre, <span class="keyword">int</span>[] factorial)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == n) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (String c : pre) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ps = factorial[n - <span class="number">1</span> - depth];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//确定递归层数的位置</span></span><br><span class="line">            <span class="keyword">if</span> (ps &lt; k) &#123;</span><br><span class="line">                k -= ps;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.add(nums[i] + <span class="string">""</span>);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> dfs(nums, used, n, k, depth + <span class="number">1</span>, pre, factorial);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果参数正确的话，代码不会走到这里</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数学</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>简化路径</title>
    <url>/2019/11/07/%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>来源Leetcode第71题简化路径</p>
<blockquote>
<p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径 <a id="more"></a></p>
<p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。</p>
<p>示例 4：</p>
<p>输入：”/a/./b/../../c/“<br>输出：”/c”</p>
</blockquote>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>思路也简单，对输入字符串做一遍遍历,首先排除字符/，如果是路径文件夹名则入栈，如果是.. 且当前栈不为空则出栈。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    String[] s = path.split(<span class="string">"/"</span>);</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; s[i].equals(<span class="string">".."</span>))</span><br><span class="line">            stack.pop();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!s[i].equals(<span class="string">""</span>) &amp;&amp; !s[i].equals(<span class="string">"."</span>) &amp;&amp; !s[i].equals(<span class="string">".."</span>))</span><br><span class="line">            stack.push(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">    StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stack.size(); i++) &#123;</span><br><span class="line">        ans.append(<span class="string">"/"</span> + stack.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>x的平方根</title>
    <url>/2019/11/07/x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    <content><![CDATA[<p>来源Leetcode第69题x的平方根</p>
<blockquote>
<p>实现 int sqrt(int x) 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。<a id="more"></a></p>
<p>示例 2:</p>
<p>输入: 8<br>输出: 2</p>
</blockquote>
<h4 id="不正经解法"><a href="#不正经解法" class="headerlink" title="不正经解法"></a>不正经解法</h4><p>最简单的就直接调用Math.sqrt()就行了，但这很明显不符合题意。<br>代码就一句:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)Math.sqrt(x);</span><br></pre></td></tr></table></figure></p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>利用x/mid 来比较是否接近目标</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span> || x == <span class="number">1</span>)    <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;<span class="comment">//左边界</span></span><br><span class="line">    <span class="keyword">int</span> r = x;<span class="comment">//右边界</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid =  (r + l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> s = x / mid; <span class="comment">//用来判断mid大于目标还是小于目标，或等于目标</span></span><br><span class="line">        <span class="keyword">int</span> ss = x / (mid + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x / s == s) <span class="keyword">return</span> s; <span class="comment">//刚好是他的算术平方根</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; mid &amp;&amp; ss &lt; mid + <span class="number">1</span>) <span class="keyword">return</span> mid; <span class="comment">//例如6 在2的平方以及 3的平方之间  答案为2</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; mid) l = mid + <span class="number">1</span>; <span class="comment">//调整边界</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt; mid) r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然也有用<strong>double</strong>类型来提高精度的</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (<span class="keyword">double</span>) x / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> right = x;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">int</span>)left &lt;(<span class="keyword">int</span>) right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mid * mid &gt; x)&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">            mid = (<span class="keyword">double</span>) (left + right) / <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">            mid = (<span class="keyword">double</span>) (left + right) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)mid ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h4><p>来源<a href="https://leetcode-cn.com/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/" target="_blank" rel="noopener">题解</a></p>
<p>关于<a href="https://baike.baidu.com/item/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95" target="_blank" rel="noopener">牛顿迭代法</a></p>
<blockquote>
<p>这种算法的原理很简单，我们仅仅是不断用 (x, f(x))的切线来逼近方程 x^2-a=0根。根号 a 实际上就是 x^2-a=0的一个正实根，这个函数的导数是 2x。也就是说，函数上任一点 (x,f(x)) 处的切线斜率是 2x。那么，x-f(x)/(2x)就是一个比 x 更接近的近似值。代入 f(x)=x^2-af得到 x-(x^2-a)/(2x)，也就是 (x+a/x)/2。</p>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">     s=x;</span><br><span class="line">     <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span>)(sqrts(x)));</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sqrts</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">      <span class="keyword">double</span> res = (x + s / x) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (res == x) &#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> sqrts(res);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数学</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的中序遍历</title>
    <url>/2019/11/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>来源Leetcode第94题二叉树的中序遍历</p>
<blockquote>
<p>给定一个二叉树，返回它的<strong>中序</strong>遍历。</p>
</blockquote>
<p>中序遍历就是<strong>左中右</strong>的顺序，就当复习一下数据结构里的内容了。<br>如果是栈的话，那就是根结点入栈，接着左子树入栈，直到左子树为空，在进行出栈操作，左子树出栈，根结点出栈，右子树入栈。<a id="more"></a></p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>很经典的递归写法。<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">          midOrder(root);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">                  midOrder(root.left);</span><br><span class="line">              result.add(root.val);</span><br><span class="line">              <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">                  midOrder(root.right);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List &lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List &lt;Integer&gt; res = <span class="keyword">new</span> ArrayList &lt; &gt; ();</span><br><span class="line">    Stack &lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack &lt; &gt; ();</span><br><span class="line">    TreeNode current = root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = stack.pop();</span><br><span class="line">        res.add(current.val);</span><br><span class="line">        current = current.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="莫里斯遍历"><a href="#莫里斯遍历" class="headerlink" title="莫里斯遍历"></a>莫里斯遍历</h4><p>莫里斯遍历首先需要将二叉树线索化，关于<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/10810037?fr=aladdin" target="_blank" rel="noopener">线索二叉树</a></p>
<p><strong>思路</strong>：<br>记当前遍历的节点为 cur</p>
<ul>
<li>cur.left 为 null，保存 cur 的值，更新 cur = cur.right</li>
<li>cur.left 不为 null，找到 cur.left 这颗子树最右边的节点记做 last<ul>
<li>last.right 为 null，那么将 last.right = cur，更新 cur = cur.left</li>
<li>last.right 不为 null，说明之前已经访问过，第二次来到这里，表明当前子树遍历完成，保存 cur 的值，更新 cur = cur.right</li>
</ul>
</li>
</ul>
<p>图示及代码参考<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-2-6/" target="_blank" rel="noopener">题解</a></p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//情况 1</span></span><br><span class="line">        <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ans.add(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//找左子树最右边的节点</span></span><br><span class="line">            TreeNode pre = cur.left;</span><br><span class="line">            <span class="keyword">while</span> (pre.right != <span class="keyword">null</span> &amp;&amp; pre.right != cur) &#123;</span><br><span class="line">                pre = pre.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况 2.1</span></span><br><span class="line">            <span class="keyword">if</span> (pre.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况 2.2</span></span><br><span class="line">            <span class="keyword">if</span> (pre.right == cur) &#123;</span><br><span class="line">                pre.right = <span class="keyword">null</span>; <span class="comment">//这里可以恢复为 null</span></span><br><span class="line">                ans.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>树</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制求和</title>
    <url>/2019/11/06/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<p>来源Leetcode第67题二进制求和</p>
<blockquote>
<p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p>
<p>输入为非空字符串且只包含数字 1 和 0。<br><a id="more"></a><br>示例 1:</p>
<p>输入: a = “11”, b = “1”<br>输出: “100”</p>
</blockquote>
<p>与上一题一样，从末位开始相加，考虑进位信息，字符串补长到一样长，不足位补0，最后考虑进位信息。</p>
<p>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//是否进位 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = carry;</span><br><span class="line">        <span class="comment">// 获取字符串a对应的某一位的值 当i&lt;0是 sum+=0（向前补0） 否则将原值转为int</span></span><br><span class="line">        sum += (i &gt;= <span class="number">0</span> ? a.charAt(i) - <span class="string">'0'</span> : <span class="number">0</span>); </span><br><span class="line">        sum +=( j &gt;= <span class="number">0</span> ? b.charAt(j) - <span class="string">'0'</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//考虑carry和a.charAt(i)、b.charAt(j)</span></span><br><span class="line">        <span class="comment">//三者相加后10进制数分别可能为0,1,2,3</span></span><br><span class="line">        <span class="comment">//需要转成二进制</span></span><br><span class="line">        ans.append(sum % <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//进位信号只有2，3会产生</span></span><br><span class="line">        carry = sum / <span class="number">2</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断最后一次计算是否有进位  有则在最前面加上1 否则原样输出</span></span><br><span class="line">    ans.append(carry == <span class="number">1</span> ? carry : <span class="string">""</span>);</span><br><span class="line">    <span class="comment">//翻转后输出</span></span><br><span class="line">    <span class="keyword">return</span> ans.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>加一</title>
    <url>/2019/11/06/%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<p>来源Leetcode第66题加一</p>
<blockquote>
<p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。<br><a id="more"></a><br>示例 1:</p>
<p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。</p>
</blockquote>
<h4 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h4><p>很简单的一道题，直接从末尾加一，携带一个进位信号carry，如果和为10，那么digits[i] %= 10 ,carry = 1，不然循环加carry即可，最后判断最高位carry是否为1，为1说明当前值为1000000，需要对数组扩容。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = digits.length;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i -- )&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len - <span class="number">1</span>)&#123;</span><br><span class="line">        digits[i] = digits[i] + carry + <span class="number">1</span>;</span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            digits[i] = digits[i] + carry ;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(digits[i] == <span class="number">10</span>)&#123;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">        digits = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>  digits;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="简洁"><a href="#简洁" class="headerlink" title="简洁"></a>简洁</h4><p>写法不简洁，来自<a href="https://leetcode-cn.com/problems/plus-one/solution/java-shu-xue-jie-ti-by-yhhzw/" target="_blank" rel="noopener">题解</a>有一个很简洁的写法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          digits[i]++;</span><br><span class="line">          digits[i] = digits[i] % <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//从ditis[i] != 0这一步就判断出了进位信号的结束</span></span><br><span class="line">	<span class="comment">//在还有进位信号的时候，末尾起每位加一</span></span><br><span class="line">	<span class="comment">//进位结束了返回digits即可</span></span><br><span class="line">          <span class="keyword">if</span> (digits[i] != <span class="number">0</span>) <span class="keyword">return</span> digits;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//这时ditis[0] = 0，意味着原先的数是999</span></span><br><span class="line"><span class="comment">//因而对其扩容，ditis[0]设置为1即可</span></span><br><span class="line">      digits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">      digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> digits;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子序和</title>
    <url>/2019/11/05/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<p>来源Leetcode第53题最大子序和</p>
<blockquote>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<a id="more"></a></p>
</blockquote>
<p>这题上课讲过，思路是分治，分越过中点，没有越过中点，又分中点左边，中点右边，共3种情况。<br>不过写的时候忘记了，于是先采用了万能的循环遍历，在倒数第三个测试用例时TLE了，打扰了</p>
<h4 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h4><p>用O(n^2)的时间，即2个循环去遍历所有子序列的情况，最终保存最大值即可，方法简单，但是会超时。<br>坑在于max值的设置，要设置成Integer.MIN_VALUE，以及第2重循环，将上一个子序列的值保留下来。<br>但是这样的效率非常低，用时62ms，击败了7.70%用户2333.</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE ;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i ++ )&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; max)</span><br><span class="line">                max = sum ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; len ;j++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; max)</span><br><span class="line">                    max = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p><strong>思路</strong></p>
<ul>
<li>动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans</li>
<li>如果 sum &gt; 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字</li>
<li>如果 sum &lt;= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字</li>
<li>每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果</li>
</ul>
<p>[动图(<a href="https://leetcode-cn.com/problems/maximum-subarray/solution/hua-jie-suan-fa-53-zui-da-zi-xu-he-by-guanpengchn/)见" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray/solution/hua-jie-suan-fa-53-zui-da-zi-xu-he-by-guanpengchn/)见</a><br>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">         <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             sum += num;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//这里包括了对sum 初始化为nums[0]</span></span><br><span class="line">             sum = num;</span><br><span class="line">         &#125;</span><br><span class="line">         ans = Math.max(ans, sum);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><p>思路见算法导论分治一节<br>数据结构与算法分析第二章P29<br>但是运行时间反而不如动态规划啊2333<br>代码来自：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> len = nums.length;</span><br><span class="line">      <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> maxSubArraySum(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxCrossingSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 一定会包含 nums[mid] 这个元素</span></span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> leftSum = Integer.MIN_VALUE;</span><br><span class="line">      <span class="comment">// 左半边包含 nums[mid] 元素，最多可以到什么地方</span></span><br><span class="line">      <span class="comment">// 走到最边界，看看最值是什么</span></span><br><span class="line">      <span class="comment">// 计算以 mid 结尾的最大的子数组的和</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &gt;= left; i--) &#123;</span><br><span class="line">          sum += nums[i];</span><br><span class="line">          <span class="keyword">if</span> (sum &gt; leftSum) &#123;</span><br><span class="line">              leftSum = sum;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> rightSum = Integer.MIN_VALUE;</span><br><span class="line">      <span class="comment">// 右半边不包含 nums[mid] 元素，最多可以到什么地方</span></span><br><span class="line">      <span class="comment">// 计算以 mid+1 开始的最大的子数组的和</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">          sum += nums[i];</span><br><span class="line">          <span class="keyword">if</span> (sum &gt; rightSum) &#123;</span><br><span class="line">              rightSum = sum;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> leftSum + rightSum;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxSubArraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">          <span class="keyword">return</span> nums[left];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> max3(maxSubArraySum(nums, left, mid),</span><br><span class="line">              maxSubArraySum(nums, mid + <span class="number">1</span>, right),</span><br><span class="line">              maxCrossingSum(nums, left, mid, right));</span><br><span class="line"><span class="comment">//返回左边最大或右边最大，或者跨越中点</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">max3</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">int</span> num3)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Math.max(num1, Math.max(num2, num3));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>解数独</title>
    <url>/2019/11/04/%E8%A7%A3%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<p>来源Leetcode第37题解数独</p>
<h4 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h4><p><strong><a href="https://leetcode-cn.com/problems/sudoku-solver/solution/jie-shu-du-by-leetcode/" target="_blank" rel="noopener">算法</a></strong></p>
<p>现在准备好写回溯函数了 <a id="more"></a><br>backtrack(row = 0, col = 0)。</p>
<ul>
<li><p>从最左上角的方格开始 row = 0, col = 0。直到到达一个空方格。</p>
</li>
<li><p>从1 到 9 迭代循环数组，尝试放置数字 d 进入 (row, col) 的格子。</p>
<ul>
<li><p>如果数字 d 还没有出现在当前行，列和子方块中：</p>
</li>
<li><p>将 d 放入 (row, col) 格子中。</p>
</li>
<li>记录下 d 已经出现在当前行，列和子方块中。</li>
<li>如果这是最后一个格子row == 8, col == 8 ：<ul>
<li>意味着已经找出了数独的解。</li>
</ul>
</li>
<li>否则<ul>
<li>放置接下来的数字。</li>
</ul>
</li>
<li>如果数独的解还没找到：将最后的数从 (row, col) 移除。</li>
</ul>
</li>
</ul>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// box size</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// row size</span></span><br><span class="line">    <span class="keyword">int</span> N = n * n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> [][] rows = <span class="keyword">new</span> <span class="keyword">int</span>[N][N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> [][] columns = <span class="keyword">new</span> <span class="keyword">int</span>[N][N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> [][] boxes = <span class="keyword">new</span> <span class="keyword">int</span>[N][N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[][] board;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> sudokuSolved = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">couldPlace</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Check if one could place a number d in (row, col) cell</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">int</span> idx = (row / n ) * n + col / n;</span><br><span class="line">        <span class="keyword">return</span> rows[row][d] + columns[col][d] + boxes[idx][d] == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeNumber</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Place a number d in (row, col) cell</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">int</span> idx = (row / n ) * n + col / n;</span><br><span class="line"></span><br><span class="line">        rows[row][d]++;</span><br><span class="line">        columns[col][d]++;</span><br><span class="line">        boxes[idx][d]++;</span><br><span class="line">        board[row][col] = (<span class="keyword">char</span>)(d + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNumber</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Remove a number which didn't lead to a solution</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">int</span> idx = (row / n ) * n + col / n;</span><br><span class="line">        rows[row][d]--;</span><br><span class="line">        columns[col][d]--;</span><br><span class="line">        boxes[idx][d]--;</span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeNextNumbers</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Call backtrack function in recursion</span></span><br><span class="line"><span class="comment">    to continue to place numbers</span></span><br><span class="line"><span class="comment">    till the moment we have a solution</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="comment">// if we're in the last cell</span></span><br><span class="line">        <span class="comment">// that means we have the solution</span></span><br><span class="line">        <span class="keyword">if</span> ((col == N - <span class="number">1</span>) &amp;&amp; (row == N - <span class="number">1</span>)) &#123;</span><br><span class="line">            sudokuSolved = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if not yet</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// if we're in the end of the row</span></span><br><span class="line">            <span class="comment">// go to the next row</span></span><br><span class="line">            <span class="keyword">if</span> (col == N - <span class="number">1</span>) backtrack(row + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// go to the next column</span></span><br><span class="line">            <span class="keyword">else</span> backtrack(row, col + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Backtracking</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="comment">// if the cell is empty</span></span><br><span class="line">        <span class="keyword">if</span> (board[row][col] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="comment">// iterate over all numbers from 1 to 9</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt; <span class="number">10</span>; d++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (couldPlace(d, row, col)) &#123;</span><br><span class="line">                    placeNumber(d, row, col);</span><br><span class="line">                    placeNextNumbers(row, col);</span><br><span class="line">                    <span class="comment">// if sudoku is solved, there is no need to backtrack</span></span><br><span class="line">                    <span class="comment">// since the single unique solution is promised</span></span><br><span class="line">                    <span class="keyword">if</span> (!sudokuSolved) removeNumber(d, row, col);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> placeNextNumbers(row, col);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.board = board;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init rows, columns and boxes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> num = board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (num != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> d = Character.getNumericValue(num);</span><br><span class="line">                    placeNumber(d, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//Type 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 三个布尔数组 表明 行, 列, 还有 3*3 的方格的数字是否被使用过</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] rowUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[][] colUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[][][] boxUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; board.length; row++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; board[<span class="number">0</span>].length; col++) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = board[row][col] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">1</span> &lt;= num &amp;&amp; num &lt;= <span class="number">9</span>)&#123;</span><br><span class="line">                    rowUsed[row][num] = <span class="keyword">true</span>;</span><br><span class="line">                    colUsed[col][num] = <span class="keyword">true</span>;</span><br><span class="line">                    boxUsed[row/<span class="number">3</span>][col/<span class="number">3</span>][num] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归尝试填充数组 </span></span><br><span class="line">        recusiveSolveSudoku(board, rowUsed, colUsed, boxUsed, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recusiveSolveSudoku</span><span class="params">(<span class="keyword">char</span>[][]board, <span class="keyword">boolean</span>[][]rowUsed, <span class="keyword">boolean</span>[][]colUsed, <span class="keyword">boolean</span>[][][]boxUsed, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 边界校验, 如果已经填充完成, 返回true, 表示一切结束</span></span><br><span class="line">        <span class="keyword">if</span>(col == board[<span class="number">0</span>].length)&#123;</span><br><span class="line">            col = <span class="number">0</span>;</span><br><span class="line">            row++;</span><br><span class="line">            <span class="keyword">if</span>(row == board.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是空则尝试填充, 否则跳过继续尝试填充下一个位置</span></span><br><span class="line">        <span class="keyword">if</span>(board[row][col] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试填充1~9</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= <span class="number">9</span>; num++)&#123;</span><br><span class="line">			<span class="comment">//确保当前位置不会冲突</span></span><br><span class="line">                <span class="keyword">boolean</span> canUsed = !(rowUsed[row][num] || colUsed[col][num] || boxUsed[row/<span class="number">3</span>][col/<span class="number">3</span>][num]);</span><br><span class="line">                <span class="keyword">if</span>(canUsed)&#123;</span><br><span class="line">                    rowUsed[row][num] = <span class="keyword">true</span>;</span><br><span class="line">                    colUsed[col][num] = <span class="keyword">true</span>;</span><br><span class="line">                    boxUsed[row/<span class="number">3</span>][col/<span class="number">3</span>][num] = <span class="keyword">true</span>;</span><br><span class="line">                    </span><br><span class="line">                    board[row][col] = (<span class="keyword">char</span>)(<span class="string">'0'</span> + num);</span><br><span class="line">                    <span class="keyword">if</span>(recusiveSolveSudoku(board, rowUsed, colUsed, boxUsed, row, col + <span class="number">1</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">					</span><br><span class="line">					<span class="comment">//填充失败，那么我们需要回溯。将原来尝试填充的地方改回来。</span></span><br><span class="line">                    board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">                    </span><br><span class="line">                    rowUsed[row][num] = <span class="keyword">false</span>;</span><br><span class="line">                    colUsed[col][num] = <span class="keyword">false</span>;</span><br><span class="line">                    boxUsed[row/<span class="number">3</span>][col/<span class="number">3</span>][num] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> recusiveSolveSudoku(board, rowUsed, colUsed, boxUsed, row, col + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><p>搜索+剪枝的方法其实是有在上学期的课设时做了的，但是emm完全忘了，挖个坑，有空填了</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 剪枝条件:我们应该选择的格子（'.'）在一行、一列和一个九宫格中可选数字最少的格子开始填数字。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于每行、每列和每个9宫格都可以用一个9位的2进制数字来标识该行（列，9宫格）那些数字可以填。</span></span><br><span class="line"><span class="comment">    用1表示可填0表示不可填</span></span><br><span class="line"><span class="comment">    如例题中第一行 ：["5","3",".",".","7",".",".",".","."]</span></span><br><span class="line"><span class="comment">    第一行中 有数字 5 3 7</span></span><br><span class="line"><span class="comment">                    下标    8  7  6  5  4  3  2  1  0</span></span><br><span class="line"><span class="comment">                二进制数    0  0  1  0  1  0  1  0  0</span></span><br><span class="line"><span class="comment">    一共有9行所以用9个int表示行row[9],同理9列col[9],9个9宫格cell[3][3]*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">int</span>[] row = <span class="keyword">new</span> <span class="keyword">int</span> [N], col = <span class="keyword">new</span> <span class="keyword">int</span> [N];</span><br><span class="line">    <span class="comment">//ones数组表示0~2^9 - 1的整数中二进制表示中1的个数:如ones[7] = 3 ones[8] = 1</span></span><br><span class="line">    <span class="comment">//map数组表示2的整数次幂中二进制1所在位置（从0开始） 如 map[1] = 0,map[2] = 1, map[4] = 2</span></span><br><span class="line">    <span class="keyword">int</span>[] ones = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> &lt;&lt; N], map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> &lt;&lt; N];</span><br><span class="line">    <span class="keyword">int</span>[][] cell = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">3</span>]; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> cnt = fill_state(board);</span><br><span class="line">        dfs(cnt, board);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) row[i] = col[i] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">                cell[i][j] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//以上2个循环把数组的数初始化为二进制表示8个1，即一开始所以格子都可填</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) map[<span class="number">1</span> &lt;&lt; i] = i;</span><br><span class="line">        <span class="comment">//统计0~2^9 - 1的整数中二进制表示中1的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j != <span class="number">0</span>; j ^= lowBit(j)) n++;</span><br><span class="line">            ones[i] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fill_state</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;    <span class="comment">//统计board数组空格('.')的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> t = board[i][j] - <span class="string">'1'</span>;</span><br><span class="line">                    <span class="comment">//数独中 i,j位置为数组，修改row col cell数组中状态</span></span><br><span class="line">                    change_state(i, j, t);  </span><br><span class="line">                &#125;<span class="keyword">else</span> cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cnt, <span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">10</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//剪枝，即找出当前所以空格可填数字个数最少的位置 记为x y</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> k = ones[get(i, j)];</span><br><span class="line">                    <span class="keyword">if</span>(k &lt; min)&#123;</span><br><span class="line">                        min = k;</span><br><span class="line">                        x = i;</span><br><span class="line">                        y = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历当前 x y所以可选数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = get(x, y); i != <span class="number">0</span>; i ^= lowBit(i))&#123;</span><br><span class="line">            <span class="keyword">int</span> t = map[lowBit(i)];</span><br><span class="line">            </span><br><span class="line">            change_state(x, y, t);</span><br><span class="line">            board[x][y] = (<span class="keyword">char</span>)(<span class="string">'1'</span> + t);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(dfs(cnt - <span class="number">1</span>, board)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//恢复现场</span></span><br><span class="line">            change_state(x, y, t);</span><br><span class="line">            board[x][y] = <span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change_state</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        row[x] ^= <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">        col[y] ^= <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">        cell[x / <span class="number">3</span>][y / <span class="number">3</span>] ^= <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> row[x] &amp; col[y] &amp; cell[x / <span class="number">3</span>][y / <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -x &amp; x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>字母异位词分组</title>
    <url>/2019/11/03/%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<p>来源Leetcode第49题字母异位词分组</p>
<blockquote>
<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p>示例:</p>
<p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”] <a id="more"></a><br>输出:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]<br>说明：</p>
<ul>
<li>所有输入均为小写字母。</li>
<li>不考虑答案输出的顺序。</li>
</ul>
</blockquote>
<p>一开始做的时候，想着通过建一个哈希表来描述一个字符串有的字母，但是没做出来，还是要多看看JAVA的Hash啊</p>
<h4 id="通用解法"><a href="#通用解法" class="headerlink" title="通用解法"></a>通用解法</h4><p>对于每个字符串，比较它们的每个字符出现的个数是否相等，相等的话就把它们放在一个 list 中去，作为一个类别。最外层写一个 for 循环然后一一比较就可以，还可以用一个等大的布尔型数组来记录当前字符串是否已经加入的了 list 。比较两个字符串的字符出现的次数可以用一个 HashMap。</p>
<p>缺点就是，超时了</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="comment">//used 数组记录当前字符串是否已经加入list</span></span><br><span class="line">    <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[strs.length];</span><br><span class="line">	<span class="comment">//遍历string数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        List&lt;String&gt; temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">            temp = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            temp.add(strs[i]);</span><br><span class="line">            <span class="comment">//判断后续字符串是否字母出现次数一样</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; strs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!used[j]&amp;&amp;equals(strs[i], strs[j])) &#123;</span><br><span class="line">                    used[j] = <span class="keyword">true</span>;</span><br><span class="line">                    temp.add(strs[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ans.add(temp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(String string1, String string2)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//记录第一个字符串每个字符出现的次数，进行累加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; string1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash.containsKey(string1.charAt(i))) &#123;</span><br><span class="line">            hash.put(string1.charAt(i), hash.get(string1.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hash.put(string1.charAt(i), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//记录第一个字符串每个字符出现的次数，将之前的每次减 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; string2.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash.containsKey(string2.charAt(i))) &#123;</span><br><span class="line">            hash.put(string2.charAt(i), hash.get(string2.charAt(i)) - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断每个字符的次数是不是 0 ，不是的话直接返回 false</span></span><br><span class="line">    Set&lt;Character&gt; set = hash.keySet();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : set) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash.get(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>来自<a href="https://leetcode-cn.com/problems/group-anagrams/solution/zi-mu-yi-wei-ci-fen-zu-by-leetcode/" target="_blank" rel="noopener">题解</a></p>
<h4 id="按计数分类"><a href="#按计数分类" class="headerlink" title="按计数分类"></a>按计数分类</h4><p><strong>思路</strong></p>
<p>当且仅当它们的字符计数（每个字符的出现次数）相同时，两个字符串是字母异位词。</p>
<p><strong>算法</strong></p>
<p>我们可以将每个字符串 s 转换为字符数 count，由26个非负整数组成，表示 a,b,c 的数量等。我们使用这些计数作为哈希映射的基础。</p>
<p>在 Java 中，我们的字符数 count 的散列化表示将是一个用 <strong>＃</strong> 字符分隔的字符串。例如，abbccc 将表示为 ＃1＃2＃3＃0＃0＃0 …＃0，其中总共有26个条目。 在 python 中，表示将是一个计数的元组。 例如，abbccc 将表示为 (1,2,3,0,0，…，0)，其中总共有 26 个条目。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="comment">//初始化HASH Map</span></span><br><span class="line">        Map&lt;String, List&gt; ans = <span class="keyword">new</span> HashMap&lt;String, List&gt;();</span><br><span class="line">		<span class="comment">//count数组，标记出现的字母次数</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">		<span class="comment">//foreach 遍历strs里的所有string</span></span><br><span class="line">        <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">		    <span class="comment">//count数组初始化为0</span></span><br><span class="line">            Arrays.fill(count, <span class="number">0</span>);</span><br><span class="line">			<span class="comment">//统计字母出现次数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) count[c - <span class="string">'a'</span>]++;</span><br><span class="line">			<span class="comment">//构造字符串</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                sb.append(<span class="string">'#'</span>);</span><br><span class="line">                sb.append(count[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            String key = sb.toString();</span><br><span class="line">			<span class="comment">//如果key(即统计字母次数字符串)没有出现在Map里，就添加key</span></span><br><span class="line">            <span class="keyword">if</span> (!ans.containsKey(key)) ans.put(key, <span class="keyword">new</span> ArrayList());</span><br><span class="line">			<span class="comment">//往Map里增加key、s的映射</span></span><br><span class="line">            ans.get(key).add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(ans.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="排序数组分类"><a href="#排序数组分类" class="headerlink" title="排序数组分类"></a>排序数组分类</h4><p><strong>思路</strong></p>
<p>当且仅当它们的排序字符串相等时，两个字符串是字母异位词。</p>
<p><strong>算法</strong></p>
<p>维护一个映射 ans : {String -&gt; List}，其中每个键 K 是一个排序字符串，每个值是初始输入的字符串列表，排序后等于 K。</p>
<p>在 Java 中，我们将键存储为字符串，例如，code。 在 Python 中，我们将键存储为散列化元组，例如，(‘c’, ‘o’, ‘d’, ‘e’)。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Map&lt;String, List&gt; ans = <span class="keyword">new</span> HashMap&lt;String, List&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] ca = s.toCharArray();</span><br><span class="line">            Arrays.sort(ca);</span><br><span class="line">            String key = String.valueOf(ca);</span><br><span class="line">            <span class="keyword">if</span> (!ans.containsKey(key)) ans.put(key, <span class="keyword">new</span> ArrayList());</span><br><span class="line">            ans.get(key).add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(ans.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="正整数的唯一分解定理"><a href="#正整数的唯一分解定理" class="headerlink" title="正整数的唯一分解定理"></a>正整数的唯一分解定理</h4><blockquote>
<p>算术基本定理，又称为正整数的唯一分解定理，即：每个大于1的自然数，要么本身就是质数，要么可以写为2个以上的质数的积，而且这些质因子按大小排列之后，写法仅有一种方式。</p>
</blockquote>
<p>利用这个，我们把每个字符串都映射到一个正数上。</p>
<p>用一个数组存储质数 prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103}。</p>
<p>然后每个字符串的字符减去 ‘ a ‘ ，然后取到 prime 中对应的质数。把它们累乘。</p>
<p>例如 abc ，就对应 ‘a’ - ‘a’， ‘b’ - ‘a’， ‘c’ - ‘a’，即 0, 1, 2，也就是对应素数 2 3 5，然后相乘 2 <em> 3 </em> 5 = 30，就把 “abc” 映射到了 30。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    HashMap&lt;Integer, List&lt;String&gt;&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//每个字母对应一个质数</span></span><br><span class="line">    <span class="keyword">int</span>[] prime = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>, <span class="number">103</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//累乘得到 key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; strs[i].length(); j++) &#123;</span><br><span class="line">            key *= prime[strs[i].charAt(j) - <span class="string">'a'</span>];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (hash.containsKey(key)) &#123;</span><br><span class="line">            hash.get(key).add(strs[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            temp.add(strs[i]);</span><br><span class="line">            hash.put(key, temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(hash.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转图像</title>
    <url>/2019/10/31/%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<p>来源Leetcode第48题旋转图像</p>
<blockquote>
<p>给定一个 n × n 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p>说明：<a id="more"></a></p>
<p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像</p>
<p>示例 1:</p>
<p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p>
</blockquote>
<h4 id="两次翻转"><a href="#两次翻转" class="headerlink" title="两次翻转"></a>两次翻转</h4><p>这题没什么思路，规律没找到。<br>看了题解之后知道可以通过上下翻转一次，在通过对角线翻转一次即可完成。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">		<span class="comment">//上下翻转</span></span><br><span class="line">		<span class="comment">// n/2代表矩阵的中间线，以实现对折翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i ++)&#123;</span><br><span class="line">		<span class="comment">//保存欲翻转的当前行</span></span><br><span class="line">            <span class="keyword">int</span>[] tmp = matrix[i];</span><br><span class="line">		<span class="comment">//整行翻转</span></span><br><span class="line">            matrix[i] = matrix[n - i - <span class="number">1</span>];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对角翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j= i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="四数交换"><a href="#四数交换" class="headerlink" title="四数交换"></a>四数交换</h4><p>当然这题规律找出来了就是简单的四数交换，感谢<a href="https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-ti-jie-by-mu-yi-wei-lan/" target="_blank" rel="noopener">木苡微澜的题解</a></p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*将举证旋转90度的方法：</span></span><br><span class="line"><span class="comment">	 * 矩阵例子：</span></span><br><span class="line"><span class="comment">	  [ 5, 1, 9, 11],</span></span><br><span class="line"><span class="comment">	  [ 2, 4, 8, 10],</span></span><br><span class="line"><span class="comment">	  [13, 3, 6,  7],</span></span><br><span class="line"><span class="comment">	  [15,14,12, 16]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> length = matrix.length;<span class="comment">// 给定的矩阵的边长</span></span><br><span class="line"><span class="keyword">int</span> lengthend = matrix.length;<span class="comment">// 每一圈中分好的块的末尾元素的行或者列的下标（具体圈具体分析）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 由外而内，逐个圈进行旋转 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt;= (length - <span class="number">1</span>) / <span class="number">2</span>; r++) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 创建一个临时数组作为中转站，存放每一个块的数据，注意由外而内每一个圈的块的元素数量不同，</span></span><br><span class="line"><span class="comment">        * 故临时数组长度不一样，用数理逻辑推出长度公式：length-2*r-1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[length-<span class="number">2</span>*r-<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*举例：（外圈情况）把第一个块元素放进临时数组temp中</span></span><br><span class="line"><span class="comment">        [ 5, 1, 9,  ], ==&gt; temp[]</span></span><br><span class="line"><span class="comment">        [           ],</span></span><br><span class="line"><span class="comment">        [           ],</span></span><br><span class="line"><span class="comment">        [           ]                    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123; <span class="comment">// 这个i是临时数组的下标</span></span><br><span class="line">        temp[i] = matrix[r][i + r];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*举例：（外圈情况）块[2,13,15]换到[5,1,9]的位置</span></span><br><span class="line"><span class="comment">        [ 5, 1, 9,  ],</span></span><br><span class="line"><span class="comment">        [ 2,        ],</span></span><br><span class="line"><span class="comment">        [13,        ],</span></span><br><span class="line"><span class="comment">        [15,        ]                     </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> + r; i &lt; lengthend; i++) &#123;</span><br><span class="line">        matrix[r][length - <span class="number">1</span> - i] = matrix[i][r];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*举例：（外圈情况）块[14,12,16]换到[2,13,15]的位置</span></span><br><span class="line"><span class="comment">        [           ],</span></span><br><span class="line"><span class="comment">        [ 2,        ],</span></span><br><span class="line"><span class="comment">        [13,        ],</span></span><br><span class="line"><span class="comment">        [15,14,12,16]                      </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> + r; i &lt; lengthend; i++) &#123;</span><br><span class="line">        matrix[i][r] = matrix[length - <span class="number">1</span> - r][i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*举例：（外圈情况）块[11,10,7]换到[14,12,16]的位置</span></span><br><span class="line"><span class="comment">        [        ,11],</span></span><br><span class="line"><span class="comment">        [        ,10],</span></span><br><span class="line"><span class="comment">        [        , 7],</span></span><br><span class="line"><span class="comment">        [  ,14,12,16]                       </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> + r; i &lt; lengthend; i++) &#123;</span><br><span class="line">        matrix[length - <span class="number">1</span> - r][i] = matrix[length - <span class="number">1</span> - i][length - <span class="number">1</span> - r];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*举例：（外圈情况）把临时数组temp中的元素放进第一个块中</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        temp[] ==&gt; [            ],</span></span><br><span class="line"><span class="comment">                    [            ],</span></span><br><span class="line"><span class="comment">                    [            ],</span></span><br><span class="line"><span class="comment">                    [            ]            </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= temp.length; i++) &#123;</span><br><span class="line">        matrix[length - i - <span class="number">1</span> - r][length - <span class="number">1</span> - r] = temp[temp.length - i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*进入下一圈之前，这一圈中分好的块的末尾元素的行或者列的下标缩小一位*/</span></span><br><span class="line">    lengthend -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将这几个循环写在一起就是这样</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//由外而内，逐个圈进行旋转</span></span><br><span class="line">        <span class="keyword">int</span> len = matrix.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">		<span class="comment">//定义由外而内每一个圈的块的元素数量</span></span><br><span class="line">            <span class="keyword">int</span> lengthend = matrix.length - <span class="number">1</span> - <span class="number">2</span> * j;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthend; i++) &#123;</span><br><span class="line">		<span class="comment">//然后开始4个数4个数的交换</span></span><br><span class="line">		<span class="comment">//第一轮的4个数是4个角的数</span></span><br><span class="line">		<span class="comment">//然后在往右移，以此类推</span></span><br><span class="line">                <span class="keyword">int</span> temp = matrix[j][i + j];</span><br><span class="line">                matrix[j][i + j] = matrix[matrix.length - <span class="number">1</span> - j - i][j];</span><br><span class="line">                matrix[matrix.length - <span class="number">1</span> - j - i][j] =  matrix[matrix.length - <span class="number">1</span> - j][matrix.length - <span class="number">1</span> - j - i];</span><br><span class="line">                matrix[matrix.length - <span class="number">1</span> - j][matrix.length - <span class="number">1</span> - j - i] = matrix[j + i][matrix.length - <span class="number">1</span> - j];</span><br><span class="line">                matrix[j + i][matrix.length - <span class="number">1</span> - j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>相同的树</title>
    <url>/2019/10/30/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<p>来源Leetcode第100题相同的树</p>
<blockquote>
<p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
</blockquote>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>最简单的比较根节点然后递归比较左子树和右子树，没有什么好说的。<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果两个根节点都为空，那肯定是相等的</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 有一个不为空，那就不等了</span></span><br><span class="line">    <span class="keyword">if</span> (q == <span class="keyword">null</span> || p == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// 都不为空，比较值</span></span><br><span class="line">	<span class="comment">//然后开始递归比较左右子树</span></span><br><span class="line">    <span class="keyword">if</span> (p.val != q.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(p.right, q.right) &amp;&amp;</span><br><span class="line">            isSameTree(p.left, q.left);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h4><p>本来后面是想用两个栈写的，但是笔记本电池续航尿崩了，先看看题解里是怎么写的吧。</p>
<p>题解采用了<strong>双向队列</strong>，并不是栈，emm</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//根节点入栈(队列)</span></span><br><span class="line">        stack1.push(p);</span><br><span class="line">        stack2.push(q);</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty() &amp;&amp; !stack2.isEmpty()) &#123;</span><br><span class="line">		</span><br><span class="line">		    <span class="comment">//栈顶元素出栈</span></span><br><span class="line">            TreeNode a = stack1.pop();</span><br><span class="line">            TreeNode b = stack2.pop();</span><br><span class="line">			<span class="comment">//比较出栈元素</span></span><br><span class="line">            <span class="keyword">if</span> (a == <span class="keyword">null</span> &amp;&amp; b == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span> &amp;&amp; b != <span class="keyword">null</span> &amp;&amp; a.val == b.val) &#123;</span><br><span class="line">			<span class="comment">//值相等或者都为空将左右子树入栈</span></span><br><span class="line">                stack1.push(a.left);</span><br><span class="line">                stack1.push(a.right);</span><br><span class="line">                stack2.push(b.left);</span><br><span class="line">                stack2.push(b.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty() &amp;&amp; stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序数组</title>
    <url>/2019/10/30/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>来源Leetcode第88题合并两个有序数组</p>
<blockquote>
<p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p>
<p>说明:<br><a id="more"></a></p>
<ul>
<li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。</li>
<li>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:</li>
</ul>
<p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p>
<p>输出: [1,2,2,3,5,6]</p>
</blockquote>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>最简单的想法就是将nums2数组的元素合并到nums1里，这个只用一个for循环就可以实现，最后调用系统库函数sort就可以了。<br>然而我万万没想到的是，系统库函数里有个arraycopy，甚至可以不用复制数组，我傻了。</p>
<blockquote>
<p>源码：public static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos,int length);</p>
<p>参数：</p>
<ul>
<li><p>src：要复制的数组(源数组)</p>
</li>
<li><p>srcPos：复制源数组的起始位置</p>
</li>
<li><p>dest：目标数组</p>
</li>
<li><p>destPos：目标数组的下标位置</p>
</li>
<li><p>length：要复制的长度</p>
</li>
</ul>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(nums2, <span class="number">0</span>, nums1, m, n);</span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetcode/" target="_blank" rel="noopener">官方题解</a>采用了两种双指针的解法，分别是从前往后和从后往前。</p>
<h4 id="从前往后"><a href="#从前往后" class="headerlink" title="从前往后"></a>从前往后</h4><blockquote>
<p>一般而言，对于有序数组可以通过 双指针法 达到OO(n+m)的时间复杂度。最直接的算法实现是将指针p1置为nums1的开头， p2为 nums2的开头，在每一步将最小值放入输出数组中。由于nums1 是用于输出的数组，需要将nums1中的前m个元素放在其他地方，也就需要O(m)的空间复杂度。</p>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make a copy of nums1.</span></span><br><span class="line">    <span class="keyword">int</span> [] nums1_copy = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    System.arraycopy(nums1, <span class="number">0</span>, nums1_copy, <span class="number">0</span>, m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Two get pointers for nums1_copy and nums2.</span></span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set pointer for nums1</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compare elements from nums1_copy and nums2</span></span><br><span class="line">    <span class="comment">// and add the smallest one into nums1.</span></span><br><span class="line">    <span class="keyword">while</span> ((p1 &lt; m) &amp;&amp; (p2 &lt; n))</span><br><span class="line">      nums1[p++] = (nums1_copy[p1] &lt; nums2[p2]) ? nums1_copy[p1++] : nums2[p2++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if there are still elements to add</span></span><br><span class="line">    <span class="keyword">if</span> (p1 &lt; m)</span><br><span class="line">      System.arraycopy(nums1_copy, p1, nums1, p1 + p2, m + n - p1 - p2);</span><br><span class="line">    <span class="keyword">if</span> (p2 &lt; n)</span><br><span class="line">      System.arraycopy(nums2, p2, nums1, p1 + p2, m + n - p1 - p2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="从后往前"><a href="#从后往前" class="headerlink" title="从后往前"></a>从后往前</h4><p>从前往后已经取得了最优的时间复杂度O(n+m)，但需要使用额外空间。这是由于在从头改变nums1的值时，需要把nums1中的元素存放在其他位置。<br>如果我们从结尾开始改写 nums1 的值又会如何呢？这里没有信息，因此不需要额外空间。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// two get pointers for nums1 and nums2</span></span><br><span class="line">    <span class="keyword">int</span> p1 = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// set pointer for nums1</span></span><br><span class="line">    <span class="keyword">int</span> p = m + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while there are still elements to compare</span></span><br><span class="line">    <span class="keyword">while</span> ((p1 &gt;= <span class="number">0</span>) &amp;&amp; (p2 &gt;= <span class="number">0</span>))</span><br><span class="line">      <span class="comment">// compare two elements from nums1 and nums2 </span></span><br><span class="line">      <span class="comment">// and add the largest one in nums1 </span></span><br><span class="line">      nums1[p--] = (nums1[p1] &lt; nums2[p2]) ? nums2[p2--] : nums1[p1--];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add missing elements from nums2</span></span><br><span class="line">	<span class="comment">//当退出循环时，有可能是p1为负，也有可能是p2为负</span></span><br><span class="line">	<span class="comment">//如果是p2为负，则说明复制已经完成，这时候的复制长度p2 + 1为0</span></span><br><span class="line">	<span class="comment">//如果是p1为负，说明nums1数组的元素大于nums2数组的元素，这时候nums1数组前面空了p2 + 1个元素出来，因而要复制nums2数组的p2 + 1个元素到nums1</span></span><br><span class="line">    System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, p2 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>香港杂谈</title>
    <url>/2019/10/30/%E9%A6%99%E6%B8%AF%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<p>来源陈启宗访谈</p>
<p>Q：香港人均居住面积在世界发达经济体里是垫底的，基尼系数是排前列的。所以内地关心香港的人士普遍认为香港问题的内因在于贫富差距、住房困难等民生议题。可是街头激进抗议者的五大诉求与百姓民生的需要毫不相干，也就是说香港人碰到的问题和街上喊出来的诉求是两回事<a id="more"></a>。对此你怎么解读？ 香港特区政府有没有可能像法国政府对待“黄背心运动”那样，通过对话妥协与抗议者达成和解？</p>
<p>A:说香港问题的核心是民生问题，这个观点绝对错了。民生问题是一个原因，甚至可以说是个很重要的原因，但绝对不是核心问题。昨天（9月3日）新加坡学者马凯硕访问香港提出一个观点，即过去二三十年全球都在增长，但美国收入较低的50%的人的平均收入没有增长，因此便产生了特朗普。香港贫富分化的情况和美国有点类似，跟房地产价格畸高有相当一部分关系，但不是唯一的关系。要知道，英国殖民统治时期香港也有同样的民生问题，但当时为什么没有演变成社会政治危机？1997年6月30日楼价创新高，人们为什么没有上街闹事？</p>
<p>归根结底，香港有一批人的“政治基因”跟内地的中国人不一样，这一小部分人从根本上不认同中华人民共和国的政体，但没有不认同大英帝国的政体。他们认老外，不认中国人。可以说在回归之后香港一直没有根本解决，或者说根本没有解决这批香港人对内地政治合法性的认同问题，而且这个情况在一些暗势力的操纵下还在恶化，因为以前港英时期为了去除香港人的国家观念——这个话题待会再说——殖民地教育是去政治化的，也就是，本来普通香港人是不关心政治的。但是英国人走之前突然把“政治”放出来了。这些年来教育掌握在泛民派手里，香港被他们搞的高度政治化，炮制出一种反中国的身份认同。</p>
<p>现在好多人——特别是我在内地的朋友——以为民生问题是导致当前困境的核心问题。甚至许多内地朋友在香港待了二三十年，可由于他们从小形成了思维定势，不自觉地就会套用到香港上来，这样认识香港、解读香港，会得出不正确的答案。民生问题是经济问题，经济问题是可以解决、可以妥协的。但政治是你死我活的。法国的“黄背心运动”跟香港完全不一样，法国那是民生诉求，香港现在是意识形态斗争。历史上，意识形态斗争就好比政治、宗教冲突，有得妥协吗？没有。香港问题的核心如果仅仅是贫富悬殊这么简单的话，早就解决掉了。但这个问题的根，在香港的政治生态。这一点你们不要搞错。我现在最担心的问题之一，就是内地的朋友误读香港的情况。</p>
<p>我最近在内地住了几天，跟不同的朋友聊天，有人质疑说香港问题都是你们房地产商搞出来的。我虽然是房地产商，虽然住在香港，也一直关注香港房地产，但我已经差不多20年没有在香港买过什么土地，基本算是退出香港房地产市场的局外人了，所以我说话还算是比较客观吧。我觉得不能把所有罪过都推到香港房地产商的头上，这倒不是我为朋友们说话，我承认香港房地产商有几个缺点，第一，私心太重，社会公益心不够；第二，除个别人外，大都对政治真是一窍不通。把问题都归咎于房地产商头上，恐怕是弄错了。</p>
<p>还有人说香港房地产商阶层控制了政治。这简直是笑话。可能有个别人很有政治手腕，但其他大多数房地产商哪里懂什么政治？8月13日，香港地产建设商会在报纸上登了个声明谴责暴力和破坏行为，对这个没有政治意识的群体来说已经很不容易了。郑永年教授不久前在一次对话里批评香港房地产商作为既得利益群体，只知逐利却不承担政治责任。可你怎么能指望一群连政治观念都没有的人去承担政治责任呢？何况现在房地产商在香港社会上不再受到普遍的尊敬，说话没有人听。这和1997年以前那个大家“向钱看”的年代不一样，那时候谁钱多谁就能得到尊敬。这个格局在回归之后早就已经改变了。</p>
<p>按理说房地产原本不应该成为香港的社会弊病。1997年香港特区首任行政长官董建华先生一上任就宣布了“八万五”计划，就是说每年兴建的公营和私营房屋单位不少于85000套。要是真的这样做，现在香港就不会出现住房难的问题了。但不幸的是，香港7月1日回归，7月2日就爆发了亚洲金融危机，导致董先生的计划落空。可这件事即便当时做不了，早晚还是应该做的，对不对？但结果后来也没有做。香港房价贵到让人负担不起，其实原因很简单就是土地供不应求，我认为有这几方面应该为此承担责任。</p>
<p>首先是香港泛民派。20多年以来，每逢该卖地的时候，泛民派就出来阻挠，不该卖地的时候，比如亚洲金融危机的时候，他们却呼吁政府快卖地。他们这样做，不是出于经济考量，而是政治原因。他们不但逢中必反，逢香港特区政府也必反。这样一来，香港房地产市场就被泛民派给搅乱了。</p>
<p>当年董先生要卖地，但不幸遇上亚洲金融危机，卖不了也没办法。曾特首上任时非典危机已经结束了，到了2005年左右应该卖地了吧？结果还是不卖，到了他任期最后一年才迫于压力开始卖地，前面几年卖地面积是零。为什么发生这样不合理的事呢？主要是因为个别房地产商私心太重。其实当时香港地产建设商会里大部分人都希望政府卖地，可就有个别人叫政府不卖政府就真不卖，大家呼吁也没有用。所以这也是今天问题的一个原因。</p>
<p>第三方面就是当初阻挠政府卖地的那几个人。梁振英先生是地产专家，他是懂行的，上世纪80年代上海土地使用权有偿出让招标文件是他亲笔帮助起草的。2012年他上任后愿意卖地了，结果因为之前15年的遗留问题，他要卖地却卖不了，填海又不准。</p>
<p>梁先生没法卖地还是因为来自泛民派的政治阻力，泛民派不是误判房地产市场，而是故意要增加政府与民众之间的矛盾。另外梁先生要卖地也影响了好多人的利益。我曾经在业界内部的饭局上听见有人大骂梁先生，就因为他要卖地。当初他还没上台的时候，香港这些人极力阻挠他上台，他上台之后就极力想把他弄下来。</p>
<p>同样，林郑月娥女士上台后，也在卖地的问题上做了不少的努力。她从前是特区政府发展局局长，对房地产非常了解。而且从我个人的认识来看，梁特首和林郑特首都是相当有社会主义价值倾向的人，他们都想努力消除社会贫富差距，改善民生，让百姓安居乐业。他们都尝试过，两个人加起来试了七年，可就是搞不出土地来。</p>
<p>其实香港的民生问题解决起来没那么复杂。许多人不知道，香港有个世界少有的土地资源，它41%的土地是郊野公园，只要拿2%的土地出来，另外59%还保持原样，就可以解决住房问题。现在全香港已经盖了房子、修了路、建了桥的土地只占24%左右，其中住宅的比例就更小了，只有7%而已。只要从郊野公园里拿出2%来，就能新增约10%的住宅用地。</p>
<p>内地许多朋友说香港可以拿出更多土地来，可两任特首都是强势的人，他们努力了七年都做不到，只抓住眼前民生问题有什么意义？香港政治生态问题不解决，再谈100年也解决不了土地问题。什么民生艰难、房子太贵太小等问题，根子都在香港的政治生态上。特区政府陷入了香港政治沼泽里，要抽干这个政治沼泽当然不容易，但是问题的根在这个地方，也必须面对。未来香港的社会结构，包括政府架构，恐怕也都需要有勇气去改革，才能走出困境！</p>
<p>Q:英国对香港的殖民统治早已结束，但它似乎保持着对香港的影响力，是否存在某种隐性殖民势力？</p>
<p>1997年之前我就说过，英国人比较现实，你保护他们的经济利益，它们手也不会伸得太长，它这方面的能力也不够强。但美国手就伸得很长，它在全世界都是这个样子，也不是只在香港才这样，所以也没什么奇怪的。你认为奇怪那才怪咧。</p>
<p>Q:在香港我们看到了颜色革命的经典套路，一是掌握媒体，二是挟持年轻人，三是瘫痪警权。不过也有新东西，比如在以往的颜色革命里，街头反对派掌握不了司法权，如今香港司法制度让警员很难有效拘捕闹事者，导致暴力违法行为一再发生。新加坡国立大学的郑永年先生最近对香港问题发表了看法，认为新加坡之所以成功，是因为它改造了殖民者留下来的司法体系，确保司法体系代表新加坡的主权利益。一旦司法体系脱离了主权，你什么事情都做不了，课文改不了，执法也很不便。他认为香港属于“无政党政治”，所以遇到教育、司法和民生问题，很难采取有效措施。你对此怎么看？</p>
<p>A:港回归22年来，司法制度绝对是个大问题。警员也是人，他尽力维持公共秩序而打你一棍，可能就要坐两年牢。其他警员目睹这种事之后，还敢不敢执法？我不赞同过分的暴力，但你去了解一下过去一二十年在巴黎、纽约、洛杉矶、巴塞罗那和伦敦发生的事，再对比一下香港，就会发现香港警员绝对非常克制。但再克制他们也是人啊，是吧？而且那些搞事的所谓“勇武派”就是要警员打他们，像什么？像敢死队。这些极端分子千方百计惹警员生气，就希望你打他们。你一打，无数镜头对准你，他们就需要这个。</p>
<p>其实司法制度说到底是个政治问题。有人说司法体系的基础是法律、法治。我问他美国的大法官是谁任命的？是总统任命的，国会的投票也是明显跟着两党的政治倾向而投票。美国法律谁写的？美国国会写的，而国会完全是受两个大党的党派政治左右的。所以追溯到源头，政治和法律是不能分开的。西方标榜司法独立，从某个角度来看是有一点道理的，但这种独立是有限的。可现在香港把司法独立说成是绝对的，认为法律就应该高高在上，殊不知法律到了顶点就是政治。</p>
<p>香港司法体系基本属于一个沦陷区。港英时期的大法官是受英国控制的，英国对香港司法是有主权的，现在中国对香港司法有主权吗？可以说香港司法体系存在一个主权真空。尽管香港司法的最高解释权在人大，虽说香港大法官是须经中央政府同意，但他们究竟是谁的人？司法主权在谁那里？当然我也不能下结论说香港司法制度受到某些外部势力有意识的操纵，它本身就有一些“政治基因”问题，导致它本身有一种强烈的倾向。话又说回来，你不培养合适的司法人选，该做的事没做，很难怪别人。</p>
<p>Q:你说的这种倾向反映了政治认同的差异，它似乎受到香港媒体的强化。你平时在香港经常看什么报纸吗？</p>
<p>A:我基本上什么报纸电视网站都不看，媒体给我的附加价值很低。公司每天把一些重要的事实汇报给我就可以了，怎么评估是我自己的事。如果我想要深入了解一点，可以去询问我很多朋友，他们的分析能力比报纸好多了。</p>
<p>Q:内地大城市连报刊亭都快没有了，也没什么人买报纸了，可香港报纸发行量却这么大，动不动就是几十万份。香港本来是个法治严明、市民遵纪守法的城市，但现在它突然运动起来了，跟媒体有没有关系？而且香港媒体为何对街头政治一致采取同情甚至支持的立场？这个群体本身也表现出很强的政治意识，仿佛是个政党，导致不一样的声音很难发出来。那么香港媒体究竟控制在谁手里？</p>
<p>A:我对媒体认识不够，但香港媒体一面倒现象倒是很清楚。尽管有《文汇报》、《大公报》，但除非你要做内地生意或者要研究内地，否则不会太关心这些报纸，它们影响力比较有限。这种情况从回归之前持续至今。另外你说得对，媒体对于社会运动而言，的确是一个很厉害的工具，是一种政治手段。但你问我谁掌握香港媒体这我真的不知道，我没有做过细致调查研究，不能妄下结论。当然香港有搞媒体的人分析说本地50%的媒体控制在一家人手上。</p>
<p>Q:过去很长一段时间，内地人看到香港经济发达，在心态上就矮一截。现在开始有些变化了。国家现在对深圳有一个宏大的计划，要将其打造为先行示范区。香港人怎么看？你会去那里去投资吗？</p>
<p>A:国家当然应该这么做。20年前我就说过，香港好比祖国的儿子，但从小时候就被拐卖掉了，150多年来在另外一个文化背景成长，根本没有作为中国人的感情和认同。后来这个儿子回来了。他有钱是有钱，但可靠吗？不是我对香港有意见，而是要看你香港怎么做。你要是回来后有一家人的样子，那很好，没事了。但要是你回来之后，不知道你姓什么，那对不起，中央不把上海深圳做大做好，简直对不起中国老百姓。香港从回归第一天开始，就不知道自己姓什么。国家当然要把上海、深圳搞起来。香港在大湾区内部没有太大的优势。很简单一个例子，我有时候需要过海关到深圳，拖着行李上车下车各种手续好麻烦。所以要把深圳做起来，它和大湾区其他城市可以做到无缝衔接，这更有利于发展。</p>
<p>香港有什么优势？基本上就一个优势，非要说也可以说有两个。最主要的就是金融，但不要忘记金融是服务行业，别的行业需要你的时候你去服务服务，而整个大湾区不是以金融为主体的。香港还有什么，我想来想去就是香港的大学相当好，理科工科医科都相当不错。除了这些之外，香港还有什么？这些问题香港年轻人是看不到的，可以说他们已经被荼毒了。</p>
<p>1997年之后，受传媒、教育等各方面因素影响，香港年轻人成了现在这个样子，从自大到自卑，落差太大了。他们从前是没有道理的自大，瞧不起内地人，现在内地人有钱了，他们又自卑了。十年前内地人来香港购物，被香港人骂“蝗虫”甚至被打，我就奇怪了香港人跟内地人有什么不一样呢，不过是早些年来香港而已嘛，凭什么瞧不起人？然而没过几年，香港人又掉过头来，从自大变得自卑。昨天晚上我跟老婆去一家档次比较高的餐厅吃饭，听到周围几桌坐的人全都是说普通话的。你想想香港人看到这种事会有什么心态？落差太大了。这时候香港媒体就出来煽风点火了，来解释这种现象的成因，这简直就是干柴烈火啊。很多香港年轻人自己不求上进，觉得一切权益都理所当然，是世界欠他们的，遇见挫折都是别人的错。二十年前我都快50岁了，那时我就跟香港年轻人说，我要是你们这个年纪，我一定往内地跑。现在内地机会很多，可他们不愿意去。</p>
<p>Q:现在香港教育界也快成了沦陷区。你觉得有什么好的办法，现在能够来改善改变这些地方？</p>
<p>A:现在的关键不是去解决某个领域里具体的事务，头痛医头脚痛医脚是不行的，要把握好大事，要治本。我们要分清楚什么样的人可以做官，什么样的人只能为吏。中国古代的官是科举考上去的，是要为国家意识形态负责的，而吏是官委任的，负责一些行政事务而已。如果把吏放在官的位置，说明我们缺乏对香港的根本认知。你能让我陈某人去CBA、NBA打篮球吗？这不是开玩笑吗？香港的事这么不重要吗？</p>
<p>Q:8月13号的时候，你参加香港地产商在报纸上发声，这是香港本地对激进暴力示威的重要反应。你当时是怎么考虑的？</p>
<p>A:老实说没怎么考虑，该做的事就做，需要什么考虑？你可能不清楚，香港人给英国人搞到了完全没有政治意识的地步，所以对政治的事非常不了解——包括最大的地产商。所以香港人一般来说政治上都极度幼稚，不同于在别的地方长大的人，比如说中国内地长大的人对政治很敏感，在美国长大也是这样。但香港有一帮人完全没有政治方面的认知。</p>
<p>Q：我很同意你的看法，你认识的李世默先生在TED上做过一个演讲，叫做“元叙事的终结”，就是冷战时期有两种元叙事，后来讲西式普世价值、普选、人权的赢了。但香港很特殊，冷战时没有经历过这两个东西。所以你刚才说香港本地老百姓不政治化，那么现在开始变得政治化，是不是有人刻意要“补课”的意思？抗议者的五大诉求与百姓民生的需要并不匹配，他们面临的民生问题与他们在街上喊出来的口号是两回事。对此你怎么解读？</p>
<p>A：怎么解释呢？第一，香港人的“政治基因”跟内地人不一样，有新中国成立时跑下来的，有“三反五反”时跑下来的，有大饥荒时跑下来的，有文革跑下来的，有学潮时跑下来的，所以这些人自然对北京方面存有戒心甚至敌意，他们使香港人的“政治基因”变得跟内地老百姓相当不一样。</p>
<p>第二，英国人也是真厉害，他们为了自身的利益，在香港回归之前的几十年里，特别是60年代中期之后——因为那时发生了两件事，一个是银行挤兑，一个是受文革影响而发生的六七暴动——促使英国人培养出一种世界少见的人，即完全没有国家观念且完全没有政治意识的人。</p>
<p>50年代有国家观念的香港人跑去台湾，就成了跟台湾勾结；70年代特别80年代之后，有国家观念的香港人就被香港当局视为勾结北京；港英政府也怕香港人在国家观念上认同英国，所以绝对不承认你是英国人，不让你移民去英国，可见他们对国家观念极度敏感，所以他们就彻底抹杀香港人的国家观念，用经济来麻醉香港人。</p>
<p>这样做也有些好处，就是让大家都不讲政治，去发展经济，所以经济比较容易起来。社会上大量优秀的、有头脑的人都涌向商界，商业气氛自然就浓厚起来。但是另一方面也就制造出来一帮全没有政治意识，甚至可以说对政治完全无知的人。港英治下的香港不容许你讲政治，更不容许你讲国与国之间的大政治。</p>
<p>1997年回归之后，要港人治港，才开始有政党，开始有地方政治，可香港人对国与国之间的大政治仍然很无知，因为他们完全没受过这方面的培养。内地的朋友们很有国家观念，对国与国之间的政治很关心，他们的问题可能在于只看到一面，比较不容易客观看待国际问题。但香港人是主观客观都没有，对大政治一窍不通。自从回归以来，香港从来没有对英国殖民统治进行过认真的反思和讨论，没有对英国人做的好事坏事进行客观评价。当然，进行这样的讨论并非易事，但总之香港社会就是没有对此进行大辩论。再加上外国某些人把香港看作棋子，特别是最近这两三年，在中美大格局变化的背景下，香港更变成一个小兵小卒了。</p>
<p>在这样的背景下，一些跟内地“政治基因”不同的人、别有用心的人、背后得到国际势力支持的人，毒害了香港的年轻人。回归至今22年了，现在上街的好多年轻人甚至不到22岁，哪怕那些30岁左右的，当初也不过8岁，他们对北京能有什么认识？北京没有对你不好吧？这30年来有做过对不起你的事吗？没有嘛！所以我说香港问题是政治问题，就这个原因。那些反北京的人控制了教育界。现在上街的这些孩子们二十多年来读的书、受的教育，都是所谓的泛民派写出来的东西。你说他们会有怎样的政治意识，会形成怎样的政治生态？学校要推行国民教育，香港人不接受，为什么不接受？政治原因。</p>
<p>Q：现在特区政府已经伸出了橄榄枝，愿意对话，但似乎对话一直对不起来，还可能有什么妥协的方式吗？如何达成和解？在法国，黄背心运动的民生诉求很强烈，政府做出一些妥协就可以达成一定程度的和解。香港反对派似乎不接受妥协，为何？</p>
<p>A：1997年回归之后，香港算是有了本地的政党政治，从第一天就开始政治斗争，注意斗的是政治而不是经济。而且香港的事还牵涉到一些外国势力，香港不过是一枚地缘政治的棋子，一个小卒而已。外国势力为什么利用香港啊，还不是为了攻击中国。正如香港反对派不是冲着香港政府，而是冲着北京。从1997年7月1日开始，他们反对的就不是香港政府而是中央政府，说白了就是反共。他们在意识形态上与中国内地是敌对的，你说这不是政治是什么？政治斗争有妥协的吗？怎么妥协？</p>
<p>以往在反对派的压力面前，我们有的政府官员，甚至北京，是你推我就退，你再推我又退，退到最后一步你说不要推了，我自刎。那下次他们不推你才奇怪了咧。1997年的时候甚至回归之后的前十年，你这样做我可以理解，毕竟中国当时的综合国力和今天不可同日而语，世界格局也和今天有很大的差别。那时候中央政府对香港高度包容，甚至把官员撤回去，认为既然港人治港了，那么不管就是管好。当时这也算是没办法的办法，不过可能真的有人错误地认为这是最好的办法。反正当时的情况下也只能如此。</p>
<p>但香港回归20多年了，我们还是没有汲取教训。为什么这么说？港英时期香港人从来没有治理过香港，回归后要港人治港了你怎么治？特区首席行政长官虽然职位里有行政二字，但这不仅是一个行政位置，它需要懂政治、会搞政治的人。把公务员放到最需要讲政治的位置是荒谬得不能再荒谬的一件事。香港人本来就国家观念淡薄，其中最没有国家观念的就是香港的公务员，在殖民统治时期他们是最不可以有政治意识的群体。1997年的时候有人跟我说，公务员可以被看作香港最大的政党。我心想你这是开玩笑呢。</p>
<p>特首这个职位不说别的，光代表中央在港主权这一件事，本身就是高度讲政治的。港英时期的港督也是个讲政治的职位，从来都是这样。不过也算英国人本领大，竟然能把香港人与政治完全隔绝开来，直到1997年之后才让这股政治力量释放出来。昨天晚上新加坡学者马凯硕跟我说，英国在殖民地都是这样，把政治锁得死死的，临走之前特意打开门放它出来。那是英国人有意留给你的。</p>
<p>1997年三四月份，董建华先生去新加坡找李光耀谈，李光耀跟他说英国人留了好多地雷，你要小心。李是在政治斗争中长大的，跟英国人明争暗斗这么久，我们香港人哪里懂这些？所以我们当初对特区行政长官这个位置的理解本身就是错误的。</p>
<p>在这件事上，中央政府第一低估了英国人；第二，高估了自己；第三，高估了在前线的香港人，根本不知道香港人是没有国家观念、没有政治意识的。</p>
<p>好多年前，我曾经跟某位国家领导人说过，共产党是统战高手，周恩来总理是统战高手，但他要是看到1997年之后在香港的统战工作，简直死不瞑目，因为完全一塌糊涂。那位国家领导人立刻转身对负责统战的人说，“我早就告诉过你们，统战工作要越做越开，你们是越做越窄。”所以最高领导层是意识到问题的，但下面的人在操作层面上问题很大。我提个简单的问题，在香港的爱国爱港阵营里，有谁受到香港老百姓的普遍尊敬？没有。22年了，一整代人了你做了什么事？马凯硕问，香港特区政府有培养政治人才吗？我说香港人连政治意识都没有，何来政治人才？</p>
<p>Q：有很多香港演艺界的明星发出一些爱国爱港的声音，更多是出于市场的需要，还是他们真的有这个政治觉悟？</p>
<p>A：那些人我不懂。但不论他们怎么表态都不重要，因为在商言商，电影明星要在内地卖片子，当然要爱国。真正重要的是香港社会所谓的精英阶层，那些会思考问题、会写文章的有几个属于爱国爱港阵营？难得一两个。我们没有培养爱国爱港的政治人才，香港为数不多的政治人才去了反对派阵营。当然我也知道，反对是容易的，正面去建设是比较难的，因为你一跟政府拉上关系，凡事都要合法的去做，反对派敢在背后做不合法的事，而且做了很多。</p>
<p>Q：香港这次动乱是由“反修例”这件事情闹起来的。依您看这是个偶然事件，还是一件迟早要来的事？</p>
<p>A：这里有个很重要的前提，就是在治理香港的问题上不能犯基本性的错误。要是没犯这样的错误，那么这件事可能是偶然的；但以往20多年犯了不少基本性错误，那么这场风波就迟早会发生。</p>
<p>Q：那么现在你觉得如果要亡羊补牢，应该从哪里着手？</p>
<p>A：哪里着手我也不知道。我不敢说怎么做是对的，怎么做是错的。我可能有点阿Q精神吧，我觉得有三个可能发生的好事，最少是坏事变好事。第一现在是买房子的好机会，道理很简单，香港不会陆沉，一国两制也不会消失。内地有十四亿同胞，有钱人多的是，中产阶级三亿人，要是有1%来香港买房子，那就是300万人，香港有多少房子给别人买？这当然是半开玩笑，不是在解决问题。第二就是回归基本法。以往这20多年，好多做法都违背了《基本法》的原意。比如立法会的议事规则成为今天这个样子，现在应该借着这个机会正本清源，回归《基本法》，一切照章办事，把以往歪掉的东西，照着《基本法》修正回来。第三点就是叫北京对香港事务及香港人看得更清楚。</p>
<blockquote>
<p>与信息数量越来越不成正比的是，我们距离事实的真相越来越远。</p>
</blockquote>
<p>报道及评论因为立场带有偏向，所以两边的舆论场截然不同。作为中国人，看到香港被破坏的一系列报道我会自然而然地产生气愤、痛心之感；看到一些正义之士的行动，又会忍不住为他们喝彩。但与之对应的，国外的舆论场也会控评，他们民众的情绪也极易被调动。当我看到两边截然不同的舆论风向时，会产生一种茫然不知所措的无力感。想要去解释，想要去证明，但是我知道这堵对彼此的误解的厚重的墙不是一日建成的。它可能来自从小到大的教育导向，来自无处不在的媒体偏向，乃至于是来自所有他们所能接触到，或者说，他们所愿意接触到的信息平台。简而言之，这就是一种双方都会觉得对方是被蒙蔽被洗脑了的局面。在这种情况下的对话是很难进行的。甚至我对自己接触到的信息产生了一定的怀疑，尤其是在看到了一位刚到港大的学姐发的票圈之后。票圈内容大致是表示自己很好，香港很安全（原话），让各位亲友别担心。虽然她可能是为了让大家放心才这么说，但当时的我是有些混乱的，一系列问题自然地产生：我所看到的究竟有多少？还有多少是我没看到的？我们能够做些什么？</p>
<p>尼采曾说：“随着舆论思考的，都是自己耳塞眼闭的人。”所以混乱之后的的我重新整理思路，从事件的起因经过重新理了一遍。我在这里不一一赘述。前期的在法律范围内的游行示威是无可厚非的，但后来的种种逐渐演化为严重危害香港社会安全的暴力行为。在大的层面上，这不利于香港的社会民生，不利于祖国的统一。</p>
<p>福布斯富豪排行榜：</p>
<ul>
<li>李嘉诚，28名。房地产</li>
<li>李兆基，29名，房地产</li>
<li>李文达，63名，房地产，耗油</li>
<li>刘銮雄，65名。房地产</li>
<li>邝肖卿，78名。房地产</li>
<li>吕志和，82名。博彩，酒店</li>
</ul>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Pow(x,n)</title>
    <url>/2019/10/29/Pow-x-n/</url>
    <content><![CDATA[<p>来源Leetcode第50题Pow(x,n)</p>
<blockquote>
<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>
<p>示例 1:</p>
<a id="more"></a>
<p>输入: 2.00000, 10<br>输出: 1024.00000</p>
<p>说明:</p>
<ul>
<li>-100.0 &lt; x &lt; 100.0</li>
<li>n 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] 。</li>
</ul>
</blockquote>
<h4 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h4><p>常规思路还是暴力，快速幂这种东西大一的时候接触过，但是已经忘了，先试试暴力能不能过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//要处理负指数将底数转变成倒数即可</span></span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            N = -N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            ans = ans * x;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>很尴尬，超时了，在第291/304个用例的时候TLE了<br>查看题解，有题解采用了二分查找的思路，将指数分解为n/2和n%2，然后一直递归下去。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123; <span class="keyword">return</span> <span class="number">1</span> / x; &#125;</span><br><span class="line">    <span class="keyword">double</span> half = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">double</span> rest = myPow(x, n % <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">double</span> total = rest * half * half;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>2019年10月31日更新：</p>
<h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><p>首先令b = p0*2^k + p1*2^k-1 + … + pk*2^0;<br>则a^b = a^p0*2^k * a^p1*2^k-1 * … * a^pk*2^0;</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> N = n;	</span><br><span class="line">	<span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//要处理负指数将底数转变成倒数即可</span></span><br><span class="line">        x = <span class="number">1</span> / x;</span><br><span class="line">        N = -N;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">1</span>,base = x;<span class="comment">// ans：幂的结果；base：底数X</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span>(N != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(N % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">		<span class="comment">//这一步对应的就是求N的二进制位的最低位</span></span><br><span class="line">        ans = ans * base;</span><br><span class="line">        &#125;</span><br><span class="line">        base = base * base;</span><br><span class="line">        N = N &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分查找</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列</title>
    <url>/2019/10/28/%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>来源Leetcode第46题全排列</p>
<h4 id="回溯1"><a href="#回溯1" class="headerlink" title="回溯1"></a>回溯1</h4><p>要求生成给定数组的全排列，可采用回溯。<br><a id="more"></a><br>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        nextPer(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextPer</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">            <span class="comment">//当start==arr.length-1时，说明子序列的长度为1，就不用再往下分子序列了</span></span><br><span class="line">            <span class="keyword">if</span>(start==arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                List&lt;Integer&gt; temp_ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length ; i++)&#123;</span><br><span class="line">                    temp_ans.add(arr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//System.out.println(temp_ans);</span></span><br><span class="line">                ans.add(temp_ans);</span><br><span class="line">				<span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;arr.length;i++)&#123;</span><br><span class="line">                <span class="comment">//start代表的是每一个子序列的第一个位置，我们每一层递归的任务都只有一个：</span></span><br><span class="line">                <span class="comment">//枚举该层子序列第一个位置可以取的值</span></span><br><span class="line">                <span class="keyword">int</span> temp=arr[start];</span><br><span class="line">                arr[start]=arr[i];</span><br><span class="line">                arr[i]=temp;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//该层递归的子序列第一个位置已经确定了，所以又可以往下再分</span></span><br><span class="line">                nextPer(arr,start+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//把第该层子序列第一个位置的值换成另外一个值，所以要交换回来</span></span><br><span class="line">                temp=arr[start];</span><br><span class="line">                arr[start]=arr[i];</span><br><span class="line">                arr[i]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>2019年10月30日更新：</p>
<h4 id="回溯2"><a href="#回溯2" class="headerlink" title="回溯2"></a>回溯2</h4><p>来自<a href="https://leetcode-cn.com/problems/permutations/solution/quan-pai-lie-by-leetcode/" target="_blank" rel="noopener">题解</a>的回溯</p>
<blockquote>
<p>这里有一个回溯函数，使用第一个整数的索引作为参数 backtrack(first)。</p>
<ul>
<li>如果第一个整数有索引 n，意味着当前排列已完成。</li>
<li>遍历索引 first 到索引 n - 1 的所有整数。<ul>
<li>在排列中放置第 i 个整数，即 swap(nums[first], nums[i]).</li>
<li>继续生成从第 i 个整数开始的所有排列: backtrack(first + 1).</li>
<li>现在回溯，即通过 swap(nums[first], nums[i]) 还原.</li>
</ul>
</li>
</ul>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ArrayList&lt;Integer&gt; nums,</span></span></span><br><span class="line"><span class="function"><span class="params">                        List&lt;List&lt;Integer&gt;&gt; output,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> first)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果所有的整数都参与排列了</span></span><br><span class="line">    <span class="keyword">if</span> (first == n)</span><br><span class="line">      output.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(nums));</span><br><span class="line">	<span class="comment">//开始遍历索引first到索n-1的所有整数。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="comment">// 在当前的一种排列中，交换第i个元素和first元素的位置</span></span><br><span class="line">      Collections.swap(nums, first, i);</span><br><span class="line">      <span class="comment">// 用下一个整数进行回溯生成排列</span></span><br><span class="line">      backtrack(n, nums, output, first + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 恢复交换的两个元素</span></span><br><span class="line">      Collections.swap(nums, first, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; output = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数组转化成列表</span></span><br><span class="line">    ArrayList&lt;Integer&gt; nums_lst = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">      nums_lst.add(num);</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    backtrack(n, nums_lst, output, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>通配符匹配</title>
    <url>/2019/10/28/%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>来源Leetcode第44题通配符匹配</p>
<blockquote>
<p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*‘ 的通配符匹配。</p>
<ul>
<li>‘?’ 可以匹配任何单个字符。</li>
<li><p>‘*‘ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p>
<a id="more"></a>
<p>说明:</p>
</li>
<li><p>s 可能为空，且只包含从 a-z 的小写字母。</p>
</li>
<li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</li>
</ul>
<p>示例 2:</p>
<p>输入:<br>s = “aa”<br>p = “*“<br>输出: true<br>解释: ‘*‘ 可以匹配任意字符串。</p>
</blockquote>
<p>和之前那题正则表达式匹配略有不同。</p>
<p>代码同第10题：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">//Method one</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//采用数组memo标记i j位置的匹配情况</span></span><br><span class="line">    Boolean[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        memo = <span class="keyword">new</span> Boolean[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> isMatch(s.toCharArray(), <span class="number">0</span>, p.toCharArray(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//两个参数分别为匹配串和模式串</span></span><br><span class="line">	<span class="comment">//i j 分别对应两个字符串起始位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span>[] ss, <span class="keyword">int</span> i, <span class="keyword">char</span>[] ps, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//这一句重点，如果memo备忘录有值说明这里已经匹配过了</span></span><br><span class="line">        <span class="keyword">if</span>(memo[i][j] != <span class="keyword">null</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">//如果已经到了模式串尾，需检查匹配串</span></span><br><span class="line">        <span class="keyword">if</span>(j == ps.length) &#123;</span><br><span class="line">            result = (i == ss.length);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//第一次匹配的情况</span></span><br><span class="line">            <span class="keyword">boolean</span> firstMatch = i != ss.length &amp;&amp; (ss[i] == ps[j] || ps[j] == <span class="string">'?'</span>);</span><br><span class="line">			<span class="comment">//如果模式串开头为'*‘</span></span><br><span class="line">			<span class="comment">//意味着可以跳过当前匹配串的字符或者跳过当前模式串中的字符</span></span><br><span class="line">            <span class="keyword">if</span>(ps[j] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                result = (i != ss.length &amp;&amp; isMatch(ss, i + <span class="number">1</span>, ps, j)) || isMatch(ss, i, ps, j + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//不为'*'</span></span><br><span class="line">			<span class="comment">//则要检查初次是否匹配以及剩下的是否匹配</span></span><br><span class="line">                result = firstMatch &amp;&amp; isMatch(ss, i + <span class="number">1</span>, ps, j + <span class="number">1</span>);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//写入结果到memo备忘录里</span></span><br><span class="line">        memo[i][j] = result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//Method Two</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 多一维的空间，因为求 dp[len - 1][j] 的时候需要知道 dp[len][j] 的情况，</span></span><br><span class="line">		<span class="comment">// 多一维的话，就可以把 对 dp[len - 1][j] 也写进循环了</span></span><br><span class="line">		<span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[text.length() + <span class="number">1</span>][pattern.length() + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// dp[len][len] 代表两个空串是否匹配了，"" 和 "" ，当然是 true 了。</span></span><br><span class="line">		dp[text.length()][pattern.length()] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从 len 开始减少</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = text.length(); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = pattern.length(); j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">				<span class="comment">// dp[text.length()][pattern.length()] 已经进行了初始化</span></span><br><span class="line">				<span class="keyword">if</span> (i == text.length() &amp;&amp; j == pattern.length())</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				<span class="comment">//相比之前增加了判断是否等于 * </span></span><br><span class="line">				<span class="keyword">boolean</span> first_match = (i &lt; text.length() &amp;&amp; j &lt; pattern.length() &amp;&amp; (pattern.charAt(j) == text.charAt(i) || pattern.charAt(j) == <span class="string">'?'</span> || pattern.charAt(j) == <span class="string">'*'</span>));</span><br><span class="line">				<span class="keyword">if</span> (j &lt; pattern.length() &amp;&amp; pattern.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="comment">//将 * 跳过 和将字符匹配一个并且 pattern 不变两种情况</span></span><br><span class="line">					dp[i][j] = dp[i][j + <span class="number">1</span>] || first_match &amp;&amp; dp[i + <span class="number">1</span>][j];</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					dp[i][j] = first_match &amp;&amp; dp[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Method Three</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String str, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, p = <span class="number">0</span>, match = <span class="number">0</span>, starIdx = -<span class="number">1</span>;     </span><br><span class="line">    <span class="comment">//遍历整个字符串</span></span><br><span class="line">    <span class="keyword">while</span> (s &lt; str.length())&#123;</span><br><span class="line">        <span class="comment">// 一对一匹配，两指针同时后移。</span></span><br><span class="line">        <span class="keyword">if</span> (p &lt; pattern.length()  &amp;&amp; (pattern.charAt(p) == <span class="string">'?'</span> || str.charAt(s) == pattern.charAt(p)))&#123;</span><br><span class="line">            s++;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 碰到 *，假设它匹配空串，并且用 startIdx 记录 * 的位置，记录当前字符串的位置，p 后移</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p &lt; pattern.length() &amp;&amp; pattern.charAt(p) == <span class="string">'*'</span>)&#123;</span><br><span class="line">            starIdx = p;</span><br><span class="line">            match = s;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前字符不匹配，并且也没有 *，回退</span></span><br><span class="line">        <span class="comment">// p 回到 * 的下一个位置</span></span><br><span class="line">        <span class="comment">// match 更新到下一个位置</span></span><br><span class="line">        <span class="comment">// s 回到更新后的 match </span></span><br><span class="line">        <span class="comment">// 这步代表用 * 匹配了一个字符</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (starIdx != -<span class="number">1</span>)&#123;</span><br><span class="line">            p = starIdx + <span class="number">1</span>;</span><br><span class="line">            match++;</span><br><span class="line">            s = match;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//字符不匹配，也没有 *，返回 false</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将末尾多余的 * 直接匹配空串 例如 text = ab, pattern = a*******</span></span><br><span class="line">    <span class="keyword">while</span> (p &lt; pattern.length() &amp;&amp; pattern.charAt(p) == <span class="string">'*'</span>)</span><br><span class="line">        p++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p == pattern.length();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串相乘</title>
    <url>/2019/10/28/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<p>来源Leetcode第43题字符串相乘</p>
<blockquote>
<p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<p>示例 2:<br><a id="more"></a><br>输入: num1 = “123”, num2 = “456”<br>输出: “56088”<br>说明：</p>
<ul>
<li>num1 和 num2 的长度小于110。</li>
<li>num1 和 num2 只包含数字 0-9。</li>
<li>num1 和 num2 均不以零开头，除非是数字 0 本身。</li>
<li>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</li>
</ul>
</blockquote>
<p>这题我傻了没见过这么奇葩的，上一题不给除，这一题不给乘，是在下输了，直接看答案吧。</p>
<p>思路如下(来自题解)：</p>
<ul>
<li>乘数 num1 位数为 M，被乘数 num2 位数为 N， num1 x num2 结果 res 最大总位数为 M+N</li>
<li>num1[i] x num2[j] 的结果为 tmp(位数为两位，”0x”,”xy”的形式)，其第一位位于 res[i+j]，第二位位于 res[i+j+1]。</li>
</ul>
<p>如下图：</p>
<div align="center">
<img width="700" src="https://pic.leetcode-cn.com/171cad48cd0c14f565f2a0e5aa5ccb130e4562906ee10a84289f12e4460fe164-image.png">
</div>


<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//特殊情况，乘数为0返回0</span></span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num1.length() + num2.length()];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//要注意到写进来的数字是地位在高地址</span></span><br><span class="line">		<span class="comment">//所以要从长度length-1 位开始，对应的位置是个位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="comment">//先取num1的第i位与num2相乘</span></span><br><span class="line">            <span class="keyword">int</span> n1 = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = num2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> n2 = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">				<span class="comment">//求一次乘法运算的和</span></span><br><span class="line">                <span class="keyword">int</span> sum = (res[i + j + <span class="number">1</span>] + n1 * n2);</span><br><span class="line">				<span class="comment">//低位取余</span></span><br><span class="line">                res[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">				<span class="comment">//高位进1</span></span><br><span class="line">                res[i + j] += sum / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; res[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            result.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>缺失的第一个正数</title>
    <url>/2019/10/26/%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[<p>来源Leetcode第41题缺失的第一个正数</p>
<blockquote>
<p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p>
<p>示例 2:<br><a id="more"></a><br>输入: [3,4,-1,1]<br>输出: 2</p>
</blockquote>
<h4 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h4><p>emmm，这题做的时候思路混乱了，而且这题的题解很怪，先看官方的题解吧。</p>
<p>来自题解的算法：</p>
<blockquote>
<p>算法</p>
<ul>
<li>检查 1 是否存在于数组中。如果没有，则已经完成，1 即为答案。</li>
<li>如果 nums = [1]，答案即为 2 。</li>
<li>将负数，零，和大于 n(定义 n 为数组nums的长度) 的数替换为 1 。</li>
<li>遍历数组。当读到数字 a 时，替换第 a 个元素的符号。</li>
<li>注意重复元素：只能改变一次符号。由于没有下标 n ，使用下标 0 的元素保存是否存在数字 n。</li>
<li>再次遍历数组。返回第一个正数元素的下标。</li>
<li>如果 nums[0] &gt; 0，则返回 n 。</li>
<li>如果之前的步骤中没有发现 nums 中有正数元素，则返回n + 1。</li>
</ul>
</blockquote>
<p>总的来说，就是用数组自身来检查所求的最小正数。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本情况</span></span><br><span class="line">    <span class="keyword">int</span> contains = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">      <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">        contains++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (contains == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nums = [1]</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 1 替换负数，0，</span></span><br><span class="line">    <span class="comment">// 和大于 n 的数</span></span><br><span class="line">    <span class="comment">// 在转换以后，nums 只会包含</span></span><br><span class="line">    <span class="comment">// 正数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">      <span class="keyword">if</span> ((nums[i] &lt;= <span class="number">0</span>) || (nums[i] &gt; n))</span><br><span class="line">        nums[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用索引和数字符号作为检查器</span></span><br><span class="line">    <span class="comment">// 例如，如果 nums[1] 是负数表示在数组中出现了数字 `1`</span></span><br><span class="line">    <span class="comment">// 如果 nums[2] 是正数 表示数字 2 没有出现</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> a = Math.abs(nums[i]);</span><br><span class="line">      <span class="comment">// 如果发现了一个数字 a - 改变第 a 个元素的符号</span></span><br><span class="line">      <span class="comment">// 注意重复元素只需操作一次</span></span><br><span class="line">      <span class="keyword">if</span> (a == n)</span><br><span class="line">        nums[<span class="number">0</span>] = - Math.abs(nums[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        nums[a] = - Math.abs(nums[a]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在第一个正数的下标</span></span><br><span class="line">    <span class="comment">// 就是第一个缺失的数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>让我们来看另一个解法：利用桶排序<br>同样是利用数组自身作为一个索引表，在做这道题的时候，我们可以明确一个事实：</p>
<ul>
<li>所要找的最小正数在1 - nums.length 之间</li>
<li>否则所要找的最小正数是nums.length + 1</li>
</ul>
<p>利用这两个事实，我们可以将数组里的正数nums[i] 放在num[nums[i] - 1] 的位置上<br>之后遍历数组，如果nums[i] != i + 1,返回 i + 1 即可<br>否则返回 nums.length + 1</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">                <span class="comment">// 满足在指定范围内、并且没有放在正确的位置上，才交换</span></span><br><span class="line">                <span class="comment">// 例如：数值 3 应该放在索引 2 的位置上</span></span><br><span class="line">                swap(nums, nums[i] - <span class="number">1</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [1, -1, 3, 4]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 都正确则返回数组长度 + 1</span></span><br><span class="line">        <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index1 == index2) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>桶排序</tag>
      </tags>
  </entry>
  <entry>
    <title>组合总和</title>
    <url>/2019/10/26/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<p>来源Leetcode第39题组合总和</p>
<blockquote>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。<br><a id="more"></a><br>说明：</p>
<ul>
<li>所有数字（包括 target）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<p>示例 2:</p>
<p>输入: candidates = [2,3,5], target = 8,<br>所求解集为:<br>[<br>  [2,2,2,2],<br>  [2,3,3],<br>  [3,5]<br>]</p>
</blockquote>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>emm,这题想了想，要重复这一点属实把我难到了，一时没想出解决办法，就看了解答。</p>
<p>解答采用了<strong>回溯 + 剪枝</strong>的思路，其实回溯 + 剪枝在课设生成数独的时候做过了，然而已经完全忘了。<br>先上图</p>
<div align="center">
<img width="800" src="https://pic.leetcode-cn.com/ade93b4f0678b2b1385ad1362ff426ce0a5a800a5b0ae07dfb65f58677374559-39-3.png">
</div>

<blockquote>
<p>说明：</p>
<ul>
<li><p>1.一个蓝色正方形表示的是 “尝试将这个数到数组 candidates 中找组合”，那么怎么找呢？挨个减掉那些数就可以了。</p>
</li>
<li><p>2.在减的过程中，会得到 00 和负数，也就是被我标红色和粉色的结点：</p>
<ul>
<li><p>得到 00 是我们喜欢的，从 00 这一点向根结点走的路径（很可能只走过一条边，也算一个路径），就是一个组合，在这一点要做一次结算（把根结点到 00 所经过的路径，加入结果集）。</p>
</li>
<li><p>得到负数就说明这条路走不通，没有必要再走下去了。</p>
</li>
</ul>
</li>
</ul>
<p>总结一下：在减的过程中，得到 00 或者负数，就没有必要再走下去，所以这两种情况就分别表示成为叶子结点。此时递归结束，然后要发生回溯。</p>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] candidates;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findCombinationSum</span><span class="params">(<span class="keyword">int</span> residue, <span class="keyword">int</span> start, Stack&lt;Integer&gt; pre)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(residue &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (residue == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Java 中可变对象是引用传递，因此需要将当前 path 里的值拷贝出来</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(pre));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 优化添加的代码2：在循环的时候做判断，尽量避免系统栈的深度</span></span><br><span class="line">        <span class="comment">// residue - candidates[i] 表示下一轮的剩余，如果下一轮的剩余都小于 0 ，就没有必要进行后面的循环了</span></span><br><span class="line">        <span class="comment">// 这一点基于原始数组是排序数组的前提，因为如果计算后面的剩余，只会越来越小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len &amp;&amp; residue - candidates[i] &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">            pre.add(candidates[i]);</span><br><span class="line">            <span class="comment">// [关键]因为元素可以重复使用，这里递归传递下去的是 i 而不是 i + 1</span></span><br><span class="line">            findCombinationSum(residue - candidates[i], i, pre);</span><br><span class="line">            pre.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = candidates.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        <span class="keyword">this</span>.len = len;</span><br><span class="line">        <span class="keyword">this</span>.candidates = candidates;</span><br><span class="line">        findCombinationSum(target, <span class="number">0</span>, <span class="keyword">new</span> Stack&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>这是没有用栈的：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtrack(candidates, target, res, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span> i, ArrayList&lt;Integer&gt; tmp_list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp_list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = i; start &lt; candidates.length; start++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; candidates[start]) <span class="keyword">break</span>;</span><br><span class="line">			<span class="comment">//从第0个元素开始进行递归</span></span><br><span class="line">            tmp_list.add(candidates[start]);</span><br><span class="line">			<span class="comment">//采用减法进行回溯</span></span><br><span class="line">            backtrack(candidates, target - candidates[start], res, start, tmp_list);</span><br><span class="line">			<span class="comment">//删去最后一个新添加的元素，然后进行下一层的回溯</span></span><br><span class="line">            tmp_list.remove(tmp_list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的数独</title>
    <url>/2019/10/24/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<p>来源Leetcode第36题有效的数独</p>
<blockquote>
<p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<ul>
<li>数字 1-9 在每一行只能出现一次。</li>
<li>数字 1-9 在每一列只能出现一次。<a id="more"></a></li>
<li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</li>
</ul>
<p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
</blockquote>
<h4 id="一次迭代"><a href="#一次迭代" class="headerlink" title="一次迭代"></a>一次迭代</h4><p>看到这题我就想起了上学期的数据结构课设，<strong>基于DPLL的数独游戏求解程序</strong>，其实这题硬要写也是直接暴力遍历一遍就好了，而且暴力遍历的效率还挺高。。。</p>
<p>执行用时 :3 ms, 在所有 java 提交中击败了89.93%的用户<br>内存消耗 :43.2 MB, 在所有 java 提交中击败了76.35%的用户</p>
<p>捂脸，就看看官方解答是怎么说的吧。</p>
<p>官方题解用了<strong>一次迭代</strong>来解决问题。<br>首先定义子数独 <strong>box_index = (row/3)*3+ columns/3</strong> 将原本的数独棋盘划分为9个小数独<br>利用<strong>value -&gt; count</strong> 哈希映射来跟踪所有已经遇到的值，确保行/列/ 子数独中没有重复项。<br>接下来要做的工作：</p>
<ul>
<li>遍历数独。</li>
<li>检查看到每个单元格值是否已经在当前的行 / 列 / 子数独中出现过：<ul>
<li>如果出现重复，返回 false。</li>
<li>如果没有，则保留此值以进行进一步跟踪。</li>
</ul>
</li>
<li>返回 true。</li>
</ul>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">	<span class="comment">//初始化行</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; [] rows = <span class="keyword">new</span> HashMap[<span class="number">9</span>];</span><br><span class="line">	<span class="comment">//初始化列</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; [] columns = <span class="keyword">new</span> HashMap[<span class="number">9</span>];</span><br><span class="line">	<span class="comment">//初始化3*3九宫格</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; [] boxes = <span class="keyword">new</span> HashMap[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">      rows[i] = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">      columns[i] = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">      boxes[i] = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历数独棋盘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">char</span> num = board[i][j];</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="string">'.'</span>) &#123;</span><br><span class="line">		<span class="comment">//如果当前格子非空</span></span><br><span class="line">          <span class="keyword">int</span> n = (<span class="keyword">int</span>)num;</span><br><span class="line">          <span class="keyword">int</span> box_index = (i / <span class="number">3</span> ) * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//将当前格子的数据放入hash表里</span></span><br><span class="line">		  <span class="comment">//key值为n,value值如果说当前格子的数字并没有在哈希表里出现过，那么就采用默认值0 然后+1，出现过就用n + 1；</span></span><br><span class="line">		  <span class="comment">//也就是说这里存放的该数字是出现的次数</span></span><br><span class="line">          rows[i].put(n, rows[i].getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">          columns[j].put(n, columns[j].getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">          boxes[box_index].put(n, boxes[box_index].getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果冲突了，就返回false</span></span><br><span class="line">          <span class="keyword">if</span> (rows[i].get(n) &gt; <span class="number">1</span> || columns[j].get(n) &gt; <span class="number">1</span> || boxes[box_index].get(n) &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="空间换时间"><a href="#空间换时间" class="headerlink" title="空间换时间"></a>空间换时间</h4><p>当然也有空间换时间的做法，用了3个9*9数组来标记情况<br>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录某行，某位数字是否已经被摆放</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] row = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="comment">// 记录某列，某位数字是否已经被摆放</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] col = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="comment">// 记录某 3x3 宫格内，某位数字是否已经被摆放</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] block = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = board[i][j] - <span class="string">'1'</span>;</span><br><span class="line">                    <span class="keyword">int</span> blockIndex = i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">if</span> (row[i][num] || col[j][num] || block[blockIndex][num]) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        row[i][num] = <span class="keyword">true</span>;</span><br><span class="line">                        col[j][num] = <span class="keyword">true</span>;</span><br><span class="line">                        block[blockIndex][num] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>最后一种解法是利用位运算<br>用10个bit位标记数据情况，哪位数字出现了并且当前位不为1，说明不冲突，那么当前位就标记为1，对于九宫格的处理同样也是用i/3*3+j/3将数独棋盘划分成了9个区域。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] rowCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">	<span class="keyword">int</span>[] colCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">	<span class="keyword">int</span>[] boxCnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">'.'</span> == board[i][j]) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> num = board[i][j] - <span class="number">48</span>;</span><br><span class="line">			<span class="comment">// 处理行</span></span><br><span class="line">			<span class="keyword">if</span> ((rowCnt[i] &gt;&gt; num) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				rowCnt[i] += <span class="number">1</span> &lt;&lt; num;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 处理列</span></span><br><span class="line">			<span class="keyword">if</span> ((colCnt[j] &gt;&gt; num) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				colCnt[j] += <span class="number">1</span> &lt;&lt; num;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 处理框</span></span><br><span class="line">			<span class="keyword">int</span> boxNum = i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">if</span> ((boxCnt[boxNum] &gt;&gt; num) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				boxCnt[boxNum] += <span class="number">1</span> &lt;&lt; num;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2019/10/23/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>来源Leetcode第34题在排序数组中查找元素的第一个和最后一个位置</p>
<blockquote>
<p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。<br><a id="more"></a><br>如果数组中不存在目标值，返回 [-1, -1]。</p>
<p>示例 1:</p>
<p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]</p>
</blockquote>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>常规思路就和上上道题一样，从左到右边遍历一次，找到第一个nums[i] == target，从右到左再遍历一次，找到第一个nums[i] == target<br>这样的作法过肯定是能过的，就是时间复杂度是在O(n)</p>
<p>官方题解也是采用了二分查找，不过在对进行二分查找时做了些许修改。<br>引入一个boolean变量判断是否要递归搜索左边区域直到找到最左边的nums[mid] == target,此时left == right，否则就递归搜索右半边，同样找到最右边的nums[mid] == target。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回target 所在的最左(或最右)位置</span></span><br><span class="line">    <span class="comment">// inserted in sorted array `nums` via binary search.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">extremeInsertionIndex</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">boolean</span> left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target || (left &amp;&amp; target == nums[mid])) &#123;</span><br><span class="line">			<span class="comment">//如果left为真 且 target == nums[mid]</span></span><br><span class="line">			<span class="comment">//说明我们还可以继续向左搜索，找到最左边的索引</span></span><br><span class="line">			<span class="comment">//如果left为假</span></span><br><span class="line">			<span class="comment">//则不管是nums[mid] 等于还是小于target</span></span><br><span class="line">			<span class="comment">//都要进行右边搜索，直到找到最右边索引</span></span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] targetRange = &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftIdx = extremeInsertionIndex(nums, target, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果此时nums[left]对应的值并不是target</span></span><br><span class="line">		<span class="comment">//说明target并不在nums数组中</span></span><br><span class="line">        <span class="keyword">if</span> (leftIdx == nums.length || nums[leftIdx] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetRange;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        targetRange[<span class="number">0</span>] = leftIdx;</span><br><span class="line">		<span class="comment">//注意-1 因为函数里返回的lo是mid + 1</span></span><br><span class="line">		<span class="comment">//而当mid=target时，也是会进行lo = mid+1的</span></span><br><span class="line">        targetRange[<span class="number">1</span>] = extremeInsertionIndex(nums, target, <span class="keyword">false</span>)-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> targetRange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索旋转排序数组</title>
    <url>/2019/10/23/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>来源Leetcode第33题搜索旋转排序数组</p>
<blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br><a id="more"></a><br>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>示例 1:</p>
<p>输入: nums = [4,5,6,7,0,1,2], target = 0<br>输出: 4</p>
</blockquote>
<h3 id="二分查找I"><a href="#二分查找I" class="headerlink" title="二分查找I"></a>二分查找I</h3><p>这道题目怎么说呢，一开始只是头铁，想试试遍历，结果还真过了，用时1ms，内存消耗36.4MB，我傻了，代码就不附了。</p>
<p>这题其实就是变了花样的二分查找，但是我一开始脑子抽了先对这个数组进行排序，我在想啥呢- -<br>这题可以先设置左右两个指针，只有当nums[right]<target&&nums[left]>target时返回-1，因为这时候找不到这样的数；如果nums[left]<target,左指针+1，如果nums[right]>target，右指针-1。<br>这样写的话，怎么看也都是很普通的查找啊，连二分查找都算不上，时间复杂度我也不会算。。。。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length=nums.length,left=<span class="number">0</span>,right=length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[right]&lt;target&amp;&amp;nums[left]&gt;target)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]==target) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span>(nums[right]==target) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]&lt;target) left++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[right]&gt;target) right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></target,左指针+1，如果nums[right]></target&&nums[left]></p>
<h3 id="二分查找II"><a href="#二分查找II" class="headerlink" title="二分查找II"></a>二分查找II</h3><p>评论区里的解答稍好些，考虑的情况更加具体：<br>同样是left、mid、right</p>
<ul>
<li>如果nums[mid] &lt; nums[right]<ul>
<li>nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]<ul>
<li>left = mid+1</li>
</ul>
</li>
<li>否则的话就是<ul>
<li>right = mid-1</li>
</ul>
</li>
</ul>
</li>
<li>如果nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]<ul>
<li>right = mid-1</li>
<li>否则left = mid+1</li>
</ul>
</li>
</ul>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length=nums.length,left=<span class="number">0</span>,right=length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二分查找III"><a href="#二分查找III" class="headerlink" title="二分查找III"></a>二分查找III</h3><p>官方题解是先找到旋转点，在根据旋转点判断，具体思路就不写了，直接附代码吧：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> [] nums;</span><br><span class="line">  <span class="keyword">int</span> target;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find_rotate_index</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[left] &lt; nums[right])</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      <span class="keyword">int</span> pivot = (left + right) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[pivot] &gt; nums[pivot + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> pivot + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[pivot] &lt; nums[left])</span><br><span class="line">          right = pivot - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          left = pivot + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Binary search</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      <span class="keyword">int</span> pivot = (left + right) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[pivot] == target)</span><br><span class="line">        <span class="keyword">return</span> pivot;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[pivot])</span><br><span class="line">          right = pivot - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          left = pivot + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rotate_index = find_rotate_index(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if target is the smallest element</span></span><br><span class="line">    <span class="keyword">if</span> (nums[rotate_index] == target)</span><br><span class="line">      <span class="keyword">return</span> rotate_index;</span><br><span class="line">    <span class="comment">// if array is not rotated, search in the entire array</span></span><br><span class="line">    <span class="keyword">if</span> (rotate_index == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> search(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>])</span><br><span class="line">      <span class="comment">// search in the right side</span></span><br><span class="line">      <span class="keyword">return</span> search(rotate_index, n - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// search in the left side</span></span><br><span class="line">    <span class="keyword">return</span> search(<span class="number">0</span>, rotate_index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外一篇的<img src="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/ji-jian-solution-by-lukelee" alt="极简Solution">，脑壳疼，先摸了</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分查找</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>最长有效括号</title>
    <url>/2019/10/22/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<p>来源Leetcode第32题最长有效括号</p>
<blockquote>
<p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>
<p>示例 2:<br><a id="more"></a><br>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”</p>
</blockquote>
<h3 id="Wrong-Answer"><a href="#Wrong-Answer" class="headerlink" title="Wrong Answer"></a>Wrong Answer</h3><p>一开始看到这题，我是用的栈写的，通过判断栈顶元素和入栈元素是否匹配，如果匹配则长度+2，不匹配则重新初始化长度，然而这样会有个问题，对于形如”()(()”这样的组合，我的输出是4，然而预期应该是2，其实还是因为算法不够完善。</p>
<p>思考了一番，既然如此，那我就对每一个可能的子串组合进行统计，记录所有子串里最长的有效括号，然而这在第227/230个算例时，发生了TLE,T T，先附上没有AC的代码吧：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">isLegal</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空字符串</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 栈元素个数</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 栈</span></span><br><span class="line">    <span class="keyword">char</span>[] stack = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (s.charAt(i)) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                <span class="comment">// 进栈</span></span><br><span class="line">                stack[index++] = s.charAt(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> (index == <span class="number">0</span> || stack[index - <span class="number">1</span>] != <span class="string">'('</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(stack[index - <span class="number">1</span>] == <span class="string">'('</span>)&#123;</span><br><span class="line">                    index--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// stack[--index] == '(' ，才会contniue</span></span><br><span class="line">                <span class="comment">// --index：相当于满足的元素出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> index == <span class="number">0</span> ?  <span class="number">1</span> :  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxlength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">2</span>;j&lt;=s.length();j+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isLegal(s.substring(i,j)) == <span class="number">1</span>)&#123;</span><br><span class="line">                maxlength = Math.max(maxlength , j - i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>在查看题解时，我看到了一篇也是用栈写的，不过答主是用了下标入栈，通过判断出栈元素之间的距离来判断最长的有效括号长度。</p>
<blockquote>
<p>我们扫描到左括号，就将当前位置入栈。</p>
<p>扫描到右括号，就将栈顶出栈（代表栈顶的左括号匹配到了右括号），然后分两种情况。</p>
<ul>
<li><p>栈不空，那么就用当前的位置减去栈顶的存的位置，然后就得到当前合法序列的长度，然后更新一下最长长度。</p>
</li>
<li><p>栈是空的，说明之前没有与之匹配的左括号，那么就将当前的位置入栈。</p>
</li>
</ul>
</blockquote>
<p>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxans = <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxans = Math.max(maxans, i - stack.peek());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="依次比对"><a href="#依次比对" class="headerlink" title="依次比对"></a>依次比对</h3><p>此外，我们可以判断从每个位置开始的最长合法子串是多长即可。而判断是否是合法子串，我们不用栈，而是用一个变量记录当前的括号情况，遇到左括号加 1，遇到右括号减 1，如果变成 0 ，我们就更新下最长合法子串。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(j) == <span class="string">'('</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//count &lt; 0 说明右括号多了，此时无论后边是什么，一定是非法字符串了，所以可以提前结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前是合法序列，更新最长长度</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; max) &#123;</span><br><span class="line">                    max = j - i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>接下来就是官方题解里提到的动态规划<br>dp[i] 代表以下标 i 结尾的合法序列的最长长度，<br>我们来分析下 dp 的规律。</p>
<p>首先我们初始化所有的 dp 都等于零。<br>以左括号结尾的字符串一定是非法序列，所以 dp 是零，不用更改。<br>以右括号结尾的字符串分两种情况。</p>
<ul>
<li>右括号前边是 ( ，类似于 ……（）。<br>  dp[i] = dp[i-2] + 2 （前一个合法序列的长度，加上当前新增的长度 2）</li>
<li>右括号前边是 )，类似于 ……））。<br>  此时我们需要判断 i-dp[i-1]-1 （前一个合法序列的前边一个位置） 是不是左括号。<br>  如果是左括号，此时dp[i] = dp[i-1]+dp[i-dp[i -1]-2]+2 （当前位置的前一个合法序列的长度，加上匹配的左括号前边的合法序列的长度，加上新增的长度 2）<br>  如果不是左括号，那么此时位置 的右括号没有匹配的左括号，所以 dp[i] = 0 ，不需要更新。</li>
</ul>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="comment">//右括号前边是左括号</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">'('</span>) &#123;</span><br><span class="line">                dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//右括号前边是右括号，并且除去前边的合法序列的前边是左括号</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">'('</span>) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxans = Math.max(maxans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="两次遍历"><a href="#两次遍历" class="headerlink" title="两次遍历"></a>两次遍历</h3><p>当然还有一种很神奇的解法：<br>从左到右扫描，用两个变量 left 和 right 保存的当前的左括号和右括号的个数，都初始化为 0 。</p>
<ul>
<li>如果左括号个数等于右括号个数了，那么就更新合法序列的最长长度。</li>
<li>如果左括号个数大于右括号个数了，那么就接着向右边扫描。</li>
<li>如果左括号数目小于右括号个数了，那么后边无论是什么，此时都不可能是合法序列了，此时 left 和 right 归 0，然后接着扫描。</li>
</ul>
<p>从左到右扫描完毕后，同样的方法从右到左再来一次，因为类似这样的情况 ( ( ( ) ) ，如果从左到右扫描到最后，left = 3，right = 2，期间不会出现 left == right。但是如果从右向左扫描，扫描到倒数第二个位置的时候，就会出现 left = 2，right = 2 ，就会得到一种合法序列。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxlength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            maxlength = Math.max(maxlength, <span class="number">2</span> * right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt;= left) &#123;</span><br><span class="line">            left = right = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left = right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            maxlength = Math.max(maxlength, <span class="number">2</span> * left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            left = right = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>下一个排列</title>
    <url>/2019/10/22/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>来源Leetcode第31题下一个排列</p>
<blockquote>
<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。<br><a id="more"></a><br>必须原地修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
</blockquote>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>看到这道题，想了一下，应该是先从最右边开始，找到第一个不是降序排列的点，如果之前的数组段是降序排列的话，说明没有下一个排列了，只能向左扩充，然后接着竟然天真的想直接右移就好了，原因在于自己考虑的时候给的例子一般性不够，不过后续推演的时候很快发现了这个问题。</p>
<p>解决方法也很简单，同样是从右到左，找到第一个比不是降序排列点数值大的数，交换这两个数的值，然后对接下来的数做升序排序即可。</p>
<p>参考题解代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i + <span class="number">1</span>] &lt;= nums[i]) &#123;</span><br><span class="line">              <span class="comment">//先找到不是降序排列的点</span></span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &lt;= nums[i]) &#123;</span><br><span class="line">                <span class="comment">//找到第一个比不是降序排列点大的数</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//之后将剩下的数按从小到大排列</span></span><br><span class="line">        reverse(nums, i + <span class="number">1</span>,nums.length - <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; end) &#123;</span><br><span class="line">            swap(nums, i, end);</span><br><span class="line">            i++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后附上题解的动图解析:</p>
<div align="center">
<img width="600" src="https://pic.leetcode-cn.com/1df4ae7eb275ba4ab944521f99c84d782d17df804d5c15e249881bafcf106173-file_1555696082944">
</div>]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>两数相除</title>
    <url>/2019/10/21/%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</url>
    <content><![CDATA[<p>来源Leetcode第29题两数相除</p>
<blockquote>
<p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的商。</p>
<p>示例 1:<br><a id="more"></a><br>输入: dividend = 10, divisor = 3<br>输出: 3</p>
<p>说明:</p>
<ul>
<li>被除数和除数均为 32 位有符号整数。</li>
<li>除数不为 0。</li>
<li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。</li>
</ul>
</blockquote>
<h3 id="Wrong-Answer"><a href="#Wrong-Answer" class="headerlink" title="Wrong Answer"></a>Wrong Answer</h3><p>除法的话，第一思路是移位。<br>对形如B(10)= 2^n + 2^n-1 + …… + 2^0<br>但是如果不是2^n的话，那么单靠移位操作是完成不了的。<br>考虑实际上计算机的除法是模二除法，可参考组原课本的 <strong>基于不恢复余数的补码除法</strong>。</p>
<p>这代码目前AC不了，因为还没考虑到各种边界值，例如被除数为-2147483648;除数为：-2147483648；或者为+1,-1等等情况。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBits</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取操作数的位长</span></span><br><span class="line">    <span class="keyword">int</span> numLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num)&#123;</span><br><span class="line">        numLen++;</span><br><span class="line">        num = num&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBit</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取从右到左的第pos位置的值1/0</span></span><br><span class="line">    pos = pos<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>&lt;&lt;pos;</span><br><span class="line">    <span class="keyword">if</span>((num&amp;index)&gt;&gt;pos)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> divide = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> dividend2 = dividend;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">int</span> minus = (dividend &gt;&gt; <span class="number">31</span>) ^ (divisor &gt;&gt; <span class="number">31</span>);  <span class="comment">//取符号位判断是否同号或异号</span></span><br><span class="line">    <span class="keyword">bool</span> minValue = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(dividend == <span class="number">-2147483648</span> &amp;&amp; divisor == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(dividend == <span class="number">-2147483648</span> &amp;&amp; divisor == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-2147483648</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(dividend &lt; divisor)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(dividend==<span class="number">-2147483648</span>)&#123;</span><br><span class="line">        minValue = <span class="literal">true</span>;</span><br><span class="line">        dividend = dividend<span class="number">-1</span>;  <span class="comment">//转成了2147483647</span></span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span>(divisor==<span class="number">-2147483648</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(minValue)<span class="comment">//被除数与除数相同</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span>(dividend &lt; <span class="number">0</span>||divisor &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend &lt; <span class="number">0</span> &amp;&amp; divisor &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dividend = dividend&lt;<span class="number">0</span>?-dividend:dividend;</span><br><span class="line">            divisor = divisor&lt;<span class="number">0</span>?-divisor:divisor;</span><br><span class="line">            minus = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(divisor==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(minus)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minValue)<span class="comment">//被除数为最大值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-2147183648</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> dividend2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> dividend2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = getBits(dividend);</span><br><span class="line">    <span class="keyword">while</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> val = getBit(dividend,index--);</span><br><span class="line">        divide = (divide&lt;&lt;<span class="number">1</span>)+val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(divide&lt;divisor)</span><br><span class="line">            res = res&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res = (res&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">            divide = divide-divisor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minValue&amp;&amp;(divide+<span class="number">1</span>)&gt;=divisor)&#123;</span><br><span class="line">        res++;</span><br><span class="line">        divide = divide+<span class="number">1</span>-divisor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minus)&#123;</span><br><span class="line">         <span class="keyword">return</span> -res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="移位除法"><a href="#移位除法" class="headerlink" title="移位除法"></a>移位除法</h3><p>停电了，这题我写了2个小时了，估计是在判断-2147483648出了点问题，明天有空把这一块重写下。<br>最后附上AC了的代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == -<span class="number">2147483648</span> &amp;&amp; divisor == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = (dividend &gt;&gt; <span class="number">31</span>) ^ (divisor &gt;&gt; <span class="number">31</span>);  <span class="comment">//取符号位判断是否同号</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((dividend &gt;&gt; <span class="number">31</span>) == <span class="number">0</span>) dividend = -dividend;  <span class="comment">//用负数进行除法运算</span></span><br><span class="line">        <span class="keyword">if</span>((divisor &gt;&gt; <span class="number">31</span>) == <span class="number">0</span>) divisor = -divisor;</span><br><span class="line">        <span class="keyword">while</span>(dividend &lt;= divisor)&#123; <span class="comment">//被除数在负数情况下比除数小，即在正数情况下比除数大</span></span><br><span class="line">        <span class="comment">//执行除法(减法运算)，直到被除数和除数相等或者小于除数</span></span><br><span class="line">            <span class="keyword">int</span> i = -<span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">int</span> temp = divisor;</span><br><span class="line">            <span class="keyword">while</span>(dividend &lt;= (temp &lt;&lt; <span class="number">1</span>))&#123;  <span class="comment">// 被除数小于(除数 * 2)</span></span><br><span class="line">            <span class="keyword">if</span>(temp &lt;= (Integer.MIN_VALUE &gt;&gt; <span class="number">1</span>))&#123;  <span class="comment">//负除数小于0xC0000000 ，即产生了溢出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = i &lt;&lt; <span class="number">1</span>;  <span class="comment">//结果*2</span></span><br><span class="line">            temp = temp &lt;&lt; <span class="number">1</span>; <span class="comment">//除数*2 以毕竟被除数</span></span><br><span class="line">            &#125;</span><br><span class="line">            dividend = dividend - temp;  <span class="comment">//被除数减去(除数*2^n)</span></span><br><span class="line">            result += i;  <span class="comment">//结果加上2^n</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//符号相同，则会可能产生除法溢出</span></span><br><span class="line">            <span class="keyword">if</span>(result &lt;= Integer.MIN_VALUE) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            result = -result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数学</tag>
        <tag>移位</tag>
      </tags>
  </entry>
  <entry>
    <title>实现strstr()</title>
    <url>/2019/10/20/%E5%AE%9E%E7%8E%B0strstr/</url>
    <content><![CDATA[<p>来源Leetcode第28题实现strstr()</p>
<blockquote>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<p>示例 1:<br><a id="more"></a><br>输入: haystack = “hello”, needle = “ll”</p>
</blockquote>
<h3 id="遍历匹配"><a href="#遍历匹配" class="headerlink" title="遍历匹配"></a>遍历匹配</h3><p>最简单的直接遍历匹配，没什么好说的，但是我最开始的时候还是越界了，脑子不够用，考虑的不够周全吧。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(needle.length() &gt; haystack.length())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; haystack.length() - needle.length() + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (haystack.charAt(i + j) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span> (j == needle.length()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><p>题解里有种写法都是用到了库函数，虽然效率高了，但是感觉这不是题目所要求考察的方向。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; haystack.length() - needle.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack.substring(i, i + needle.length()).equals(needle)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>以下是来自源码的解答：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Code shared by String and AbstractStringBuilder to do searches. The</span></span><br><span class="line"><span class="comment">     * source is the character array being searched, and the target</span></span><br><span class="line"><span class="comment">     * is the string being searched for.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   source       the characters being searched.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   target       the characters being searched for.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   fromIndex    the index to begin searching from.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String source, String target, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> sourceLength = source.length();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> targetLength = target.length();</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &gt;= sourceLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> (targetLength == <span class="number">0</span> ? sourceLength : -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fromIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetLength == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fromIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> first = target.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 计算出最多比较的次数</span></span><br><span class="line">        <span class="keyword">int</span> max = (sourceLength - targetLength);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">            <span class="comment">// 寻找在source中出现和target第一个字符相等的位置</span></span><br><span class="line">            <span class="keyword">if</span> (source.charAt(i)!= first) &#123;</span><br><span class="line">                <span class="keyword">while</span> (++i &lt;= max &amp;&amp; source.charAt(i) != first);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">                <span class="comment">// 找到第一个相等的字符后，从下一个字符开始再比较（下次比较开始的位置）</span></span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 除target第一个字符，剩下字符再比较结束的位置</span></span><br><span class="line">                <span class="comment">// 可以理解为：j+(targetLength-1)， 即开始的位置+ target剩下要比较字符的长度</span></span><br><span class="line">                <span class="keyword">int</span> end = j + targetLength - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">/* j &lt; end 说明还没有比较完</span></span><br><span class="line"><span class="comment">                 * j &lt; end &amp;&amp; source.charAt(j) == target.charAt(k) 是真说明在还没比较完的情况下比较的字符相等，</span></span><br><span class="line"><span class="comment">                 *  那么继续循环，直到条件为false</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; j &lt; end &amp;&amp; source.charAt(j) == target.charAt(k); j++, k++);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 上面循环结束时 j刚好等于结束比较的位置，那么就返回上面找到的target第一个字符相等的位置</span></span><br><span class="line">                <span class="keyword">if</span> (j == end) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>最后附上<a href="https://leetcode-cn.com/problems/implement-strstr/solution/kmp-suan-fa-xiang-jie-by-labuladong/" target="_blank" rel="noopener">KMP算法</a>的解答，来自题解，先摸了。</p>
<p>题解算法的思路与传统的KMP算法不一致，题解采用了一个dp[par.length()][256]的数组来标记有限状态机的下一步该怎么走，示意图如下：</p>
<div align="center">
<img width="600" src="https://pic.leetcode-cn.com/74666053023d668f2007c84382a86930c1270807cdf2f4394165bf2b16336f72-file_1568963023167">
</div>

<p>具体过程在题解里说的很清楚了，这里补一下题解的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">private</span> String pat;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pat = pat;</span><br><span class="line">        <span class="keyword">int</span> M = pat.length();</span><br><span class="line">        <span class="comment">// dp[状态][字符] = 下个状态</span></span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[M][<span class="number">256</span>];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        dp[<span class="number">0</span>][pat.charAt(<span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 影子状态 X 初始为 0</span></span><br><span class="line">        <span class="keyword">int</span> X = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 构建状态转移图（稍改的更紧凑了）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">256</span>; c++) &#123;</span><br><span class="line">                dp[j][c] = dp[X][c];</span><br><span class="line">            dp[j][pat.charAt(j)] = j + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 更新影子状态</span></span><br><span class="line">            X = dp[X][pat.charAt(j)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = pat.length();</span><br><span class="line">        <span class="keyword">int</span> N = txt.length();</span><br><span class="line">        <span class="comment">// pat 的初始态为 0</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算 pat 的下一个状态</span></span><br><span class="line">            j = dp[j][txt.charAt(i)];</span><br><span class="line">            <span class="comment">// 到达终止态，返回结果</span></span><br><span class="line">            <span class="keyword">if</span> (j == M) <span class="keyword">return</span> i - M + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没到达终止态，匹配失败</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>传统的 KMP 算法是使用一个一维数组 next 记录前缀信息，而本文是使用一个二维数组 dp 以状态转移的角度解决字符匹配问题，但是空间复杂度仍然是 O(256M) = O(M)。</p>
<p>在 pat 匹配 txt 的过程中，只要明确了「当前处在哪个状态」和「遇到的字符是什么」这两个问题，就可以确定应该转移到哪个状态（推进或回退）。</p>
<p>对于一个模式串 pat，其总共就有 M 个状态，对于 ASCII 字符，总共不会超过 256 种。所以我们就构造一个数组 dp[M][256] 来包含所有情况，并且明确 dp 数组的含义：</p>
<p>dp[j][c] = next 表示，当前是状态 j，遇到了字符 c，应该转移到状态 next。</p>
<p>明确了其含义，就可以很容易写出 search 函数的代码。</p>
<p>对于如何构建这个 dp 数组，需要一个辅助状态 X，它永远比当前状态 j 落后一个状态，拥有和 j 最长的相同前缀，我们给它起了个名字叫「影子状态」。</p>
<p>在构建当前状态 j 的转移方向时，只有字符 pat[j] 才能使状态推进（dp[j][pat[j]] = j+1）；而对于其他字符只能进行状态回退，应该去请教影子状态 X 应该回退到哪里（dp[j][other] = dp[X][other]，其中 other 是除了 pat[j] 之外所有字符）。</p>
<p>对于影子状态 X，我们把它初始化为 0，并且随着 j 的前进进行更新，更新的方式和 search 过程更新 j 的过程非常相似（X = dp[X][pat[j]]）。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>DARK SOULS III的BGM</title>
    <url>/2019/10/20/DSIII%E7%9A%84BGM/</url>
    <content><![CDATA[<p>上半年6月入的坑，昨晚又找了一波魂3的bgm，听者触人心弦。<br>也不想学习，就摸会鱼，写点东西纪念我数不清的”YOU DIED“吧。</p>
<h5 id="1-Gwyn-Lord-of-Cinder"><a href="#1-Gwyn-Lord-of-Cinder" class="headerlink" title="1.Gwyn, Lord of Cinder"></a>1.Gwyn, Lord of Cinder</h5><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=509038&auto=0&height=66"></iframe><br><a id="more"></a></p>
<p><img src="https://imgs.aixifan.com/o_1dp9smju04d01jmg1kj91cf11eir2i.jpg" alt="葛温"></p>
<p>尽管这首歌不是魂3的BGM，但我还是想把他放进来。<br>葛温的BGM，是我目前听到的最好的BMG之一，身为太阳王，开创了火之级元的男人，却自愿投入初始之火的火炉，化为柴薪，供初始之火燃烧。<br>尽管世界终将陷入黑暗，但是葛温还是义无反顾，歌曲中低吟婉转的歌声，似乎在诉说着葛温的一生。</p>
<h5 id="2-ludex-Gundyr"><a href="#2-ludex-Gundyr" class="headerlink" title="2.ludex Gundyr"></a>2.ludex Gundyr</h5><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679531&auto=0&height=66"></iframe><br><img src="https://imgs.aixifan.com/o_1dp9st3e5cf7h7u19sh1junp982s.jpg" alt="古达"></p>
<p>被传火束缚的英雄古达，或许是因为迟到还是种种原因，在火灭时离传火祭祀场只有一步之遥，最终以身为螺旋剑的剑鞘，审判着钟声响起踏上探王之旅的灰烬们。<br>二阶段爆发了人之脓的病毒，压迫感较之一阶段更令萌新感到压抑，窒息。</p>
<h5 id="3-Vordt-of-the-Boreal-Valley"><a href="#3-Vordt-of-the-Boreal-Valley" class="headerlink" title="3.Vordt of the Boreal Valley"></a>3.Vordt of the Boreal Valley</h5><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407677583&auto=0&height=66"></iframe><br><img src="https://imgs.aixifan.com/o_1dp9suktb16h97dh15ml185ff2936.jpg" alt="冰狗"></p>
<p>作为正确流程下的第二个boss，这首BGM与其说是波尔多的专属，倒不如说是整个冷冽谷征战骑士的缩影，前半段雄壮中带着点哀伤的意味，描绘了骑士们的出征，而后半段骤起的激昂慷慨则更多表现了骑士们凝视教宗眼眸的结局——在狂热中拼命作战，直至死亡，既是宿命，又何尝不是一种自我告慰与解脱呢？<br>高潮始于1:47，慷慨激昂的音乐中，彷佛看见了教宗沙利万眼里的永不熄灭的罪业之火，为了教宗而征战四方，以致献上生命。</p>
<blockquote>
<p>很久以前，年轻魔法师沙利万<br>在远离伊鲁席尔的地底下<br>发现罪业之都与不熄火焰<br>从那以后，他心中不曾消失的野心之火<br>更是猛烈燃烧</p>
</blockquote>
<h5 id="4-Abyss-Watchers"><a href="#4-Abyss-Watchers" class="headerlink" title="4.Abyss Watchers"></a>4.Abyss Watchers</h5><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679537&auto=0&height=66"></iframe><br><img src="https://imgs.aixifan.com/o_1dp9t03ep1nlkls4vil1cei1k9c3g.jpg" alt="街舞队"></p>
<blockquote>
<p>与魔鬼战斗的人，应当小心自己不要成为魔鬼。当你远远凝视深渊时，深渊也在凝视你。——尼采 《善恶的彼岸》</p>
</blockquote>
<p>一群继承了一代A大意志的不死人们，他们分享狼血，以狼血为誓，他们自发组建了法兰不死队，对狼血起誓，监视深渊。只要有一丁点深渊的征兆，即便灭了一个国家也在所不惜。<br>然而或许是因为以为传火能压制深渊，可是没想到钟声响起之后，深渊仍在，反而有了扩张的痕迹，他们征讨深渊，却因为传火导致自身实力不足，不足以剿灭深渊，于是他们在被深渊侵蚀的卡萨斯地下墓地之上建立了法兰要塞，以彻底压制深渊，不让深渊爆发。</p>
<p><img src="https://imgs.aixifan.com/o_1dp9t0rrm1vdp1295159v18vb16f23q.jpg" alt="街舞队"></p>
<p>然而在征讨深渊时，队友感染了深渊，于是在法兰灵庙里响起了法兰大剑相碰的清脆声，他们的血源于狼血，他们在不断地重复清洗队友，但又由于不死人的身份不能根治，只能不断的自相残杀只能等待灰烬来给他们一个了断，这是一种解脱。</p>
<h5 id="5-Aldritch-Devourer-of-Gods"><a href="#5-Aldritch-Devourer-of-Gods" class="headerlink" title="5.Aldritch, Devourer of Gods"></a>5.Aldritch, Devourer of Gods</h5><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679538&auto=0&height=66"></iframe><br><img src="https://imgs.aixifan.com/o_1dp9t35o8b8e1ut06j110r47bf44.jpg" alt="吃神"></p>
<blockquote>
<p>“艾尔德里奇，臭名昭著的吞噬者，渴望与他人分享被吸取生命者最后的战栗，沉醉于聆听受害者的尖叫声。”</p>
</blockquote>
<p>吃神被钟声唤醒之后回到了幽邃教堂，最终前往故乡伊鲁席尔，在那里遇到了25仔剑圣沙利万，沙利万将病重的伪娘投食给吃神，以此两人来达成合作，来度过火熄灭后的日子。</p>
<p>这首BGM更多地是为了纪念伪娘格温德林，和声是用的1代伪娘的和声。伪娘被沙利万设计陷害导致病重，交出暗月教宗席位，妹妹沦为阶下囚，自己最后还被喂食给艾尔德里奇。</p>
<h5 id="6-Yhorm-the-Giant"><a href="#6-Yhorm-the-Giant" class="headerlink" title="6.Yhorm the Giant"></a>6.Yhorm the Giant</h5><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407677590&auto=0&height=66"></iframe><br><img src="https://imgs.aixifan.com/o_1dp9t88b0p4qc1idm1pu1j634e.png" alt="王尤姆"></p>
<p>这首歌更多的是为了纪念萌萌哒的葱哥。</p>
<blockquote>
<p>To your valor, my sword, and our victory together<br>To your valor, and my old friend Yorn!<br>Long may the sun shine!<br>Yhorm. Old friend. I, Siegward of the knights of Catarina. Have come to uphold my promise. Let the sun shine on this Lord of Cinder!</p>
</blockquote>
<p>自知罪都的居民不承认他，只是一面畏惧着他伟岸的身姿，又希望他抑制住地下的罪业之火。<br>伟岸的巨人从棺木中坐起，意识到他本应守护的人民早已面目全非，尤姆发出了震天动地的怒吼。他回到罪都，坐在残破的王座之上，身边被烧成焦炭的扭曲尸体历历在目，他们无声的哀嚎折磨着这位王者。尤姆的内心深处除了自责，还有对传火的滚滚恨意，他的希望并没有成为现实，而是化作畸形的烈焰吞噬一切，他的灵魂也随着这股力量开始扭曲。</p>
<h5 id="7-Secret-Betrayal"><a href="#7-Secret-Betrayal" class="headerlink" title="7.Secret Betrayal"></a>7.Secret Betrayal</h5><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407677592&auto=0&height=66"></iframe><br><img src="/2019/10/20/DSIII的BGM/firekeeper.png" alt="灭火"></p>
<p>在无火的祭祀场里的幻影墙里找到的防火女的眼眸，并交给现在祭祀场里的防火女后，整个祭祀场的BGM就会改变。</p>
<p><img src="https://imgs.aixifan.com/o_1dp9tbjsv1jd47g81cv912nk1luo4o.jpg" alt="防火女"></p>
<p>防火女必须爱上黑暗才能有成为防火女的资格，但其职责却是为了帮助传火者，当其看见了属于自己的世界时，矛盾的内心，背叛的欲望和应履行的使命感交织在一起。</p>
<p>透过防火女的眼眸，可以看到一些不存在的东西。</p>
<p>或许她看到的就是火已经熄灭后的世界吧，但是为了帮助灰烬，不得不做出违心的选项。</p>
<blockquote>
<p>Ashen one hearest thou my voice still.</p>
</blockquote>
<h5 id="8-Nameless-King"><a href="#8-Nameless-King" class="headerlink" title="8.Nameless King"></a>8.Nameless King</h5><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407677589&auto=0&height=66"></iframe><br><img src="https://imgs.aixifan.com/o_1dp9tgbes1sgh1ujk1jeqr0413jf52.png" alt="校长"></p>
<blockquote>
<p>欲步向龙道者，切勿敲响大钟。</p>
</blockquote>
<p>太阳长男因为其愚蠢的想法，惨遭众神驱逐，剥夺名字，曾经的猎龙战神最终余生与自己的战友风暴龙度过。<br>然而尽管如此，弟弟伪娘还是在新神都伊鲁席尔设置有无名的供奉，在那里可以获得太阳长男戒指。<br>而且无名作为一代战神，太阳神教教主，其誓约太阳战士更是贯穿了3代，让玩家在传火的路上不在孤单。long may the sun shine！</p>
<p>进入大钟楼，敲响那口大钟，随着一段CG，四周被白雾笼罩，进入白雾，看到远处的天空出现了一个手持剑枪，乘坐风暴龙的魁梧大汉，紧接着伴随着BGM的响起，仿佛是真的在挑战神明吧。</p>
<h5 id="9-Soul-of-Cinder"><a href="#9-Soul-of-Cinder" class="headerlink" title="9.Soul of Cinder"></a>9.Soul of Cinder</h5><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679539&auto=0&height=66"></iframe><br><img src="/2019/10/20/DSIII的BGM/SoulCinder.png" alt="化身"></p>
<p>前半段是魂系列一贯的恢弘，却比每一个薪王的BGM都舒缓，因为最后的传火者不是什么伟大的英雄，只是一个曾弱小不堪的余灰，而BGM的最后，葛温王的曲调宛若淬火而生，无数英雄的逐一闪现，他们的伟大与渺小，他们的爱与恨，这些身影逐渐重合成一个手持大剑，高大却枯瘦的老者，Gwyn，lord of cinder.</p>
<p><img src="https://imgs.aixifan.com/o_1dp9tnqpcqenemh1fcosi314r65c.png" alt="化身"></p>
<blockquote>
<p>“因为万物都在永恒之源泉中受了洗礼，而且在善与恶的彼岸：但善与恶本身也只不过是短暂的阴影、潮湿的悲伤和浮云。”——尼采《查拉图斯特拉如是说》</p>
</blockquote>
<h5 id="10-For-the-Dark-Soul"><a href="#10-For-the-Dark-Soul" class="headerlink" title="10.For the Dark Soul"></a>10.For the Dark Soul</h5><p>(由于版权保护，无法生成外链)</p>
<h5 id="11-Sister-Friede-Father-Ariandel-and-Friede-Blackflame-Friede"><a href="#11-Sister-Friede-Father-Ariandel-and-Friede-Blackflame-Friede" class="headerlink" title="11.Sister Friede | Father Ariandel and Friede | Blackflame Friede"></a>11.Sister Friede | Father Ariandel and Friede | Blackflame Friede</h5><p>(由于版权保护，无法生成外链)</p>
<p><img src="https://imgs.aixifan.com/o_1dp9tpsal1jit7aj1em81cj51g0a5n.png" alt="修女"></p>
<p>来自艾雷德尔的灰烬，因不堪传火的痛苦，在绘画世界里选择与神父维持腐朽破败的世界，以度过余生。</p>
<p>然而主人公灰烬受到火焰的吸引，触碰了神父手里的火，最终触发了一场boss战。</p>
<p>开头是一段凄凉悲伤的音乐，仿佛是在讲述芙利徳传火时的痛苦与悲伤。当修女轻抚镰刀走进来，战斗无可避免。</p>
<p>只是迷路至此的灰烬撼动了火焰。</p>
<p><img src="https://imgs.aixifan.com/o_1dp9tpsalvjj1nv11obm1lhb1rfe5o.png" alt="修女"></p>
<p>不明火焰者，不足以绘世。<br>受火引诱者，则不得绘世。<br>让我看见火焰吧，那阵燃烧我们的故乡——艾雷德尔的绘画的火焰。</p>
<p>犹如预言中的那样。<br>灰烬成双，则火燃起。</p>
<h5 id="11-Darkeater-Midir"><a href="#11-Darkeater-Midir" class="headerlink" title="11.Darkeater Midir"></a>11.Darkeater Midir</h5><p>(由于版权保护，无法生成外链)</p>
<p><img src="https://imgs.aixifan.com/o_1dp9u1r7apug17l827csap10a365.jpg" alt="黑龙"></p>
<p>论压迫力，论场景设计，加之深渊激光炮，米狄尔真的是完美诠释了什么叫龙，一种不该与之为敌的神级生物应该是什么样子，尽管熟悉了确实不算难。</p>
<h5 id="12-Firelink-Shrine"><a href="#12-Firelink-Shrine" class="headerlink" title="12.Firelink Shrine"></a>12.Firelink Shrine</h5><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407677582&auto=0&height=66"></iframe><br><img src="https://imgs.aixifan.com/o_1dp9u59481fjk11ql11sk23a1fr86k.png" alt="火鸡场"></p>
<p>这是没有希望的世界，每一代的我们都在延续一个苟延残喘的灰烬之地，薪王都疯了，因我们累了真正累了，世上只有一种英雄主义，就是在认清生活真相后依然热爱生活，但在灰烬世界，英雄本就不存，这词对不死人而言，太高傲也太自以为是了，我们只是余火行将熄灭。</p>
<p>“灰烬大人，愿火焰将您引导”<br>”“灰烬大人，欢迎再拿点灵魂过来”“你可要安全回来啊，不然就白费我锻造的武器了”“记得回来啊，没了弟子的师父可不像样”“你要平安无事啊”“再见，还有保重，在这个无聊的地方偷的东西也没有意义了”“再见，无火的灰烬”</p>
<h5 id="13-Epilogue"><a href="#13-Epilogue" class="headerlink" title="13.Epilogue"></a>13.Epilogue</h5><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407677593&auto=0&height=66"></iframe><br><img src="https://imgs.aixifan.com/o_1dp9u6n4p1mmmqdu1gh3dr7apq6u.png" alt="结束曲"></p>
<p>照亮了世界千年的火焰，曾给世界带来了生死，光暗，冷暖。最初的太阳王葛温，牺牲自己将原初之火传承下来。但万物都是有始终的，寄托了无数代薪王意志的火啊，最后也逃不过熄灭的命运。随着防火女的手慢慢收拢，见证了罗德兰千年风云变幻潮起潮落的火苗，就从此消失不见，就好似黄粱一梦。</p>
<h5 id="14-DARK-SOULS-Ⅲ"><a href="#14-DARK-SOULS-Ⅲ" class="headerlink" title="14.DARK SOULS Ⅲ"></a>14.DARK SOULS Ⅲ</h5><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407677581&auto=0&height=66"></iframe><br><img src="https://imgs.aixifan.com/o_1dp9u7s8u1jeh1rlhlgc1pqqhhr78.png" alt="载入曲"></p>
<p>吟唱至高潮处，一张蛮荒，昏暗，绝望，宏大的画卷扑面而来，不同于前两代菜单曲的深邃神秘悠远之感，这首菜单曲的感觉是大气苍凉史诗，仿佛在昭示着为这个上世代/本世代最伟大的游戏系列之一落下一个直冲灵魂深处的句号，凄凉，悲哀同时却壮丽绚烂，又与黑魂系列脱不出的绝望与晦涩风格呼应。<br>燃烧吧，那无生命的薪柴，渐渐进走向黑暗！</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>音乐</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>移除元素</title>
    <url>/2019/10/07/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>来源Leetcode第27题移除元素</p>
<blockquote>
<p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<a id="more"></a>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 1:</p>
<p>给定 nums = [3,2,2,3], val = 3,</p>
<p>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>拿到这题的时候第一想法就是头尾双指针，但是不知道这样写为什么会出问题，太蔡了，一时找不到问题出错点。后面重写时又出问题了，TLE,T T，也没搞懂为什么会超时，太难了，明明是和之前删除重复元素差不多的写法。<br>先附上AC的代码吧：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numsSize ; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != val) &#123;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至于自己写问题的代码，先附上吧：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i] != val &amp;&amp; i &lt; j)&#123;</span><br><span class="line">        i++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"i = %d  nums[%d] = %d \n"</span>,i,i,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从左向右找到等于 val 的位置</span></span><br><span class="line">        <span class="keyword">while</span>(nums[j] == val &amp;&amp; i &lt; j)&#123;</span><br><span class="line">        j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右向左找到不等于 val 的位置</span></span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时i == j ,但是不知道nums[i] 的值是否等于val</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>,i);</span><br><span class="line">    <span class="keyword">return</span> i + nums[i] != val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums[<span class="number">4</span>];</span><br><span class="line">    nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    nums[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    nums[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    nums[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> k = removeElement(nums,<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"k = %d\n"</span>,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>执行完成，耗时：4 ms<br>i = 1  nums[1] = 2<br>i = 1<br>k = 1</p>
</blockquote>
<p>有点迷，这结果。</p>
<p>找到结果了，优先级的问题， != 的优先级比 ‘+’ 低，修改成了  return i + (nums[i] != val); 就过了</p>
<p>正确的应该是:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> i + (nums[i] != val);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发小记</title>
    <url>/2019/10/06/Android%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>做了几天的软工作业，今天终于磨出了点东西了<br>虽然我负责的是比较水的出题模块，但是还是出现了许多智障操作。<br>我巴不得每一个类型写一个方法出来<br>最后记一下今天遇到的几个坑</p>
<a id="more"></a>
<ul>
<li>空指针异常</li>
<li>空栈异常</li>
<li>除数为0异常</li>
</ul>
<p>空指针异常的出错代码为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StatOfType E = <span class="keyword">new</span> StatOfType();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">47</span>; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            E.setNum(<span class="number">10</span>);</span><br><span class="line">            E.setTypeId(i+<span class="number">1</span>);</span><br><span class="line">            typeList.add(E);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>折磨了我一个下午之后，终于经过坤滨的提示找到了问题所在。<br>由于对象E是在循环外实例的，导致List里其实共享的是最后一个对象E的地址，于是List 在作为参数传参时，输出的都是最后一次修改的结果。<br>其次，由于对象E(StatOfType)类型初始时设置的id是0，这样在传参时，子函数在调用LitePal的find方法时会出错，返回一个空的List，所以也会导致空指针异常。</p>
<p>空栈异常的出错代码为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">aAns = (<span class="keyword">int</span>)CalExpression.executeExpression(aProblem);</span><br></pre></td></tr></table></figure></p>
<p>原因是因为 aProblem 的 Num1 没有增加String.Valueof()，这个方法，导致计算时出现了空栈异常。</p>
<p>除法异常的出错代码为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">GetRandomNum</span><span class="params">(<span class="keyword">int</span> min,<span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//return random.nextInt(max) % (max - min + 1) + min;</span></span><br><span class="line">        <span class="keyword">return</span> random.nextInt(max - min + <span class="number">1</span>) + min;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>除法异常出错的原因在于注释的那一句 <code>Javareturn random.nextInt(max) % (max - min + 1) + min;</code><br>max - min +1 存在可能为0的情况？但也不对，emmm反正就是这个改了就可以了<br>Random的nextInt()这个函数里对参数有要求&gt;=0。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>删除排序数组中的重复项</title>
    <url>/2019/09/30/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<p>来源Leetcode第26题删除排序数组中的重复项</p>
<blockquote>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<a id="more"></a>
<p>示例 1:</p>
<p>给定数组 nums = [1,1,2], </p>
<p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p>这题和之前的随机的<a href="https://yorxika.github.io/2019/09/16/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II/">第80题</a>是一样的2333,代码就在之前的改改就好了</p>
<p>2种代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*First solution</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">1</span> || n &gt; nums[i-<span class="number">1</span>])</span><br><span class="line">                nums[i++] = n;</span><br><span class="line">        <span class="keyword">return</span> i;  </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*Second solution</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = nums[i];  <span class="comment">//记录当前值</span></span><br><span class="line">            nums[m++] = nums[i++]; <span class="comment">//对数组进行1次操作</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; nums.length &amp;&amp; nums[i] == val) <span class="comment">//如果2个数之后的数据元素仍与之前相等就跳过</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            nums[m++] = nums[i++];  <span class="comment">//最后两个元素无所谓从不重复，直接复制就完事了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>两两交换链表中的结点</title>
    <url>/2019/09/29/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<p>来源Leetcode第24题两两交换链表中的结点</p>
<blockquote>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br><a id="more"></a><br>示例:</p>
<p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p>
</blockquote>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>初做这道题时没找清数学规律，用了好几个变量来标记，但是厘清之后，其实就是第一个结点最终会指向第4个结点，第二个结点指向第一个结点，第4个结点指向第三个结点。<br>分解开来，第一轮循环完成2个结点交换，那么需要一个nxt指针指向第三个结点，然后让头指针完成一、二结点的交换(使第二个结点的next指向第一个结点),接下来判断第三、四个结点是否为空，否的话，第一个结点的next域指向第四个结点，是的话，第一个结点的next于指向第三个；最后让头指针指向第三个结点即可完成一轮循环。<br>代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">swapPairs</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span>= <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    head = cur-&gt;next;</span><br><span class="line">   <span class="keyword">while</span>(cur !=<span class="literal">NULL</span> &amp;&amp; cur-&gt;next !=<span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span> = <span class="title">NULL</span>;</span></span><br><span class="line">       <span class="keyword">if</span>(cur-&gt;next-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">       next = cur-&gt;next-&gt;next;  <span class="comment">//next指向第三个结点</span></span><br><span class="line">       cur-&gt;next-&gt;next = cur;  <span class="comment">//使第二个结点的next指向第一个结点</span></span><br><span class="line">       <span class="keyword">if</span>(next != <span class="literal">NULL</span> &amp;&amp; next-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           cur-&gt;next = next-&gt;next;  <span class="comment">//另第一个结点的下一个结点指向第四个结点</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           cur-&gt;next = next;</span><br><span class="line">       &#125;</span><br><span class="line">       cur = next;  <span class="comment">//cur指向第三个结点</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>看了下评论，写了个递归的<br>代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">swapPairs</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!head || !head-&gt;next)&#123;</span><br><span class="line">       <span class="keyword">return</span> head; <span class="comment">//头指针或尾指针为空</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span> = <span class="title">head</span> -&gt;<span class="title">next</span>;</span></span><br><span class="line">   head-&gt;next = swapPairs(next-&gt;next);</span><br><span class="line">   next-&gt;next = head;</span><br><span class="line">   <span class="keyword">return</span> next; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>图解源自<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/chao-qiang-gifzhu-ni-li-jie-shi-yong-di-gui-fa-qiu/" target="_blank" rel="noopener">题解</a><br><img src="/2019/09/29/两两交换链表中的结点/NO24.gif" alt="递归调用图解"></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>合并K个排序链表</title>
    <url>/2019/09/28/%E5%90%88%E5%B9%B6K%E4%B8%AA%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>来源Leetcode第23题合并K个排序链表</p>
<blockquote>
<p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p>示例:</p>
<p>输入:<br><a id="more"></a><br>[<br> 1-&gt;4-&gt;5,<br> 1-&gt;3-&gt;4,<br> 2-&gt;6<br>]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
</blockquote>
<h4 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h4><p>这题其实之前做过简化版的，合并2个有序链表，这次合并K个，就可以采用K路归并的思路，两两合并有序链表。<br>代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">mergeTwoLists</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span>  <span class="comment">//合并2个有序链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">l1</span>,*<span class="title">l2</span>,*<span class="title">head</span>,*<span class="title">n</span>;</span></span><br><span class="line">    l1=p1;</span><br><span class="line">    l2=p2;</span><br><span class="line">    <span class="keyword">if</span>(l1==<span class="literal">NULL</span>)<span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2==<span class="literal">NULL</span>)<span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">    head = l1;</span><br><span class="line">    n = head;</span><br><span class="line">    l1=l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    head = l2;</span><br><span class="line">    n = head;</span><br><span class="line">    l2=l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>&amp;&amp;l2!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            head-&gt;next=l1;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">            head = head -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            head -&gt;next = l2;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">            head = head -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head -&gt; next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="literal">NULL</span>)</span><br><span class="line">    head -&gt; next = l1;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* _<span class="title">mergeKLists</span>(<span class="title">struct</span> <span class="title">ListNode</span>** <span class="title">lists</span>, <span class="title">int</span> <span class="title">listsSize</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">l1</span>, *<span class="title">l2</span>;</span></span><br><span class="line">	count = listsSize;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> mergeTwoLists(lists[<span class="number">0</span>], lists[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	l1 = _mergeKLists(&amp;lists[<span class="number">0</span>], (count+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">	l2 = _mergeKLists(&amp;lists[(count+<span class="number">1</span>)/<span class="number">2</span>], count - (count+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">return</span> mergeTwoLists(l1, l2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">mergeKLists</span><span class="params">(struct ListNode** lists, <span class="keyword">int</span> listsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> _mergeKLists(lists, listsSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>接下来我们来看看<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/he-bing-kge-pai-xu-lian-biao-by-leetcode/" target="_blank" rel="noopener">官方解答</a></p>
<hr>
<h4 id="方法1：暴力"><a href="#方法1：暴力" class="headerlink" title="方法1：暴力"></a>方法1：暴力</h4><p><strong>想法 &amp; 算法</strong></p>
<ul>
<li>遍历所有链表，将所有节点的值放到一个数组中。</li>
<li>将这个数组排序，然后遍历所有元素得到正确顺序的值。</li>
<li>用遍历得到的值，创建一个新的有序链表。</li>
</ul>
<p>不得不吐槽，这排序是怎么做的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.nodes = []</span><br><span class="line">        head = point = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> l:</span><br><span class="line">                self.nodes.append(l.val)</span><br><span class="line">                l = l.next</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> sorted(self.nodes):</span><br><span class="line">            point.next = ListNode(x)</span><br><span class="line">            point = point.next</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(NlogN) ，其中 NN 是节点的总数目。<ul>
<li>遍历所有的值需花费 O(N) 的时间。</li>
</ul>
<ul>
<li>一个稳定的排序算法花费 O(NlogN) 的时间。</li>
<li>遍历同时创建新的有序链表花费 O(N) 的时间。</li>
</ul>
</li>
<li>空间复杂度：O(N) 。<ul>
<li>排序花费 O(N) 空间（这取决    于你选择的算法）。</li>
<li>创建一个新的链表花费 O(N) 的空间。</li>
</ul>
</li>
</ul>
<h4 id="方法2：逐一比较"><a href="#方法2：逐一比较" class="headerlink" title="方法2：逐一比较"></a>方法2：逐一比较</h4><p><strong>算法</strong></p>
<ul>
<li>比较 k 个节点（每个链表的首节点），获得最小值的节点。</li>
<li>将选中的节点接在最终有序链表的后面。</li>
</ul>
<p>代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">mergeKListsSub</span><span class="params">(struct ListNode** lists, <span class="keyword">int</span> listsSize)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> val = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; listsSize;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(val &gt; lists[i]-&gt;val)&#123;</span><br><span class="line">                val = lists[i]-&gt;val;</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">//先找到所有链表里最小的元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pos != <span class="number">-1</span>)&#123;</span><br><span class="line">        temp = lists[pos];</span><br><span class="line">        lists[pos] = lists[pos]-&gt;next; <span class="comment">//修改已经找到的最小元素链表的节点，将其指向下一个</span></span><br><span class="line">        temp-&gt;next = mergeKListsSub(lists,listsSize); <span class="comment">//递归查找第二个最小的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">mergeKLists</span><span class="params">(struct ListNode** lists, <span class="keyword">int</span> listsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mergeKListsSub(lists,listsSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度： O(kN) ，其中 k 是链表的数目。</p>
<ul>
<li>几乎最终有序链表中每个节点的时间开销都为 O(k) （k-1 次比较）。</li>
<li>总共有 N 个节点在最后的链表中。</li>
</ul>
</li>
<li><p>空间复杂度：</p>
<ul>
<li>O(n)。创建一个新的链表空间开销为 O(n) 。</li>
<li>O(1)。重复利用原来的链表节点，每次选择节点时将它直接接在最后返回的链表后面，而不是创建一个新的节点。</li>
</ul>
</li>
</ul>
<p>对比初始代码，可以发现时间复杂度明显提升，运行时间也由12ms提升到480ms。</p>
<h4 id="方法3：用优先队列优化方法-2"><a href="#方法3：用优先队列优化方法-2" class="headerlink" title="方法3：用优先队列优化方法 2"></a>方法3：用优先队列优化方法 2</h4><p><strong>算法</strong></p>
<p>几乎与上述方法一样，除了将<strong>比较环节</strong>用 <strong>优先队列</strong>进行了优化。你可以参考<a href="https://baike.baidu.com/item/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/9354754?fr=aladdin" target="_blank" rel="noopener">这里</a> 获取更多信息。</p>
<p>代码依旧是Python，摸了<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        head = point = ListNode(<span class="number">0</span>)</span><br><span class="line">        q = PriorityQueue()</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">if</span> l:</span><br><span class="line">                q.put((l.val, l))</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            val, node = q.get()</span><br><span class="line">            point.next = ListNode(val)</span><br><span class="line">            point = point.next</span><br><span class="line">            node = node.next</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                q.put((node.val, node))</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure></p>
<p>Java实现一：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparingInt(node -&gt; node.val));</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode p = dummy;</span><br><span class="line">    queue.addAll(Stream.of(lists).filter(Objects::nonNull).collect(Collectors.toList()));</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        ListNode node = queue.poll();</span><br><span class="line">        p.next = node;</span><br><span class="line">        p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>)</span><br><span class="line">            queue.add(node.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java实现二：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode(Integer[] nums) &#123;</span><br><span class="line">        ListNode currNode = <span class="keyword">this</span>;</span><br><span class="line">        currNode.val = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            currNode.next = <span class="keyword">new</span> ListNode(nums[i]);</span><br><span class="line">            currNode = currNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode currNode = <span class="keyword">this</span>;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (currNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.append(currNode.val);</span><br><span class="line">            s.append(<span class="string">" -&gt; "</span>);</span><br><span class="line">            currNode = currNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后添加一个 NULL 标志表示添加到末尾了</span></span><br><span class="line">        s.append(<span class="string">"NULL"</span>);</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = lists.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(len, Comparator.comparingInt(a -&gt; a.val));</span><br><span class="line">        ListNode dummyNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode curNode = dummyNode;</span><br><span class="line">        <span class="keyword">for</span> (ListNode list : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 这一步很关键，不能也没有必要将空对象添加到优先队列中</span></span><br><span class="line">                priorityQueue.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 优先队列非空才能出队</span></span><br><span class="line">            ListNode node = priorityQueue.poll();</span><br><span class="line">            <span class="comment">// 当前节点的 next 指针指向出队元素</span></span><br><span class="line">            curNode.next = node;</span><br><span class="line">            <span class="comment">// 当前指针向前移动一个元素，指向了刚刚出队的那个元素</span></span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">            <span class="keyword">if</span> (curNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 只有非空节点才能加入到优先队列中</span></span><br><span class="line">                priorityQueue.add(curNode.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] nums1 = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Integer[] nums2 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        Integer[] nums3 = &#123;<span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        ListNode head1 = <span class="keyword">new</span> ListNode(nums1);</span><br><span class="line">        ListNode head2 = <span class="keyword">new</span> ListNode(nums2);</span><br><span class="line">        ListNode head3 = <span class="keyword">new</span> ListNode(nums3);</span><br><span class="line">        ListNode[] lists = <span class="keyword">new</span> ListNode[<span class="number">3</span>];</span><br><span class="line">        lists[<span class="number">0</span>] = head1;</span><br><span class="line">        lists[<span class="number">1</span>] = head2;</span><br><span class="line">        lists[<span class="number">2</span>] = head3;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        ListNode mergeKLists = solution.mergeKLists(lists);</span><br><span class="line">        System.out.println(mergeKLists);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度： O(Nlogk) ，其中 k 是链表的数目。</p>
<ul>
<li>弹出操作时，比较操作的代价会被优化到 O(logk) 。同时，找到最小值节点的时间开销仅仅为 O(1)。</li>
</ul>
<ul>
<li>最后的链表中总共有 N 个节点。</li>
</ul>
</li>
<li><p>空间复杂度：</p>
<ul>
<li>O(n)。创造一个新的链表需要 O(n) 的开销。</li>
<li>O(k)。以上代码采用了重复利用原有节点，所以只要 O(1) 的空间。同时优先队列（通常用堆实现）需要 O(k) 的空间（远比大多数情况的 NN要小）</li>
</ul>
</li>
</ul>
<p>最小索引堆实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span>((len=lists.length)==<span class="number">0</span> || lists == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       ListNode preHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">       ListNode preNode = preHead;</span><br><span class="line">       PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(len, <span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> o1.val - o2.val;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">for</span> (ListNode node : lists) &#123;</span><br><span class="line">           <span class="keyword">if</span>(node!=<span class="keyword">null</span>) queue.add(node);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">           ListNode small = queue.poll();</span><br><span class="line">           preNode.next = small;</span><br><span class="line">           <span class="keyword">if</span>(small.next!=<span class="keyword">null</span>) queue.add(small.next); <span class="comment">//将最小值节点后面的节点添加到队里中</span></span><br><span class="line">           preNode = preNode.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> preHead.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="方法4：逐一两两合并链表"><a href="#方法4：逐一两两合并链表" class="headerlink" title="方法4：逐一两两合并链表"></a>方法4：逐一两两合并链表</h4><p><strong>算法</strong></p>
<p>将合并 k 个链表的问题转化成合并 2 个链表 k-1 次</p>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度： O(kN)，其中 k 是链表的数目。</p>
<ul>
<li>我们可以在 O(n) 的时间内合并两个有序链表，其中 n 是两个链表的总长度。</li>
<li>把所有合并过程所需的时间加起来，我们可以得到： O(kN)</li>
</ul>
</li>
<li><p>空间复杂度：O(1)</p>
<ul>
<li>我们可以在 O(1) 空间内合并两个有序链表。</li>
</ul>
</li>
</ul>
<p>代码见最开始部分。</p>
<h4 id="方法5：分治"><a href="#方法5：分治" class="headerlink" title="方法5：分治"></a>方法5：分治</h4><p>这个方法沿用了上面的解法，但是进行了较大的优化。我们不需要对大部分节点重复遍历多次。</p>
<pre><code>+ 将 k 个链表配对并将同一对中的链表合并。
+ 第一轮合并以后，k 个链表被合并成了 K/2个链表，平均长度为 2N/k，然后是k/4个链表，K/8个链表等等。
+ 重复这一过程，直到我们得到了最终的有序链表。
</code></pre><p>因此，我们在每一次配对合并的过程中都会遍历几乎全部 N 个节点，并重复这一过程 log2K 次。</p>
<p>代码依旧是Python，摸了,下次补个C或者JAVA的<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        amount = len(lists)</span><br><span class="line">        interval = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> interval &lt; amount:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, amount - interval, interval * <span class="number">2</span>):</span><br><span class="line">                lists[i] = self.merge2Lists(lists[i], lists[i + interval])</span><br><span class="line">            interval *= <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>] <span class="keyword">if</span> amount &gt; <span class="number">0</span> <span class="keyword">else</span> lists</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge2Lists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        head = point = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                point.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                point.next = l2</span><br><span class="line">                l2 = l1</span><br><span class="line">                l1 = point.next.next</span><br><span class="line">            point = point.next</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">            point.next=l2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            point.next=l1</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure></p>
<p>Java实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode(Integer[] nums) &#123;</span><br><span class="line">        ListNode currNode = <span class="keyword">this</span>;</span><br><span class="line">        currNode.val = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            currNode.next = <span class="keyword">new</span> ListNode(nums[i]);</span><br><span class="line">            currNode = currNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode currNode = <span class="keyword">this</span>;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (currNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.append(currNode.val);</span><br><span class="line">            s.append(<span class="string">" -&gt; "</span>);</span><br><span class="line">            currNode = currNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后添加一个 NULL 标志表示添加到末尾了</span></span><br><span class="line">        s.append(<span class="string">"NULL"</span>);</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = lists.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergeKLists(lists, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 思考这里为什么取等于？这是因为根据下文对 mergeKLists 的递归调用情况，区间最窄的时候，只可能是左右端点重合</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (r - l) / <span class="number">2</span> + l;</span><br><span class="line">        ListNode l1 = mergeKLists(lists, l, mid);</span><br><span class="line">        ListNode l2 = mergeKLists(lists, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoSortedListNode(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoSortedListNode</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoSortedListNode(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        l2.next = mergeTwoSortedListNode(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：O(Nlogk) ，其中 k 是链表的数目。</p>
<ul>
<li>我们可以在 O(n) 的时间内合并两个有序链表，其中 n 是两个链表中的总节点数。</li>
<li>将所有的合并进程加起来，我们可以得到：O(Nlogk) 。</li>
</ul>
</li>
<li>空间复杂度：O(1)<ul>
<li>我们可以用 O(1)的空间实现两个有序链表的合并。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>贪心</tag>
        <tag>链表</tag>
        <tag>归并</tag>
        <tag>分治</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>括号生成</title>
    <url>/2019/09/26/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<p>来源Leetcode第22题括号生成</p>
<blockquote>
<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n = 3，生成结果为：</p>
<a id="more"></a>
<p>[<br> “((()))”,<br> “(()())”,<br> “(())()”,<br> “()(())”,<br> “()()()”<br>]</p>
</blockquote>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>其实可以把这道题看作是一道完全二叉树的题目，根结点为’(‘,树的最长路径为2n,那么只需当当前路径长度小于输入的n值时即可增加’(‘和’)’。<br>采用两个变量open、close分别标记’(‘和’)’的数量，那么满足以下两个条件即可进入更深一层递归：</p>
<ul>
<li>当open &lt; n 时，说明当前增加的’(‘还没到达上限，仍可继续增加</li>
<li>当close &lt; opne时，说明此时的’)’数量小于’(‘数量，可以增加’)’的数量以达到配对’(‘</li>
</ul>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        backtrack(ans, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; ans, String cur, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.length() == max * <span class="number">2</span>) &#123;</span><br><span class="line">            ans.add(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (open &lt; max)</span><br><span class="line">            backtrack(ans, cur+<span class="string">"("</span>, open+<span class="number">1</span>, close, max);</span><br><span class="line">        <span class="keyword">if</span> (close &lt; open)</span><br><span class="line">            backtrack(ans, cur+<span class="string">")"</span>, open, close+<span class="number">1</span>, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="规划条件"><a href="#规划条件" class="headerlink" title="规划条件"></a>规划条件</h3><p>来自于题解里的另一种解法：</p>
<blockquote>
<p>当我们清楚所有 i&lt;n 时括号的可能生成排列后，对与 i=n 的情况，我们考虑整个括号排列中最左边的括号。<br>它一定是一个左括号，那么它可以和它对应的右括号组成一组完整的括号 “( )”，我们认为这一组是相比 n-1 增加进来的括号。</p>
<p>那么，剩下 n-1 组括号有可能在哪呢？</p>
<p><strong>[这里是重点，请着重理解]</strong></p>
<p>剩下的括号要么在这一组新增的括号内部，要么在这一组新增括号的外部（右侧）。</p>
<p>既然知道了 i&lt;n 的情况，那我们就可以对所有情况进行遍历：</p>
<p><strong>“(“ + [i=p时所有括号的排列组合] + “)” + [i=q时所有括号的排列组合]</strong></p>
<p>其中 p + q = n-1，且 p q 均为非负整数。</p>
<p>事实上，当上述 p 从 0 取到 n-1，q 从 n-1 取到 0 后，所有情况就遍历完了。</p>
<p>注：上述遍历是没有重复情况出现的，即当 (p1,q1)≠(p2,q2) 时，按上述方式取的括号组合一定不同。</p>
<p>简单来说，在求N个括号的排列组合时，把第N种情况（也就是N个括号排列组合）视为单独拿一个括号E出来，剩下的N-1个括号分为两部分，P个括号和Q个括号，P+Q=N-1，然后这两部分分别处于括号E内和括号E的右边，各自进行括号的排列组合。由于我们是一步步计算得到N个括号的情况的，所以小于等于N-1个括号的排列组合方式我们是已知的（用合适的数据结构存储，方便后续调用，且在存储时可利用特定数据结构实现题目某些要求，如排序，去重等），且P+Q=N-1，P和Q是小于等于N-1的，所以我们能直接得到P个和Q个括号的情况，进而得到N个括号的结果！</p>
<p>这个解法的算法思想很巧妙，这个算法主要的基点就是将排列组合的情况分为了括号内和括号外这两种情况，且仅存在两种情况！至于为什么，原因在于楼主的算法的前提是单独拿出来的括号E的左边在N个括号所有排列组合情况中都是处于最左边，所以不存在括号位于括号E的左边的情况。因此，N-1个括号（拿出了括号E）仅可能分布于括号E内和括号E外，分为两种子情况讨论！(其实可以证明形如 “()A” 是会有和 “A()” 重复部分的)  这种思想还可以应用于其他类似的题的求解中，即怎样合理高效的利用前面步骤的计算结果得出当前步骤结果，从而得出最终结果。</p>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		LinkedList&lt;LinkedList&lt;String&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;LinkedList&lt;String&gt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> result.get(<span class="number">0</span>);</span><br><span class="line">		LinkedList&lt;String&gt; list0 = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">		list0.add(<span class="string">""</span>);</span><br><span class="line">		result.add(list0);</span><br><span class="line">		LinkedList&lt;String&gt; list1 = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">		list1.add(<span class="string">"()"</span>);</span><br><span class="line">		result.add(list1);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			LinkedList&lt;String&gt; temp = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">				List&lt;String&gt; str1 = result.get(j);</span><br><span class="line">				List&lt;String&gt; str2 = result.get(i - <span class="number">1</span> - j);</span><br><span class="line">				<span class="keyword">for</span> (String s1 : str1) &#123;</span><br><span class="line">					<span class="keyword">for</span> (String s2 : str2) &#123;</span><br><span class="line">						String el = <span class="string">"("</span> + s1 + <span class="string">")"</span> + s2;</span><br><span class="line">						temp.add(el);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			result.add(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result.get(n);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="题解摸了"><a href="#题解摸了" class="headerlink" title="题解摸了"></a>题解摸了</h3><p>来自题解的另一种解法，看不懂，困了，摸了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">tatal</span><span class="params">(<span class="keyword">int</span> num[], <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">            result += num[i];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">int</span> num[], <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i] != <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="built_in">string</span> <span class="title">once</span><span class="params">(<span class="keyword">int</span> num[], <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp += <span class="string">'('</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num[i]; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp += <span class="string">')'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> temp0 = <span class="string">""</span>;</span><br><span class="line">            result.push_back(temp0);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> *num = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            num[i] = <span class="number">0</span>;</span><br><span class="line">        num[n<span class="number">-1</span>] = n;</span><br><span class="line">        <span class="keyword">if</span>(n &gt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> temp0 = once(num, n);</span><br><span class="line">            result.push_back(temp0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] num;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[n<span class="number">-1</span>] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num[n<span class="number">-1</span>]--;</span><br><span class="line">                num[n<span class="number">-2</span>]++;</span><br><span class="line">                <span class="built_in">string</span> temp0 = once(num, n);</span><br><span class="line">                result.push_back(temp0);</span><br><span class="line">                <span class="keyword">if</span>(equal(num, n))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                num[i] += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>((num[i] &gt; i + <span class="number">1</span>)||(tatal(num,i+<span class="number">1</span>) &gt; i + <span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    num[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num[n<span class="number">-1</span>] = n - tatal(num,n<span class="number">-2</span>);</span><br><span class="line">            <span class="built_in">string</span> temp1 = once(num, n);</span><br><span class="line">            result.push_back(temp1);</span><br><span class="line">            <span class="keyword">if</span>(equal(num, n))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> [] num;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="闭合数"><a href="#闭合数" class="headerlink" title="闭合数"></a>闭合数</h3><p>来自于官方解答的闭合数，其实和动态规划是差不多的，也摸了，明天再看了。</p>
<blockquote>
<p>方法三：闭合数<br><strong>思路</strong></p>
<p>为了枚举某些内容，我们通常希望将其表示为更容易计算的不相交子集的总和。</p>
<p>考虑有效括号序列 S 的 闭包数：至少存在 index &gt;= 0，使得 S[0], S[1], …, S[2*index+1]是有效的。 显然，每个括号序列都有一个唯一的闭包号。 我们可以尝试单独列举它们。</p>
<p><strong>算法</strong></p>
<p>对于每个闭合数 c，我们知道起始和结束括号必定位于索引 0 和 2<em>c + 1。然后两者间的 2</em>c 个元素一定是有效序列，其余元素一定是有效序列。</p>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="string">""</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c)</span><br><span class="line">                <span class="keyword">for</span> (String left: generateParenthesis(c))</span><br><span class="line">                    <span class="keyword">for</span> (String right: generateParenthesis(n-<span class="number">1</span>-c))</span><br><span class="line">                        ans.add(<span class="string">"("</span> + left + <span class="string">")"</span> + right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的括号</title>
    <url>/2019/09/25/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<p>来源Leetcode第20题有效的括号</p>
<blockquote>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以<strong>正确的顺序</strong>闭合。<br><a id="more"></a><br>注意空字符串可被认为是有效字符串。</p>
<p>示例 1:<br>输入: “()”<br>输出: true</p>
</blockquote>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>这题一看到就知道和表达式匹配里的括号规则一样是要考虑括号的顺序的，方法是用栈来实现，但是由于玩了会魂3(但其实什么也没玩到，灰心哥下次我必在火鸡场杀了你)，导致偷懒直接标记括号数量来匹配，完全忽略了另一个要求正确的顺序，导致AC不了。<br><strong>正确的顺序</strong>这样只能够通过栈来实现了。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 空字符串</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 排除奇数长度(位运算)</span></span><br><span class="line">        <span class="keyword">if</span> ((s.length() &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈元素个数</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 栈</span></span><br><span class="line">        <span class="keyword">char</span>[] stack = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (s.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'['</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&#123;'</span>:</span><br><span class="line">                    <span class="comment">// 进栈</span></span><br><span class="line">                    stack[index++] = s.charAt(i); </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">if</span> (index == <span class="number">0</span> || stack[--index] != <span class="string">'('</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// stack[--index] == '(' ，才会contniue</span></span><br><span class="line">                    <span class="comment">// --index：相当于满足的元素出栈</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">                    <span class="keyword">if</span> (index == <span class="number">0</span> || stack[--index] != <span class="string">'['</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">                    <span class="keyword">if</span> (index == <span class="number">0</span> || stack[--index] != <span class="string">'&#123;'</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index == <span class="number">0</span>; <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>C语言版本：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span> || s[<span class="number">0</span>] == <span class="string">'\0'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">stack</span>[<span class="number">10240</span>]; <span class="keyword">int</span> top =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'('</span> || s[i] == <span class="string">'['</span> || s[i] == <span class="string">'&#123;'</span>) <span class="built_in">stack</span>[top++] = s[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((--top) &lt; <span class="number">0</span>)                      <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//先减减，让top指向栈顶元素</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">')'</span> &amp;&amp; <span class="built_in">stack</span>[top] != <span class="string">'('</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">']'</span> &amp;&amp; <span class="built_in">stack</span>[top] != <span class="string">'['</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'&#125;'</span> &amp;&amp; <span class="built_in">stack</span>[top] != <span class="string">'&#123;'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (top ? <span class="literal">false</span> : <span class="literal">true</span>);<span class="comment">//防止“【”这种类似情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表倒数第N个结点</title>
    <url>/2019/09/25/%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<p>来源于Leetcode第19题删除链表倒数第N个结点</p>
<blockquote>
<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>示例：<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br><a id="more"></a><br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p>
</blockquote>
<p>最常见的思路就是两次遍历，第一次遍历先确定整个链表的长度，第二次遍历找到倒数第N个结点。<br>但是如果采用一次遍历的方法话，就会快很多，使用两个指针p,q，先让指针p前进n步，然后在让p、q同时前进，直到p来到最后一个结点，此时q的下一个结点就是要删除的结点，只需修改q的下一结点即可。<br>但是在提交时遇到了坑，当输入为[1]，1时，会直接超时，查看评论，得知可以直接返回空，具体代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head -&gt; next == <span class="literal">NULL</span>&amp;&amp;n == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">p</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">q</span>= <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p -&gt; next != <span class="literal">NULL</span>)</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        q=q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp  = q -&gt;next;</span><br><span class="line">    q -&gt; next = temp -&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    temp = head;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>四数之和</title>
    <url>/2019/09/24/%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>来源Leetcode第18题四数之和</p>
<blockquote>
<p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。<br>注意：<br>答案中不可以包含重复的四元组。<br><a id="more"></a><br>示例：<br>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。<br>满足要求的四元组集合为：<br>[<br> [-1,  0, 0, 1],<br> [-2, -1, 1, 2],<br> [-2,  0, 0, 2]<br>]</p>
</blockquote>
<p>这题思路其实和之前的三数之和是一样的，但是由于我自己逻辑不够完善，导致了卡在这题很久。<br>同样是采用双指针，先固定2个数，在对剩下2层进行遍历操作检查sum是否和target相等。<br>在最外层遍历时，受到了三数之和这题的影响，判断了第一层if nums[s] &gt; target ,then break;<br>这其实是没有必要的，因为有<strong>负数</strong>的存在，当有负数时，连续几个负数相加会越来越小，从而满足target。<br>其次，在第二层遍历时，同样的，if nums[j] &gt; target,then break;<br>这也是没必要的，原因同上。<br>最后附上完成代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || len &lt; <span class="number">4</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//if(nums[i] &gt; target) break; // 如果当前数字大于target，则4数之和一定大于target，所以结束循环</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">if</span>((nums[i] + nums[i+<span class="number">1</span>] + nums[i+<span class="number">2</span>] + nums[i+<span class="number">3</span>])&gt;target)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>((nums[i]+nums[len-<span class="number">1</span>]+nums[len-<span class="number">2</span>]+nums[len-<span class="number">3</span>])&lt;target)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j&lt;len - <span class="number">2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="keyword">if</span>(j &gt; i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">                <span class="comment">//if(nums[j] &gt; target) break; // 如果当前数字大于target，则4数之和一定大于target，所以结束循环</span></span><br><span class="line">                <span class="comment">//if(nums[i] + nums[j] &gt; target) break;</span></span><br><span class="line">                <span class="keyword">if</span>((nums[i] + nums[j] + nums[len - <span class="number">1</span>] + nums[len - <span class="number">2</span>]) &lt; target) <span class="comment">//最大4个数字组合都小于target，进入下一个数字的循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>((nums[i] + nums[j] + nums[j+<span class="number">1</span>] + nums[j+<span class="number">2</span>])&gt;target)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> L = j+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = len-<span class="number">1</span>;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[L] + nums[R];</span><br><span class="line">                <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i],nums[j],nums[L],nums[R]));</span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[L] == nums[L+<span class="number">1</span>]) L++; <span class="comment">// 去重</span></span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[R] == nums[R-<span class="number">1</span>]) R--; <span class="comment">// 去重</span></span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) </span><br><span class="line">               <span class="keyword">while</span>(L&lt;R&amp;&amp;nums[L]==nums[++L]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) </span><br><span class="line">                <span class="keyword">while</span>(L&lt;R&amp;&amp;nums[R]==nums[--R]);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>电话号码的字母组合</title>
    <url>/2019/09/24/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81/</url>
    <content><![CDATA[<p>来源Leetcode第17题电话号码字母组合</p>
<blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p>示例:<br><a id="more"></a><br>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
</blockquote>
<p>想了一下还是逐个数字生成组合，人后根据生成的组合再组合生成对应的代码但是这样的代码量有点问题，现在明明也做了些题，但是代码、算法意识什么的基本还是没有，唉。</p>
<p>官方题解的描述是一个树，通过回溯穷举所有可能情况来找到所有解的算法，如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。<br>给出如下回溯函数 backtrack(combination, next_digits) ，它将一个目前已经产生的组合 combination 和接下来准备要输入的数字 next_digits 作为参数。<br>如果没有更多的数字需要被输入，那意味着当前的组合已经产生好了。<br>如果还有数字需要被输入：<br>遍历下一个数字所对应的所有映射的字母。<br>将当前的字母添加到组合最后，也就是 combination = combination + letter 。<br>重复这个过程，输入剩下的数字： backtrack(combination + letter, next_digits[1:]) 。</p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  Map&lt;String, String&gt; phone = <span class="keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;</span><br><span class="line">    put(<span class="string">"2"</span>, <span class="string">"abc"</span>);</span><br><span class="line">    put(<span class="string">"3"</span>, <span class="string">"def"</span>);</span><br><span class="line">    put(<span class="string">"4"</span>, <span class="string">"ghi"</span>);</span><br><span class="line">    put(<span class="string">"5"</span>, <span class="string">"jkl"</span>);</span><br><span class="line">    put(<span class="string">"6"</span>, <span class="string">"mno"</span>);</span><br><span class="line">    put(<span class="string">"7"</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">    put(<span class="string">"8"</span>, <span class="string">"tuv"</span>);</span><br><span class="line">    put(<span class="string">"9"</span>, <span class="string">"wxyz"</span>);</span><br><span class="line">  &#125;&#125;;  <span class="comment">//生成哈希图，对应着8个数字按键与字母的组合</span></span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; output = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//返回的List 包含若干个组合字符串</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String combination, String next_digits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有数字需要继续匹配组合了</span></span><br><span class="line">    <span class="keyword">if</span> (next_digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">      output.add(combination);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还有数字要生成对应的字母组合</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 循环遍历地图里当前字母所对应的字符串里的所有字母</span></span><br><span class="line">      String digit = next_digits.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">      String letters = phone.get(digit);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letters.length(); i++) &#123;</span><br><span class="line">        String letter = phone.get(digit).substring(i, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将当前字母加入组合，并且将数字串减1开始下一层的回溯</span></span><br><span class="line">        backtrack(combination + letter, next_digits.substring(<span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits.length() != <span class="number">0</span>)</span><br><span class="line">      backtrack(<span class="string">""</span>, digits);</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>中国古典诗词中的品格与修养</title>
    <url>/2019/09/24/%E4%B8%AD%E5%9B%BD%E5%8F%A4%E5%85%B8%E8%AF%97%E8%AF%8D%E4%B8%AD%E7%9A%84%E5%93%81%E6%A0%BC%E4%B8%8E%E4%BF%AE%E5%85%BB/</url>
    <content><![CDATA[<blockquote>
<p>一种学问总要和人的生命、生活发生关系。        ————顾随</p>
<p>   房兵曹胡马诗<br>               杜甫<br>胡马大宛名，锋棱瘦骨成。<br>竹批双耳峻，风入四蹄轻。<br>所向无空阔，真堪托死生。<br>骁腾有如此，万里可横行。</p>
<p>骥不称其力，称其徳也。        ————《论语》</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>公选课</category>
      </categories>
      <tags>
        <tag>公选课</tag>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>最接近的三数之和</title>
    <url>/2019/09/23/%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>来源Leetcode第16题最接近的三数之和</p>
<blockquote>
<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p>
<a id="more"></a>
</blockquote>
<p>思路与上一题类似，但是我在做题的时候掉进了nums[i] == target这个坑，加之与坤滨一席话，让我久久没有从坑里出来。<br>思路来自题解</p>
<ul>
<li>1.排序</li>
<li>2.在数组 nums 中，进行遍历，每遍历一个值利用其下标k，形成一个固定值 nums[k]<br>两个指针， 左边起点为 left = k + 1 ，右边终点 right = nums.length - 1 处</li>
<li>3.因为数组已经排序，故在 [left, right]区间内，最大值 rangeMax = nums[k] + nums[right] + nums[right - 1],</li>
<li>4.最小值为 rangeMin = nums[k] + nums[left] + nums[left + 1];</li>
<li>5.如果最大值比target还大，或者最小值比target还小，则整个区间就没必要循环下去了。</li>
<li>6.如果不是，就是正常的双指针找法。</li>
<li>7.根据 sum = nums[left] + nums[right] + nums[k] 的结果，判断 sum 与目标 target 的距离，如果更近则更新结果 min</li>
<li>8.同时判断 sum 与 target 的大小关系，因为数组有序，如果 sum > target 则 right—，如果 sum &lt; target 则 right++，如果 sum == target 直接返回结果</li>
</ul>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> result = Integer.MAX_VALUE, left, right, min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; nums.length - <span class="number">2</span>; k++) &#123;</span><br><span class="line">            left = k + <span class="number">1</span>;</span><br><span class="line">            right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 区间[left,right]内,和最小的值</span></span><br><span class="line">            <span class="keyword">int</span> rangeMin = nums[k] + nums[left] + nums[left + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 区间[left,right]内,和最大的值</span></span><br><span class="line">            <span class="keyword">int</span> rangeMax = nums[k] + nums[right] + nums[right - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (rangeMin &gt; target) &#123;</span><br><span class="line">                <span class="comment">// 区间最小值比目标大, 没必要寻找区间其他值的和了</span></span><br><span class="line">                <span class="keyword">if</span> (rangeMin - target &lt; min) &#123;</span><br><span class="line">                    min = rangeMin - target;</span><br><span class="line">                    result = rangeMin;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rangeMax &lt; target) &#123;</span><br><span class="line">                <span class="comment">// 区间最大的值比目标还要小,也没必要寻找区间其他值的和了</span></span><br><span class="line">                <span class="keyword">if</span> (target - rangeMax &lt; min) &#123;</span><br><span class="line">                    min = target - rangeMax;</span><br><span class="line">                    result = rangeMax;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[left] + nums[right] + nums[k];</span><br><span class="line">                    <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (Math.abs(sum - target) &lt; min) &#123;</span><br><span class="line">                        result = sum;</span><br><span class="line">                        min = Math.abs(sum - target);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和</title>
    <url>/2019/09/23/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>来源Leetcode第15题三数之和</p>
<blockquote>
<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。<br>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[<br><a id="more"></a><br> [-1, 0, 1],<br> [-1, -1, 2]<br>]</p>
</blockquote>
<p>简述下思路吧，采用三重循环遍历，但是这样时间复杂度先不提，就实现方式而言，C语言提供的malloc确实可以一直malloc下去，就是空间不是连续的，没有实现，查看解答发现先排序后可以减少很多工作量，排序后将首指针记为i,j=i+1,k=numsSize-1,判断三数之和是否为0，是的话就添加进结果集。</p>
<ul>
<li>如果nums[i]大于0,则三数之和必然无法等于0，结束循环</li>
<li>如果nums[i] == nums[i-1],数字重复,会导致结果重复，跳过</li>
<li>如果sum == 0,nums[j] == nums[j+1],则会导致结果重复，跳过,j++</li>
<li>如果sum == 0,nums[k] == nums[k-1],则会导致重复，跳过，k—</li>
</ul>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || len &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 如果当前数字大于0，则三数之和一定大于0，所以结束循环</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">int</span> L = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = len-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));</span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[L] == nums[L+<span class="number">1</span>]) L++; <span class="comment">// 去重</span></span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[R] == nums[R-<span class="number">1</span>]) R--; <span class="comment">// 去重</span></span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) L++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) R--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统概论</title>
    <url>/2019/09/22/%E7%BB%84%E5%8E%9F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前略"><a href="#前略" class="headerlink" title="前略"></a>前略</h2><h2 id="计算机系统的性能评价"><a href="#计算机系统的性能评价" class="headerlink" title="计算机系统的性能评价"></a>计算机系统的性能评价</h2><ul>
<li>非时间指标<ul>
<li>机器字长</li>
<li>总线宽度</li>
<li>主存容量、存储带宽</li>
<li>CPU内核数</li>
</ul>
</li>
<li>时间指标<ul>
<li>主频、周期、外频、倍频</li>
<li>CPI、IPC</li>
<li>MIPS、MFLOPS</li>
<li>CPU执行时间</li>
</ul>
</li>
</ul>
<h3 id="非时间指标"><a href="#非时间指标" class="headerlink" title="非时间指标"></a>非时间指标</h3><p>机器字长：机器一次能处理的二进制位数</p>
<ul>
<li>由运算器、寄存器的位数决定；</li>
<li>一般与内部寄存器的位数相等；</li>
<li>字长决定数据表示范围与精度；</li>
<li>目前常见的有32位和64位字长。</li>
</ul>
<p>总线宽度：数据总线一次能并行传送的最大信息位数</p>
<ul>
<li>运算器与存储器之间的数据总线位数。</li>
<li>有些计算机内部与外部数据总线宽度不一致：</li>
<li>8086、80286、80386内外数据总线等宽；</li>
<li>Pentium外总线64位，内总线32位（两条32位流水线）</li>
</ul>
<p>主存容量与存储带宽 </p>
<ul>
<li>主存容量：是指一台计算机主存所包含的存储单元总数。</li>
<li>存储带宽： 指单位时间内与主存交换的二进制信息量，单位Byte/s。<br>(影响存储带宽的指标包括数据位宽和数据传输速率)。</li>
</ul>
<h3 id="时间指标"><a href="#时间指标" class="headerlink" title="时间指标"></a>时间指标</h3><ul>
<li>主频f<ul>
<li>CPU工作的时钟频率，与CPU运算能力之间不是唯一的、直接关系；</li>
</ul>
</li>
<li>时钟周期T = 1/f<ul>
<li>计算机中最基本的、最小的时间单位。一个时钟周期CPU仅完成一个最基本的动作；</li>
</ul>
</li>
<li>外频<ul>
<li>系统总线的工作频率，CPU与主板之间同步运行的速度，标准外频66MHz、100MHz、133MHz、200MHz、400MHz</li>
</ul>
</li>
<li>倍频<ul>
<li>主频=外频×倍频 ， Pentium 4 2.4G 主频  2400M = 133M (外频) × 18 (倍频)</li>
<li>调整倍频可以获得较高的主频，486后出现的技术，使得外设低频，CPU高频</li>
</ul>
</li>
</ul>
<p>CPI   (Clock cycles Per Instruction)</p>
<ul>
<li>执行一条指令 (平均) 需要的时钟周期数<ul>
<li>单条指令CPI </li>
<li>一段程序中所有指令的CPI</li>
<li>指令系统CPI<br>CPI = 一段程序中所有指令的时钟周期数之和 / 指令条数       //统计<br>=  程序中各类指令的CPI  *  程序中该类指令的比例           //加权</li>
</ul>
</li>
</ul>
<p>例1 假设一台计算机主频为1GHZ，在其上运行由2105条指令组成的目标代码，程序主要由4类指令组成，他们所占的比例和各自的CPI如下表所示，求程序的CPI和MIPS。<br>|   指令类型    | CPI  | 指令比例 |<br>| :—————-: | :—: | :———: |<br>|  算术和逻辑   |  1   |   60%    |<br>|  Load/Store   |  2   |   18%    |<br>|     转移      |  4   |   12%    |<br>| Cache缺失访存 |  8   |   10%    |</p>
<p>解：    CPI = 1*60% + 2*18% + 4*12% +8*10% = 2.24<br>     MIPS = f/(CPI * 10^6) = 1*10^9/ (2.24 *10^6 ) = 446.4</p>
<p>MFLOPS   (Million Floating-Point Operations Per Second) </p>
<ul>
<li>计算机每秒钟执行浮点操作的次数</li>
<li>MIPS：单位时间内执行的指令条数</li>
<li>MFLOPS = 程序中的浮点运算次数 / (执行时间 * 10^6 ）</li>
<li>MFLOPS (Mega) = 10^6  FLOPS     GFLOPS  (Giga)  = 10^9  FLOPS</li>
<li>TFLOPS   (Tera)  = 10^12  FLOPS    PFLOPS   (Peta)  = 10^15  FLOPS </li>
<li>EFLOPS   (Exa)   = 10^18  FLOPS </li>
</ul>
<p>CPU执行</p>
<ul>
<li>执行一段程序所需的时间<br>( CPU时间 + I/O时间 + 存储访问时间 + 各类排队时延等)</li>
<li>CPU时间 = 程序中所有指令的时钟周期数之和 *  T<pre><code>   =程序中所有指令的时钟周期数之和 / f
</code></pre>CPU 时间  =   CPI  *  指令条数  *  时钟周期<br>CPU 时间  =   指令条数 / (MIPS * 10^6)</li>
</ul>
<p>例1 假设一台计算机主频为1GHZ，在其上运行由2*10^5条指令组成的目标代码，程序主要由4类指令组成，他们所占的比例和各自的CPI如下表所示，求程序的CPI和MIPS，求程序执行时间？<br>| 指令类型      | CPI  | 指令混合比例 |<br>| ——————- | —— | —————— |<br>| 算术和逻辑    | 1    | 60%          |<br>| Load/Store    | 2    | 18%          |<br>| 转移          | 4    | 12%          |<br>| Cache缺失访存 | 8    | 10%          |</p>
<p>CPI = 2.24<br>MIPS =  446.4<br>CPU时间 = 2 *10^5 * CPI / f  = (2 *10^5 * 2.24 / 10^9 ) = 4.48 *10^-4 (秒)<br>CPU时间 =  指令条数/MIPS*10^6 = 2 *10^5  / 446.44*10^6</p>
<p>关键时间指标</p>
<ul>
<li>实际上频率和IPC真正决定CPU性能</li>
<li>CPU性能=IPC × 频率  (MHz时钟速度)<ul>
<li>英特尔提出并被业界广泛认可</li>
</ul>
</li>
</ul>
<h3 id="计算机性能测试"><a href="#计算机性能测试" class="headerlink" title="计算机性能测试"></a>计算机性能测试</h3><ul>
<li>性能测试原理<ul>
<li>计算机中配置了大量传感器和状态寄存器</li>
<li>通过读取相应寄存器的值得到系统运行的状况</li>
<li>通过实际运行测试关键指标获取性能数据</li>
</ul>
</li>
<li>性能测试工具分类<ul>
<li>CPU测试工具</li>
<li>显卡测试工具</li>
<li>磁盘测试工具</li>
<li>内存测试工具 </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共前缀</title>
    <url>/2019/09/18/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<p>来源Leetcode第14题最长公共前缀</p>
<blockquote>
<p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p>
<p>示例 1:<br><a id="more"></a></p>
<p>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”</p>
</blockquote>
<h3 id="列遍历"><a href="#列遍历" class="headerlink" title="列遍历"></a>列遍历</h3><p>先进行列扫描，如果当前列的字符都相等，则进行下一列字符的扫描，直到扫描到不相等的字符。<br>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].length() ; i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; strs.length; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c)</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i);             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="行遍历"><a href="#行遍历" class="headerlink" title="行遍历"></a>行遍历</h3><p>当然也可以横向扫描，找到第一字符串与第二字符串之间的最长公共前缀，记为LCP(1,2)，之后再比较LCP(1,2)与第三个字符串之间的最长公共前缀，以此类推，由于没学Java，代码看的不是很懂。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">   String prefix = strs[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++)</span><br><span class="line">       <span class="keyword">while</span> (strs[i].indexOf(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">           prefix = prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">if</span> (prefix.isEmpty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">       &#125;        </span><br><span class="line">   <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>注意到LCP(S1~Sn) = LCP(LCP(LCP(S1~Sk),LCP(Sk+1~Sn)),因而我们可以将原问题LCP(Si~Sj)分解成LCP(Si~Smid)与LCP(Smid+~Sj),其中mid=i+j/2,用子问题的解构造原问题的解。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;    </span><br><span class="line">        <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span> , strs.length - <span class="number">1</span>);<span class="comment">//初始化,将原问题分解为2个小问题,分别求LCPleft与LCPright</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123; <span class="comment">//左右相等，要么是到了中间，要么是只传入了一个字符串</span></span><br><span class="line">        <span class="keyword">return</span> strs[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">        String lcpLeft =   longestCommonPrefix(strs, l , mid);</span><br><span class="line">        String lcpRight =  longestCommonPrefix(strs, mid + <span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> commonPrefix(lcpLeft, lcpRight); <span class="comment">//求左右两个LCP</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">commonPrefix</span><span class="params">(String left,String right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Math.min(left.length(), right.length());   <span class="comment">//先确定最小字符串长度    </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( left.charAt(i) != right.charAt(i) )</span><br><span class="line">            <span class="keyword">return</span> left.substring(<span class="number">0</span>, i); <span class="comment">//找到的公共前缀</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.substring(<span class="number">0</span>, min); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>整数转罗马数</title>
    <url>/2019/09/17/%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0/</url>
    <content><![CDATA[<p>来源Leetcode第12题整数转罗马数字</p>
<blockquote>
<p>罗马数字包含以下七种字符：I，V，X，L，C，D和M。<br><a id="more"></a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">数值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center">1</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">V</td>
<td style="text-align:center">5</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">10</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">L</td>
<td style="text-align:center">50</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">100</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">500</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">1000</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>例如，罗马数字2写做II，即为两个并列的1。12 写做XII，即为X+II。27写做XXVII,即为XX+V+II。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如4不写做IIII，而是IV。数字1在数字5 的左边，所表示的数等于大数5减小数1得到的数值4 。同样地，数字9 表示为 IX。这个特殊的规则只适用于以下六种情况：<br>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。<br>示例 1:</p>
<p>输入: 3<br>输出: “III”</p>
</blockquote>
<p>根据题意可知罗马数字有如下基数：1，4，5，9，10，40，50，90，100，400，500，900，1000<br>在进行转化时只用将待转换数字减去基数，并在输出的字符串上加上对应的罗马字母，直到当前基数大于剩下的待转换数字，用下一个基数进行转化。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> values[]=&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> reps[]=&#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">13</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(num&gt;=values[i])&#123;</span><br><span class="line">                num -= values[i];</span><br><span class="line">                res += reps[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>盛最多的水</title>
    <url>/2019/09/17/%E7%9B%9B%E6%9C%80%E5%A4%9A%E7%9A%84%E6%B0%B4/</url>
    <content><![CDATA[<p>来源Leetcode第11题盛最多的水</p>
<blockquote>
<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>说明：你不能倾斜容器，且 n 的值至少为 2。<br>示例:</p>
<a id="more"></a>
<p>输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49</p>
</blockquote>
<p>用暴力法遍历时遇到了TLE的问题，重新考虑题目，不妨将两个指针设置在头和尾，取头尾指针中较小的*两指针之间的距离得到其之间的面积，因为面积是以较小的指针高度为准，所以移动较小的指针即可，直到两指针相遇。<br>严谨证明链接：<a href="https://leetcode-cn.com/problems/container-with-most-water/solution/shuang-zhi-zhen-fa-zheng-que-xing-zheng-ming-by-r3/" target="_blank" rel="noopener">双指针法正确性证明</a><br>代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>* height, <span class="keyword">int</span> heightSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = heightSize<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(;start!=end;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(height[start]&lt;height[end])</span><br><span class="line">        &#123;</span><br><span class="line">            temp = (end - start)*(height[start]);</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = (end - start)*(height[end]);</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        maxsize = (maxsize &gt; temp?maxsize:temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式匹配</title>
    <url>/2019/09/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>来源Leetcode第10题正则表达式匹配</p>
<blockquote>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持’.’和’*‘的正则表达式匹配。<br>‘.’匹配任意单个字符<br>‘*‘匹配零个或多个前面的那一个元素<br>所谓匹配，是要<strong> 涵盖整个字符串s</strong>的，而<strong> 不是部分字符串s </strong>。<br><a id="more"></a><br>说明:<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ‘.’和’*‘。<br>示例 4:</p>
<p>输入:<br>s = “aab”<br>p = “c*a*b”<br>输出: true<br>解释: 因为’*‘表示零个或多个，这里’c’为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p>
</blockquote>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>采用递归的思想，当前层匹配了就可以匹配下一层。当遇到字符’.’时可以认为直接匹配进入下一层，当遇到字符’*‘时要考虑字符’*‘前一个字符出现的次数是0次还是多次，所以在递归的时候有两个方向的递归，一个是认为前一个字符出现0次，所以直接从模式串p的第3个字符开始匹配，一个是认为出现多次，因而需要模式串第一个字符与匹配串第一个字符匹配，在来匹配匹配串后续字符。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern.isEmpty()) <span class="keyword">return</span> text.isEmpty();  <span class="comment">//对应空串</span></span><br><span class="line">        <span class="keyword">boolean</span> first_match = (!text.isEmpty() &amp;&amp;</span><br><span class="line">                               (pattern.charAt(<span class="number">0</span>) == text.charAt(<span class="number">0</span>) || pattern.charAt(<span class="number">0</span>) == <span class="string">'.'</span>));  <span class="comment">//非空且第一个字符对应相等，或者p的一个字符为‘.’</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pattern.length() &gt;= <span class="number">2</span> &amp;&amp; pattern.charAt(<span class="number">1</span>) == <span class="string">'*'</span>)&#123; <span class="comment">//p的长度为2 且第二个字符为'*'的话</span></span><br><span class="line">            <span class="keyword">return</span> (isMatch(text, pattern.substring(<span class="number">2</span>)) ||  <span class="comment">//看P第三个字符是否与s的字符匹配，可以参考例4，s=aab,p=c*a*b，因为*表示0个或多个，这里S有0个c，a被重复一次，所以是可以匹配的</span></span><br><span class="line">                    (first_match &amp;&amp; isMatch(text.substring(<span class="number">1</span>), pattern))); <span class="comment">//或者是第一个字符匹配，查看s的后续字符是否重复</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> first_match &amp;&amp; isMatch(text.substring(<span class="number">1</span>), pattern.substring(<span class="number">1</span>)); <span class="comment">//进行下一个字符的匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>可以看到回溯的话时空复杂度相当的高，因为题目拥有最优子结构，一个自然的想法是将中间结果保存起来。我们通过用dp[i,j]表示text[i:]和pattern[j:]是否能匹配，即用户dp[i][j]表示s的前i个能否被p的前j的匹配。<br>考虑转移方程：<br>1.p[j] == s[i] -&gt; dp[i][j] = dp[i-1][j-1]<br>2.if p[j] == ‘.‘ -&gt; dp[i][j] = dp[i-1][j-1]<br>3.if p[j] = ‘*‘ -&gt;<br>if p[j-1] != s[i] -&gt; dp[i][j] = dp[i][j-2]  //对应示例4，’*‘前的字符出现了0次<br>if p[j-1] == s[i] || p[j-1] == ‘.‘ -&gt; dp[i][j] = dp[i-1][j] || dp[i][j] = dp[i][j-1] || dp[i][j] = dp[i][j-2] //分别对应着若干个字符匹配、单个字符匹配、没有字符匹配<br>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> ls = s.length(), lp = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[ls + <span class="number">1</span>][lp + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= lp; j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>] &amp;&amp; p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>;  <span class="comment">//初始化第一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ls; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lp; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>] || dp[i - <span class="number">1</span>][j] &amp;&amp; </span><br><span class="line">                        (s.charAt(i-<span class="number">1</span>) == p.charAt(j - <span class="number">2</span>) || p.charAt(j - <span class="number">2</span>) == <span class="string">'.'</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>) || p.charAt(j-<span class="number">1</span>) == <span class="string">'.'</span>) </span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[ls][lp];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>删除排序数组中的重复项II</title>
    <url>/2019/09/16/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II/</url>
    <content><![CDATA[<p>来源Leetcode第80题删除排序数组中的重复项II</p>
<blockquote>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:<br><a id="more"></a></p>
<p>给定 nums = [1,1,1,2,2,3],<br>函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。<br>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p>第一反应是新建一个表，按顺序记录下排序数组中对应数字出现的次数，但是发现题目要求空间负责度为O(1)，那么则可以简化一下思路，采用两个指针，一个记录当前要修改部位，一个保持向后遍历数组，当有两个连续的数字重复的时候就要进行判断，先保存当前val，然后再复制两个重复的元素，接着指针i开始跳过多余的重复元素即可。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = nums[i];  <span class="comment">//记录当前值</span></span><br><span class="line">            nums[m++] = nums[i++]; <span class="comment">//对数组进行两次操作</span></span><br><span class="line">            nums[m++] = nums[i++];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; nums.length &amp;&amp; nums[i] == val) <span class="comment">//如果2个数之后的数据元素仍与之前相等就跳过</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            nums[m++] = nums[i++];  <span class="comment">//最后两个元素无所谓从不重复，直接复制就完事了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在附上一个评论区比较秀的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">2</span> || n &gt; nums[i-<span class="number">2</span>])</span><br><span class="line">                nums[i++] = n;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>当i<2时，前两项直接复制就好，从第三项开始，如果数组里的n>nums[i-2],说明当前元素和前面复制的不等，拓展开来复制前K个重复的数字就可以把i-2替换成i-K。</2时，前两项直接复制就好，从第三项开始，如果数组里的n></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>回文数</title>
    <url>/2019/09/15/%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<p>来源Leetcode第9题回文数</p>
<blockquote>
<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p>示例 1:</p>
<a id="more"></a>
<p>输入: 121<br>输出: true</p>
</blockquote>
<p>这道题第一眼看到就是直接将数字反转后比对两者是否相等，提交了也过了，但是看了解答后发现需要考虑溢出的问题，如果给定的数字翻转后溢出了那怎么办？但是仔细想想，32位数最大的范围是214748367，也就是说最大的回文数应该是214747412，在10位数范围内，只有尾数是2的情况下，才会需要考虑是否翻转后溢出，翻转后产生溢出，也可以认为这个数不是一个回文数，所以是不是可以认为这样某种程度上限制了测试用例输入的数据，因而不用考虑溢出问题？<br>官方解答的思路未避免溢出，取出整数的后半段将其翻转后比较，翻转则是通过对10取余得到低位数(顺便复习一下），在*10相加。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> bool <span class="title">IsPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; revertedNumber) &#123; <span class="comment">//如果是全部数据翻转则是x!=0</span></span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回文</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串转换成整数</title>
    <url>/2019/09/14/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p>来源Leetcod第8题，字符串转换成整数</p>
<blockquote>
<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。<br>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。<br><a id="more"></a><br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。<br>在任何情况下，若函数不能进行有效的转换时，请返回 0。<br>说明：<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>示例 1:</p>
<p>输入: “   -42”<br>输出: -42</p>
</blockquote>
<p>库函数里有自带atoi函数可以把字符串里的数字转化为整数，但是题目给定的带有其他字符的字符串，非纯数字字符串，因而我们首先要判断第一位是不是字符，如果是返回0，不是则根据是否空格、整数字符继续判断。<br>在转化时，注意到<strong>INT_MAX=2147483647  INT_MIN=-2147483648</strong>，且INT_MIN=-INT_MAX-1，所以在实际转化时最好采用从负数方向开始转化，避免出现溢出。<br>又由于题目要求在32位大小的有符号数内存储，因而在用两个变量记录INT_MIN/10和INT_MIN%10，当要转化的数小于INT_MIN/10且后续还有数字时，说明发生了溢出，这时只需按题意要求返回INT_MIN或者INT_MAX即可；当待转化的数字为INT_MIN/10且后续还有数字时，需要比较下一位是否比INT_MIN%10小，是的话同样溢出。最后按传入符号输出正负值即可。<br>代码如下:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_q = INT_MIN / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> min_r = INT_MIN % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">//记录数字的长度   </span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> negative = <span class="literal">false</span>;<span class="comment">// 出现 '-' 置真</span></span><br><span class="line">        <span class="keyword">int</span> flag_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:str)<span class="comment">//判断 正负号   且数字长度为0  防止 "0-1" 这样的情况 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((c==<span class="string">'+'</span>||c==<span class="string">'-'</span>) &amp;&amp; len==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag_count++;  <span class="comment">//记录符号出现次数 </span></span><br><span class="line">                negative = c==<span class="string">'-'</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">'0'</span>&amp;&amp; c&lt;=<span class="string">'9'</span> &amp;&amp; flag_count&lt;<span class="number">2</span>)<span class="comment">//temp&lt;2 表示 正负号 只出现过一次 </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = <span class="number">-1</span>*<span class="keyword">int</span>(c-<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span>(res&lt;min_q || (res==min_q &amp;&amp; cur&lt;min_r))</span><br><span class="line">                &#123;</span><br><span class="line">					<span class="comment">// INT_MAX=2147483647 	INT_MIN=-2147483648   </span></span><br><span class="line">                    <span class="keyword">return</span> negative?INT_MIN:INT_MAX;</span><br><span class="line">                &#125;</span><br><span class="line">                res = res*<span class="number">10</span> + cur;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">' '</span> &amp;&amp; len==<span class="number">0</span> &amp;&amp; flag_count==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res==INT_MIN &amp;&amp; !negative)</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">return</span> negative?res:<span class="number">-1</span>*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串</title>
    <url>/2019/09/13/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<p>来源Leetcode第五题最长回文子串</p>
<blockquote>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>示例 1：</p>
<p>输入: “babad”<br><a id="more"></a><br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p>
</blockquote>
<p>又是一次常规暴力遍历找到答案，但是在第93个用例时超时了，查看官方解答，采用动态规划。<br>定义p(i,j),如果子串si到sj是回文子串，则p(i,j)为真，否则为假，可得p(i,j)=((p(i+1,j-1) and Si==Sj)。这样如果p(i,i)为真，则p(i,i+1)=(Si+1)。<br>求 长度为 1 和长度为 2 的 P(i,j) 时不能用上边的公式，因为我们代入公式后会遇到 P[i][j]中i &gt;j的情况，比如求 P[1][2]的话，我们需要知道 P[1+1][2-1]=P[2][1]，而P[2][1]代表着S[2,1] 是不是回文串，显然是不对的，所以我们需要单独判断。<br>所以我们先初始化长度是1的回文串的P[i,j]，这样利用上边提出的公式，然后两边向外各扩充一个字符，长度为3的，为5的，所有奇数长度的就都求出来了。<br>同理，初始化长度是2的回文串P[i,i+1]，利用公式，长度为4的，6的所有偶数长度的就都求出来了。<br>时间复杂度：O(n^2)O<br>空间复杂度：O(n^2)，该方法使用 O(n^2)的空间来存储表。<br>附上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] P = <span class="keyword">new</span> <span class="keyword">boolean</span>[length][length];</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    String maxPal = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= length; len++) <span class="comment">//遍历所有的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; length; start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> end = start + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (end &gt;= length) <span class="comment">//下标已经越界，结束本次循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            P[start][end] = (len == <span class="number">1</span> || len == <span class="number">2</span> || P[start + <span class="number">1</span>][end - <span class="number">1</span>]) &amp;&amp; s.charAt(start) == s.charAt(end); <span class="comment">//长度为 1 和 2 的单独判断下</span></span><br><span class="line">            <span class="keyword">if</span> (P[start][end] &amp;&amp; len &gt; maxLen) &#123;</span><br><span class="line">                maxPal = s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> maxPal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样效率还是很低，执行用时:906 ms, 在所有 Java 提交中击败了5.26%的用户，内存消耗:372.5 MB, 在所有 Java 提交中击败了5.00%的用户<br>但是从公式发现是从i+1才知道i，所以我们不妨试着倒着遍历，提供两个版本的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = s.length();</span><br><span class="line">		String res = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">boolean</span>[] P = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= i; j--) &#123;</span><br><span class="line">				P[j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; <span class="number">3</span> || P[j - <span class="number">1</span>]);</span><br><span class="line">				<span class="keyword">if</span> (P[j] &amp;&amp; j - i + <span class="number">1</span> &gt; res.length()) &#123;</span><br><span class="line">					res = s.substring(i,j + <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    String res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]); <span class="comment">//j - i 代表长度减去 1        </span></span><br><span class="line">            <span class="keyword">if</span> (dp[i][j] &amp;&amp;  j - i + <span class="number">1</span> &gt; res.length()) &#123;</span><br><span class="line">                res = s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种思路是拓展中心，回文串一定是对称的，所以在每一次循环中选择一个中心，向左右拓展，判断两边字符是否相等。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i); <span class="comment">//对应奇数回文串中心</span></span><br><span class="line">        <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>); <span class="comment">//对应偶数回文串中心</span></span><br><span class="line">        <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">            start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            end = i + len / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">    <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">        L--;</span><br><span class="line">        R++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>动态规划补充：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s.length() &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">1</span> , maxEnd = <span class="number">0</span>;  <span class="comment">//注意maxLen初始化为1，因为单个字符一定是可以的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> right = <span class="number">1</span> ; right &lt; len ; ++right)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left = <span class="number">0</span> ; left &lt; right ; ++left)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[left] == arr[right] &amp;&amp; (right - left &lt;= <span class="number">2</span> || dp[left+<span class="number">1</span>][right-<span class="number">1</span>]))&#123;</span><br><span class="line">                dp[left][right] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(right - left + <span class="number">1</span> &gt; maxLen)&#123;</span><br><span class="line">                    maxLen = right - left + <span class="number">1</span>;</span><br><span class="line">                    maxEnd = right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(maxEnd - maxLen + <span class="number">1</span> , maxEnd + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一种Manacher’s Algorithm 马拉车算法先挖个坑吧，下次再看。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
        <tag>回文</tag>
        <tag>拓展中心</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找中位数</title>
    <url>/2019/09/12/%E5%AF%BB%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<p>来源：Leetcode第四题寻找两个有序数组的中位数</p>
<blockquote>
<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。<br>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<br>你可以假设 nums1 和 nums2 不会同时为空。<br>示例 1:<br><a id="more"></a></p>
<p>nums1 = [1, 3]<br>nums2 = [2]<br>则中位数是 2.0</p>
</blockquote>
<p>先想到了归并两个数组后在从新的有序数组中找中位数，可是这样的时间复杂度是O(m+n)，不符合题目要求。<br>在查看题解之后知道是要用二分的思想。<br>简单的说，就是同时对两个数组进行切割，使得数组1左边最大<a href="数组2右边最小，数组2左边最大＜数组1右边最小，这样就有中位数是从两个数组左边最大的值和右边最小的值中取出来。
原解答链接：[寻找中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/)
C++代码如下：
&lt;!--￼0--">数组2右边最小，数组2左边最大＜数组1右边最小，这样就有中位数是从两个数组左边最大的值和右边最小的值中取出来。
原解答链接：[寻找中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/)
C++代码如下：
&lt;!--￼0--</a></p>
<p>JAVA</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] A,<span class="keyword">int</span>[] B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = A.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = B.length;</span><br><span class="line">    <span class="keyword">if</span>(len1 &gt; len2)</span><br><span class="line">        <span class="keyword">return</span> find(B,A);</span><br><span class="line">    <span class="keyword">int</span> iMin = <span class="number">0</span> , iMax = len1, mid = (len1 + len2 + <span class="number">1</span>) / <span class="number">2</span>;  <span class="comment">//对数组划分 mid为两个数组的中间位置</span></span><br><span class="line">    <span class="comment">//imin imax 为 数组A的搜索范围，进而影响到数组B</span></span><br><span class="line">    <span class="keyword">while</span> (iMin &lt; iMax)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = (iMax + iMin) / <span class="number">2</span>;  <span class="comment">//数组A的中间值</span></span><br><span class="line">        <span class="keyword">int</span> j = mid - i;  <span class="comment">//倒推出数组B的中间值</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; iMax &amp;&amp; A[i] &lt; B[j-<span class="number">1</span>])  <span class="comment">//A的右边最小小了需要扩大搜索范围</span></span><br><span class="line">            iMin = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; iMin &amp;&amp; B[j] &lt; A[i - <span class="number">1</span>])  <span class="comment">//B的右边最大小了减小搜索范围</span></span><br><span class="line">            iMax = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;  <span class="comment">//找到期望值</span></span><br><span class="line">            <span class="keyword">int</span> maxLeft = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)  <span class="comment">//特殊情况 判断是否是端点</span></span><br><span class="line">                maxLeft = B[j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                maxLeft = A[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> maxLeft = Math.max(A[i-<span class="number">1</span>],B[j-<span class="number">1</span>]);  <span class="comment">//否则取左边最大</span></span><br><span class="line">            <span class="keyword">if</span>((len1 + len2) % <span class="number">2</span> == <span class="number">1</span>)  <span class="comment">//数组长度为奇数，直接返回</span></span><br><span class="line">                <span class="keyword">return</span> maxLeft;</span><br><span class="line">            <span class="keyword">int</span> minRight = <span class="number">0</span>;  <span class="comment">//偶数，需要求出右边最小</span></span><br><span class="line">            <span class="keyword">if</span>(i == len1)  <span class="comment">//特殊情况</span></span><br><span class="line">                minRight = B[j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == len2)</span><br><span class="line">                minRight = A[i];</span><br><span class="line">            <span class="keyword">else</span> minRight = Math.min(B[j],A[i]);</span><br><span class="line">            <span class="keyword">return</span> (minRight + maxLeft) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">00.00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>无重复字符的最长子串</title>
    <url>/2019/09/11/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>来源：Leetcode第三题无重复字符的最长子串</p>
<blockquote>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<a id="more"></a>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
</blockquote>
<p>同第一题一样习惯了暴力遍历，没有对时空复杂度上做过多的优化，官方解答没多少是C的，于是先找到了一个个人认为还不错的C的解答。<br>思路：同样是两层遍历，但是如果当剩下要遍历字符串的长度小于已求出的最长无重复子串时就没必要继续遍历了，其次，在内层循环遍历时，如果前面几位都不包含当前字符，则继续遍历，如果包含，就退出循环，计算下一个子串，采用的是滑动窗口的思想，遇到重复，左边i持续向右，直到不在重复，右边j再继续遍历字符串。C语言代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 字符串s前len位是否包含字符c</span></span><br><span class="line"><span class="comment">* return 0：不包含 1：包含</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">contains</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> c, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[i] != <span class="literal">NULL</span> &amp;&amp; i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == c)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">char</span>* s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果从i位开始的字符串到末尾的长度小于最大字符串的长度，则不需要继续计算</span></span><br><span class="line">    <span class="keyword">while</span>(s[i] != <span class="literal">NULL</span> &amp;&amp; (len - i &gt; maxLen)) &#123;</span><br><span class="line">        <span class="keyword">while</span>(s[j] != <span class="literal">NULL</span> &amp;&amp; (contains( &amp;s[i], s[j], j - i) == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 遍历子串，如果前面几位都不包含当前的字符，则继续遍历；如果包含，则退出循环，计算下一个子串</span></span><br><span class="line">            <span class="comment">// 如果之前计算过的子串，则不继续计算</span></span><br><span class="line">            <span class="comment">// 例如，abcdabcd，当计算以首位开始的子串最长长度为abcd的字符串，因为bcd是abcd的子串，则不需要重复计算</span></span><br><span class="line">            <span class="comment">// 计算以b开头的子串时，直接判断上一次遍历j=4，即a是否属于bcd</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j - i &gt; maxLen) &#123;</span><br><span class="line">            maxLen = j - i;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>官方解答有滑动窗口的进一步优化：</p>
<blockquote>
<p>上述的方法最多需要执行 2n 个步骤。事实上，它可以被进一步优化为仅需要 n 个步骤。我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。<br>也就是说，如果 s[j]在 [i, j)范围内有与 j’重复的字符，我们不需要逐渐增加i。我们可以直接跳过 [i，j’]范围内的所有元素，并将i变为j’ + 1。</p>
</blockquote>
<p>但是为什么按照官方优化的方法，将左指针改成了j’ + 1之后反而在Leetcode上的运行时间会增加了呢？</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>思辨与创新</title>
    <url>/2019/09/11/%E6%80%9D%E8%BE%A8%E4%B8%8E%E5%88%9B%E6%96%B0/</url>
    <content><![CDATA[<h2 id="提出问题：如何提出一个新的、好的问题"><a href="#提出问题：如何提出一个新的、好的问题" class="headerlink" title="提出问题：如何提出一个新的、好的问题"></a>提出问题：如何提出一个新的、好的问题</h2><h3 id="才大：交叉学科与多元阅历"><a href="#才大：交叉学科与多元阅历" class="headerlink" title="才大：交叉学科与多元阅历"></a>才大：交叉学科与多元阅历</h3><p>不规格自己，让不同的营养成为自己思考问题，乃至精神成长的储备。</p>
<p>真正的智慧，来自于观念的彼此通接。</p>
<p>不要把自己局限在一个专业学科里,think ouf of the box</p>
<a id="more"></a>
<blockquote>
<p>志于道，据于徳，依于仁，游于艺<br>君子不器</p>
</blockquote>
<p>处于结构洞(structure hole)的位置</p>
<p>走出自己专业，更多强调人文，更多强调通识</p>
<p>所谓的才大，并不是一个简单的功课，需要你持续的跨越山峰，需要你持续的游走边界，需要你有足够的耐心，去接受不仅仅是资讯是多元的知识。</p>
<p>重视通识教育和人文教育</p>
<p>现实生活中所谓的利益是分流的，不用的阶层有他们不用的利益</p>
<p>推荐阅读：</p>
<blockquote>
<p>TED演讲：好想法从哪里来？<br>论文 苏力：”《秋菊打官司》的官司、邱式鼠药案和言论自由“<br>论文 吴国胜：”从求真的科学到求力的科学“<br><a href="http://matt.might.net/articles/phd-school-in-pictures/" target="_blank" rel="noopener">PHD的历程</a></p>
</blockquote>
<h3 id="心细：让思维细如柳叶"><a href="#心细：让思维细如柳叶" class="headerlink" title="心细：让思维细如柳叶"></a>心细：让思维细如柳叶</h3><p>心细：sensitive</p>
<p>心细是说一个人足够的敏感，足够的觉知，他所身处的世界，他会认为即使是在一个有足够熟悉的环境所构成的外部语境中，他仍然能够发现这其中的好奇，仍然能够发现问题的间隙，仍然愿意投注感情和投注精力去提问，这就是叫心细。</p>
<p>心细就是对外部世界永远保持探究和追问的好奇。</p>
<p>单次博弈容易发生欺骗，类似于旅游景点的商铺，车船店脚牙</p>
<p>什么是一个好的问题？</p>
<p><img src="/2019/09/11/思辨与创新/morris清单.jpg" alt="Morris清单"></p>
<p>应无所住，而生其心(住：停留和牵绊)</p>
<p>才大跟心细是获得新知的两个观念的基础，才大是让自己变得开放和广博，心细这必须在其中有你真诚的愿望，愿意投入，有感情有好奇，有智识上的欢喜。</p>
<h3 id="一些增进创造力的方法"><a href="#一些增进创造力的方法" class="headerlink" title="一些增进创造力的方法"></a>一些增进创造力的方法</h3><h4 id="活化的否定-gt-我们有可能通过否定完成建构"><a href="#活化的否定-gt-我们有可能通过否定完成建构" class="headerlink" title="活化的否定 -&gt; 我们有可能通过否定完成建构"></a>活化的否定 -&gt; 我们有可能通过否定完成建构</h4><p>活化的否定是最后走向的是一个有创意的节点，他并不是把这件事情彻底否定掉，而是通过否定一些在我们的既有认知结构中，依然根深蒂固的所谓的必备条件，从而激发我们重新的想象力。</p>
<p>重新think out of the box</p>
<h4 id="Enlarge-the-pie"><a href="#Enlarge-the-pie" class="headerlink" title="Enlarge the pie"></a>Enlarge the pie</h4><p>让这个盘里有更多可以分配，可以组合，可以调试的资源</p>
<p>从更多的利益角度方面组接出一些新的package，以致于让对方有一些让步，而不是单单局限于某一利益角度(好比例子时的薪资讨价还价)</p>
<p>有足够大的pie，可以重新调整，重新分配资源，更好的negotiation</p>
<blockquote>
<p>有的时候所谓的创意，是用更正确的方法，了解到更全面的资讯。</p>
</blockquote>
<h4 id="头脑风暴"><a href="#头脑风暴" class="headerlink" title="头脑风暴"></a>头脑风暴</h4><p>在所有的头脑风暴中，都必须要有一个基本的合适的对话场域。</p>
<p>有效的头脑风暴，必须是我们足够的平等，同时又足够平权。</p>
<blockquote>
<p>当我们需要创意的时候，我们要把创意的过程和决定的过程分开<br>                         —form William Ury 《Getting to yes》</p>
</blockquote>
<p>否则会产生不必要的干扰</p>
<p>没有平权，忍不住对那些所谓的不好的观念的那种批评，那种压抑，那种鞭斥，你就不可能有足够的耐心等到真正的好的idea，扎根在这些混战idea的土壤中，而最终开出灿烂之花。</p>
<h4 id="培育创新的急智：Yes-and"><a href="#培育创新的急智：Yes-and" class="headerlink" title="培育创新的急智：Yes and"></a>培育创新的急智：Yes and</h4><p>创意是一种习惯：即兴戏剧</p>
<p>Yes but，no 让创意停顿下来 Yes and 保留idea的火种，让他变成火炬甚至燎原</p>
<p>所谓的创意是一种日常积累而变成的思维方式乃至心智模式</p>
<p>推荐阅读</p>
<blockquote>
<p>采铜：《精进：如何成为一个厉害的人》第二章“寻找心中的巴拿马：如何做出比好更好的选择<br>即兴戏剧演讲：逢场作个戏-沈飞<br>《谈判力》第四章”为了共同利益创造选择方案“ (即Getting to yes)</p>
</blockquote>
<h3 id="系统-立体-学习观"><a href="#系统-立体-学习观" class="headerlink" title="系统(立体)学习观"></a>系统(立体)学习观</h3><p>从学而时习之到不知不愠(习：练习，实践)</p>
<p>一个人最重要的学习是夜深人静，向自我的追问和反思，从书本和老师那完成知识的传递，在朋友和同学那完成知识的参照最后把知识留给自己，沉淀为心底的反思。</p>
<h2 id="展开论证：如何让自己的想法被证明"><a href="#展开论证：如何让自己的想法被证明" class="headerlink" title="展开论证：如何让自己的想法被证明"></a>展开论证：如何让自己的想法被证明</h2><h3 id="区分一些事"><a href="#区分一些事" class="headerlink" title="区分一些事"></a>区分一些事</h3><h4 id="论证需要明确的议题"><a href="#论证需要明确的议题" class="headerlink" title="论证需要明确的议题"></a>论证需要明确的议题</h4><blockquote>
<p>任何人的一个观点，当得到表达得到证明的时候，我们一定要分清什么是鱼骨、鱼骸，什么是鱼肉，也就是外面丰满的部分</p>
</blockquote>
<p>观点真正的内核————明确的议题</p>
<p>我在面对的是什么一个议题？</p>
<ul>
<li>结论一：论证需要有明确的议题</li>
</ul>
<h4 id="论证要有立场-态度"><a href="#论证要有立场-态度" class="headerlink" title="论证要有立场(态度)"></a>论证要有立场(态度)</h4><p>真正的问题不是讨论的不够，而是讨论的太多</p>
<p>你能不能用一句话明确的阐明你的观点</p>
<ul>
<li>结论二：论证必须要有一个清晰的议题，同时在这个具体的议题上，要有一个明确的态度，或者立场。</li>
</ul>
<h4 id="推测性的解释不是论证"><a href="#推测性的解释不是论证" class="headerlink" title="推测性的解释不是论证"></a>推测性的解释不是论证</h4><blockquote>
<p>什么是论证？</p>
<p>论证不仅仅是一个逻辑可能性的堆叠，而必须要让他照进现实，让他对照理论才有可能为证。</p>
<p>你讲的这一切都只是逻辑上，看上去对的假说，它跟现实不一样。                              ————科斯</p>
</blockquote>
<p><strong>区分两件事</strong></p>
<ul>
<li>1.Hypothesis 假说：逻辑上的可能性 (纯粹在观念上存在这样的一种可能性)</li>
<li>2.Argument   论证：现实中的有效性 (证明一定要和经验相符合，一定要能够落到实践当中)</li>
</ul>
<p><strong>有效证明的条件</strong></p>
<ul>
<li>1.逻辑自洽</li>
<li><p>2.前提为真</p>
</li>
<li><p>结论三：假说或者推测性的解释，并不是论证。</p>
</li>
</ul>
<h4 id="无效的论证-错误的论证"><a href="#无效的论证-错误的论证" class="headerlink" title="无效的论证 != 错误的论证"></a>无效的论证 != 错误的论证</h4><p>无效的论证：论证的内部逻辑和阐述体系中有瑕疵，但仍可能是现实相符合</p>
<p>错误的论证：和现实不符合<br>逻辑上正确 <strong>并不证明</strong> 事实上正确<br>逻辑上错误 <strong>并不证明</strong> 事实上错误</p>
<ul>
<li>结论四：无效的论证 != 错误的论证</li>
</ul>
<h3 id="诉诸权威"><a href="#诉诸权威" class="headerlink" title="诉诸权威"></a>诉诸权威</h3><h4 id="诉诸权威的念"><a href="#诉诸权威的念" class="headerlink" title="诉诸权威的念"></a>诉诸权威的念</h4><p>问题不会自我证明</p>
<blockquote>
<ul>
<li>个人经验</li>
<li>未公开的传闻</li>
<li>公开的报导</li>
<li>目击者的证言</li>
<li>名人名言</li>
<li>专家意见</li>
<li>实验</li>
<li>实验</li>
<li>统计资料</li>
<li>调查</li>
<li>正规观察</li>
<li>研究评述</li>
</ul>
</blockquote>
<p>即</p>
<blockquote>
<ul>
<li>诉诸权威 (不能断章取义)</li>
<li>诉诸经验</li>
<li>诉诸叙事</li>
</ul>
</blockquote>
<h4 id="还原权威的脉络和质地"><a href="#还原权威的脉络和质地" class="headerlink" title="还原权威的脉络和质地"></a>还原权威的脉络和质地</h4><p><strong>怎么样去保证，论证前提为真</strong></p>
<blockquote>
<p>I think, therefore I am.                                 —笛卡尔</p>
</blockquote>
<p>一件事该当不该当？</p>
<blockquote>
<ul>
<li>第一个维度：超验的神(飘忽不可知的天意，或者过往的古典传统)</li>
<li>第二个维度：理性的人(凭借人的理性去思考)</li>
<li>第三个维度：物质的算计、力量的博弈(关键看现实)</li>
</ul>
<p>为最大多数人能够创造最大多数的福利，这件事就是正义。                    —边沁</p>
<p>我们做判断的基础，仍然是理性。    康德</p>
<p>一件事情应该做还是不应该做，应该符合三个原则。                        —康德</p>
<ul>
<li>人的个体行为，成为普遍的立法</li>
<li>永远服从你的理性，即永远被你的理性支配，而不是受你的感性影响。</li>
<li>把人永远当目的而不是手段</li>
</ul>
</blockquote>
<p>诉诸不同的权威，会出现完全不一样的结果。<br>因而我们需要对权威，有全面的准确地理解。</p>
<p><a href="https://wenku.baidu.com/view/da6178104431b90d6c85c778.html" target="_blank" rel="noopener">康德道德哲学三原则</a></p>
<h4 id="权威的限度"><a href="#权威的限度" class="headerlink" title="权威的限度"></a>权威的限度</h4><ul>
<li>权威一定会遭遇时间和空间的挑战。</li>
</ul>
<p>那个曾经如何能够有效的解释当下的我们？那个彼地如何有效的解释当下的此地？</p>
<p>真正的指挥和真实，来自自下而上的草根的力量。</p>
<h3 id="诉诸经验"><a href="#诉诸经验" class="headerlink" title="诉诸经验"></a>诉诸经验</h3><h4 id="定性的经验VS定量的检验"><a href="#定性的经验VS定量的检验" class="headerlink" title="定性的经验VS定量的检验"></a>定性的经验VS定量的检验</h4><ul>
<li>诉诸一个个体的经验</li>
<li>诉诸大样本的经验</li>
</ul>
<blockquote>
<p>定性的经验：<br>他是相对个体的，相对情境的，我们获得个体性经验的方式，往往是坐下来能够跟我们想要了解的对象完成访谈。</p>
<p>定量的经验：<br>采取的样本相对较多，我们是用统计的方式，获得数据而反应现实。</p>
</blockquote>
<p>定量研究背后的意识形态:相信数字才是真实。运用数据的目标是控制。<br>定量研究的背后实际上是把数字和真相，合二为一，认为他们本质上是重叠的。</p>
<p>定性研究背后潜藏的方法论的预设，是每一个人的生命都永垂不朽。</p>
<p>田野调查</p>
<blockquote>
<p>同吃同住同劳动(定性)</p>
</blockquote>
<p>如果我们适用的方法是想普及更多的人，形成普泛的政策，我们必须要采用的是<strong>定量</strong>的方法，更多的数据，更多的数据分析和整合。</p>
<p>想深入到问题的机理当中，去了解为什么会这样？什么要素造就了此时此地的你，形成了你的判断时？我们可以采用<strong>定性</strong>的方法，也就会访谈和田野调查。</p>
<blockquote>
<p>方法：技巧、文案、步骤、流程<br>方法论：方法背后所隐含的方法为何可操作的意识形态</p>
</blockquote>
<h4 id="经验的限度"><a href="#经验的限度" class="headerlink" title="经验的限度"></a>经验的限度</h4><p>诉诸定性经验<br>诉诸定量数据</p>
<pre><code>定性的更强调个体自由，定量的更强调本质控制，而所有的数据都会面临时间和空间的挑战。

但是想让数据解释所有人，不可能的。
</code></pre><h3 id="诉诸叙事"><a href="#诉诸叙事" class="headerlink" title="诉诸叙事"></a>诉诸叙事</h3><h4 id="主观证明与客观证明"><a href="#主观证明与客观证明" class="headerlink" title="主观证明与客观证明"></a>主观证明与客观证明</h4><blockquote>
<p>诉诸叙事：当我们证明一件事情的时候，它不是一个客观的证明，就不是一个逻辑的证明。</p>
</blockquote>
<p>主观上是对的：我所说的这一切，能够说(shuo)服你，或者说(shui)服你。重要的是你被我影响。</p>
<p>主观证明关心的是观念和说服。有效的实现观念的传递跟说服的达成。</p>
<h4 id="说服要素"><a href="#说服要素" class="headerlink" title="说服要素"></a>说服要素</h4><blockquote>
<p>六个要素影响我们是不是被说服或者被别人影响：权威、从众、互惠、稀缺、喜好、一致</p>
</blockquote>
<p>施惠越明显，回馈越直接。</p>
<p>产生喜好的一个常见方法：找到共同点</p>
<p>说服研究的就是怎么样让我的观念，能够有效的通畅的影响到你。</p>
<h4 id="叙事的要素"><a href="#叙事的要素" class="headerlink" title="叙事的要素"></a>叙事的要素</h4><blockquote>
<p>有效的信息投射和信息黏着。</p>
</blockquote>
<p>有效的叙事包含四个要素</p>
<ul>
<li>细腻如绢帛之画</li>
<li>悬念如浩转之思</li>
<li>裹卷如身临其境</li>
<li>情绪如山溪涌流</li>
</ul>
<p>分别对应着<strong>画面</strong>、<strong>悬念</strong>、<strong>角色</strong>、<strong>情绪</strong></p>
<blockquote>
<p>《为时代发声》  ——熊浩 《我是演说家》</p>
<p>饱食终日，无所用心，难矣哉！</p>
</blockquote>
<p>自我成长和灵魂的抱负<br>重新捡拾起阅读的习惯,求学的兴致</p>
<p>对情绪的呼唤、渲染<br>一旦回来，你重新平复你的情绪，把自己变成一个机器人，而不是感性人去评价认知和接受这个讯息的时候，它的力量当然就衰竭。</p>
<p>推荐阅读：</p>
<ul>
<li>《新卖桔者言》 张五常 “一、旧《卖桔》原文”</li>
<li>黄执忠：你如何听懂我的话</li>
<li>熊浩：知乎 如何从心理学的角度解释黄执中进行结辩的时候说服力是那么的大</li>
<li>文森特·鲁吉罗 《超越感觉》 第六章、第七章</li>
</ul>
<h2 id="发起质疑：如何让别人的想法被撼动"><a href="#发起质疑：如何让别人的想法被撼动" class="headerlink" title="发起质疑：如何让别人的想法被撼动"></a>发起质疑：如何让别人的想法被撼动</h2><h3 id="思辨的意义"><a href="#思辨的意义" class="headerlink" title="思辨的意义"></a>思辨的意义</h3><h4 id="辩论的价值"><a href="#辩论的价值" class="headerlink" title="辩论的价值"></a>辩论的价值</h4><p>锻炼口才<br>培养协同<br>促发急智</p>
<blockquote>
<p>武大与新加坡国立大学03年辩论赛 以成败论英雄</p>
</blockquote>
<h4 id="思辨的意义-1"><a href="#思辨的意义-1" class="headerlink" title="思辨的意义"></a>思辨的意义</h4><ul>
<li>优化决策<br>当观点得以被交互的时候，其实我们相互之间得到了检查，得到了攻防，得到了提升。而这种竞争的态势，可以让我们的决策被得以优化。<br>他对我们的思质、认知、想法乃至人格和意义世界所有可能产生的帮助。</li>
</ul>
<p><strong>Think differently</strong></p>
<p>思辨的功能最后是落实再拓展你的意义的可能性，和想象力的边界。</p>
<p>产生新的观念：让想象力夺权</p>
<ul>
<li>激发求知 拓展意义的边界</li>
<li>拓展意义</li>
<li>慈悲人格</li>
</ul>
<p>思辨有观点的交锋，有立场的挪移<br>有立和破的对抗，有正和反的较量<br>有质疑 有证成</p>
<h3 id="当我们反对和质疑"><a href="#当我们反对和质疑" class="headerlink" title="当我们反对和质疑"></a>当我们反对和质疑</h3><h4 id="动摇论证"><a href="#动摇论证" class="headerlink" title="动摇论证"></a>动摇论证</h4><p>质疑分为三个层次：</p>
<ul>
<li>动摇观点</li>
<li>动摇人</li>
<li>动摇对方的哲学根基</li>
</ul>
<p>反驳的三种方式：</p>
<ul>
<li>A未必造成B        -&gt;        检查逻辑</li>
<li>没有A也有B        -&gt;        检查事实</li>
<li>B不重要            -&gt;        提供观点</li>
</ul>
<h4 id="动摇人"><a href="#动摇人" class="headerlink" title="动摇人"></a>动摇人</h4><p>质疑可信度</p>
<blockquote>
<p>不要因为客观论证的成功，或者是失败。而影响你对一个人的主观判断，同样不要因为你对一个人的主观判断，而影响你对客观证明的成功还是失败的判断。</p>
<p>把主观证明和客观证明有效区分是让逻辑归逻辑，让喜好归喜好，不要让你的喜好影响你的判断。</p>
</blockquote>
<h4 id="动摇哲学根基"><a href="#动摇哲学根基" class="headerlink" title="动摇哲学根基"></a>动摇哲学根基</h4><p>哲学的前提：逻辑或者意识形态的假设</p>
<p>数据哲学包含的三个维度：</p>
<ul>
<li>第一个维度：告诉统计量，不要以偏概全</li>
<li>第二个维度：时间当中数据的变化趋势，避免误导性判断</li>
<li>第三个判断： 问人的惰性、人的本性时，这样的问题不要问（永远无法获得相反的答案）</li>
</ul>
<p>哲学之基：用数的方式、平均数的方式了解世界。</p>
<p>反驳：数据可以被发现，但数据没有价值。</p>
<p>思辨：破与立的交织，破：反对和质疑，立：论证</p>
<p>TODO : </p>
<ul>
<li>以成败论英雄是否可取 2001年 </li>
<li>《人类学关键词》 第一章</li>
</ul>
<h2 id="磨砺自我：批判思维的演练和沉淀"><a href="#磨砺自我：批判思维的演练和沉淀" class="headerlink" title="磨砺自我：批判思维的演练和沉淀"></a>磨砺自我：批判思维的演练和沉淀</h2><h3 id="批判思维的一般观念"><a href="#批判思维的一般观念" class="headerlink" title="批判思维的一般观念"></a>批判思维的一般观念</h3><h4 id="什么是批判思维，什么不是？"><a href="#什么是批判思维，什么不是？" class="headerlink" title="什么是批判思维，什么不是？"></a>什么是批判思维，什么不是？</h4><p>批判性思维：客观的分析和评价一个问题，并形成一个判断，合理的、反思性的思维，其目的在于决定我们的信念和行动。</p>
<p>4个动作：</p>
<ul>
<li>检视：问题的基本假设</li>
<li>辨明：事实和逻辑</li>
<li>洞察：背景和语境</li>
<li>创造：开拓新的想象的可能</li>
</ul>
<p>批判性思维不是简单的否定。<br>本质：磨砺思维方法和智慧水准的一种技术<br>目的：不盲从于一个文本；是让我们不再第一时间做简单的表态和接受，是让我们走到这个这个论证题型内部去。</p>
<h4 id="批判思维的心智状态"><a href="#批判思维的心智状态" class="headerlink" title="批判思维的心智状态"></a>批判思维的心智状态</h4><p>4个标准：</p>
<ul>
<li>第一：把你对任何人一题或情绪的第一反应堪称是尝试性的。</li>
<li>第二：判断你为什么会做出这种反应。</li>
<li>第三：考虑你有可能对这个人、这个议题和这个情绪所作出其他反应的可能性。</li>
<li>第四：询问你自己是否还有比你的第一反应更恰当的反应。</li>
</ul>
<p>不确定，不急于确定，待证实，可求证，进一步去验证。</p>
<blockquote>
<p>当我们和新的观念遭遇，当我们触摸到新的问题的时候，Do not judge！不要快速做判断，请放慢你的断言，去更深入的了解，去等待更多的资讯。</p>
</blockquote>
<p>框定思维，进入批判性思维的心智状态中。<br><img src="/2019/09/11/思辨与创新/11.jpg" alt="Do not judge"></p>
<p><strong>聆听</strong></p>
<ul>
<li>收敛自己的固执</li>
<li>克制自己的偏见</li>
<li>放弃自上而下的自以为是</li>
<li>把对方的生命看成跟我一模一样的(平等)</li>
</ul>
<h4 id="不确定的意义"><a href="#不确定的意义" class="headerlink" title="不确定的意义"></a>不确定的意义</h4><p>人和物的差距：人具有不确定性，因为人有自由意志，自由就是不确定性。</p>
<p>存在主义：存在主义就是人因为有自由的意志，因为可以做自由的选择，从而获得了某种生命的不确定性，而这个不确定性把你这个人，活生生的生命个体和那些僵死的事物区别开来的最重要原因。</p>
<p>杜尚《泉》 重新定义艺术</p>
<p>拓展自由、意义的边界</p>
<blockquote>
<p>不确定性意味着自由，意味着选择，当然也同时意味着我们面对更多选择时应当承担的某种心灵代价，那就是慌张和茫然。</p>
</blockquote>
<h4 id="用批判思维学习理解历程"><a href="#用批判思维学习理解历程" class="headerlink" title="用批判思维学习理解历程"></a>用批判思维学习理解历程</h4><p>博学、审问、慎思、明辨、笃行</p>
<p>海绵式学习、淘金式学习</p>
<p>淘金式学习：</p>
<ul>
<li>具有问题意识</li>
<li>学习者的主体性</li>
<li>吸收-选择-对话-建构</li>
</ul>
<p>淘金：具有主体性，主动去选择，去判断，去对话，从而提高知识的吸收效率以及提升知识的记忆水平。</p>
<p>知识是自由选择的结果，是不确定性的拥抱。</p>
<h4 id="读书这件事"><a href="#读书这件事" class="headerlink" title="读书这件事"></a>读书这件事</h4><p>读书本身是必须要做的，没有任何一本书可以改变一个人的生命，但读书这件事本身可以改变。</p>
<ul>
<li>书不一定要读完。</li>
<li>书不一定要读完。</li>
</ul>
<p>阅读的方法是批判性的精神，以及去养育阅读的习惯，而不是去寻找所谓的一本能够改变你命运的书。没有那本书能够改变你的命运自由阅读的习惯本身能改变你的命运。</p>
<p>阅读本身和阅读兴趣的培养和维系</p>
<h3 id="批判思维的演练"><a href="#批判思维的演练" class="headerlink" title="批判思维的演练"></a>批判思维的演练</h3><h4 id="示例一：谈判是科学还是技艺？"><a href="#示例一：谈判是科学还是技艺？" class="headerlink" title="示例一：谈判是科学还是技艺？"></a>示例一：谈判是科学还是技艺？</h4><p>《谈判力》  getting to yes</p>
<p>批判性阅读4阶段：</p>
<ul>
<li>提炼、质询、深研、汇通</li>
</ul>
<p>批判性阅读，有自己的选择和判断</p>
<p>见文字有大小。</p>
<p>连字带空白一起读。</p>
<p>开放性问题</p>
<p>Anything else？ 横向的提问，想了解的更全面<br>纵向的提问，想了解的更深，更通</p>
<blockquote>
<p>谈判方法：根据事情是是非曲直寻找解决方案</p>
<p>和其光同其尘，和光同尘</p>
<p>君子如玉,方而不割,廉而不刿,直而不肆,光而不耀</p>
</blockquote>
<p>科学是整理过的知识，而智慧是整理过的人生。</p>
<h4 id="批判阅读-平拖车风波"><a href="#批判阅读-平拖车风波" class="headerlink" title="批判阅读-平拖车风波"></a>批判阅读-平拖车风波</h4><p>假设人的生命和健康有价值</p>
<h3 id="批判思维与真实价值的分歧"><a href="#批判思维与真实价值的分歧" class="headerlink" title="批判思维与真实价值的分歧"></a>批判思维与真实价值的分歧</h3><h4 id="批判思维与分歧-语境"><a href="#批判思维与分歧-语境" class="headerlink" title="批判思维与分歧 语境"></a>批判思维与分歧 语境</h4><p>洞察事情的背景和语境</p>
<p>经验、立场、利益等导致的不客观的思考</p>
<h4 id="批判思维与同情理解与自我反思"><a href="#批判思维与同情理解与自我反思" class="headerlink" title="批判思维与同情理解与自我反思"></a>批判思维与同情理解与自我反思</h4><p>人和人之所以发生冲突，每个人都有局限</p>
<p>冲突的解决是在于我们有没有这种意志，走出我自己狭小的这个城池</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>公选课</category>
      </categories>
      <tags>
        <tag>公选课</tag>
        <tag>思辨与创新</tag>
      </tags>
  </entry>
  <entry>
    <title>C的HASH表</title>
    <url>/2019/09/10/C%E7%9A%84HASH%E8%A1%A8/</url>
    <content><![CDATA[<p>来源：Leetcode第一题两数之和</p>
<blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:<br><a id="more"></a><br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
</blockquote>
<h3 id="建立哈希表"><a href="#建立哈希表" class="headerlink" title="建立哈希表"></a>建立哈希表</h3><p>常规思路是暴力求解，但是这样的时间复杂度是O(n^2)，而利用哈希表进行迭代将元素插入到表中的同时，并且回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回，这可以将时间复杂度降至O(n)，但是也占用了O(n)的空间复杂度。C语言代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* hash map method */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash_data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="comment">// int data;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash_table</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash_data</span>* <span class="title">element</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>* nums;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_init</span><span class="params">(struct hash_table* table, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    table-&gt;element = (struct hash_data*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct hash_data)*count);</span><br><span class="line">    <span class="keyword">if</span>(table-&gt;element==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++)&#123;</span><br><span class="line">        table-&gt;element[i].index = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//table-&gt;element[i].data = 0;</span></span><br><span class="line">    &#125;</span><br><span class="line">    table-&gt;count = count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_free</span><span class="params">(struct hash_table* table)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(table-&gt;element!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(table-&gt;element);</span><br><span class="line">        table-&gt;element = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    table-&gt;count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_addr</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">int</span> table_count)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> addr = data % table_count;</span><br><span class="line">    <span class="keyword">return</span> (addr&gt;=<span class="number">0</span>)?addr:(addr+table_count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_insert</span><span class="params">(struct hash_table* table, <span class="keyword">int</span> data, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> addr = hash_addr(data, table-&gt;count);</span><br><span class="line">    <span class="keyword">while</span>(table-&gt;element[addr].index&gt;=<span class="number">0</span>)&#123;  <span class="comment">//解决冲突</span></span><br><span class="line">        addr = (addr+<span class="number">1</span>)%table-&gt;count;</span><br><span class="line">    &#125;</span><br><span class="line">    table-&gt;element[addr].index = index;  <span class="comment">//addr是与data有关的函数构成</span></span><br><span class="line">    <span class="comment">//table-&gt;element[addr].data = data;  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct hash_data* <span class="title">hash_find</span><span class="params">(struct hash_table* table, <span class="keyword">int</span> data)</span></span>&#123;  <span class="comment">//查找表</span></span><br><span class="line">    <span class="keyword">int</span> primary;</span><br><span class="line">    <span class="keyword">int</span> addr = primary = hash_addr(data, table-&gt;count);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(table-&gt;element[addr].index&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(table-&gt;nums[table-&gt;element[addr].index] == data)&#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;table-&gt;element[addr];</span><br><span class="line">        &#125;</span><br><span class="line">        addr = (addr+<span class="number">1</span>)%table-&gt;count;  <span class="comment">//插入时冲突情况</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(addr!=primary);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash_table</span> <span class="title">table</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash_data</span> *<span class="title">p_data</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(hash_init(&amp;table, numsSize+numsSize/<span class="number">5</span>)&lt;<span class="number">0</span>)&#123;  <span class="comment">//为什么要numsSize+numsSize/5来初始化哈希表？</span></span><br><span class="line">        <span class="keyword">return</span> twoSum_basic(nums, numsSize, target, returnSize);</span><br><span class="line">    &#125;;</span><br><span class="line">    table.nums = nums;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numsSize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((p_data=hash_find(&amp;table,target-nums[i]))!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((ret = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ret[<span class="number">0</span>] = p_data-&gt;index;</span><br><span class="line">                ret[<span class="number">1</span>] = i;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        hash_insert(&amp;table, nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    hash_free(&amp;table);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="哈希遍历"><a href="#哈希遍历" class="headerlink" title="哈希遍历"></a>哈希遍历</h3><p>遍历数组，将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(complement))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(complement),i&#125;;</span><br><span class="line">        map.put(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Leetcode</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/09/10/hello-world/</url>
    <content><![CDATA[<p>作为一名计院学子在浑浑噩噩过了两年之后，好像似乎有决心开始做点跟本专业有关的事情了。</p>
<p>或许这个博客就会用来记载后面日子的学习生涯和心情了。</p>
<p>一个民工终于有了自己的一份天地可供自己耕耘。</p>
<p>感谢09级的学长，提供了这么好的主题。</p>
<p>在2019年12月12日，将主题从yilia迁移到了next，并完成了之前目录的重构,特此记录。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
